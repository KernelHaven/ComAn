2003-06-11 21:55:00 +0000
diff --git a/src/southbridge/amd/amd8111/ide.c b/src/southbridge/amd/amd8111/ide.c
index a7eee35..fec424d 100644
--- a/src/southbridge/amd/amd8111/ide.c
+++ b/src/southbridge/amd/amd8111/ide.c
@@ -1,65 +1,65 @@
 #include <console/console.h>
 #include <device/device.h>
 #include <device/pci.h>
 #include <device/pci_ids.h>
 #include <device/pci_ops.h>
 #include "amd8111.h"
 
 static void ide_init(struct device *dev)
 {
 	struct southbridge_amd_amd8111_config *conf;
 	/* Enable ide devices so the linux ide driver will work */
 	uint16_t word;
 	uint8_t byte;
 	conf = dev->chip_info;
 
 	word = pci_read_config16(dev, 0x40);
 	/* Ensure prefetch is disabled */
 	word &= ~((1 << 15) | (1 << 13));
 	if (conf->ide1_enable) {
 		/* Enable secondary ide interface */
 		word |= (1<<0);
 		printk(BIOS_DEBUG, "IDE1 ");
 	}
 	if (conf->ide0_enable) {
 		/* Enable primary ide interface */
 		word |= (1<<1);
 		printk(BIOS_DEBUG, "IDE0 ");
 	}
 
 	word |= (1<<12);
 	word |= (1<<14);
 
 	pci_write_config16(dev, 0x40, word);
 
 
-	byte = 0x20 ; // Latency: 64-->32
+	byte = 0x20; // Latency: 64-->32
 	pci_write_config8(dev, 0xd, byte);
 
 	word = 0x0f;
 	pci_write_config16(dev, 0x42, word);
 }
 
 static void lpci_set_subsystem(device_t dev, unsigned vendor, unsigned device)
 {
 	pci_write_config32(dev, 0x70,
 		((device & 0xffff) << 16) | (vendor & 0xffff));
 }
 static struct pci_operations lops_pci = {
 	.set_subsystem = lpci_set_subsystem,
 };
 static struct device_operations ide_ops  = {
 	.read_resources   = pci_dev_read_resources,
 	.set_resources    = pci_dev_set_resources,
 	.enable_resources = pci_dev_enable_resources,
 	.init             = ide_init,
 	.scan_bus         = 0,
 	.enable           = amd8111_enable,
 	.ops_pci          = &lops_pci
 };
 
 static const struct pci_driver ide_driver __pci_driver = {
 	.ops    = &ide_ops,
 	.vendor = PCI_VENDOR_ID_AMD,
 	.device = PCI_DEVICE_ID_AMD_8111_IDE,
 };
diff --git a/src/southbridge/amd/cimx/sb700/bootblock.c b/src/southbridge/amd/cimx/sb700/bootblock.c
index 2f67a36..e10bb05 100644
--- a/src/southbridge/amd/cimx/sb700/bootblock.c
+++ b/src/southbridge/amd/cimx/sb700/bootblock.c
@@ -1,59 +1,59 @@
 /*
  * This file is part of the coreboot project.
  *
  * Copyright (C) 2012 Advanced Micro Devices, Inc.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; version 2 of the License.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  */
 
 
 #include <arch/io.h>
 
 static void sb700_enable_rom(void)
 {
 	u32 word;
 	u32 dword;
 	pci_devfn_t dev;
 
 	dev = PCI_DEV(0, 0x14, 0x03);
 	/* SB700 LPC Bridge 0:20:3:44h.
 	 * BIT6: Port Enable for serial port 0x3f8-0x3ff
 	 * BIT29: Port Enable for KBC port 0x60 and 0x64
 	 * BIT30: Port Enable for ACPI Micro-Controller port 0x66 and 0x62
 	 */
 	dword = pci_io_read_config32(dev, 0x44);
-	//dword |= (1<<6) | (1<<29) | (1<<30) ;
+	//dword |= (1<<6) | (1<<29) | (1<<30);
 	/*Turn on all of LPC IO Port decode enable */
 	dword = 0xffffffff;
 	pci_io_write_config32(dev, 0x44, dword);
 
 	/* SB700 LPC Bridge 0:20:3:48h.
 	 * BIT0: Port Enable for SuperIO 0x2E-0x2F
 	 * BIT1: Port Enable for SuperIO 0x4E-0x4F
 	 * BIT4: Port Enable for LPC ROM Address Arrage2 (0x68-0x6C)
 	 * BIT6: Port Enable for RTC IO 0x70-0x73
 	 * BIT21: Port Enable for Port 0x80
 	 */
 	dword = pci_io_read_config32(dev, 0x48);
-	dword |= (1<<0) | (1<<1) | (1<<4) | (1<<6) | (1<<21) ;
+	dword |= (1<<0) | (1<<1) | (1<<4) | (1<<6) | (1<<21);
 	pci_io_write_config32(dev, 0x48, dword);
 
 	/* Enable 4MB ROM access at 0xFFE00000 - 0xFFFFFFFF */
 	/* Set the 4MB enable bits */
 	word = pci_io_read_config16(dev, 0x6c);
 	word = 0xFFC0;
 	pci_io_write_config16(dev, 0x6c, word);
 }
 
 static void bootblock_southbridge_init(void)
 {
 	/* Setup the ROM access for 2M */
 	sb700_enable_rom();
 }
diff --git a/src/southbridge/amd/cimx/sb800/bootblock.c b/src/southbridge/amd/cimx/sb800/bootblock.c
index 89e56b6..008a19b 100644
--- a/src/southbridge/amd/cimx/sb800/bootblock.c
+++ b/src/southbridge/amd/cimx/sb800/bootblock.c
@@ -1,115 +1,115 @@
 /*
  * This file is part of the coreboot project.
  *
  * Copyright (C) 2011 Advanced Micro Devices, Inc.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; version 2 of the License.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  */
 
 #include <arch/io.h>
 
 static void enable_rom(void)
 {
 	u16 word;
 	u32 dword;
 	pci_devfn_t dev;
 
 	dev = PCI_DEV(0, 0x14, 0x03);
 	/* SB800 LPC Bridge 0:20:3:44h.
 	 * BIT6: Port Enable for serial port 0x3f8-0x3ff
 	 * BIT29: Port Enable for KBC port 0x60 and 0x64
 	 * BIT30: Port Enable for ACPI Micro-Controller port 0x66 and 0x62
 	 */
 	dword = pci_io_read_config32(dev, 0x44);
-	//dword |= (1<<6) | (1<<29) | (1<<30) ;
+	//dword |= (1<<6) | (1<<29) | (1<<30);
 	/* Turn on all of LPC IO Port decode enable */
 	dword = 0xffffffff;
 	pci_io_write_config32(dev, 0x44, dword);
 
 	/* SB800 LPC Bridge 0:20:3:48h.
 	 * BIT0: Port Enable for SuperIO 0x2E-0x2F
 	 * BIT1: Port Enable for SuperIO 0x4E-0x4F
 	 * BIT4: Port Enable for LPC ROM Address Arrage2 (0x68-0x6C)
 	 * BIT6: Port Enable for RTC IO 0x70-0x73
 	 * BIT21: Port Enable for Port 0x80
 	 */
 	dword = pci_io_read_config32(dev, 0x48);
 	dword |= (1 << 0) | (1 << 1) | (1 << 4) | (1 << 6) | (1 << 21);
 	pci_io_write_config32(dev, 0x48, dword);
 
 	/* Enable ROM access */
 	word = pci_io_read_config16(dev, 0x6c);
 	word = 0x10000 - (CONFIG_COREBOOT_ROMSIZE_KB >> 6);
 	pci_io_write_config16(dev, 0x6c, word);
 }
 
 static void enable_prefetch(void)
 {
 	u32 dword;
 	pci_devfn_t dev = PCI_DEV(0, 0x14, 0x03);
 
 	/* Enable PrefetchEnSPIFromHost */
 	dword = pci_io_read_config32(dev, 0xb8);
 	pci_io_write_config32(dev, 0xb8, dword | (1 << 24));
 }
 
 static void enable_spi_fast_mode(void)
 {
 	u32 dword;
 	pci_devfn_t dev = PCI_DEV(0, 0x14, 0x03);
 
 	// set temp MMIO base
 	volatile u32 *spi_base = (void *)0xa0000000;
 	u32 save = pci_io_read_config32(dev, 0xa0);
 	pci_io_write_config32(dev, 0xa0, (u32) spi_base | 2);
 
 	// early enable of SPI 33 MHz fast mode read
 	dword = spi_base[3];
 	spi_base[3] = (dword & ~(3 << 14)) | (1 << 14);
 	spi_base[0] = spi_base[0] | (1 << 18);	// fast read enable
 
 	pci_io_write_config32(dev, 0xa0, save);
 }
 
 static void enable_clocks(void)
 {
 	u8 reg8;
 	u32 reg32;
 	volatile u32 *acpi_mmio = (void *) (0xFED80000 + 0xE00 + 0x40);
 
 	// Program AcpiMmioEn to enable MMIO access to MiscCntrl register
 	outb(0x24, 0xCD6);
 	reg8 = inb(0xCD7);
 	reg8 |= 1;
 	reg8 &= ~(1 << 1);
 	outb(reg8, 0xCD7);
 
 	// Program SB800 MiscClkCntrl register to configure clock output on the
 	// 14M_25M_48M_OSC ball usually used for the Super-I/O.
 	// Almost all SIOs need 48 MHz, only the SMSC SCH311x wants 14 MHz,
 	// which is the SB800's power up default.  We could switch back to 14
 	// in the mainboard's romstage.c, but then the clock frequency would
 	// change twice.
 	reg32 = *acpi_mmio;
 	reg32 &= ~((1 << 2) | (3 << 0)); // enable, 14 MHz (power up default)
 #if !CONFIG_SUPERIO_WANTS_14MHZ_CLOCK
 	reg32 |= 2 << 0; // Device_CLK1_sel = 48 MHz
 #endif
 	*acpi_mmio = reg32;
 }
 
 static void bootblock_southbridge_init(void)
 {
 	/* Setup the ROM access for 2M */
 	enable_rom();
 	enable_prefetch();
 	enable_spi_fast_mode();
 	enable_clocks();
 }
diff --git a/src/southbridge/amd/cimx/sb800/fan.c b/src/southbridge/amd/cimx/sb800/fan.c
index e37fc3d..5925330 100644
--- a/src/southbridge/amd/cimx/sb800/fan.c
+++ b/src/southbridge/amd/cimx/sb800/fan.c
@@ -1,305 +1,305 @@
 /*
  * This file is part of the coreboot project.
  *
  * Copyright (C) 2012 Sage Electronic Engineering, LLC
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; version 2 of the License.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  */
 
 #include <southbridge/amd/cimx/cimx_util.h>
 #include <device/device.h>	/* device_t */
 #include <device/pci.h>		/* device_operations */
 #include "SBPLATFORM.h"
 #include "sb_cimx.h"
 #include "chip.h"		/* struct southbridge_amd_cimx_sb800_config */
 #include "fan.h"
 
 void init_sb800_MANUAL_fans(device_t dev)
 {
 	int i;
 	struct southbridge_amd_cimx_sb800_config *sb_chip =
 		(struct southbridge_amd_cimx_sb800_config *)(dev->chip_info);
 
 	/* Init Fan 0 */
 	if (sb_chip->fan0_enabled)
 		for (i = 0; i < FAN_REGISTER_COUNT; i++)
 			pm2_iowrite(FAN_0_OFFSET + i, sb_chip->fan0_config_vals[i]);
 
 	/* Init Fan 1 */
 	if (sb_chip->fan1_enabled)
 		for (i = 0; i < FAN_REGISTER_COUNT; i++)
 			pm2_iowrite(FAN_1_OFFSET + i, sb_chip->fan1_config_vals[i]);
 
 	/* Init Fan 2 */
 	if (sb_chip->fan2_enabled)
 		for (i = 0; i < FAN_REGISTER_COUNT; i++)
 			pm2_iowrite(FAN_2_OFFSET + i, sb_chip->fan2_config_vals[i]);
 
 	/* Init Fan 3 */
 	if (sb_chip->fan3_enabled)
 		for (i = 0; i < FAN_REGISTER_COUNT; i++)
 			pm2_iowrite(FAN_3_OFFSET + i, sb_chip->fan3_config_vals[i]);
 
 	/* Init Fan 4 */
 	if (sb_chip->fan4_enabled)
 		for (i = 0; i < FAN_REGISTER_COUNT; i++)
 			pm2_iowrite(FAN_4_OFFSET + i, sb_chip->fan4_config_vals[i]);
 
 }
 
 void init_sb800_IMC_fans(device_t dev)
 {
 
 	AMDSBCFG sb_config;
 	unsigned char *message_ptr;
 	int i;
 	struct southbridge_amd_cimx_sb800_config *sb_chip =
 		(struct southbridge_amd_cimx_sb800_config *)(dev->chip_info);
 
 	/*
 	 * The default I/O address of the IMC configuration register index
 	 *  port is 0x6E. Change the IMC Config port I/O Address if it
 	 *  conflicts with other components in the system.
 	 *
 	 * Device 20, Function 3, Reg 0xA4
 	 * [0]: if 1, the address specified in IMC_PortAddress is used.
 	 * [15:1] IMC_PortAddress bits 15:1 (0x17 - address 0x2E )
 	 */
 
 	pci_write_config16(dev, 0xA4, sb_chip->imc_port_address | 0x01);
 
 
 	/*
 	 * Do an initial manual setup of the fans for things like polarity
 	 * and frequency.
 	 */
 	init_sb800_MANUAL_fans(dev);
 
 	/*
 	 * FLAG for Func 81/83/85/89 support (1=On,0=Off)
 	 * Bit0-3   = Func 81 Zone0-Zone3
 	 * Bit4-7   = Func 83 Zone0-Zone3
 	 * Bit8-11  = Func 85 Zone0-Zone3
 	 * Bit12-15 = Func 89 Tempin Channel0-Channel3
 	 */
 	sb_config.Pecstruct.IMCFUNSupportBitMap = 0;
 
 /*
  ********** Zone 0 **********
  */
 if (sb_chip->imc_fan_zone0_enabled) {
 
 	sb_config.Pecstruct.IMCFUNSupportBitMap |= IMC_ENABLE_ZONE0;
 
 	/* EC LDN9 function 81 zone 0 */
 	sb_config.Pecstruct.MSGFun81zone0MSGREG0 = 0x00;
 	sb_config.Pecstruct.MSGFun81zone0MSGREG1 = IMC_ZONE0;
 	message_ptr = &sb_config.Pecstruct.MSGFun81zone0MSGREG2;
-	for (i = 0; i < IMC_FAN_CONFIG_COUNT ; i++ )
+	for (i = 0; i < IMC_FAN_CONFIG_COUNT; i++ )
 		*(message_ptr + i) = sb_chip->imc_zone0_config_vals[i];
 
 	/* EC LDN9 function 83 zone 0 - Temperature Thresholds */
 	sb_config.Pecstruct.MSGFun83zone0MSGREG0 = 0x00;
 	sb_config.Pecstruct.MSGFun83zone0MSGREG1 = IMC_ZONE0;
 	sb_config.Pecstruct.MSGFun83zone0MSGREGB = 0x00;
 	message_ptr = &sb_config.Pecstruct.MSGFun83zone0MSGREG2;
-	for (i = 0; i < IMC_FAN_THRESHOLD_COUNT ; i++ )
+	for (i = 0; i < IMC_FAN_THRESHOLD_COUNT; i++ )
 		*(message_ptr + i) = sb_chip->imc_zone0_thresholds[i];
 
 	/*EC LDN9 function 85 zone 0 - Fan Speeds */
 	sb_config.Pecstruct.MSGFun85zone0MSGREG0 = 0x00;
 	sb_config.Pecstruct.MSGFun85zone0MSGREG1 = IMC_ZONE0;
 	message_ptr = &sb_config.Pecstruct.MSGFun85zone0MSGREG2;
-	for (i = 0; i < IMC_FAN_SPEED_COUNT ; i++ )
+	for (i = 0; i < IMC_FAN_SPEED_COUNT; i++ )
 		*(message_ptr + i) = sb_chip->imc_zone0_fanspeeds[i];
 
 }
 
 /*
  ********** Zone 1 **********
  */
 if (sb_chip->imc_fan_zone1_enabled) {
 
 	sb_config.Pecstruct.IMCFUNSupportBitMap |= IMC_ENABLE_ZONE1;
 
 	/* EC LDN9 function 81 zone 1 */
 	sb_config.Pecstruct.MSGFun81zone1MSGREG0 = 0x00;
 	sb_config.Pecstruct.MSGFun81zone1MSGREG1 = IMC_ZONE1;
 	message_ptr = &sb_config.Pecstruct.MSGFun81zone1MSGREG2;
-	for (i = 0; i < IMC_FAN_CONFIG_COUNT ; i++ )
+	for (i = 0; i < IMC_FAN_CONFIG_COUNT; i++ )
 		*(message_ptr + i) = sb_chip->imc_zone1_config_vals[i];
 
 	/* EC LDN9 function 83 zone 1 - Temperature Thresholds */
 	sb_config.Pecstruct.MSGFun83zone1MSGREG0 = 0x00;
 	sb_config.Pecstruct.MSGFun83zone1MSGREG1 = IMC_ZONE1;
 	sb_config.Pecstruct.MSGFun83zone1MSGREGB = 0x00;
 	message_ptr = &sb_config.Pecstruct.MSGFun83zone1MSGREG2;
-	for (i = 0; i < IMC_FAN_THRESHOLD_COUNT ; i++ )
+	for (i = 0; i < IMC_FAN_THRESHOLD_COUNT; i++ )
 		*(message_ptr + i) = sb_chip->imc_zone1_thresholds[i];
 
 	/* EC LDN9 function 85 zone 1 - Fan Speeds */
 	sb_config.Pecstruct.MSGFun85zone1MSGREG0 = 0x00;
 	sb_config.Pecstruct.MSGFun85zone1MSGREG1 = IMC_ZONE1;
 	message_ptr = &sb_config.Pecstruct.MSGFun85zone1MSGREG2;
-	for (i = 0; i < IMC_FAN_SPEED_COUNT ; i++ )
+	for (i = 0; i < IMC_FAN_SPEED_COUNT; i++ )
 		*(message_ptr + i) = sb_chip->imc_zone1_fanspeeds[i];
 
 }
 
 
 /*
  ********** Zone 2 **********
  */
 if (sb_chip->imc_fan_zone2_enabled) {
 
 	sb_config.Pecstruct.IMCFUNSupportBitMap |= IMC_ENABLE_ZONE2;
 
 	/* EC LDN9 function 81 zone 2 */
 	sb_config.Pecstruct.MSGFun81zone2MSGREG0 = 0x00;
 	sb_config.Pecstruct.MSGFun81zone2MSGREG1 = IMC_ZONE2;
 	message_ptr = &sb_config.Pecstruct.MSGFun81zone2MSGREG2;
-	for (i = 0; i < IMC_FAN_CONFIG_COUNT ; i++ )
+	for (i = 0; i < IMC_FAN_CONFIG_COUNT; i++ )
 		*(message_ptr + i) = sb_chip->imc_zone2_config_vals[i];
 
 	/* EC LDN9 function 83 zone 2 */
 	sb_config.Pecstruct.MSGFun83zone2MSGREG0 = 0x00;
 	sb_config.Pecstruct.MSGFun83zone2MSGREG1 = IMC_ZONE2;
 	sb_config.Pecstruct.MSGFun83zone2MSGREGB = 0x00;
 	message_ptr = &sb_config.Pecstruct.MSGFun83zone2MSGREG2;
-	for (i = 0; i < IMC_FAN_THRESHOLD_COUNT ; i++ )
+	for (i = 0; i < IMC_FAN_THRESHOLD_COUNT; i++ )
 		*(message_ptr + i) = sb_chip->imc_zone2_thresholds[i];
 
 	/* EC LDN9 function 85 zone 2 */
 	sb_config.Pecstruct.MSGFun85zone2MSGREG0 = 0x00;
 	sb_config.Pecstruct.MSGFun85zone2MSGREG1 = IMC_ZONE2;
 	message_ptr = &sb_config.Pecstruct.MSGFun85zone2MSGREG2;
-	for (i = 0; i < IMC_FAN_SPEED_COUNT ; i++ )
+	for (i = 0; i < IMC_FAN_SPEED_COUNT; i++ )
 		*(message_ptr + i) = sb_chip->imc_zone2_fanspeeds[i];
 
 }
 
 /*
  ********** Zone 3 **********
  */
 
 if (sb_chip->imc_fan_zone3_enabled) {
 
 	sb_config.Pecstruct.IMCFUNSupportBitMap |= IMC_ENABLE_ZONE3;
 
 	/* EC LDN9 function 81 zone 3 */
 	sb_config.Pecstruct.MSGFun81zone3MSGREG0 = 0x00;
 	sb_config.Pecstruct.MSGFun81zone3MSGREG1 = IMC_ZONE3;
 	message_ptr = &sb_config.Pecstruct.MSGFun81zone3MSGREG2;
-	for (i = 0; i < IMC_FAN_CONFIG_COUNT ; i++ )
+	for (i = 0; i < IMC_FAN_CONFIG_COUNT; i++ )
 		*(message_ptr + i) = sb_chip->imc_zone3_config_vals[i];
 
 	/* EC LDN9 function 83 zone 3 */
 	sb_config.Pecstruct.MSGFun83zone3MSGREG0 = 0x00;
 	sb_config.Pecstruct.MSGFun83zone3MSGREG1 = IMC_ZONE3;
 	sb_config.Pecstruct.MSGFun83zone3MSGREGB = 0x00;
 	message_ptr = &sb_config.Pecstruct.MSGFun83zone3MSGREG2;
-	for (i = 0; i < IMC_FAN_THRESHOLD_COUNT ; i++ )
+	for (i = 0; i < IMC_FAN_THRESHOLD_COUNT; i++ )
 		*(message_ptr + i) = sb_chip->imc_zone3_thresholds[i];
 
 	/* EC LDN9 function 85 zone 3 */
 	sb_config.Pecstruct.MSGFun85zone3MSGREG0 = 0x00;
 	sb_config.Pecstruct.MSGFun85zone3MSGREG1 = IMC_ZONE3;
 	message_ptr = &sb_config.Pecstruct.MSGFun85zone3MSGREG2;
-	for (i = 0; i < IMC_FAN_SPEED_COUNT ; i++ )
+	for (i = 0; i < IMC_FAN_SPEED_COUNT; i++ )
 		*(message_ptr + i) = sb_chip->imc_zone3_fanspeeds[i];
 
 }
 
 	/*
 	 * EC LDN9 function 89 - Set HWM TEMPIN Temperature Calculation Parameters
 	 * This function provides the critical parameters of the HWM TempIn
 	 * sensors, IMC would not perform temperature measurement using those
 	 * sensors until the parameters are provided.
 	 */
 
 if (sb_chip->imc_tempin0_enabled) {
 
 	sb_config.Pecstruct.IMCFUNSupportBitMap |= IMC_ENABLE_TEMPIN0;
 
 	/* EC LDN9 function 89 TEMPIN channel 0 */
 	sb_config.Pecstruct.MSGFun89zone0MSGREG0 = 0x00;
 	sb_config.Pecstruct.MSGFun89zone0MSGREG1 = 0x00;
 	sb_config.Pecstruct.MSGFun89zone0MSGREG2 = ( sb_chip->imc_tempin0_at & 0xff);
 	sb_config.Pecstruct.MSGFun89zone0MSGREG3 = ((sb_chip->imc_tempin0_at >> 8)  & 0xff);
 	sb_config.Pecstruct.MSGFun89zone0MSGREG4 = ((sb_chip->imc_tempin0_at >> 16) & 0xff);
 	sb_config.Pecstruct.MSGFun89zone0MSGREG5 = ((sb_chip->imc_tempin0_at >> 24) & 0xff);
 	sb_config.Pecstruct.MSGFun89zone0MSGREG6 = ( sb_chip->imc_tempin0_ct & 0xff);
 	sb_config.Pecstruct.MSGFun89zone0MSGREG7 = ((sb_chip->imc_tempin0_ct >> 8)  & 0xff);
 	sb_config.Pecstruct.MSGFun89zone0MSGREG8 = ((sb_chip->imc_tempin0_ct >> 16)  & 0xff);
 	sb_config.Pecstruct.MSGFun89zone0MSGREG9 = ((sb_chip->imc_tempin0_ct >> 24)  & 0xff);
 	sb_config.Pecstruct.MSGFun89zone0MSGREGA = sb_chip->imc_tempin0_tuning_param;
 }
 
 if (sb_chip->imc_tempin1_enabled) {
 
 	sb_config.Pecstruct.IMCFUNSupportBitMap |= IMC_ENABLE_TEMPIN1;
 
 	/* EC LDN9 function 89 TEMPIN channel 1 */
 	sb_config.Pecstruct.MSGFun89zone1MSGREG0 = 0x00;
 	sb_config.Pecstruct.MSGFun89zone1MSGREG1 = 0x01;
 	sb_config.Pecstruct.MSGFun89zone1MSGREG2 = ( sb_chip->imc_tempin1_at & 0xff);
 	sb_config.Pecstruct.MSGFun89zone1MSGREG3 = ((sb_chip->imc_tempin1_at >> 8)  & 0xff);
 	sb_config.Pecstruct.MSGFun89zone1MSGREG4 = ((sb_chip->imc_tempin1_at >> 16) & 0xff);
 	sb_config.Pecstruct.MSGFun89zone1MSGREG5 = ((sb_chip->imc_tempin1_at >> 24) & 0xff);
 	sb_config.Pecstruct.MSGFun89zone1MSGREG6 = ( sb_chip->imc_tempin1_ct & 0xff);
 	sb_config.Pecstruct.MSGFun89zone1MSGREG7 = ((sb_chip->imc_tempin1_ct >> 8)  & 0xff);
 	sb_config.Pecstruct.MSGFun89zone1MSGREG8 = ((sb_chip->imc_tempin1_ct >> 16)  & 0xff);
 	sb_config.Pecstruct.MSGFun89zone1MSGREG9 = ((sb_chip->imc_tempin1_ct >> 24)  & 0xff);
 	sb_config.Pecstruct.MSGFun89zone1MSGREGA = sb_chip->imc_tempin1_tuning_param;
 }
 
 if (sb_chip->imc_tempin2_enabled) {
 
 	sb_config.Pecstruct.IMCFUNSupportBitMap |= IMC_ENABLE_TEMPIN2;
 
 	/* EC LDN9 function 89 TEMPIN channel 2 */
 	sb_config.Pecstruct.MSGFun89zone2MSGREG0 = 0x00;
 	sb_config.Pecstruct.MSGFun89zone2MSGREG1 = 0x02;
 	sb_config.Pecstruct.MSGFun89zone2MSGREG2 = ( sb_chip->imc_tempin2_at & 0xff);
 	sb_config.Pecstruct.MSGFun89zone2MSGREG3 = ((sb_chip->imc_tempin2_at >> 8)  & 0xff);
 	sb_config.Pecstruct.MSGFun89zone2MSGREG4 = ((sb_chip->imc_tempin2_at >> 16) & 0xff);
 	sb_config.Pecstruct.MSGFun89zone2MSGREG5 = ((sb_chip->imc_tempin2_at >> 24) & 0xff);
 	sb_config.Pecstruct.MSGFun89zone2MSGREG6 = ( sb_chip->imc_tempin2_ct & 0xff);
 	sb_config.Pecstruct.MSGFun89zone2MSGREG7 = ((sb_chip->imc_tempin2_ct >> 8)  & 0xff);
 	sb_config.Pecstruct.MSGFun89zone2MSGREG8 = ((sb_chip->imc_tempin2_ct >> 16)  & 0xff);
 	sb_config.Pecstruct.MSGFun89zone2MSGREG9 = ((sb_chip->imc_tempin2_ct >> 24)  & 0xff);
 	sb_config.Pecstruct.MSGFun89zone2MSGREGA = sb_chip->imc_tempin2_tuning_param;
 }
 
 if (sb_chip->imc_tempin3_enabled) {
 
 	sb_config.Pecstruct.IMCFUNSupportBitMap |= IMC_ENABLE_TEMPIN3;
 
 	/* EC LDN9 function 89 TEMPIN channel 3 */
 	sb_config.Pecstruct.MSGFun89zone3MSGREG0 = 0x00;
 	sb_config.Pecstruct.MSGFun89zone3MSGREG1 = 0x03;
 	sb_config.Pecstruct.MSGFun89zone3MSGREG2 = ( sb_chip->imc_tempin3_at & 0xff);
 	sb_config.Pecstruct.MSGFun89zone3MSGREG3 = ((sb_chip->imc_tempin3_at >> 8)  & 0xff);
 	sb_config.Pecstruct.MSGFun89zone3MSGREG4 = ((sb_chip->imc_tempin3_at >> 16) & 0xff);
 	sb_config.Pecstruct.MSGFun89zone3MSGREG5 = ((sb_chip->imc_tempin3_at >> 24) & 0xff);
 	sb_config.Pecstruct.MSGFun89zone3MSGREG6 = ( sb_chip->imc_tempin3_ct & 0xff);
 	sb_config.Pecstruct.MSGFun89zone3MSGREG7 = ((sb_chip->imc_tempin3_ct >> 8)  & 0xff);
 	sb_config.Pecstruct.MSGFun89zone3MSGREG8 = ((sb_chip->imc_tempin3_ct >> 16)  & 0xff);
 	sb_config.Pecstruct.MSGFun89zone3MSGREG9 = ((sb_chip->imc_tempin3_ct >> 24)  & 0xff);
 	sb_config.Pecstruct.MSGFun89zone3MSGREGA = sb_chip->imc_tempin3_tuning_param;
 }
 
 	/* Set up the sb_config structure for the fan control initialization */
 	sb_config.StdHeader.Func = SB_EC_FANCONTROL;
 
 	AmdSbDispatcher(&sb_config);
 
 	return;
 }
diff --git a/src/southbridge/amd/cimx/sb900/bootblock.c b/src/southbridge/amd/cimx/sb900/bootblock.c
index 50d3087..a069463 100644
--- a/src/southbridge/amd/cimx/sb900/bootblock.c
+++ b/src/southbridge/amd/cimx/sb900/bootblock.c
@@ -1,58 +1,58 @@
 /*
  * This file is part of the coreboot project.
  *
  * Copyright (C) 2011 Advanced Micro Devices, Inc.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; version 2 of the License.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  */
 
 #include <arch/io.h>
 
 static void sb900_enable_rom(void)
 {
   u32 word;
   u32 dword;
   pci_devfn_t dev;
 
   dev = PCI_DEV(0, 0x14, 0x03);
   /* SB900 LPC Bridge 0:20:3:44h.
    * BIT6: Port Enable for serial port 0x3f8-0x3ff
    * BIT29: Port Enable for KBC port 0x60 and 0x64
    * BIT30: Port Enable for ACPI Micro-Controller port 0x66 and 0x62
    */
   dword = pci_io_read_config32(dev, 0x44);
-  //dword |= (1<<6) | (1<<29) | (1<<30) ;
+  //dword |= (1<<6) | (1<<29) | (1<<30);
   /*Turn on all of LPC IO Port decode enable */
   dword = 0xffffffff;
   pci_io_write_config32(dev, 0x44, dword);
 
   /* SB900 LPC Bridge 0:20:3:48h.
    * BIT0: Port Enable for SuperIO 0x2E-0x2F
    * BIT1: Port Enable for SuperIO 0x4E-0x4F
    * BIT4: Port Enable for LPC ROM Address Arrage2 (0x68-0x6C)
    * BIT6: Port Enable for RTC IO 0x70-0x73
    * BIT21: Port Enable for Port 0x80
    */
   dword = pci_io_read_config32(dev, 0x48);
-  dword |= (1<<0) | (1<<1) | (1<<4) | (1<<6) | (1<<21) ;
+  dword |= (1<<0) | (1<<1) | (1<<4) | (1<<6) | (1<<21);
   pci_io_write_config32(dev, 0x48, dword);
 
   /* Enable 4MB ROM access at 0xFFE00000 - 0xFFFFFFFF */
   /* Set the 4MB enable bits */
   word = pci_io_read_config16(dev, 0x6c);
   word = 0xFFC0;
   pci_io_write_config16(dev, 0x6c, word);
 }
 
 static void bootblock_southbridge_init(void)
 {
   /* Setup the ROM access for 2M */
   sb900_enable_rom();
 }
diff --git a/src/southbridge/amd/rs780/gfx.c b/src/southbridge/amd/rs780/gfx.c
index c2b3d3a..52bc071 100644
--- a/src/southbridge/amd/rs780/gfx.c
+++ b/src/southbridge/amd/rs780/gfx.c
@@ -1,1574 +1,1574 @@
 /*
  * This file is part of the coreboot project.
  *
  * Copyright (C) 2010 Advanced Micro Devices, Inc.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; version 2 of the License.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  */
 
 /*
  *  for rs780 internal graphics device
  *  device id of internal graphics:
  *	RS780:	0x9610
  *	RS780C:	0x9611
  *	RS780M:	0x9612
  *	RS780MC:0x9613
  *	RS780E: 0x9615
  *	RS785G: 0x9710 - just works, not much tested
  *	RS785C: 0x9711
  *	RS785M: 0x9712
  *	RS785MC:0x9713
  *	RS785D: 0x9714
  */
 #include <console/console.h>
 #include <device/device.h>
 #include <device/pci.h>
 #include <device/pci_ids.h>
 #include <device/pci_ops.h>
 #include <delay.h>
 #include <cpu/x86/msr.h>
 #include "rs780.h"
 extern int is_dev3_present(void);
 void set_pcie_reset(void);
 void set_pcie_dereset(void);
 
 /* Trust the original resource allocation. Don't do it again. */
 #undef DONT_TRUST_RESOURCE_ALLOCATION
 //#define DONT_TRUST_RESOURCE_ALLOCATION
 
 #define CLK_CNTL_INDEX	0x8
 #define CLK_CNTL_DATA	0xC
 
 /* The Integrated Info Table. */
 ATOM_INTEGRATED_SYSTEM_INFO_V2 vgainfo;
 
 #ifdef UNUSED_CODE
 static u32 clkind_read(device_t dev, u32 index)
 {
 	u32	gfx_bar2 = pci_read_config32(dev, 0x18) & ~0xF;
 
 	*(u32*)(gfx_bar2+CLK_CNTL_INDEX) = index & 0x7F;
 	return *(u32*)(gfx_bar2+CLK_CNTL_DATA);
 }
 #endif
 
 static void clkind_write(device_t dev, u32 index, u32 data)
 {
 	u32	gfx_bar2 = pci_read_config32(dev, 0x18) & ~0xF;
 	/* printk(BIOS_DEBUG, "gfx bar 2 %02x\n", gfx_bar2); */
 
 	*(u32*)(gfx_bar2+CLK_CNTL_INDEX) = index | 1<<7;
 	*(u32*)(gfx_bar2+CLK_CNTL_DATA)  = data;
 }
 
 /*
 * pci_dev_read_resources thinks it is a IO type.
 * We have to force it to mem type.
 */
 static void rs780_gfx_read_resources(device_t dev)
 {
 	printk(BIOS_DEBUG, "rs780_gfx_read_resources.\n");
 
 	/* The initial value of 0x24 is 0xFFFFFFFF, which is confusing.
 	   Even if we write 0xFFFFFFFF into it, it will be 0xFFF00000,
 	   which tells us it is a memory address base.
 	 */
 	pci_write_config32(dev, 0x24, 0x00000000);
 
 	/* Get the normal pci resources of this device */
 	pci_dev_read_resources(dev);
 	compact_resources(dev);
 }
 
 typedef struct _MMIORANGE
 {
 	u32	Base;
 	u32	Limit;
 	u8	Attribute;
 } MMIORANGE;
 
 MMIORANGE MMIO[8], CreativeMMIO[8];
 
 #define CIM_STATUS u32
 #define CIM_SUCCESS 0x00000000
 #define CIM_ERROR	0x80000000
 #define CIM_UNSUPPORTED	0x80000001
 #define CIM_DISABLEPORT 0x80000002
 
 #define	MMIO_ATTRIB_NP_ONLY	1
 #define MMIO_ATTRIB_BOTTOM_TO_TOP 1<<1
 #define MMIO_ATTRIB_SKIP_ZERO 1<<2
 
 #ifdef DONT_TRUST_RESOURCE_ALLOCATION
 static MMIORANGE* AllocMMIO(MMIORANGE* pMMIO)
 {
 	int i;
 	for (i = 0; i < 8; i++) {
 		if (pMMIO[i].Limit == 0)
 				return &pMMIO[i];
 	}
 	return 0;
 }
 
 static void FreeMMIO(MMIORANGE* pMMIO)
 {
 	pMMIO->Base = 0;
 	pMMIO->Limit = 0;
 }
 
 static u32 SetMMIO(u32 Base, u32 Limit, u8 Attribute, MMIORANGE *pMMIO)
 {
 	int i;
 	MMIORANGE * TempRange;
 	for (i = 0; i < 8; i++) {
 		if (pMMIO[i].Attribute != Attribute && Base >= pMMIO[i].Base && Limit <= pMMIO[i].Limit) {
 			TempRange = AllocMMIO(pMMIO);
 			if (TempRange == 0) return 0x80000000;
 			TempRange->Base = Limit;
 			TempRange->Limit = pMMIO[i].Limit;
 			TempRange->Attribute = pMMIO[i].Attribute;
 			pMMIO[i].Limit = Base;
 		}
 	}
 	TempRange = AllocMMIO(pMMIO);
 	if (TempRange == 0) return 0x80000000;
 	TempRange->Base = Base;
 	TempRange->Limit = Limit;
 	TempRange->Attribute = Attribute;
 	return 0;
 }
 
 static u8 FinalizeMMIO(MMIORANGE *pMMIO)
 {
 	int i, j, n = 0;
 	for (i = 0; i < 8; i++) {
 		if (pMMIO[i].Base == pMMIO[i].Limit) {
 			FreeMMIO(&pMMIO[i]);
 			continue;
 		}
 		for (j = 0; j < i; j++) {
 			if (i!=j && pMMIO[i].Attribute == pMMIO[j].Attribute) {
 				if (pMMIO[i].Base == pMMIO[j].Limit) {
 					pMMIO[j].Limit = pMMIO[i].Limit;
 					 FreeMMIO(&pMMIO[i]);
 				}
 				if (pMMIO[i].Limit == pMMIO[j].Base) {
 					pMMIO[j].Base = pMMIO[i].Base;
 				   FreeMMIO(&pMMIO[i]);
 				}
 			}
 		}
 	}
 	for (i = 0; i < 8; i++) {
 		if (pMMIO[i].Limit != 0) n++;
 	}
 	return n;
 }
 
 static CIM_STATUS GetCreativeMMIO(MMIORANGE *pMMIO)
 {
 	CIM_STATUS Status = CIM_UNSUPPORTED;
 	u8 Bus, Dev, Reg, BusStart, BusEnd;
 	u32	Value;
 	device_t dev0x14 = dev_find_slot(0, PCI_DEVFN(0x14, 4));
 	device_t tempdev;
 	Value = pci_read_config32(dev0x14, 0x18);
 	BusStart = (Value >> 8) & 0xFF;
 	BusEnd = (Value >> 16) & 0xFF;
 	for (Bus = BusStart; Bus <= BusEnd; Bus++) {
 		for (Dev = 0; Dev <= 0x1f; Dev++) {
 			tempdev = dev_find_slot(Bus, Dev << 3);
 			Value = pci_read_config32(tempdev, 0);
 			printk(BIOS_DEBUG, "Dev ID %x\n", Value);
 			if ((Value & 0xffff) == 0x1102) {//Creative
 				//Found Creative SB
 			 	u32	MMIOStart = 0xffffffff;
 				u32 MMIOLimit = 0;
 				for (Reg = 0x10; Reg < 0x20; Reg+=4) {
 					u32	BaseA, LimitA;
 					BaseA = pci_read_config32(tempdev, Reg);
 					Value = BaseA;
 					if (!(Value & 0x01)) {
 						Value = Value & 0xffffff00;
 						if (Value !=  0) {
 							if (MMIOStart > Value)
 								MMIOStart = Value;
 							LimitA = 0xffffffff;
 							//WritePCI(PciAddress,AccWidthUint32,&LimitA);
 							pci_write_config32(tempdev, Reg, LimitA);
 							//ReadPCI(PciAddress,AccWidthUint32,&LimitA);
 							LimitA = pci_read_config32(tempdev, Reg);
 							LimitA = Value + (~LimitA + 1);
 							//WritePCI(PciAddress,AccWidthUint32,&BaseA);
 							pci_write_config32(tempdev, Reg, BaseA);
 							if (LimitA > MMIOLimit)
 								MMIOLimit = LimitA;
 						}
 					}
 				}
 				printk(BIOS_DEBUG, " MMIOStart %x MMIOLimit %x\n", MMIOStart, MMIOLimit);
 				if (MMIOStart < MMIOLimit)
 				{
 					Status = SetMMIO(MMIOStart>>8, MMIOLimit>>8, 0x80, pMMIO);
 					if (Status == CIM_ERROR) return Status;
 				}
 			}
 		}
 	}
 	if (Status == CIM_SUCCESS) {
 		//Lets optimize MMIO
 		if (FinalizeMMIO(pMMIO) > 4) {
 			Status = CIM_ERROR;
 		}
 	}
 
 	return Status;
 }
 
 static void ProgramMMIO(MMIORANGE *pMMIO, u8 LinkID, u8 Attribute)
 {
 	int i, j, n = 7;
 	device_t k8_f1;
 
 	k8_f1 = dev_find_slot(0, PCI_DEVFN(0x18, 1));
 
 	for (i = 0; i < 8; i++) {
 		int k = 0, MmioReg;
 		u32 Base = 0;
 		u32 Limit = 0;
 		for (j = 0; j < 8; j++) {
 			if (Base < pMMIO[j].Base) {
 				Base = pMMIO[j].Base;
 				k = j;
 			}
 		}
 		if (pMMIO[k].Limit != 0) {
 			if (Attribute & MMIO_ATTRIB_NP_ONLY && pMMIO[k].Attribute == 0 ) {
 				Base = 0;
 			}
 			else
 			{
 				Base = pMMIO[k].Base | 0x3;
 				Limit= ((pMMIO[k].Limit - 1) & 0xffffff00) | pMMIO[k].Attribute | (LinkID << 4);
 			}
 			FreeMMIO(&pMMIO[k]);
 		}
 		if (Attribute & MMIO_ATTRIB_SKIP_ZERO && Base == 0 && Limit == 0) continue;
 		MmioReg = (Attribute & MMIO_ATTRIB_BOTTOM_TO_TOP)?n:(7-n);
 		n--;
 		//RWPCI(PCI_ADDRESS(0,CPU_DEV,CPU_F1,0x80+MmioReg*8),AccWidthUint32 |S3_SAVE,0x0,0x0);
 		pci_write_config32(k8_f1, 0x80+MmioReg*8, 0);
 
 		//WritePCI(PCI_ADDRESS(0,CPU_DEV,CPU_F1,0x84+MmioReg*8),AccWidthUint32 |S3_SAVE,&Limit);
 		pci_write_config32(k8_f1, 0x84+MmioReg*8, Limit);
 
 		//WritePCI(PCI_ADDRESS(0,CPU_DEV,CPU_F1,0x80+MmioReg*8),AccWidthUint32 |S3_SAVE,&Base);
 		pci_write_config32(k8_f1, 0x80+MmioReg*8, Base);
 	}
 }
 #endif
 
 #define GFX_CONFIG_DDI1		0x04
 #define GFX_CONFIG_DDI2		0x08
 #define GFX_CONFIG_DDI		(GFX_CONFIG_DDI1 | GFX_CONFIG_DDI2)
 
 /**
  * Force poweron pads for lanes used for DDI
  * reference CIMx PCIEL_PowerOnDDILanes()
  *
  * Inactive    B_PRX_PDNB_FDIS  B_PTX_PDNB_FDIS
  *  Lanes
  * Lanes  0-1   Bit  8           Bit 0
  * Lanes  2-3   Bit  9           Bit 1
  * Lanes  4-5   Bit 10           Bit 2
  * Lanes  6-7   Bit 11           Bit 3
  * Lanes  8-9   Bit 12           Bit 4
  * Lanes 10-11  Bit 13           Bit 5
  * Lanes 12-13  Bit 14           Bit 6
  * Lanes 14-15  Bit 15           Bit 7
  */
 static void poweron_ddi_lanes(device_t nb_dev)
 {
 	u8 i;
 	u32 gfx_cfg = 0;
 	u32 ddi_pads = 0;
 
 	ddi_pads = ~(nbpcie_ind_read_index(nb_dev, 0x65)); /* save original setting */
 	gfx_cfg = nbmisc_read_index(nb_dev, 0x74);
-	for (i = 0; i < 3 ; i++) {
+	for (i = 0; i < 3; i++) {
 		if (gfx_cfg & GFX_CONFIG_DDI) {
 			ddi_pads |= (3 << (i * 2));
 		}
 		gfx_cfg >>= 8;
 	}
 	ddi_pads |= ddi_pads << 8; /* both TX and RX */
 	nbpcie_ind_write_index(nb_dev, 0x65, ~ddi_pads);
 }
 
 static void internal_gfx_pci_dev_init(struct device *dev)
 {
 	unsigned char * bpointer;
 	volatile u32 * GpuF0MMReg;
 	volatile u32 * pointer;
 	int i;
 	u16 command;
 	u32 value;
 	u16 deviceid, vendorid;
 	device_t nb_dev = dev_find_slot(0, 0);
 	device_t k8_f2 = dev_find_slot(0, PCI_DEVFN(0x18, 2));
 	device_t k8_f0 = dev_find_slot(0, PCI_DEVFN(0x18, 0));
 	static const u8 ht_freq_lookup [] = {2, 0, 4, 0, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 0, 0, 28, 30, 32};
 	static const u8 ht_width_lookup [] = {8, 16, 0, 0, 2, 4, 0, 0};
 	static const u16 memclk_lookup_fam0F [] = {100, 0, 133, 0, 0, 166, 0, 200};
 	static const u16 memclk_lookup_fam10 [] = {200, 266, 333, 400, 533, 667, 800, 800};
 
 	/* We definitely will use this in future. Just leave it here. */
 	/*struct southbridge_amd_rs780_config *cfg =
 	   (struct southbridge_amd_rs780_config *)dev->chip_info;*/
 
 	deviceid = pci_read_config16(dev, PCI_DEVICE_ID);
 	vendorid = pci_read_config16(dev, PCI_VENDOR_ID);
 	printk(BIOS_DEBUG, "internal_gfx_pci_dev_init device=%x, vendor=%x.\n",
 	     deviceid, vendorid);
 
 	command = pci_read_config16(dev, 0x04);
 	command |= 0x7;
 	pci_write_config16(dev, 0x04, command);
 
 	/* Clear vgainfo. */
 	bpointer = (unsigned char *) &vgainfo;
 	for (i = 0; i < sizeof(ATOM_INTEGRATED_SYSTEM_INFO_V2); i++) {
 		*bpointer = 0;
 		bpointer++;
 	}
 
 	GpuF0MMReg = (u32 *)pci_read_config32(dev, 0x18);
 
 	/* GFX_InitFBAccess. */
 	value = nbmc_read_index(nb_dev, 0x10);
 	*(GpuF0MMReg + 0x2000/4) = 0x11;
 	*(GpuF0MMReg + 0x2180/4) = ((value&0xff00)>>8)|((value&0xff000000)>>8);
 	*(GpuF0MMReg + 0x2c04/4) = ((value&0xff00)<<8);
 	*(GpuF0MMReg + 0x5428/4) = ((value&0xffff0000)+0x10000)-((value&0xffff)<<16);
 	*(GpuF0MMReg + 0xF774/4) = 0xffffffff;
 	*(GpuF0MMReg + 0xF770/4) = 0x00000001;
 	*(GpuF0MMReg + 0x2000/4) = 0x00000011;
 	*(GpuF0MMReg + 0x200c/4) = 0x00000020;
 	*(GpuF0MMReg + 0x2010/4) = 0x10204810;
 	*(GpuF0MMReg + 0x2010/4) = 0x00204810;
 	*(GpuF0MMReg + 0x2014/4) = 0x10408810;
 	*(GpuF0MMReg + 0x2014/4) = 0x00408810;
 	*(GpuF0MMReg + 0x2414/4) = 0x00000080;
 	*(GpuF0MMReg + 0x2418/4) = 0x84422415;
 	*(GpuF0MMReg + 0x2418/4) = 0x04422415;
 	*(GpuF0MMReg + 0x5490/4) = 0x00000001;
 	*(GpuF0MMReg + 0x7de4/4) |= (1<<3) | (1<<4);
 	/* Force allow LDT_STOP Cool'n'Quiet workaround. */
 	*(GpuF0MMReg + 0x655c/4) |= 1<<4;
 
 	// disable write combining, needed for stability
 	// reference bios does this only for RS780 rev A11
 	// need to figure out why we need it for all revs
 	*(GpuF0MMReg + 0x2000/4) = 0x00000010;
 	*(GpuF0MMReg + 0x2408/4) = 1 << 9;
 	*(GpuF0MMReg + 0x2000/4) = 0x00000011;
 
 	/* GFX_InitFBAccess finished. */
 
 #if CONFIG_GFXUMA /* for UMA mode. */
 	/* GFX_StartMC. */
 	set_nbmc_enable_bits(nb_dev, 0x02, 0x00000000, 0x80000000);
 	set_nbmc_enable_bits(nb_dev, 0x01, 0x00000000, 0x00000001);
 	set_nbmc_enable_bits(nb_dev, 0x01, 0x00000000, 0x00000004);
 	set_nbmc_enable_bits(nb_dev, 0x01, 0x00040000, 0x00000000);
 	set_nbmc_enable_bits(nb_dev, 0xB1, 0xFFFF0000, 0x00000040);
 	set_nbmc_enable_bits(nb_dev, 0xC3, 0x00000000, 0x00000001);
 	set_nbmc_enable_bits(nb_dev, 0x07, 0xFFFFFFFF, 0x00000018);
 	set_nbmc_enable_bits(nb_dev, 0x06, 0xFFFFFFFF, 0x00000102);
 	set_nbmc_enable_bits(nb_dev, 0x09, 0xFFFFFFFF, 0x40000008);
 	set_nbmc_enable_bits(nb_dev, 0x06, 0x00000000, 0x80000000);
 	/* GFX_StartMC finished. */
 #else
 	/* for SP mode. */
 	set_nbmc_enable_bits(nb_dev, 0xaa, 0xf0, 0x30);
 	set_nbmc_enable_bits(nb_dev, 0xce, 0xf0, 0x30);
 	set_nbmc_enable_bits(nb_dev, 0xca, 0xff000000, 0x47000000);
 	set_nbmc_enable_bits(nb_dev, 0xcb, 0x3f000000, 0x01000000);
 	set_nbmc_enable_bits(nb_dev, 0x01, 0, 1<<0);
 	set_nbmc_enable_bits(nb_dev, 0x04, 0, 1<<31);
 	set_nbmc_enable_bits(nb_dev, 0xb4, 0x3f, 0x3f);
 	set_nbmc_enable_bits(nb_dev, 0xb4, 0, 1<<6);
 	set_nbmc_enable_bits(nb_dev, 0xc3, 1<<11, 0);
 	set_nbmc_enable_bits(nb_dev, 0xa0, 1<<29, 0);
 	nbmc_write_index(nb_dev, 0xa4, 0x3484576f);
 	nbmc_write_index(nb_dev, 0xa5, 0x222222df);
 	nbmc_write_index(nb_dev, 0xa6, 0x00000000);
 	nbmc_write_index(nb_dev, 0xa7, 0x00000000);
 	set_nbmc_enable_bits(nb_dev, 0xc3, 1<<8, 0);
 	udelay(10);
 	set_nbmc_enable_bits(nb_dev, 0xc3, 1<<9, 0);
 	udelay(10);
 	set_nbmc_enable_bits(nb_dev, 0x01, 0, 1<<2);
 	udelay(200);
 	set_nbmc_enable_bits(nb_dev, 0x01, 0, 1<<3);
 	set_nbmc_enable_bits(nb_dev, 0xa0, 0, 1<<31);
 	udelay(500);
 	set_nbmc_enable_bits(nb_dev, 0x02, 0, 1<<31);
 	set_nbmc_enable_bits(nb_dev, 0xa0, 0, 1<<30);
 	set_nbmc_enable_bits(nb_dev, 0xa0, 1<<31, 0);
 	set_nbmc_enable_bits(nb_dev, 0xa0, 0, 1<<29);
 	nbmc_write_index(nb_dev, 0xa4, 0x23484576);
 	nbmc_write_index(nb_dev, 0xa5, 0x00000000);
 	nbmc_write_index(nb_dev, 0xa6, 0x00000000);
 	nbmc_write_index(nb_dev, 0xa7, 0x00000000);
 	/* GFX_StartMC finished. */
 
 	/* GFX_SPPowerManagment, don't care for new. */
 	/* Post MC Init table programming. */
 	set_nbmc_enable_bits(nb_dev, 0xac, ~(0xfffffff0), 0x0b);
 
 	/* Do we need Write and Read Calibration? */
 	/* GFX_Init finished. */
 #endif
 
 	/* GFX_InitIntegratedInfo. */
 	/* fill the Integrated Info Table. */
 	vgainfo.sHeader.usStructureSize = sizeof(ATOM_INTEGRATED_SYSTEM_INFO_V2);
 	vgainfo.sHeader.ucTableFormatRevision = 1;
 	vgainfo.sHeader.ucTableContentRevision = 2;
 
 #if !CONFIG_GFXUMA /* SP mode. */
 	// Side port support is incomplete, do not use it
 	// These parameters must match the motherboard
 	vgainfo.ulBootUpSidePortClock = 667*100;
 	vgainfo.ucMemoryType = 3;  // 3 = ddr3 sp mem, 2 = ddr2 sp mem
 	vgainfo.ulMinSidePortClock = 333*100;
 #endif
 
 	vgainfo.ulBootUpEngineClock = 500 * 100;	       	// setup option on reference BIOS, 500 is default
 
 	// find the DDR memory frequency
 	if (is_family10h()) {
 		value = pci_read_config32(k8_f2, 0x94);		// read channel 0 DRAM Configuration High Register
 		if (extractbit(value, 14))			// if channel 0 disabled, channel 1 must have memory
 			value = pci_read_config32(k8_f2, 0x194);// read channel 1 DRAM Configuration High Register
 		vgainfo.ulBootUpUMAClock = memclk_lookup_fam10 [extractbits (value, 0, 2)] * 100;
 	}
 	if (is_family0Fh()) {
 		value = pci_read_config32(k8_f2, 0x94);
 		vgainfo.ulBootUpUMAClock = memclk_lookup_fam0F [extractbits (value, 20, 22)] * 100;
 	}
 
 	/* UMA Channel Number: 1 or 2. */
 	vgainfo.ucUMAChannelNumber = 1;
 	if (is_family0Fh()) {
 		value = pci_read_config32(k8_f2, 0x90);
 	if (extractbit(value, 11))  // 128-bit mode
 		vgainfo.ucUMAChannelNumber = 2;
 	}
 	if (is_family10h()) {
 		u32 dch0 = pci_read_config32(k8_f2, 0x94);
 		u32 dch1 = pci_read_config32(k8_f2, 0x194);
 		if (extractbit(dch0, 14) == 0 && extractbit(dch1, 14) == 0) { // both channels enabled
 			value = pci_read_config32(k8_f2, 0x110);
 			if (extractbit(value, 4))  // ganged mode
 			vgainfo.ucUMAChannelNumber = 2;
 		}
 	}
 
 	// processor type
 	if (is_family0Fh())
 		vgainfo.ulCPUCapInfo = 3;
 	if (is_family10h())
 		vgainfo.ulCPUCapInfo = 2;
 
 	/* HT speed */
 	value = pci_read_config8(nb_dev, 0xd1);
 	value = ht_freq_lookup [value] * 100;  // HT link frequency in MHz
 	vgainfo.ulHTLinkFreq = value * 100;    // HT frequency in units of 100 MHz
 	vgainfo.ulHighVoltageHTLinkFreq = vgainfo.ulHTLinkFreq;
 	vgainfo.ulLowVoltageHTLinkFreq = vgainfo.ulHTLinkFreq;
 
 	if (value <= 1800)
 		vgainfo.ulLowVoltageHTLinkFreq = vgainfo.ulHTLinkFreq;
 	else {
 		int sblink, cpuLnkFreqCap, nbLnkFreqCap;
 		value = pci_read_config32(k8_f0, 0x64);
 		sblink = extractbits(value, 8, 10);
 		cpuLnkFreqCap = pci_read_config16(k8_f0, 0x8a + sblink * 0x20);
 		nbLnkFreqCap = pci_read_config16(nb_dev, 0xd2);
 		if (cpuLnkFreqCap & nbLnkFreqCap & (1 << 10)) // if both 1800 MHz capable
 		vgainfo.ulLowVoltageHTLinkFreq = 1800*100;
 	}
 
 	/* HT width. */
 	value = pci_read_config8(nb_dev, 0xcb);
 	vgainfo.usMinDownStreamHTLinkWidth =
 	vgainfo.usMaxDownStreamHTLinkWidth =
 	vgainfo.usMinUpStreamHTLinkWidth =
 	vgainfo.usMaxUpStreamHTLinkWidth =
 	vgainfo.usMinHTLinkWidth =
 	vgainfo.usMaxHTLinkWidth = ht_width_lookup [extractbits(value, 0, 2)];
 
 	if (is_family0Fh()) {
 		vgainfo.usUMASyncStartDelay = 322;
 		vgainfo.usUMADataReturnTime = 286;
 	}
 
 	if (is_family10h()) {
 		static u16 t0mult_lookup [] = {10, 50, 200, 2000};
 		int t0time, t0scale;
 		value = pci_read_config32(k8_f0, 0x16c);
 		t0time = extractbits(value, 0, 3);
 		t0scale = extractbits(value, 4, 5);
 		vgainfo.usLinkStatusZeroTime = t0mult_lookup [t0scale] * t0time;
 		vgainfo.usUMASyncStartDelay = 100;
 		if (vgainfo.ulHTLinkFreq < 1000 * 100) { // less than 1000 MHz
 			vgainfo.usUMADataReturnTime = 300;
 			vgainfo.usLinkStatusZeroTime = 6 * 100;   // 6us for GH in HT1 mode
 		}
 		else {
 			int lssel;
 			value = pci_read_config32(nb_dev, 0xac);
 			lssel = extractbits (value, 7, 8);
 			vgainfo.usUMADataReturnTime = 1300;
 			if (lssel == 0) vgainfo.usUMADataReturnTime = 150;
 		}
 	}
 
 	/* Poweron DDI Lanes */
 	poweron_ddi_lanes(nb_dev);
 
 	printk(BIOS_DEBUG,"vgainfo:\n"
 			"  ulBootUpEngineClock:%lu\n"
 			"  ulBootUpUMAClock:%lu\n"
 			"  ulBootUpSidePortClock:%lu\n"
 			"  ulMinSidePortClock:%lu\n"
 			"  ulSystemConfig:%lu\n"
 			"  ulBootUpReqDisplayVector:%lu\n"
 			"  ulOtherDisplayMisc:%lu\n"
 			"  ulDDISlot1Config:%lu\n"
 			"  ulDDISlot2Config:%lu\n"
 
 			"  ucMemoryType:%u\n"
 			"  ucUMAChannelNumber:%u\n"
 			"  ucDockingPinBit:%u\n"
 			"  ucDockingPinPolarity:%u\n"
 
 			"  ulDockingPinCFGInfo:%lu\n"
 			"  ulCPUCapInfo: %lu\n"
 
 			"  usNumberOfCyclesInPeriod:%hu\n"
 			"  usMaxNBVoltage:%hu\n"
 			"  usMinNBVoltage:%hu\n"
 			"  usBootUpNBVoltage:%hu\n"
 
 			"  ulHTLinkFreq:%lu\n"
 
 			"  usMinHTLinkWidth:%hu\n"
 			"  usMaxHTLinkWidth:%hu\n"
 			"  usUMASyncStartDelay:%hu\n"
 			"  usUMADataReturnTime:%hu\n"
 			"  usLinkStatusZeroTime:%hu\n"
 
 			"  ulHighVoltageHTLinkFreq:%lu\n"
 			"  ulLowVoltageHTLinkFreq:%lu\n"
 
 			"  usMaxUpStreamHTLinkWidth:%hu\n"
 			"  usMaxDownStreamHTLinkWidth:%hu\n"
 			"  usMinUpStreamHTLinkWidth:%hu\n"
 			"  usMinDownStreamHTLinkWidth:%hu\n",
 
 			(unsigned long)vgainfo.ulBootUpEngineClock,
 			(unsigned long)vgainfo.ulBootUpUMAClock,
 			(unsigned long)vgainfo.ulBootUpSidePortClock,
 			(unsigned long)vgainfo.ulMinSidePortClock,
 			(unsigned long)vgainfo.ulSystemConfig,
 			(unsigned long)vgainfo.ulBootUpReqDisplayVector,
 			(unsigned long)vgainfo.ulOtherDisplayMisc,
 			(unsigned long)vgainfo.ulDDISlot1Config,
 			(unsigned long)vgainfo.ulDDISlot2Config,
 
 			vgainfo.ucMemoryType,
 			vgainfo.ucUMAChannelNumber,
 			vgainfo.ucDockingPinBit,
 			vgainfo.ucDockingPinPolarity,
 
 			(unsigned long)vgainfo.ulDockingPinCFGInfo,
 			(unsigned long)vgainfo.ulCPUCapInfo,
 
 			vgainfo.usNumberOfCyclesInPeriod,
 			vgainfo.usMaxNBVoltage,
 			vgainfo.usMinNBVoltage,
 			vgainfo.usBootUpNBVoltage,
 
 			(unsigned long)vgainfo.ulHTLinkFreq,
 
 			vgainfo.usMinHTLinkWidth,
 			vgainfo.usMaxHTLinkWidth,
 			vgainfo.usUMASyncStartDelay,
 			vgainfo.usUMADataReturnTime,
 			vgainfo.usLinkStatusZeroTime,
 
 			(unsigned long)vgainfo.ulHighVoltageHTLinkFreq,
 			(unsigned long)vgainfo.ulLowVoltageHTLinkFreq,
 
 			vgainfo.usMaxUpStreamHTLinkWidth,
 			vgainfo.usMaxDownStreamHTLinkWidth,
 			vgainfo.usMinUpStreamHTLinkWidth,
 			vgainfo.usMinDownStreamHTLinkWidth);
 
 
 	/* Transfer the Table to VBIOS. */
 	pointer = (u32 *)&vgainfo;
 	for (i = 0; i < sizeof(ATOM_INTEGRATED_SYSTEM_INFO_V2); i+=4) {
 #if CONFIG_GFXUMA
 		*GpuF0MMReg = 0x80000000 + uma_memory_size - 512 + i;
 #else
 		*GpuF0MMReg = 0x80000000 + 0x8000000 - 512 + i;
 #endif
 		*(GpuF0MMReg+1) = *pointer++;
 	}
 
 	/* GFX_InitLate. */
 	{
 		u32 temp;
 		temp = pci_read_config8(dev, 0x4);
 		//temp &= ~1; /* CIM clears this bit. Strangely, I can'd. */
 		temp |= 1<<1|1<<2;
 		pci_write_config8(dev, 0x4, temp);
 
 		// if the GFX debug bar is writable, then it has
 		// been programmed and can be safely enabled now
 		temp = pci_read_config32(nb_dev, 0x8c);
 
 		// if bits 1 (intgfx_enable) and 9 (gfx_debug_bar_enable)
 		// then enable gfx debug bar (set gxf_debug_decode_enable)
 		if (temp & 0x202)
 			temp |= (1 << 10);
 		pci_write_config32(nb_dev, 0x8c, temp);
 
 	}
 
 #ifdef DONT_TRUST_RESOURCE_ALLOCATION
 	/* NB_SetupMGMMIO. */
 
 	/* clear MMIO and CreativeMMIO. */
 	bpointer = (unsigned char *)MMIO;
 	for (i = 0; i < sizeof(MMIO); i++) {
 		*bpointer = 0;
 		bpointer++;
 	}
 	bpointer = (unsigned char *)CreativeMMIO;
 	for (i = 0; i < sizeof(CreativeMMIO); i++) {
 		*bpointer = 0;
 		bpointer++;
 	}
 
 	/* Set MMIO ranges in K8. */
 	/* Set MMIO TOM - 4G. */
 	SetMMIO(0x400<<12, 0x1000000, 0x80, &MMIO[0]);
 	/* Set MMIO for VGA Legacy FB. */
 	SetMMIO(0xa00, 0xc00, 0x80, &MMIO[0]);
 
 	/* Set MMIO for non prefetchable P2P. */
 	temp = pci_read_config32(dev0x14, 0x20);
 	Base32 = (temp & 0x0fff0) << 8;
 	Limit32 = ((temp & 0x0fff00000) + 0x100000) >> 8;
 	if (Base32 < Limit32) {
 		Status = GetCreativeMMIO(&CreativeMMIO[0]);
 		if (Status != CIM_ERROR)
 			SetMMIO(Base32, Limit32, 0x0, &MMIO[0]);
 	}
 	/* Set MMIO for prefetchable P2P. */
 	if (Status != CIM_ERROR) {
 		temp = pci_read_config32(dev0x14, 0x24);
 
 		Base32 = (temp & 0x0fff0) <<8;
 		Limit32 = ((temp & 0x0fff00000) + 0x100000) >> 8;
 		if (Base32 < Limit32)
 			SetMMIO(Base32, Limit32, 0x0, &MMIO[0]);
 	}
 
 	FinalizeMMIO(&MMIO[0]);
 
 	ProgramMMIO(&CreativeMMIO[0], 0, MMIO_ATTRIB_NP_ONLY);
 	ProgramMMIO(&MMIO[0], 0, MMIO_ATTRIB_NP_ONLY | MMIO_ATTRIB_BOTTOM_TO_TOP | MMIO_ATTRIB_SKIP_ZERO);
 #endif
 
 	pci_dev_init(dev);
 
 	/* clk ind */
 	clkind_write(dev, 0x08, 0x01);
 	clkind_write(dev, 0x0C, 0x22);
 	clkind_write(dev, 0x0F, 0x0);
 	clkind_write(dev, 0x11, 0x0);
 	clkind_write(dev, 0x12, 0x0);
 	clkind_write(dev, 0x14, 0x0);
 	clkind_write(dev, 0x15, 0x0);
 	clkind_write(dev, 0x16, 0x0);
 	clkind_write(dev, 0x17, 0x0);
 	clkind_write(dev, 0x18, 0x0);
 	clkind_write(dev, 0x19, 0x0);
 	clkind_write(dev, 0x1A, 0x0);
 	clkind_write(dev, 0x1B, 0x0);
 	clkind_write(dev, 0x1C, 0x0);
 	clkind_write(dev, 0x1D, 0x0);
 	clkind_write(dev, 0x1E, 0x0);
 	clkind_write(dev, 0x26, 0x0);
 	clkind_write(dev, 0x27, 0x0);
 	clkind_write(dev, 0x28, 0x0);
 	clkind_write(dev, 0x5C, 0x0);
 }
 
 /**
  * Set registers in RS780 and CPU to disable the internal GFX.
  * Please refer to `rs780_internal_gfx_enable()`.
  */
 static void rs780_internal_gfx_disable(device_t dev)
 {
 	u32 l_dword;
 	device_t nb_dev = dev_find_slot(0, 0);
 
 	/* Disable internal GFX and enable external GFX. */
 	l_dword = pci_read_config32(nb_dev, 0x8c);
 	l_dword |= 1<<0;
 	l_dword &= ~(1<<1);
 	pci_write_config32(nb_dev, 0x8c, l_dword);
 
 	dev->enabled = 0;
 }
 
 /*
 * Set registers in RS780 and CPU to enable the internal GFX.
 * Please refer to CIM source code and BKDG.
 */
 
 static void rs780_internal_gfx_enable(device_t dev)
 {
 	u32 l_dword;
 	int i;
 	device_t nb_dev = dev_find_slot(0, 0);
 	msr_t sysmem;
 
 #if !CONFIG_GFXUMA
 	u32 FB_Start, FB_End;
 #endif
 
 	printk(BIOS_DEBUG, "rs780_internal_gfx_enable dev = 0x%p, nb_dev = 0x%p.\n", dev, nb_dev);
 
 	/* The system top memory in 780. */
 	sysmem = rdmsr(0xc001001a);
 	printk(BIOS_DEBUG, "Sysmem TOM = %x_%x\n", sysmem.hi, sysmem.lo);
 	pci_write_config32(nb_dev, 0x90, sysmem.lo);
 
 	sysmem = rdmsr(0xc001001D);
 	printk(BIOS_DEBUG, "Sysmem TOM2 = %x_%x\n", sysmem.hi, sysmem.lo);
 	htiu_write_index(nb_dev, 0x31, sysmem.hi);
 	htiu_write_index(nb_dev, 0x30, sysmem.lo | 1);
 
 	/* Disable external GFX and enable internal GFX. */
 	l_dword = pci_read_config32(nb_dev, 0x8c);
 	l_dword &= ~(1<<0);
 	l_dword |= 1<<1;
 	pci_write_config32(nb_dev, 0x8c, l_dword);
 
 	/* NB_SetDefaultIndexes */
 	pci_write_config32(nb_dev, 0x94, 0x7f);
 	pci_write_config32(nb_dev, 0x60, 0x7f);
 	pci_write_config32(nb_dev, 0xe0, 0);
 
 	/* NB_InitEarlyNB finished. */
 
 	/* LPC DMA Deadlock workaround? */
 	/* GFX_InitCommon*/
 	device_t k8_f0 = dev_find_slot(0, PCI_DEVFN(0x18, 0));
 	l_dword = pci_read_config32(k8_f0, 0x68);
 	l_dword &= ~(3 << 21);
 	l_dword |= (1 << 21);
 	pci_write_config32(k8_f0, 0x68, l_dword);
 
 	/* GFX_InitCommon. */
 	nbmc_write_index(nb_dev, 0x23, 0x00c00010);
 	set_nbmc_enable_bits(nb_dev, 0x16, 1<<15, 1<<15);
 	set_nbmc_enable_bits(nb_dev, 0x25, 0xffffffff, 0x111f111f);
 	set_htiu_enable_bits(nb_dev, 0x37, 1<<24, 1<<24);
 
 #if CONFIG_GFXUMA
 	/* GFX_InitUMA. */
 	/* Copy CPU DDR Controller to NB MC. */
 	device_t k8_f1 = dev_find_slot(0, PCI_DEVFN(0x18, 1));
 	device_t k8_f2 = dev_find_slot(0, PCI_DEVFN(0x18, 2));
 	device_t k8_f4 = dev_find_slot(0, PCI_DEVFN(0x18, 4));
 	for (i = 0; i < 12; i++) {
 		l_dword = pci_read_config32(k8_f2, 0x40 + i * 4);
 		nbmc_write_index(nb_dev, 0x30 + i, l_dword);
 	}
 
 	l_dword = pci_read_config32(k8_f2, 0x80);
 	nbmc_write_index(nb_dev, 0x3c, l_dword);
 	l_dword = pci_read_config32(k8_f2, 0x94);
 	set_nbmc_enable_bits(nb_dev, 0x3c, 0, !!(l_dword & (1<<22))<<16);
 	set_nbmc_enable_bits(nb_dev, 0x3c, 0, !!(l_dword & (1<< 8))<<17);
 	l_dword = pci_read_config32(k8_f2, 0x90);
 	set_nbmc_enable_bits(nb_dev, 0x3c, 0, !!(l_dword & (1<<10))<<18);
    if (is_family10h()) {
 	   for (i = 0; i < 12; i++) {
 		   l_dword = pci_read_config32(k8_f2, 0x140 + i * 4);
 		   nbmc_write_index(nb_dev, 0x3d + i, l_dword);
 	   }
 
 	   l_dword = pci_read_config32(k8_f2, 0x180);
 	   nbmc_write_index(nb_dev, 0x49, l_dword);
 	   l_dword = pci_read_config32(k8_f2, 0x194);
 	   set_nbmc_enable_bits(nb_dev, 0x49, 0, !!(l_dword & (1<<22))<<16);
 	   set_nbmc_enable_bits(nb_dev, 0x49, 0, !!(l_dword & (1<< 8))<<17);
 	   l_dword = pci_read_config32(k8_f2, 0x190);
 	   set_nbmc_enable_bits(nb_dev, 0x49, 0, !!(l_dword & (1<<10))<<18);
 
 	   l_dword = pci_read_config32(k8_f2, 0x110);
 	   nbmc_write_index(nb_dev, 0x4a, l_dword);
 	   l_dword = pci_read_config32(k8_f2, 0x114);
 	   nbmc_write_index(nb_dev, 0x4b, l_dword);
 	   l_dword = pci_read_config32(k8_f4, 0x44);
 	   set_nbmc_enable_bits(nb_dev, 0x4a, 0, !!(l_dword & (1<<22))<<24);
 	   l_dword = pci_read_config32(k8_f1, 0x40);
 	   nbmc_write_index(nb_dev, 0x4c, l_dword);
 	   l_dword = pci_read_config32(k8_f1, 0xf0);
 	   nbmc_write_index(nb_dev, 0x4d, l_dword);
    }
 
 
 	/* Set UMA in the 780 side. */
 	/* UMA start address, size. */
 	/* The UMA starts at 0xC0000000 of internal RS780 address space
 	    [31:16] addr of last byte | [31:16] addr of first byte
 	*/
 	nbmc_write_index(nb_dev, 0x10, ((uma_memory_size - 1 + 0xC0000000) & (~0xffff)) | 0xc000);
 	nbmc_write_index(nb_dev, 0x11, uma_memory_base);
 	nbmc_write_index(nb_dev, 0x12, 0);
 	nbmc_write_index(nb_dev, 0xf0, uma_memory_size >> 20);
 	/* GFX_InitUMA finished. */
 #else
 	/* GFX_InitSP. */
 	/* SP memory:Hynix HY5TQ1G631ZNFP. 128MB = 64M * 16. 667MHz. DDR3. */
 
 	/* Enable Async mode. */
 	set_nbmc_enable_bits(nb_dev, 0x06, 7<<8, 1<<8);
 	set_nbmc_enable_bits(nb_dev, 0x08, 1<<10, 0);
 	/* The last item in AsynchMclkTaskFileIndex. Why? */
 	/* MC_MPLL_CONTROL2. */
 	nbmc_write_index(nb_dev, 0x07, 0x40100028);
 	/* MC_MPLL_DIV_CONTROL. */
 	nbmc_write_index(nb_dev, 0x0b, 0x00000028);
 	/* MC_MPLL_FREQ_CONTROL. */
 	set_nbmc_enable_bits(nb_dev, 0x09, 3<<12|15<<16|15<<8, 1<<12|4<<16|0<<8);
 	/* MC_MPLL_CONTROL3. For PM. */
 	set_nbmc_enable_bits(nb_dev, 0x08, 0xff<<13, 1<<13|1<<18);
 	/* MPLL_CAL_TRIGGER. */
 	set_nbmc_enable_bits(nb_dev, 0x06, 0, 1<<0);
 	udelay(200); /* time is long enough? */
 	set_nbmc_enable_bits(nb_dev, 0x06, 0, 1<<1);
 	set_nbmc_enable_bits(nb_dev, 0x06, 1<<0, 0);
 	/* MCLK_SRC_USE_MPLL. */
 	set_nbmc_enable_bits(nb_dev, 0x02, 0, 1<<20);
 
 	/* Pre Init MC. */
 	nbmc_write_index(nb_dev, 0x01, 0x88108280);
 	set_nbmc_enable_bits(nb_dev, 0x02, ~(1<<20), 0x00030200);
 	nbmc_write_index(nb_dev, 0x04, 0x08881018);
 	nbmc_write_index(nb_dev, 0x05, 0x000000bb);
 	nbmc_write_index(nb_dev, 0x0c, 0x0f00001f);
 	nbmc_write_index(nb_dev, 0xa1, 0x01f10000);
 	/* MCA_INIT_DLL_PM. */
 	set_nbmc_enable_bits(nb_dev, 0xc9, 1<<24, 1<<24);
 	nbmc_write_index(nb_dev, 0xa2, 0x74f20000);
 	nbmc_write_index(nb_dev, 0xa3, 0x8af30000);
 	nbmc_write_index(nb_dev, 0xaf, 0x47d0a41c);
 	nbmc_write_index(nb_dev, 0xb0, 0x88800130);
 	nbmc_write_index(nb_dev, 0xb1, 0x00000040);
 	nbmc_write_index(nb_dev, 0xb4, 0x41247000);
 	nbmc_write_index(nb_dev, 0xb5, 0x00066664);
 	nbmc_write_index(nb_dev, 0xb6, 0x00000022);
 	nbmc_write_index(nb_dev, 0xb7, 0x00000044);
 	nbmc_write_index(nb_dev, 0xb8, 0xbbbbbbbb);
 	nbmc_write_index(nb_dev, 0xb9, 0xbbbbbbbb);
 	nbmc_write_index(nb_dev, 0xba, 0x55555555);
 	nbmc_write_index(nb_dev, 0xc1, 0x00000000);
 	nbmc_write_index(nb_dev, 0xc2, 0x00000000);
 	nbmc_write_index(nb_dev, 0xc3, 0x80006b00);
 	nbmc_write_index(nb_dev, 0xc4, 0x00066664);
 	nbmc_write_index(nb_dev, 0xc5, 0x00000000);
 	nbmc_write_index(nb_dev, 0xd2, 0x00000022);
 	nbmc_write_index(nb_dev, 0xd3, 0x00000044);
 	nbmc_write_index(nb_dev, 0xd6, 0x00050005);
 	nbmc_write_index(nb_dev, 0xd7, 0x00000000);
 	nbmc_write_index(nb_dev, 0xd8, 0x00700070);
 	nbmc_write_index(nb_dev, 0xd9, 0x00700070);
 	nbmc_write_index(nb_dev, 0xe0, 0x00200020);
 	nbmc_write_index(nb_dev, 0xe1, 0x00200020);
 	nbmc_write_index(nb_dev, 0xe8, 0x00200020);
 	nbmc_write_index(nb_dev, 0xe9, 0x00200020);
 	nbmc_write_index(nb_dev, 0xe0, 0x00180018);
 	nbmc_write_index(nb_dev, 0xe1, 0x00180018);
 	nbmc_write_index(nb_dev, 0xe8, 0x00180018);
 	nbmc_write_index(nb_dev, 0xe9, 0x00180018);
 
 	/* Misc options. */
 	/* Memory Termination. */
 	set_nbmc_enable_bits(nb_dev, 0xa1, 0x0ff, 0x044);
 	set_nbmc_enable_bits(nb_dev, 0xb4, 0xf00, 0xb00);
 #if 0
 	/* Controller Termination. */
 	set_nbmc_enable_bits(nb_dev, 0xb1, 0x77770000, 0x77770000);
 #endif
 
 	/* OEM Init MC. 667MHz. */
 	nbmc_write_index(nb_dev, 0xa8, 0x7a5aaa78);
 	nbmc_write_index(nb_dev, 0xa9, 0x514a2319);
 	nbmc_write_index(nb_dev, 0xaa, 0x54400520);
 	nbmc_write_index(nb_dev, 0xab, 0x441460ff);
 	nbmc_write_index(nb_dev, 0xa0, 0x20f00a48);
 	set_nbmc_enable_bits(nb_dev, 0xa2, ~(0xffffffc7), 0x10);
 	nbmc_write_index(nb_dev, 0xb2, 0x00000303);
 	set_nbmc_enable_bits(nb_dev, 0xb1, ~(0xffffff70), 0x45);
 	/* Do it later. */
 	/* set_nbmc_enable_bits(nb_dev, 0xac, ~(0xfffffff0), 0x0b); */
 
 	/* Init PM timing. */
 	for (i = 0; i < 4; i++) {
 		l_dword = nbmc_read_index(nb_dev, 0xa0+i);
 		nbmc_write_index(nb_dev, 0xc8+i, l_dword);
 	}
 	for (i = 0; i < 4; i++) {
 		l_dword = nbmc_read_index(nb_dev, 0xa8+i);
 		nbmc_write_index(nb_dev, 0xcc+i, l_dword);
 	}
 	l_dword = nbmc_read_index(nb_dev, 0xb1);
 	set_nbmc_enable_bits(nb_dev, 0xc8, 0xff<<24, ((l_dword&0x0f)<<24)|((l_dword&0xf00)<<20));
 
 	/* Init MC FB. */
 	/* FB_Start = ; FB_End = ; iSpSize = 0x0080, 128MB. */
 	nbmc_write_index(nb_dev, 0x11, 0x40000000);
 	FB_Start = 0xc00 + 0x080;
 	FB_End = 0xc00 + 0x080;
 	nbmc_write_index(nb_dev, 0x10, (((FB_End&0xfff)<<20)-0x10000)|(((FB_Start&0xfff)-0x080)<<4));
 	set_nbmc_enable_bits(nb_dev, 0x0d, ~0x000ffff0, (FB_Start&0xfff)<<20);
 	nbmc_write_index(nb_dev, 0x0f, 0);
 	nbmc_write_index(nb_dev, 0x0e, (FB_Start&0xfff)|(0xaaaa<<12));
 #endif
 
 	/* GFX_InitSP finished. */
 }
 
 static struct pci_operations lops_pci = {
 	.set_subsystem = pci_dev_set_subsystem,
 };
 
 static struct device_operations pcie_ops = {
 	.read_resources = rs780_gfx_read_resources,
 	.set_resources = pci_dev_set_resources,
 	.enable_resources = pci_dev_enable_resources,
 	.init = internal_gfx_pci_dev_init,	/* The option ROM initializes the device. rs780_gfx_init, */
 	.scan_bus = 0,
 	.enable = rs780_internal_gfx_enable,
 	.disable = rs780_internal_gfx_disable,
 	.ops_pci = &lops_pci,
 };
 
 /*
  * We should list all of them here.
  * */
 static const unsigned short pcie_780_ids[] = {
 	PCI_DEVICE_ID_ATI_RS780_INT_GFX,
 	PCI_DEVICE_ID_ATI_RS780C_INT_GFX,
 	PCI_DEVICE_ID_ATI_RS780M_INT_GFX,
 	PCI_DEVICE_ID_ATI_RS780MC_INT_GFX,
 	PCI_DEVICE_ID_ATI_RS780E_INT_GFX,
 	PCI_DEVICE_ID_ATI_RS785G_INT_GFX,
 	PCI_DEVICE_ID_ATI_RS785C_INT_GFX,
 	PCI_DEVICE_ID_ATI_RS785M_INT_GFX,
 	PCI_DEVICE_ID_ATI_RS785MC_INT_GFX,
 	PCI_DEVICE_ID_ATI_RS785D_INT_GFX,
 	0
 };
 
 static const struct pci_driver pcie_driver_780 __pci_driver = {
 	.ops = &pcie_ops,
 	.vendor = PCI_VENDOR_ID_ATI,
 	.devices = pcie_780_ids,
 };
 
 /* step 12 ~ step 14 from rpr */
 static void single_port_configuration(device_t nb_dev, device_t dev)
 {
 	u8 result, width;
 	u32 reg32;
 	struct southbridge_amd_rs780_config *cfg =
 	    (struct southbridge_amd_rs780_config *)nb_dev->chip_info;
 
 	printk(BIOS_DEBUG, "rs780_gfx_init single_port_configuration.\n");
 
 	/* step 12 training, releases hold training for GFX port 0 (device 2) */
 	PcieReleasePortTraining(nb_dev, dev, 2);
 	result = PcieTrainPort(nb_dev, dev, 2);
 	printk(BIOS_DEBUG, "rs780_gfx_init single_port_configuration step12.\n");
 
 	/* step 13 Power Down Control */
 	/* step 13.1 Enables powering down transmitter and receiver pads along with PLL macros. */
 	set_pcie_enable_bits(nb_dev, 0x40, 1 << 0, 1 << 0);
 
 	/* step 13.a Link Training was NOT successful */
 	if (!result) {
 		set_nbmisc_enable_bits(nb_dev, 0x8, 0, 0x3 << 4); /* prevent from training. */
 		set_nbmisc_enable_bits(nb_dev, 0xc, 0, 0x3 << 2); /* hide the GFX bridge. */
 		if (cfg->gfx_tmds)
 			nbpcie_ind_write_index(nb_dev, 0x65, 0xccf0f0);
 		else {
 			nbpcie_ind_write_index(nb_dev, 0x65, 0xffffffff);
 			set_nbmisc_enable_bits(nb_dev, 0x7, 1 << 3, 1 << 3);
 		}
 	} else {		/* step 13.b Link Training was successful */
 		AtiPcieCfg.PortDetect |= 1 << 2; /* Port 2 */
 		set_pcie_enable_bits(dev, 0xA2, 0xFF, 0x1);
 		reg32 = nbpcie_p_read_index(dev, 0x29);
 		width = reg32 & 0xFF;
 		printk(BIOS_DEBUG, "GFX Inactive Lanes = 0x%x.\n", width);
 		switch (width) {
 		case 1:
 		case 2:
 			nbpcie_ind_write_index(nb_dev, 0x65,
 					       cfg->gfx_lane_reversal ? 0x7f7f : 0xccfefe);
 			break;
 		case 4:
 			nbpcie_ind_write_index(nb_dev, 0x65,
 					       cfg->gfx_lane_reversal ? 0x3f3f : 0xccfcfc);
 			break;
 		case 8:
 			nbpcie_ind_write_index(nb_dev, 0x65,
 					       cfg->gfx_lane_reversal ? 0x0f0f : 0xccf0f0);
 			break;
 		}
 	}
 	printk(BIOS_DEBUG, "rs780_gfx_init single_port_configuration step13.\n");
 
 	/* step 14 Reset Enumeration Timer, disables the shortening of the enumeration timer */
 	set_pcie_enable_bits(dev, 0x70, 1 << 19, 1 << 19);
 	printk(BIOS_DEBUG, "rs780_gfx_init single_port_configuration step14.\n");
 }
 
 static void dual_port_configuration(device_t nb_dev, device_t dev)
 {
 	u8 result, width;
 	u32 reg32, dev_ind = dev->path.pci.devfn >> 3;
 	struct southbridge_amd_rs780_config *cfg =
 		    (struct southbridge_amd_rs780_config *)nb_dev->chip_info;
 
 	/* 5.4.1.2 Dual Port Configuration */
 	set_nbmisc_enable_bits(nb_dev, 0x36, 1 << 31, 1 << 31);
 	set_nbmisc_enable_bits(nb_dev, 0x08, 0xF << 8, 0x5 << 8);
 	set_nbmisc_enable_bits(nb_dev, 0x36, 1 << 31, 0 << 31);
 
 	/* 5.7. Training for Device 2 */
 	/* 5.7.1. Releases hold training for GFX port 0 (device 2) */
 	PcieReleasePortTraining(nb_dev, dev, dev_ind);
 	/* 5.7.2- 5.7.9. PCIE Link Training Sequence */
 	result = PcieTrainPort(nb_dev, dev, dev_ind);
 
 	/* Power Down Control for Device 2 */
 	/* Link Training was NOT successful */
 	if (!result) {
 		/* Powers down all lanes for port A */
 		/* nbpcie_ind_write_index(nb_dev, 0x65, 0x0f0f); */
 		/* Note: I have to disable the slot where there isn't a device,
 		 * otherwise the system will hang. I don't know why. */
 		set_nbmisc_enable_bits(nb_dev, 0x0c, 1 << dev_ind, 1 << dev_ind);
 
 	} else {		/* step 16.b Link Training was successful */
 		AtiPcieCfg.PortDetect |= 1 << dev_ind;
 		reg32 = nbpcie_p_read_index(dev, 0xa2);
 		width = (reg32 >> 4) & 0x7;
 		printk(BIOS_DEBUG, "GFX LC_LINK_WIDTH = 0x%x.\n", width);
 		switch (width) {
 		case 1:
 		case 2:
 			nbpcie_ind_write_index(nb_dev, 0x65,
 					       cfg->gfx_lane_reversal ? 0x0707 : 0x0e0e);
 			break;
 		case 4:
 			nbpcie_ind_write_index(nb_dev, 0x65,
 					       cfg->gfx_lane_reversal ? 0x0303 : 0x0c0c);
 			break;
 		}
 	}
 }
 
 /* For single port GFX configuration Only
 * width:
 * 	000 = x16
 * 	001 = x1
 *	010 = x2
 *	011 = x4
 *	100 = x8
 *	101 = x12 (not supported)
 *	110 = x16
 */
 static void dynamic_link_width_control(device_t nb_dev, device_t dev, u8 width)
 {
 	u32 reg32;
 	device_t sb_dev;
 	struct southbridge_amd_rs780_config *cfg =
 	    (struct southbridge_amd_rs780_config *)nb_dev->chip_info;
 
 	/* step 5.9.1.1 */
 	reg32 = nbpcie_p_read_index(dev, 0xa2);
 
 	/* step 5.9.1.2 */
 	set_pcie_enable_bits(nb_dev, 0x40, 1 << 0, 1 << 0);
 	/* step 5.9.1.3 */
 	set_pcie_enable_bits(dev, 0xa2, 3 << 0, width << 0);
 	/* step 5.9.1.4 */
 	set_pcie_enable_bits(dev, 0xa2, 1 << 8, 1 << 8);
 	/* step 5.9.2.4 */
 	if (0 == cfg->gfx_reconfiguration)
 		set_pcie_enable_bits(dev, 0xa2, 1 << 11, 1 << 11);
 
 	/* step 5.9.1.5 */
 	do {
 		reg32 = nbpcie_p_read_index(dev, 0xa2);
 	}
 	while (reg32 & 0x100);
 
 	/* step 5.9.1.6 */
 	sb_dev = dev_find_slot(0, PCI_DEVFN(8, 0));
 	do {
 		reg32 = pci_ext_read_config32(nb_dev, sb_dev,
 					  PCIE_VC0_RESOURCE_STATUS);
 	} while (reg32 & VC_NEGOTIATION_PENDING);
 
 	/* step 5.9.1.7 */
 	reg32 = nbpcie_p_read_index(dev, 0xa2);
 	if (((reg32 & 0x70) >> 4) != 0x6) {
 		/* the unused lanes should be powered off. */
 	}
 
 	/* step 5.9.1.8 */
 	set_pcie_enable_bits(nb_dev, 0x40, 1 << 0, 0 << 0);
 }
 
 /*
 * GFX Core initialization, dev2, dev3
 */
 void rs780_gfx_init(device_t nb_dev, device_t dev, u32 port)
 {
 	u32 reg32;
 	struct southbridge_amd_rs780_config *cfg =
 	    (struct southbridge_amd_rs780_config *)nb_dev->chip_info;
 
 	printk(BIOS_DEBUG, "rs780_gfx_init, nb_dev=0x%p, dev=0x%p, port=0x%x.\n",
 		    nb_dev, dev, port);
 
 	/* GFX Core Initialization */
 	//if (port == 2) return;
 
 	/* step 2, TMDS, (only need if CMOS option is enabled) */
 	if (cfg->gfx_tmds) {
 		/**
 		 * PCIe Initialization for DDI.
 		 * The VBIOS/Driver is responsible for DDI programming sequence,
 		 * The SBIOS is responsible for programming the lane and clock muxing specific to each case.
 		 * Refer to RPR Chapter 7: "PCIe Initialization for DDI".
 		 * Note: This programming must be done before hold training is released.
 		 */
 		switch (cfg->gfx_pcie_config) {
 			case 1: /* 1x16 GFX -default case, no programming required */
 				break;
 			case 2: /* 1x8 GFX on Lanes 0-7 */
 			case 5: /* 1x4 GPP on Lanes 0-3 */
 				set_nbmisc_enable_bits(nb_dev, 0x27, 0x1 << 6, 0x1 << 6); /* Disables PCIe mode on PHY Lanes  8-11 */
 				set_nbmisc_enable_bits(nb_dev, 0x27, 0x1 << 7, 0x1 << 7); /* Disables PCIe mode on PHY Lanes 12-15 */
 				break;
 			case 3: /* 1x8 on Lanes 8-15 */
 			case 7: /* 1x4 GPP on Lanes 8-11 */
 				/* TXCLK */
 				set_nbmisc_enable_bits(nb_dev, 0x07, 1 << 16, 1 << 16);
 				set_nbmisc_enable_bits(nb_dev, 0x07, 0xF << 12, 0xF << 12);
 				set_nbmisc_enable_bits(nb_dev, 0x07, 0x3 << 24, 0x2 << 24);
 				set_nbmisc_enable_bits(nb_dev, 0x28, 0x3 << 0, 0x0 << 0);
 				/* RXCLK */
 				set_nbmisc_enable_bits(nb_dev, 0x27, 0x3 << 8, 0x2 << 8);
 				set_nbmisc_enable_bits(nb_dev, 0x27, 0x3 << 10, 0x2 << 10);
 				set_nbmisc_enable_bits(nb_dev, 0x27, 0x3 << 12, 0x2 << 12);
 				set_nbmisc_enable_bits(nb_dev, 0x27, 0x3 << 14, 0x2 << 14);
 				/* TX Lane Muxing */
 				set_nbmisc_enable_bits(nb_dev, 0x27, 0x1 << 2, 0x1 << 2);
 				set_nbmisc_enable_bits(nb_dev, 0x27, 0x1 << 3, 0x1 << 3);
 				set_nbmisc_enable_bits(nb_dev, 0x27, 0x1 << 4, 0x1 << 4);
 				set_nbmisc_enable_bits(nb_dev, 0x27, 0x1 << 5, 0x1 << 5);
 				break;
 			case 4:  /* 2x8 */
 			case 10: /* 1x4 GPP on Lanes 0-3 and 1x4 GPP on Lanes 8-11 */
 			case 14: /* 1x8 GFX on Lanes 0-7 and 1x4 GPP on Lanes 8-11 */
 			case 17: /* 1x4 GPP on Lanes 0-3 and 1x8 GFX on Lanes 8-15 */
 				/* Set dual slot configuration */
 				set_nbmisc_enable_bits(nb_dev, 0x08, 0xF << 8, 0x5 << 8);
 				break;
 			case 9: /* PCIe 2x4 GPPs on Lanes 0-7 */
 			case 6: /* PCIe 1x4 GPP on Lanes 4-7 */
 				/* Set dual slot configuration */
 				set_nbmisc_enable_bits(nb_dev, 0x08, 0xF << 8, 0x5 << 8);
 				/* TXCLK */
 				set_nbmisc_enable_bits(nb_dev, 0x07, 1 << 16, 0 << 16);
 				set_nbmisc_enable_bits(nb_dev, 0x07, 0xF << 12, 0x0 << 12);
 				set_nbmisc_enable_bits(nb_dev, 0x07, 0x3 << 20, 0x0 << 20);
 				set_nbmisc_enable_bits(nb_dev, 0x28, 0x1 << 0, 0x0 << 0);
 				/* RXCLK */
 				set_nbmisc_enable_bits(nb_dev, 0x27, 0x3 << 8, 0x0 << 8);
 				set_nbmisc_enable_bits(nb_dev, 0x27, 0x3 << 10, 0x1 << 10);
 				set_nbmisc_enable_bits(nb_dev, 0x27, 0x3 << 12, 0x3 << 12);
 				set_nbmisc_enable_bits(nb_dev, 0x27, 0x3 << 14, 0x0 << 14);
 				/* TX Lane Muxing */
 				set_nbmisc_enable_bits(nb_dev, 0x27, 0x1 << 1, 0x1 << 1);
 				set_nbmisc_enable_bits(nb_dev, 0x27, 0x1 << 6, 0x1 << 6);
 				set_nbmisc_enable_bits(nb_dev, 0x27, 0x1 << 7, 0x1 << 7);
 				break;
 			case 13: /* 2x4 GPPs on Lanes 8-15 */
 			case 8:  /* 1x4 GPP on Lanes 12-15 */
 				/* Set dual slot configuration */
 				set_nbmisc_enable_bits(nb_dev, 0x08, 0xF << 8, 0x5 << 8);
 				/* TXCLK */
 				set_nbmisc_enable_bits(nb_dev, 0x07, 1 << 16, 1 << 16);
 				set_nbmisc_enable_bits(nb_dev, 0x07, 0xF << 12, 0xF << 12);
 				set_nbmisc_enable_bits(nb_dev, 0x07, 0x3 << 24, 0x2 << 24);
 				set_nbmisc_enable_bits(nb_dev, 0x28, 0x3 << 0, 0x3 << 0);
 				/* RXCLK */
 				set_nbmisc_enable_bits(nb_dev, 0x27, 0x3 << 8, 0x2 << 8);
 				set_nbmisc_enable_bits(nb_dev, 0x27, 0x3 << 10, 0x3 << 10);
 				set_nbmisc_enable_bits(nb_dev, 0x27, 0x3 << 12, 0x1 << 12);
 				set_nbmisc_enable_bits(nb_dev, 0x27, 0x3 << 14, 0x2 << 14);
 				/* TX Lane Muxing */
 				set_nbmisc_enable_bits(nb_dev, 0x27, 0x1 << 2, 0x1 << 2);
 				set_nbmisc_enable_bits(nb_dev, 0x28, 0x1 << 14, 0x1 << 14);
 				set_nbmisc_enable_bits(nb_dev, 0x27, 0x1 << 4, 0x1 << 4);
 				set_nbmisc_enable_bits(nb_dev, 0x27, 0x1 << 5, 0x1 << 5);
 				break;
 			case 15: /* 1x8 GFX on Lanes 0-7 and 1x4 GPP on Lanes 12-15 */
 			case 11: /* 1x4 GPP on Lanes 0-3 and 1x4 GPP on Lanes 12-15 */
 				/* Set dual slot configuration */
 				set_nbmisc_enable_bits(nb_dev, 0x08, 0xF << 8, 0x5 << 8);
 				/* TXCLK */
 				set_nbmisc_enable_bits(nb_dev, 0x07, 1 << 16, 0 << 16);
 				set_nbmisc_enable_bits(nb_dev, 0x07, 0xF << 12, 0x0 << 12);
 				set_nbmisc_enable_bits(nb_dev, 0x07, 0x3 << 20, 0x0 << 20);
 				set_nbmisc_enable_bits(nb_dev, 0x28, 0x3 << 0, 0x1 << 0);
 				/* RXCLK */
 				set_nbmisc_enable_bits(nb_dev, 0x27, 0x3 << 8, 0x0 << 8);
 				set_nbmisc_enable_bits(nb_dev, 0x27, 0x3 << 10, 0x0 << 10);
 				set_nbmisc_enable_bits(nb_dev, 0x27, 0x3 << 12, 0x1 << 12);
 				set_nbmisc_enable_bits(nb_dev, 0x27, 0x3 << 14, 0x3 << 14);
 				/* TX Lane Muxing */
 				set_nbmisc_enable_bits(nb_dev, 0x28, 0x1 << 14, 0x1 << 14);
 				set_nbmisc_enable_bits(nb_dev, 0x27, 0x1 << 6, 0x1 << 6);
 				break;
 			case 16: /* 1x8 GFX on Lanes 8-15 and 1x4 GPP on Lanes 4-7 */
 			case 12: /* 1x4 GPP on Lanes 4-7 and 1x8 GFX on Lanes 8-15 */
 				/* Set dual slot configuration */
 				set_nbmisc_enable_bits(nb_dev, 0x08, 0xF << 8, 0x5 << 8);
 				/* TXCLK */
 				set_nbmisc_enable_bits(nb_dev, 0x07, 1 << 16, 1 << 16);
 				set_nbmisc_enable_bits(nb_dev, 0x07, 0xF << 12, 0xF << 12);
 				set_nbmisc_enable_bits(nb_dev, 0x07, 0x3 << 24, 0x2 << 24);
 				set_nbmisc_enable_bits(nb_dev, 0x07, 0x3 << 22, 0x2 << 22);
 				set_nbmisc_enable_bits(nb_dev, 0x28, 0x3 << 0, 0x2 << 0);
 				/* RXCLK */
 				set_nbmisc_enable_bits(nb_dev, 0x27, 0x3 << 8, 0x2 << 8);
 				set_nbmisc_enable_bits(nb_dev, 0x27, 0x3 << 10, 0x2 << 10);
 				set_nbmisc_enable_bits(nb_dev, 0x27, 0x3 << 12, 0x3 << 12);
 				set_nbmisc_enable_bits(nb_dev, 0x27, 0x3 << 14, 0x1 << 14);
 				/* TX Lane Muxing */
 				set_nbmisc_enable_bits(nb_dev, 0x27, 0x1 << 2, 0x1 << 2);
 				set_nbmisc_enable_bits(nb_dev, 0x27, 0x1 << 3, 0x1 << 3);
 				set_nbmisc_enable_bits(nb_dev, 0x27, 0x1 << 1, 0x1 << 1);
 				set_nbmisc_enable_bits(nb_dev, 0x27, 0x1 << 4, 0x1 << 4);
 				break;
 			default:
 				printk(BIOS_INFO, "Incorrect configuration of external GFX slot.\n");
 				break;
 		}
 
 		/* DDI Configuration */
 		switch (cfg->gfx_ddi_config) {
 			case 1: /* DDI_SL lanes0-3 */
 				nbmisc_write_index(nb_dev, 0x74, GFX_CONFIG_DDI);
 				break;
 			case 2: /* DDI_SL lanes4-7 */
 				nbmisc_write_index(nb_dev, 0x74, (GFX_CONFIG_DDI << 8));
 				break;
 			case 5: /* DDI_SL lanes0-4, lanes4-7 */
 				nbmisc_write_index(nb_dev, 0x74, (GFX_CONFIG_DDI << 8) | GFX_CONFIG_DDI);
 				break;
 			case 6: /* DDI_DL lanes0-7 */
 				nbmisc_write_index(nb_dev, 0x74, (GFX_CONFIG_DDI << 8) | GFX_CONFIG_DDI);
 				break;
 			default:
 				printk(BIOS_INFO, "Incorrect configuration of external GFX slot.\n");
 				break;
 		}
 	}
 
 #if 1				/* external clock mode */
 	/* table 5-22, 5.9.1. REFCLK */
 	/* 5.9.1.1. Disables the GFX REFCLK transmitter so that the GFX
 	 * REFCLK PAD can be driven by an external source. */
 	/* 5.9.1.2. Enables GFX REFCLK receiver to receive the REFCLK from an external source. */
 	set_nbmisc_enable_bits(nb_dev, 0x38, 1 << 29 | 1 << 28 | 1 << 26, 1 << 28);
 
 	/* 5.9.1.3 Selects the GFX REFCLK to be the source for PLL A. */
 	/* 5.9.1.4 Selects the GFX REFCLK to be the source for PLL B. */
 	/* 5.9.1.5 Selects the GFX REFCLK to be the source for PLL C. */
 	reg32 = nbmisc_read_index(nb_dev, 0x28);
 	printk(BIOS_DEBUG, "misc 28 = %x\n", reg32);
 
 	/* 5.9.1.6.Selects the single ended GFX REFCLK to be the source for core logic. */
 	set_nbmisc_enable_bits(nb_dev, 0x6C, 1 << 31, 1 << 31);
 #else				/* internal clock mode */
 	/* table 5-23, 5.9.1. REFCLK */
 	/* 5.9.1.1. Enables the GFX REFCLK transmitter so that the GFX
 	 * REFCLK PAD can be driven by the SB REFCLK. */
 	/* 5.9.1.2. Disables GFX REFCLK receiver from receiving the
 	 * REFCLK from an external source.*/
 	set_nbmisc_enable_bits(nb_dev, 0x38, 1 << 29 | 1 << 28, 1 << 29 | 0 << 28);
 
 	/* 5.9.1.3 Selects the GFX REFCLK to be the source for PLL A. */
 	/* 5.9.1.4 Selects the GFX REFCLK to be the source for PLL B. */
 	/* 5.9.1.5 Selects the GFX REFCLK to be the source for PLL C. */
 	set_nbmisc_enable_bits(nb_dev, 0x28, 3 << 6 | 3 << 8 | 3 << 10,
 			       0);
 	reg32 = nbmisc_read_index(nb_dev, 0x28);
 	printk(BIOS_DEBUG, "misc 28 = %x\n", reg32);
 
 	/* 5.9.1.6.Selects the single ended GFX REFCLK to be the source for core logic. */
 	set_nbmisc_enable_bits(nb_dev, 0x6C, 1 << 31, 0 << 31);
 #endif
 
 	/* step 5.9.3, GFX overclocking, (only need if CMOS option is enabled) */
 	/* 5.9.3.1. Increases PLL BW for 6G operation.*/
 	/* set_nbmisc_enable_bits(nb_dev, 0x36, 0x3FF << 4, 0xB5 << 4); */
 	/* skip */
 
 	/* step 5.9.4, reset the GFX link */
 	/* step 5.9.4.1 asserts both calibration reset and global reset */
 	set_nbmisc_enable_bits(nb_dev, 0x8, 0x3 << 14, 0x3 << 14);
 
 	/* step 5.9.4.2 de-asserts calibration reset */
 	set_nbmisc_enable_bits(nb_dev, 0x8, 1 << 14, 0 << 14);
 
 	/* step 5.9.4.3 wait for at least 200us */
 	udelay(300);
 
 	/* step 5.9.4.4 de-asserts global reset */
 	set_nbmisc_enable_bits(nb_dev, 0x8, 1 << 15, 0 << 15);
 
 	/* 5.9.5 Reset PCIE_GFX Slot */
 	/* It is done in mainboard.c */
 	set_pcie_reset();
 	mdelay(1);
 	set_pcie_dereset();
 
 	/* step 5.9.8 program PCIE memory mapped configuration space */
 	/* done by enable_pci_bar3() before */
 
 	/* step 7 compliance state, (only need if CMOS option is enabled) */
 	/* the compliance state is just for test. refer to 4.2.5.2 of PCIe specification */
 	if (cfg->gfx_compliance) {
 		/* force compliance */
 		set_nbmisc_enable_bits(nb_dev, 0x32, 1 << 6, 1 << 6);
 		/* release hold training for device 2. GFX initialization is done. */
 		set_nbmisc_enable_bits(nb_dev, 0x8, 1 << 4, 0 << 4);
 		dynamic_link_width_control(nb_dev, dev, cfg->gfx_link_width);
 		printk(BIOS_DEBUG, "rs780_gfx_init step7.\n");
 		return;
 	}
 
 	/* 5.9.12 Core Initialization. */
 	/* 5.9.12.1 sets RCB timeout to be 25ms */
 	/* 5.9.12.2. RCB Cpl timeout on link down. */
 	set_pcie_enable_bits(dev, 0x70, 7 << 16 | 1 << 19, 4 << 16 | 1 << 19);
 	printk(BIOS_DEBUG, "rs780_gfx_init step5.9.12.1.\n");
 
 	/* step 5.9.12.3 disables slave ordering logic */
 	set_pcie_enable_bits(nb_dev, 0x20, 1 << 8, 1 << 8);
 	printk(BIOS_DEBUG, "rs780_gfx_init step5.9.12.3.\n");
 
 	/* step 5.9.12.4 sets DMA payload size to 64 bytes */
 	set_pcie_enable_bits(nb_dev, 0x10, 7 << 10, 4 << 10);
 	/* 5.9.12.5. Blocks DMA traffic during C3 state. */
 	set_pcie_enable_bits(dev, 0x10, 1 << 0, 0 << 0);
 
 	/* 5.9.12.6. Disables RC ordering logic */
 	set_pcie_enable_bits(nb_dev, 0x20, 1 << 9, 1 << 9);
 
 	/* Enables TLP flushing. */
 	/* Note: It is got from RS690. The system will hang without this action. */
 	set_pcie_enable_bits(dev, 0x20, 1 << 19, 0 << 19);
 
 	/* 5.9.12.7. Ignores DLLPs during L1 so that txclk can be turned off */
 	set_pcie_enable_bits(nb_dev, 0x2, 1 << 0, 1 << 0);
 
 	/* 5.9.12.8 Prevents LC to go from L0 to Rcv_L0s if L1 is armed. */
 	set_pcie_enable_bits(dev, 0xA1, 1 << 11, 1 << 11);
 
 	/* 5.9.12.9 CMGOOD_OVERRIDE for end point initiated lane degradation. */
 	set_nbmisc_enable_bits(nb_dev, 0x6a, 1 << 17, 1 << 17);
 	printk(BIOS_DEBUG, "rs780_gfx_init step5.9.12.9.\n");
 
 	/* 5.9.12.10 Sets the timer in Config state from 20us to */
 	/* 5.9.12.11 De-asserts RX_EN in L0s. */
 	/* 5.9.12.12 Enables de-assertion of PG2RX_CR_EN to lock clock
 	 * recovery parameter when lane is in electrical idle in L0s.*/
 	set_pcie_enable_bits(dev, 0xB1, 1 << 23 | 1 << 19 | 1 << 28, 1 << 23 | 1 << 19 | 1 << 28);
 
 	/* 5.9.12.13. Turns off offset calibration. */
 	/* 5.9.12.14. Enables Rx Clock gating in CDR */
 	set_nbmisc_enable_bits(nb_dev, 0x34, 1 << 10/* | 1 << 22 */, 1 << 10/* | 1 << 22 */);
 
 	/* 5.9.12.15. Sets number of TX Clocks to drain TX Pipe to 3. */
 	set_pcie_enable_bits(dev, 0xA0, 0xF << 4, 3 << 4);
 
 	/* 5.9.12.16. Lets PI use Electrical Idle from PHY when
 	 * turning off PLL in L1 at Gen2 speed instead Inferred Electrical Idle. */
 	set_pcie_enable_bits(nb_dev, 0x40, 3 << 14, 2 << 14);
 
 	/* 5.9.12.17. Prevents the Electrical Idle from causing a transition from Rcv_L0 to Rcv_L0s. */
 	set_pcie_enable_bits(dev, 0xB1, 1 << 20, 1 << 20);
 
 	/* 5.9.12.18. Prevents the LTSSM from going to Rcv_L0s if it has already
 	 * acknowledged a request to go to L1. */
 	set_pcie_enable_bits(dev, 0xA1, 1 << 11, 1 << 11);
 
 	/* 5.9.12.19. LDSK only taking deskew on deskewing error detect */
 	set_pcie_enable_bits(nb_dev, 0x40, 1 << 28, 0 << 28);
 
 	/* 5.9.12.20. Bypasses lane de-skew logic if in x1 */
 	set_pcie_enable_bits(nb_dev, 0xC2, 1 << 14, 1 << 14);
 
 	/* 5.9.12.21. Sets Electrical Idle Threshold. */
 	set_nbmisc_enable_bits(nb_dev, 0x35, 3 << 21, 2 << 21);
 
 	/* 5.9.12.22. Advertises -6 dB de-emphasis value in TS1 Data Rate Identifier
 	 * Only if CMOS Option in section. skip */
 
 	/* 5.9.12.23. Disables GEN2 capability of the device. */
 	set_pcie_enable_bits(dev, 0xA4, 1 << 0, 0 << 0);
 
 	/* 5.9.12.24.Disables advertising Upconfigure Support. */
 	set_pcie_enable_bits(dev, 0xA2, 1 << 13, 1 << 13);
 
 	/* 5.9.12.25. No comment in RPR. */
 	set_nbmisc_enable_bits(nb_dev, 0x39, 1 << 10, 0 << 10);
 
 	/* 5.9.12.26. This capacity is required since links wider than x1 and/or multiple link
 	 * speed are supported */
 	set_pcie_enable_bits(nb_dev, 0xC1, 1 << 0, 1 << 0);
 
 	/* 5.9.12.27. Enables NVG86 ECO. A13 above only. */
 	if (get_nb_rev(nb_dev) == REV_RS780_A12)			/* A12 */
 		set_pcie_enable_bits(dev, 0x02, 1 << 11, 1 << 11);
 
 	/* 5.9.12.28 Hides and disables the completion timeout method. */
 	set_pcie_enable_bits(nb_dev, 0xC1, 1 << 2, 0 << 2);
 
 	/* 5.9.12.29. Use the bif_core de-emphasis strength by default. */
 	/* set_nbmisc_enable_bits(nb_dev, 0x36, 1 << 28, 1 << 28); */
 
 	/* 5.9.12.30. Set TX arbitration algorithm to round robin */
 	set_pcie_enable_bits(nb_dev, 0x1C,
 			     1 << 0 | 0x1F << 1 | 0x1F << 6,
 			     1 << 0 | 0x04 << 1 | 0x04 << 6);
 
 	/* Single-port/Dual-port configuration. */
 	switch (cfg->gfx_dual_slot) {
 	case 0:
 		/* step 1, lane reversal (only need if build config option is enabled) */
 		if (cfg->gfx_lane_reversal) {
 			set_nbmisc_enable_bits(nb_dev, 0x36, 1 << 31, 1 << 31);
 			set_nbmisc_enable_bits(nb_dev, 0x33, 1 << 2, 1 << 2);
 			set_nbmisc_enable_bits(nb_dev, 0x36, 1 << 31, 0 << 31);
 		}
 		printk(BIOS_DEBUG, "rs780_gfx_init step1.\n");
 
 		printk(BIOS_DEBUG, "device = %x\n", dev->path.pci.devfn >> 3);
 		if ((dev->path.pci.devfn >> 3) == 2) {
 			single_port_configuration(nb_dev, dev);
 		} else {
 			set_nbmisc_enable_bits(nb_dev, 0xc, 0, 0x2 << 2); /* hide the GFX bridge. */
 			printk(BIOS_INFO, "Single port. Do nothing.\n"); // If dev3
 		}
 
 		break;
 	case 1:
 		/* step 1, lane reversal (only need if build config option is enabled) */
 		if (cfg->gfx_lane_reversal) {
 			set_nbmisc_enable_bits(nb_dev, 0x36, 1 << 31, 1 << 31);
 			set_nbmisc_enable_bits(nb_dev, 0x33, 1 << 2, 1 << 2);
 			set_nbmisc_enable_bits(nb_dev, 0x33, 1 << 3, 1 << 3);
 			set_nbmisc_enable_bits(nb_dev, 0x36, 1 << 31, 0 << 31);
 		}
 		printk(BIOS_DEBUG, "rs780_gfx_init step1.\n");
 		/* step 1.1, dual-slot gfx configuration (only need if CMOS option is enabled) */
 		/* AMD calls the configuration CrossFire */
 		set_nbmisc_enable_bits(nb_dev, 0x0, 0xf << 8, 5 << 8);
 		printk(BIOS_DEBUG, "rs780_gfx_init step2.\n");
 
 		printk(BIOS_DEBUG, "device = %x\n", dev->path.pci.devfn >> 3);
 		dual_port_configuration(nb_dev, dev);
 		break;
 
 	case 2:
 		if (is_dev3_present()) {
 			/* step 1, lane reversal (only need if CMOS option is enabled) */
 			if (cfg->gfx_lane_reversal) {
 				set_nbmisc_enable_bits(nb_dev, 0x36, 1 << 31, 1 << 31);
 				set_nbmisc_enable_bits(nb_dev, 0x33, 1 << 2, 1 << 2);
 				set_nbmisc_enable_bits(nb_dev, 0x33, 1 << 3, 1 << 3);
 				set_nbmisc_enable_bits(nb_dev, 0x36, 1 << 31, 0 << 31);
 			}
 			printk(BIOS_DEBUG, "rs780_gfx_init step1.\n");
 			/* step 1.1, dual-slot gfx configuration (only need if CMOS option is enabled) */
 			/* AMD calls the configuration CrossFire */
 			set_nbmisc_enable_bits(nb_dev, 0x0, 0xf << 8, 5 << 8);
 			printk(BIOS_DEBUG, "rs780_gfx_init step2.\n");
 
 
 			printk(BIOS_DEBUG, "device = %x\n", dev->path.pci.devfn >> 3);
 			dual_port_configuration(nb_dev, dev);
 
 		} else {
 			if (cfg->gfx_lane_reversal) {
 				set_nbmisc_enable_bits(nb_dev, 0x36, 1 << 31, 1 << 31);
 				set_nbmisc_enable_bits(nb_dev, 0x33, 1 << 2, 1 << 2);
 				set_nbmisc_enable_bits(nb_dev, 0x36, 1 << 31, 0 << 31);
 			}
 			printk(BIOS_DEBUG, "rs780_gfx_init step1.\n");
 
 			if ((dev->path.pci.devfn >> 3) == 2)
 				single_port_configuration(nb_dev, dev);
 			else {
 				set_nbmisc_enable_bits(nb_dev, 0xc, 0, 0x2 << 2); /* hide the GFX bridge. */
 				printk(BIOS_DEBUG, "If dev3.., single port. Do nothing.\n");
 			    }
 		}
 		break;
 
 	default:
 		printk(BIOS_INFO, "Incorrect configuration of external GFX slot.\n");
 		break;
 	}
 }
diff --git a/src/southbridge/ricoh/rl5c476/rl5c476.c b/src/southbridge/ricoh/rl5c476/rl5c476.c
index 8284ec8..78561cc 100644
--- a/src/southbridge/ricoh/rl5c476/rl5c476.c
+++ b/src/southbridge/ricoh/rl5c476/rl5c476.c
@@ -1,237 +1,237 @@
 /*
  * This file is part of the coreboot project.
  *
  * Copyright (C) 2004-2005 Nick Barker <nick.barker@btinternet.com>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  */
 
 #include <arch/io.h>
 #include <device/device.h>
 #include <device/pci.h>
 #include <device/pci_ops.h>
 #include <device/pci_ids.h>
 #include <console/console.h>
 #include <device/cardbus.h>
 #include <delay.h>
 #include "rl5c476.h"
 #include "chip.h"
 
 static int enable_cf_boot = 0;
 static unsigned int cf_base;
 
 static void rl5c476_init(device_t dev)
 {
 	pc16reg_t *pc16;
 	unsigned char *base;
 
 	/* cardbus controller function 1 for CF Socket */
 	printk(BIOS_DEBUG, "Ricoh RL5c476: Initializing.\n");
 
 	printk(BIOS_DEBUG, "CF Base = %0x\n",cf_base);
 
 	/* misc control register */
 	pci_write_config16(dev,0x82,0x00a0);
 
 	/* set up second slot as compact flash port if asked to do so */
 
 	if (!enable_cf_boot) {
 		printk(BIOS_DEBUG, "CF boot not enabled.\n");
 		return;
 	}
 
 	if (PCI_FUNC(dev->path.pci.devfn) != 1) {
 		// Only configure if second CF slot.
 		return;
 	}
 
 	/* make sure isa interrupts are enabled */
 	pci_write_config16(dev,0x3e,0x0780);
 
 	/* pick up where 16 bit card control structure is
 	 * (0x800 bytes into config structure)
 	 */
 	base = (unsigned char *)pci_read_config32(dev,0x10);
 	pc16 = (pc16reg_t *)(base + 0x800);
 
 	/* disable memory and io windows and turn off socket power */
 	pc16->pwctrl = 0;
 
 	/* disable irq lines */
 	pc16->igctrl = 0;
 
 	/* disable memory and I/O windows */
 	pc16->awinen = 0;
 
 	/* reset card, configure for I/O and set IRQ line */
 	pc16->igctrl = 0x69;
 
 	/* set io window 0 for 1e0 - 1ef */
 	/* NOTE: This now sets CF up on a contiguous I/O window of
 	 * 16 bytes, 0x1e0 to 0x1ef.
 	 * Be warned that this is not a standard IDE address as
 	 * automatically detected by the likes of FILO, and would need
 	 * patching to recognize these addresses as an IDE drive.
 	 *
 	 * An earlier version of this driver set up 2 I/O windows to
 	 * emulate the expected addresses for IDE2, however the PCMCIA
 	 * package within Linux then could not re-initialize the
 	 * device as it tried to take control of it. So I believe it is
 	 * easier to patch Filo or the like to pick up this drive
 	 * rather than playing silly games as the kernel tries to
 	 * boot.
 	 *
 	 * Nonetheless, FILO needs a special option enabled to boot
 	 * from this configuration, and it needs to clean up
 	 * afterwards. Please refer to FILO documentation and source
 	 * code for more details.
 	 */
 	pc16->iostl0 = 0xe0;
 	pc16->iosth0 = 1;
 
 	pc16->iospl0 = 0xef;
 	pc16->iosph0 = 1;
 
 	pc16->ioffl0 = 0;
 	pc16->ioffh0 = 0;
 
 	/* clear window 1 */
 	pc16->iostl1 = 0;
 	pc16->iosth1 = 0;
 
 	pc16->iospl1 = 0;
 	pc16->iosph1 = 0;
 
 	pc16->ioffl1 = 0x0;
 	pc16->ioffh1 = 0;
 
 	/* set up CF config window */
 	pc16->smpga0 = cf_base>>24;
 	pc16->smsth0 = (cf_base>>20)&0x0f;
 	pc16->smstl0 = (cf_base>>12)&0xff;
 	pc16->smsph0 = ((cf_base>>20)&0x0f) | 0x80;
 	pc16->smspl0 = (cf_base>>12)&0xff;
 	pc16->moffl0 = 0;
 	pc16->moffh0 = 0x40;
 
 
 	/* set I/O width for Auto Data width */
 	pc16->ioctrl = 0x22;
 
 
 	/* enable I/O window 0 and 1 */
 	pc16->awinen = 0xc1;
 
 	pc16->miscc1 = 1;
 
 	/* apply power and enable outputs */
 	pc16->pwctrl = 0xb0;
 
 	// delay could be optimised, but this works
 	udelay(100000);
 
 	pc16->igctrl = 0x69;
 
 
 	/* 16 bit CF always have first config byte at 0x200 into
 	 * Config structure, but CF+ may not according to spec -
 	 * should locate through reading tuple data, but this should
 	 * do for now.
 	 */
 	unsigned char *cptr;
 	cptr = (unsigned char *)(cf_base + 0x200);
 	printk(BIOS_DEBUG, "CF Config = %x\n",*cptr);
 
 	/* Set CF to decode 16 IO bytes on any 16 byte boundary -
 	 * rely on the io windows of the bridge set up above to
 	 * map those bytes into the addresses for IDE controller 3
 	 * (0x1e8 - 0x1ef and 0x3ed - 0x3ee)
 	 */
 	*cptr = 0x41;
 }
 
 static void rl5c476_read_resources(device_t dev)
 {
 
 	struct resource *resource;
 
 	 /* For CF socket we need an extra memory window for
 	  * the control structure of the CF itself
 	  */
 	if ( enable_cf_boot && (PCI_FUNC(dev->path.pci.devfn) == 1)){
 		/* fake index as it isn't in PCI config space */
 		resource = new_resource(dev, 1);
 		resource->flags |= IORESOURCE_MEM;
 		resource->size = 0x1000;
 		resource->align = resource->gran = 12;
 		resource->limit= 0xffff0000;
 	}
 	cardbus_read_resources(dev);
 }
 
 static void rl5c476_set_resources(device_t dev)
 {
 	struct resource *resource;
 	printk(BIOS_DEBUG, "%s In set resources\n",dev_path(dev));
 	if ( enable_cf_boot && (PCI_FUNC(dev->path.pci.devfn) == 1)){
 		resource = find_resource(dev,1);
 		if ( !(resource->flags & IORESOURCE_STORED) ){
-			resource->flags |= IORESOURCE_STORED ;
+			resource->flags |= IORESOURCE_STORED;
 			printk(BIOS_DEBUG, "%s 1 ==> %llx\n", dev_path(dev), resource->base);
 			cf_base = resource->base;
 		}
 	}
 
 	pci_dev_set_resources(dev);
 
 }
 
 static void rl5c476_set_subsystem(device_t dev, unsigned vendor, unsigned device)
 {
        u16 miscreg = pci_read_config16(dev, 0x82);
        /* Enable subsystem id register writes */
        pci_write_config16(dev, 0x82, miscreg | 0x40);
 
        pci_write_config16(dev, 0x40, vendor);
        pci_write_config16(dev, 0x42, device);
        /* restore original contents */
        pci_write_config16(dev, 0x82, miscreg);
 }
 
 static struct pci_operations rl5c476_pci_ops = {
        .set_subsystem    = rl5c476_set_subsystem,
 };
 
 static struct device_operations ricoh_rl5c476_ops = {
 	.read_resources   = rl5c476_read_resources,
 	.set_resources    = rl5c476_set_resources,
 	.enable_resources = cardbus_enable_resources,
 	.init             = rl5c476_init,
 	.scan_bus         = pci_scan_bridge,
 	.ops_pci          = &rl5c476_pci_ops,
 };
 
 static const struct pci_driver ricoh_rl5c476_driver __pci_driver = {
 	.ops    = &ricoh_rl5c476_ops,
 	.vendor = PCI_VENDOR_ID_RICOH,
 	.device = PCI_DEVICE_ID_RICOH_RL5C476,
 };
 
 static void southbridge_init(device_t dev)
 {
 	struct southbridge_ricoh_rl5c476_config *conf = dev->chip_info;
 	enable_cf_boot = conf->enable_cf;
 }
 
 struct chip_operations southbridge_ricoh_rl5c476_ops = {
 	CHIP_NAME("Ricoh RL5C476 CardBus Controller")
 	.enable_dev    = southbridge_init,
 };
diff --git a/src/southbridge/sis/sis966/ide.c b/src/southbridge/sis/sis966/ide.c
index 5686227..6c7c7fe 100644
--- a/src/southbridge/sis/sis966/ide.c
+++ b/src/southbridge/sis/sis966/ide.c
@@ -1,184 +1,184 @@
 /*
  * This file is part of the coreboot project.
  *
  * Copyright (C) 2004 Tyan Computer
  * Written by Yinghai Lu <yhlu@tyan.com> for Tyan Computer.
  * Copyright (C) 2006,2007 AMD
  * Written by Yinghai Lu <yinghai.lu@amd.com> for AMD.
  * Copyright (C) 2007 Silicon Integrated Systems Corp. (SiS)
  * Written by Morgan Tsai <my_tsai@sis.com> for SiS.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  */
 
 #include <console/console.h>
 #include <device/device.h>
 #include <device/pci.h>
 #include <device/pci_ids.h>
 #include <device/pci_ops.h>
 #include <arch/io.h>
 #include "sis966.h"
 #include "chip.h"
 
 uint8_t	SiS_SiS5513_init[49][3]={
 {0x04, 0xFF, 0x05},
 {0x0D, 0xFF, 0x80},
 {0x2C, 0xFF, 0x39},
 {0x2D, 0xFF, 0x10},
 {0x2E, 0xFF, 0x13},
 {0x2F, 0xFF, 0x55},
 {0x50, 0xFF, 0xA2},
 {0x51, 0xFF, 0x21},
 {0x53, 0xFF, 0x21},
 {0x54, 0xFF, 0x2A},
 {0x55, 0xFF, 0x96},
 {0x52, 0xFF, 0xA2},
 {0x56, 0xFF, 0x81},
 {0x57, 0xFF, 0xC0},
 {0x60, 0xFF, 0xFB},
 {0x61, 0xFF, 0xAA},
 {0x62, 0xFF, 0xFB},
 {0x63, 0xFF, 0xAA},
 {0x81, 0xFF, 0xB3},
 {0x82, 0xFF, 0x72},
 {0x83, 0xFF, 0x40},
 {0x85, 0xFF, 0xB3},
 {0x86, 0xFF, 0x72},
 {0x87, 0xFF, 0x40},
 {0x94, 0xFF, 0xC0},
 {0x95, 0xFF, 0x08},
 {0x96, 0xFF, 0xC0},
 {0x97, 0xFF, 0x08},
 {0x98, 0xFF, 0xCC},
 {0x99, 0xFF, 0x04},
 {0x9A, 0xFF, 0x0C},
 {0x9B, 0xFF, 0x14},
 {0xA0, 0xFF, 0x11},
 {0x57, 0xFF, 0xD0},
 
 {0xD8, 0xFE, 0x01},    // Com reset
 {0xC8, 0xFE, 0x01},
 {0xC4, 0xFF, 0xFF},    // Clear status
 {0xC5, 0xFF, 0xFF},
 {0xC6, 0xFF, 0xFF},
 {0xC7, 0xFF, 0xFF},
 {0xD4, 0xFF, 0xFF},
 {0xD5, 0xFF, 0xFF},
 {0xD6, 0xFF, 0xFF},
 {0xD7, 0xFF, 0xFF},
 
 
 {0x2C, 0xFF, 0x39},	// set subsystem ID
 {0x2D, 0xFF, 0x10},
 {0x2E, 0xFF, 0x13},
 {0x2F, 0xFF, 0x55},
 
 
 {0x00, 0x00, 0x00}					//End of table
 };
 
 static void ide_init(struct device *dev)
 {
 	struct southbridge_sis_sis966_config *conf;
 	/* Enable ide devices so the linux ide driver will work */
 	uint32_t dword;
 	uint16_t word;
 	uint8_t byte;
 	conf = dev->chip_info;
 
 
 
 printk(BIOS_DEBUG, "IDE_INIT:---------->\n");
 
 
 //-------------- enable IDE (SiS5513) -------------------------
 {
 	uint8_t  temp8;
 	int i=0;
 	while (SiS_SiS5513_init[i][0] != 0) {
 		temp8 = pci_read_config8(dev, SiS_SiS5513_init[i][0]);
 		temp8 &= SiS_SiS5513_init[i][1];
 		temp8 |= SiS_SiS5513_init[i][2];
 		pci_write_config8(dev, SiS_SiS5513_init[i][0], temp8);
 		i++;
 	};
 }
 //-----------------------------------------------------------
 
 	word = pci_read_config16(dev, 0x50);
 	/* Ensure prefetch is disabled */
 	word &= ~((1 << 15) | (1 << 13));
 	if (conf->ide1_enable) {
 		/* Enable secondary ide interface */
 		word |= (1<<0);
 		printk(BIOS_DEBUG, "IDE1\t");
 	}
 	if (conf->ide0_enable) {
 		/* Enable primary ide interface */
 		word |= (1<<1);
 		printk(BIOS_DEBUG, "IDE0\n");
 	}
 
 	word |= (1<<12);
 	word |= (1<<14);
 
 	pci_write_config16(dev, 0x50, word);
 
 
-	byte = 0x20 ; // Latency: 64-->32
+	byte = 0x20; // Latency: 64-->32
 	pci_write_config8(dev, 0xd, byte);
 
 	dword = pci_read_config32(dev, 0xf8);
 	dword |= 12;
 	pci_write_config32(dev, 0xf8, dword);
 
 #if DEBUG_IDE
 {
 	int i;
 
 	printk(BIOS_DEBUG, "****** IDE PCI config ******");
 	printk(BIOS_DEBUG, "\n    03020100  07060504  0B0A0908  0F0E0D0C");
 
 	for (i=0;i<0xff;i+=4) {
 		if ((i%16)==0)
 			printk(BIOS_DEBUG, "\n%02x: ", i);
 		printk(BIOS_DEBUG, "%08x  ", pci_read_config32(dev,i));
 	}
 	printk(BIOS_DEBUG, "\n");
 }
 #endif
 printk(BIOS_DEBUG, "IDE_INIT:<----------\n");
 }
 
 static void lpci_set_subsystem(device_t dev, unsigned vendor, unsigned device)
 {
 	pci_write_config32(dev, 0x40,
 		((device & 0xffff) << 16) | (vendor & 0xffff));
 }
 static struct pci_operations lops_pci = {
 	.set_subsystem	= lpci_set_subsystem,
 };
 
 static struct device_operations ide_ops  = {
 	.read_resources	= pci_dev_read_resources,
 	.set_resources	= pci_dev_set_resources,
 	.enable_resources	= pci_dev_enable_resources,
 	.init		= ide_init,
 	.scan_bus	= 0,
 //	.enable		= sis966_enable,
 	.ops_pci	= &lops_pci,
 };
 
 static const struct pci_driver ide_driver __pci_driver = {
 	.ops	= &ide_ops,
 	.vendor	= PCI_VENDOR_ID_SIS,
 	.device	= PCI_DEVICE_ID_SIS_SIS966_IDE,
 };
diff --git a/src/southbridge/sis/sis966/nic.c b/src/southbridge/sis/sis966/nic.c
index a167848..448514b 100644
--- a/src/southbridge/sis/sis966/nic.c
+++ b/src/southbridge/sis/sis966/nic.c
@@ -1,339 +1,339 @@
 /*
  * This file is part of the coreboot project.
  *
  * Copyright (C) 2004 Tyan Computer
  * Written by Yinghai Lu <yhlu@tyan.com> for Tyan Computer.
  * Copyright (C) 2006,2007 AMD
  * Written by Yinghai Lu <yinghai.lu@amd.com> for AMD.
  * Copyright (C) 2007 Silicon Integrated Systems Corp. (SiS)
  * Written by Morgan Tsai <my_tsai@sis.com> for SiS.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  */
 
 #include <console/console.h>
 #include <device/device.h>
 #include <device/smbus.h>
 #include <device/pci.h>
 #include <device/pci_ids.h>
 #include <device/pci_ops.h>
 #include <arch/io.h>
 #include <delay.h>
 #include "sis966.h"
 
 
 u8	SiS_SiS191_init[6][3]={
 {0x04, 0xFF, 0x07},
 {0x2C, 0xFF, 0x39},
 {0x2D, 0xFF, 0x10},
 {0x2E, 0xFF, 0x91},
 {0x2F, 0xFF, 0x01},
 {0x00, 0x00, 0x00}					//End of table
 };
 
 
 #define StatusReg       0x1
 #define SMI_READ	0x0
 #define SMI_REQUEST	0x10
 #define TRUE            1
 #define FALSE           0
 
 u16 MacAddr[3];
 
 
 static void writeApcByte(int addr, u8 value)
 {
 	outb(addr,0x78);
 	outb(value,0x79);
 }
 
 static u8 readApcByte(int addr)
 {
 	u8 value;
 	outb(addr,0x78);
 	value=inb(0x79);
 	return(value);
 }
 
 static void readApcMacAddr(void)
 {
 	u8 i;
 
 // enable APC in south bridge sis966 D2F0
 
 	outl(0x80001048,0xcf8);
 	outl((inl(0xcfc) & 0xfffffffd),0xcfc ); // enable IO78/79h for APC Index/Data
 
 	printk(BIOS_DEBUG, "MAC addr in APC = ");
-	for (i = 0x9 ; i <=0xe ; i++) {
+	for (i = 0x9; i <=0xe; i++) {
 		printk(BIOS_DEBUG, "%2.2x",readApcByte(i));
 	}
 	printk(BIOS_DEBUG, "\n");
 
 	/* Set APC Reload */
 	writeApcByte(0x7,readApcByte(0x7)&0xf7);
 	writeApcByte(0x7,readApcByte(0x7)|0x0a);
 
 	/* disable APC in south bridge */
 	outl(0x80001048,0xcf8);
 	outl(inl(0xcfc)&0xffffffbf,0xcfc);
 }
 
 static void set_apc(struct device *dev)
 {
 	u16 addr;
 	u16 i;
 	u8   bTmp;
 
 	/* enable APC in south bridge sis966 D2F0 */
 	outl(0x80001048,0xcf8);
 	outl((inl(0xcfc) & 0xfffffffd),0xcfc ); // enable IO78/79h for APC Index/Data
 
-	for (i = 0 ; i <3; i++) {
+	for (i = 0; i <3; i++) {
 		addr=0x9+2*i;
 		writeApcByte(addr,(u8)(MacAddr[i]&0xFF));
 		writeApcByte(addr+1L,(u8)((MacAddr[i]>>8)&0xFF));
 		// printf("%x - ",readMacAddrByte(0x59+i));
 	}
 
 	/* Set APC Reload */
 	writeApcByte(0x7,readApcByte(0x7)&0xf7);
 	writeApcByte(0x7,readApcByte(0x7)|0x0a);
 
 	/* disable APC in south bridge */
 	outl(0x80001048,0xcf8);
 	outl(inl(0xcfc)&0xffffffbf,0xcfc);
 
 	// CFG reg0x73 bit=1, tell driver MAC Address load to APC
 	bTmp = pci_read_config8(dev, 0x73);
 	bTmp|=0x1;
 	pci_write_config8(dev, 0x73, bTmp);
 }
 
 /**
  * Read one word out of the serial EEPROM.
  *
  * @param dev TODO
  * @param base TODO
  * @param Reg EEPROM word to read.
  * @return Contents of EEPROM word (Reg).
  */
 #define LoopNum 200
 static  unsigned long ReadEEprom( struct device *dev,  u8 *base,  u32 Reg)
 {
 	u32 	data;
 	u32 	i;
 	u32 	ulValue;
 
 	ulValue = (0x80 | (0x2 << 8) | (Reg << 10));  //BIT_7
 
 	write32(base + 0x3c, ulValue);
 
 	mdelay(10);
 
-	for (i=0 ; i <= LoopNum; i++) {
+	for (i=0; i <= LoopNum; i++) {
 		ulValue=read32(base + 0x3c);
 
 		if (!(ulValue & 0x0080)) //BIT_7
 		break;
 
 		mdelay(100);
 	}
 
 	mdelay(50);
 
 	if (i==LoopNum)   data=0x10000;
 	else {
 		ulValue=read32(base + 0x3c);
 		data = ((ulValue & 0xffff0000) >> 16);
 	}
 
 	return data;
 }
 
 static int phy_read(u8 *base, unsigned phy_addr, unsigned phy_reg)
 {
 	u32   ulValue;
 	u32   Read_Cmd;
 	u16   usData;
 
 	Read_Cmd = ((phy_reg << 11) |
 			(phy_addr << 6) |
 			SMI_READ |
 			SMI_REQUEST);
 
 	// SmiMgtInterface Reg is the SMI management interface register(offset 44h) of MAC
 	write32(base + 0x44, Read_Cmd);
 
 	// Polling SMI_REQ bit to be deasserted indicated read command completed
 	do {
 		// Wait 20 usec before checking status
 		mdelay(20);
 		ulValue = read32(base + 0x44);
 	} while ((ulValue & SMI_REQUEST) != 0);
 	//printk(BIOS_DEBUG, "base %x cmd %lx ret val %lx\n", tmp,Read_Cmd,ulValue);
 	usData=(ulValue>>16);
 
 	return usData;
 }
 
 // Detect a valid PHY
 // If there exist a valid PHY then return TRUE, else return FALSE
 static int phy_detect(u8 *base,u16 *PhyAddr) //BOOL PHY_Detect()
 {
 	int	              bFoundPhy = FALSE;
 	u16		usData;
 	int		       PhyAddress = 0;
 
 
 	// Scan all PHY address(0 ~ 31) to find a valid PHY
 	for (PhyAddress = 0; PhyAddress < 32; PhyAddress++) {
 		usData=phy_read(base,PhyAddress,StatusReg);  // Status register is a PHY's register(offset 01h)
 
 		// Found a valid PHY
 
 		if ((usData != 0x0) && (usData != 0xffff)) {
 			bFoundPhy = TRUE;
 			break;
 		}
 	}
 
 	if (!bFoundPhy) {
 		printk(BIOS_DEBUG, "PHY not found !!!!\n");
 	}
 
 	*PhyAddr=PhyAddress;
 
 	return bFoundPhy;
 }
 
 
 static void nic_init(struct device *dev)
 {
 	int val;
 	u16 PhyAddr;
 	u8 *base;
 	struct resource *res;
 
 	printk(BIOS_DEBUG, "NIC_INIT:---------->\n");
 
 //-------------- enable NIC (SiS19x) -------------------------
 {
 	u8  temp8;
 	int i=0;
 	while (SiS_SiS191_init[i][0] != 0) {
 		temp8 = pci_read_config8(dev, SiS_SiS191_init[i][0]);
 		temp8 &= SiS_SiS191_init[i][1];
 		temp8 |= SiS_SiS191_init[i][2];
 		pci_write_config8(dev, SiS_SiS191_init[i][0], temp8);
 		i++;
 	};
 }
 //-----------------------------------------------------------
 
 {
 	unsigned long  i;
 	unsigned long ulValue;
 
 	res = find_resource(dev, 0x10);
 
 	if (!res) {
 		printk(BIOS_DEBUG, "NIC Cannot find resource..\n");
 		return;
 	}
 	base = res2mmio(res, 0, 0);
 	printk(BIOS_DEBUG, "NIC base address %p\n",base);
 
 	if (!(val=phy_detect(base,&PhyAddr))) {
 		printk(BIOS_DEBUG, "PHY detect fail !!!!\n");
 		return;
 	}
 
 	ulValue=read32(base + 0x38L);   //  check EEPROM existing
 
 	if ((ulValue & 0x0002)) {
 
 	  //	read MAC address from EEPROM at first
 
 	  //	if that is valid we will use that
 
 			printk(BIOS_DEBUG, "EEPROM contents %lx\n",ReadEEprom( dev,  base,  0LL));
 			for (i=0;i<3;i++) {
 				//status = smbus_read_byte(dev_eeprom, i);
 				ulValue=ReadEEprom( dev,  base,  i+3L);
 				if (ulValue ==0x10000) break;  // error
 
 				MacAddr[i] =ulValue & 0xFFFF;
 
 			}
 	} else {
 		// read MAC address from firmware
 		printk(BIOS_DEBUG, "EEPROM invalid!!\nReg 0x38h=%.8lx\n",ulValue);
 		MacAddr[0]=read16((u16 *)0xffffffc0); // mac address store at here
 		MacAddr[1]=read16((u16 *)0xffffffc2);
 		MacAddr[2]=read16((u16 *)0xffffffc4);
 	}
 
 	set_apc(dev);
 
 	readApcMacAddr();
 
 #if DEBUG_NIC
 {
 	int i;
 
 	printk(BIOS_DEBUG, "****** NIC PCI config ******");
 	printk(BIOS_DEBUG, "\n    03020100  07060504  0B0A0908  0F0E0D0C");
 
 	for (i=0;i<0xff;i+=4) {
 		if ((i%16)==0)
 			printk(BIOS_DEBUG, "\n%02x: ", i);
 		printk(BIOS_DEBUG, "%08x  ", pci_read_config32(dev,i));
 	}
 	printk(BIOS_DEBUG, "\n");
 }
 
 
 #endif
 
 }
 
 printk(BIOS_DEBUG, "NIC_INIT:<----------\n");
 return;
 
 
 }
 
 static void lpci_set_subsystem(device_t dev, unsigned vendor, unsigned device)
 {
 	pci_write_config32(dev, 0x40,
 		((device & 0xffff) << 16) | (vendor & 0xffff));
 }
 
 static struct pci_operations lops_pci = {
 	.set_subsystem	= lpci_set_subsystem,
 };
 
 static struct device_operations nic_ops  = {
 	.read_resources	= pci_dev_read_resources,
 	.set_resources	= pci_dev_set_resources,
 	.enable_resources	= pci_dev_enable_resources,
 	.init		= nic_init,
 	.scan_bus	= 0,
 //	.enable		= sis966_enable,
 	.ops_pci	= &lops_pci,
 };
 
 static const struct pci_driver nic_driver __pci_driver = {
 	.ops	= &nic_ops,
 	.vendor	= PCI_VENDOR_ID_SIS,
 	.device	= PCI_DEVICE_ID_SIS_SIS966_NIC,
 };
diff --git a/src/southbridge/via/vt8237r/early_smbus.c b/src/southbridge/via/vt8237r/early_smbus.c
index 23f5928..96a5c1b 100644
--- a/src/southbridge/via/vt8237r/early_smbus.c
+++ b/src/southbridge/via/vt8237r/early_smbus.c
@@ -1,507 +1,507 @@
 /*
  * This file is part of the coreboot project.
  *
  * Copyright (C) 2007 Corey Osgood <corey.osgood@gmail.com>
  * Copyright (C) 2007 Rudolf Marek <r.marek@assembler.cz>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  */
 
 #if !defined(__ROMCC__)
 #include <arch/acpi.h>
 #endif
 #include <device/pci_ids.h>
 #include <spd.h>
 #include <stdlib.h>
 #include "vt8237r.h"
 
 /**
  * Print an error, should it occur. If no error, just exit.
  *
  * @param host_status The data returned on the host status register after
  *		      a transaction is processed.
  * @param loops The number of times a transaction was attempted.
  */
 static void smbus_print_error(u8 host_status, int loops)
 {
 	/* Check if there actually was an error. */
 	if ((host_status == 0x00 || host_status == 0x40 ||
 	     host_status == 0x42) && (loops < SMBUS_TIMEOUT))
 		return;
 
 	if (loops >= SMBUS_TIMEOUT)
 		printk(BIOS_ERR, "SMBus timeout\n");
 	if (host_status & (1 << 4))
 		printk(BIOS_ERR, "Interrupt/SMI# was Failed Bus Transaction\n");
 	if (host_status & (1 << 3))
 		printk(BIOS_ERR, "Bus error\n");
 	if (host_status & (1 << 2))
 		printk(BIOS_ERR, "Device error\n");
 	if (host_status & (1 << 1))
 		printk(BIOS_DEBUG, "Interrupt/SMI# completed successfully\n");
 	if (host_status & (1 << 0))
 		printk(BIOS_ERR, "Host busy\n");
 }
 
 /**
  * Wait for the SMBus to become ready to process the next transaction.
  */
 static void smbus_wait_until_ready(void)
 {
 	int loops;
 
 	PRINT_DEBUG("Waiting until SMBus ready\n");
 
 	/* Loop up to SMBUS_TIMEOUT times, waiting for bit 0 of the
 	 * SMBus Host Status register to go to 0, indicating the operation
 	 * was completed successfully. I don't remember why I did it this way,
 	 * but I think it was because ROMCC was running low on registers */
 	loops = 0;
 	while ((inb(SMBHSTSTAT) & 1) == 1 && loops < SMBUS_TIMEOUT)
 		++loops;
 
 	smbus_print_error(inb(SMBHSTSTAT), loops);
 }
 
 /**
  * Reset and take ownership of the SMBus.
  */
 static void smbus_reset(void)
 {
 	outb(HOST_RESET, SMBHSTSTAT);
 
 	/* Datasheet says we have to read it to take ownership of SMBus. */
 	inb(SMBHSTSTAT);
 
 	PRINT_DEBUG("After reset status: ");
 	PRINT_DEBUG_HEX16(inb(SMBHSTSTAT));
 	PRINT_DEBUG("\n");
 }
 
 static u8 smbus_transaction(u8 dimm, u8 offset, u8 data, int do_read)
 {
 	u8 val;
 
 	PRINT_DEBUG(do_read ? "RD: " : "WR: ");
 	PRINT_DEBUG("ADDR ");
 	PRINT_DEBUG_HEX16(dimm);
 	PRINT_DEBUG(" OFFSET ");
 	PRINT_DEBUG_HEX16(offset);
 	PRINT_DEBUG("\n");
 
 	smbus_reset();
 
 	/* Clear host data port. */
 	outb(do_read ? 0x00 : data, SMBHSTDAT0);
 	SMBUS_DELAY();
 	smbus_wait_until_ready();
 
 	/* Actual addr to reg format. */
 	dimm = (dimm << 1);
 	dimm |= !!do_read;
 	outb(dimm, SMBXMITADD);
 	outb(offset, SMBHSTCMD);
 
 	/* Start transaction, byte data read. */
 	outb(0x48, SMBHSTCTL);
 	SMBUS_DELAY();
 	smbus_wait_until_ready();
 
 	val = inb(SMBHSTDAT0);
 	PRINT_DEBUG("Read: ");
 	PRINT_DEBUG_HEX16(val);
 	PRINT_DEBUG("\n");
 
 	/* Probably don't have to do this, but it can't hurt. */
 	smbus_reset();
 
 	return val;
 }
 
 /**
  * Read a byte from the SMBus.
  *
  * @param dimm The address location of the DIMM on the SMBus.
  * @param offset The offset the data is located at.
  */
 u8 smbus_read_byte(u8 dimm, u8 offset)
 {
 	return smbus_transaction(dimm, offset, 0, 1);
 }
 
 void smbus_write_byte(u8 dimm, u8 offset, u8 data)
 {
 	smbus_transaction(dimm, offset, data, 0);
 }
 
 #define PSONREADY_TIMEOUT 0x7fffffff
 
 static pci_devfn_t get_vt8237_lpc(void)
 {
 	pci_devfn_t dev;
 
 	/* Power management controller */
 	dev = pci_locate_device(PCI_ID(PCI_VENDOR_ID_VIA,
 				       PCI_DEVICE_ID_VIA_VT8237R_LPC), 0);
 	if (dev != PCI_DEV_INVALID)
 		return dev;
 
 	dev = pci_locate_device(PCI_ID(PCI_VENDOR_ID_VIA,
 				PCI_DEVICE_ID_VIA_VT8237S_LPC), 0);
 	if (dev != PCI_DEV_INVALID)
 		return dev;
 
 	dev = pci_locate_device(PCI_ID(PCI_VENDOR_ID_VIA,
 				PCI_DEVICE_ID_VIA_VT8237A_LPC), 0);
 	return dev;
 }
 
 /**
  * Enable the SMBus on VT8237R-based systems.
  */
 void enable_smbus(void)
 {
 	pci_devfn_t dev;
 	int loops;
 
 	/* Power management controller */
 	dev = get_vt8237_lpc();
 	if (dev == PCI_DEV_INVALID)
 		die("Power management controller not found\n");
 
 	/* Make sure the RTC power well is up before touching smbus. */
 	loops = 0;
 	while (!(pci_read_config8(dev, VT8237R_PSON) & (1<<6))
 	       && loops < PSONREADY_TIMEOUT)
 		++loops;
 
 	/*
 	 * 7 = SMBus Clock from RTC 32.768KHz
 	 * 5 = Internal PLL reset from susp
 	 */
 	pci_write_config8(dev, VT8237R_POWER_WELL, 0xa0);
 
 	/* Enable SMBus. */
 	pci_write_config16(dev, VT8237R_SMBUS_IO_BASE_REG,
 			   VT8237R_SMBUS_IO_BASE | 0x1);
 
 	/* SMBus Host Configuration, enable. */
 	pci_write_config8(dev, VT8237R_SMBUS_HOST_CONF, 0x01);
 
 	/* Make it work for I/O. */
 	pci_write_config16(dev, PCI_COMMAND, PCI_COMMAND_IO);
 
 	smbus_reset();
 
 	/* Reset the internal pointer. */
 	inb(SMBHSTCTL);
 }
 
 /**
  * A fixup for some systems that need time for the SMBus to "warm up". This is
  * needed on some VT823x based systems, where the SMBus spurts out bad data for
  * a short time after power on. This has been seen on the VIA Epia series and
  * Jetway J7F2-series. It reads the ID byte from SMBus, looking for
  * known-good data from a slot/address. Exits on either good data or a timeout.
  *
  * TODO: This should probably go into some global file, but one would need to
  *       be created just for it. If some other chip needs/wants it, we can
  *       worry about it then.
  *
  * @param ctrl The memory controller and SMBus addresses.
  */
 void smbus_fixup(const struct mem_controller *ctrl)
 {
 	int i, ram_slots, current_slot = 0;
 	u8 result = 0;
 
 	ram_slots = ARRAY_SIZE(ctrl->channel0);
 	if (!ram_slots) {
 		printk(BIOS_ERR, "smbus_fixup() thinks there are no RAM slots!\n");
 		return;
 	}
 
 	PRINT_DEBUG("Waiting for SMBus to warm up");
 
 	/*
 	 * Bad SPD data should be either 0 or 0xff, but YMMV. So we look for
 	 * the ID bytes of SDRAM, DDR, DDR2, and DDR3 (and anything in between).
 	 * VT8237R has only been seen on DDR and DDR2 based systems, so far.
 	 */
 	for (i = 0; (i < SMBUS_TIMEOUT && ((result < SPD_MEMORY_TYPE_SDRAM) ||
 	   (result > SPD_MEMORY_TYPE_SDRAM_DDR3))); i++) {
 
 		if (current_slot > ram_slots)
 			current_slot = 0;
 
 		result = smbus_read_byte(ctrl->channel0[current_slot],
 					 SPD_MEMORY_TYPE);
 		current_slot++;
 		PRINT_DEBUG(".");
 	}
 
 	if (i >= SMBUS_TIMEOUT)
 		printk(BIOS_ERR, "SMBus timed out while warming up\n");
 	else
 		PRINT_DEBUG("Done\n");
 }
 
 /* FIXME: Better separate the NB and SB, will be done once it works. */
 
 void vt8237_sb_enable_fid_vid(void)
 {
 	pci_devfn_t dev, devctl;
 	u16 devid;
 
 	/* Power management controller */
 	dev = get_vt8237_lpc();
 	if (dev == PCI_DEV_INVALID)
 		return;
 
 	devid = pci_read_config16(dev, PCI_DEVICE_ID);
 
 	/* generic setup */
 
 	/* Set ACPI base address to I/O VT8237R_ACPI_IO_BASE. */
 	pci_write_config16(dev, 0x88, VT8237R_ACPI_IO_BASE | 0x1);
 
 	/* Enable ACPI access RTC signal gated with PSON. */
 	pci_write_config8(dev, 0x81, 0x84);
 
 	/* chipset-specific parts */
 
 	/* VLINK: FIXME: can we drop the device check and just look for the VLINK device? */
 	if (devid == PCI_DEVICE_ID_VIA_VT8237S_LPC ||
 	    devid == PCI_DEVICE_ID_VIA_VT8237A_LPC) {
 		devctl = pci_locate_device(PCI_ID(PCI_VENDOR_ID_VIA,
 					   PCI_DEVICE_ID_VIA_VT8237_VLINK), 0);
 
 		if (devctl != PCI_DEV_INVALID) {
 			/* So the chip knows we are on AMD. */
 			pci_write_config8(devctl, 0x7c, 0x7f);
 		}
 	}
 
 	if (devid == PCI_DEVICE_ID_VIA_VT8237S_LPC) {
 		/*
 		 * Allow SLP# signal to assert LDTSTOP_L.
 		 * Will work for C3 and for FID/VID change.
 		 */
 
 		outb(0xff, VT8237R_ACPI_IO_BASE + 0x50);
 
 		/* Reduce further the STPCLK/LDTSTP signal to 5us. */
 		pci_write_config8(dev, 0xec, 0x4);
 
 		return;
 	}
 
 	/* VT8237R and VT8237A */
 
 	/*
 	 * Allow SLP# signal to assert LDTSTOP_L.
 	 * Will work for C3 and for FID/VID change.
 	 */
 	outb(0x1, VT8237R_ACPI_IO_BASE + 0x11);
 }
 
 void enable_rom_decode(void)
 {
 	pci_devfn_t dev;
 
 	/* Power management controller */
 	dev = get_vt8237_lpc();
 	if (dev == PCI_DEV_INVALID)
 		return;
 
 	/* ROM decode last 1MB FFC00000 - FFFFFFFF. */
 	pci_write_config8(dev, 0x41, 0x7f);
 }
 
 int acpi_get_sleep_type(void)
 {
 	pci_devfn_t dev;
 	u16 tmp;
 
 	printk(BIOS_DEBUG, "IN TEST WAKEUP\n");
 
 	/* Power management controller */
 	dev = get_vt8237_lpc();
 	if (dev == PCI_DEV_INVALID)
 		die("Power management controller not found\n");
 
 	/* Set ACPI base address to I/O VT8237R_ACPI_IO_BASE. */
 	pci_write_config16(dev, 0x88, VT8237R_ACPI_IO_BASE | 0x1);
 
 	/* Enable ACPI access RTC signal gated with PSON. */
 	pci_write_config8(dev, 0x81, 0x84);
 
 	tmp = inw(VT8237R_ACPI_IO_BASE + 0x04);
 
 	printk(BIOS_DEBUG, "%02x", tmp);
-	return ((tmp & (7 << 10)) >> 10) == 1 ? 3 : 0 ;
+	return ((tmp & (7 << 10)) >> 10) == 1 ? 3 : 0;
 }
 
 #if defined(__GNUC__)
 void vt8237_early_spi_init(void)
 {
 	pci_devfn_t dev;
 	volatile u16 *spireg;
 	u32 tmp;
 
 	/* Bus Control and Power Management */
 	dev = pci_locate_device(PCI_ID(PCI_VENDOR_ID_VIA,
 				       PCI_DEVICE_ID_VIA_VT8237S_LPC), 0);
 
 	if (dev == PCI_DEV_INVALID)
 		die("SB not found\n");
 
 	/* Put SPI base 20 d0 fe. */
 	tmp = pci_read_config32(dev, 0xbc);
 	pci_write_config32(dev, 0xbc,
 			   (VT8237S_SPI_MEM_BASE >> 8) | (tmp & 0xFF000000));
 
 	/* Set SPI clock to 33MHz. */
 	spireg = (u16 *) (VT8237S_SPI_MEM_BASE + 0x6c);
 	(*spireg) &= 0xff00;
 }
 #endif
 
 /* This #if is special. ROMCC chokes on the (rom == NULL) comparison.
  * Since the whole function is only called for one target and that target
  * is compiled with GCC, hide the function from ROMCC and be happy.
  */
 #if defined(__GNUC__)
 /*
  * Offset 0x58:
  * 31:20 	reserved
  * 19:16	4 bit position in shadow EEPROM
  * 15:0		data to write
  *
  * Offset 0x5c:
  * 31:28	reserved
  * 27 		ERDBG - enable read from 0x5c
  * 26		reserved
  * 25		SEELD
  * 24		SEEPR - write 1 when done updating, wait until SEELD is
  * 			set to 1, sticky
  *		cleared by reset, if it is 1 writing is disabled
  * 19:16	4 bit position in shadow EEPROM
  * 15:0		data from shadow EEPROM
  *
  * After PCIRESET SEELD and SEEPR must be 1 and 1.
  */
 
 /* 1 = needs PCI reset, 0 don't reset, network initialized. */
 
 /* FIXME: Maybe close the debug register after use? */
 
 #define LAN_TIMEOUT 0x7FFFFFFF
 
 int vt8237_early_network_init(struct vt8237_network_rom *rom)
 {
 	struct vt8237_network_rom n;
 	int i, loops;
 	pci_devfn_t dev;
 	u32 tmp;
 	u8 status;
 	u16 *rom_write;
 	unsigned int checksum;
 
 	/* Network adapter */
 	dev = pci_locate_device(PCI_ID(PCI_VENDOR_ID_VIA,
 				       PCI_DEVICE_ID_VIA_8233_7), 0);
 	if (dev == PCI_DEV_INVALID) {
 		printk(BIOS_ERR, "Network is disabled, please enable\n");
 		return 0;
 	}
 
 	tmp = pci_read_config32(dev, 0x5c);
 	tmp |= 0x08000000;	/* Enable ERDBG. */
 	pci_write_config32(dev, 0x5c, tmp);
 
 	status = ((pci_read_config32(dev, 0x5c) >> 24) & 0x3);
 
 	/* Network controller OK, EEPROM loaded. */
 	if (status == 3)
 		return 0;
 
 	if (rom == NULL) {
 		printk(BIOS_ERR, "No config data specified, using default MAC!\n");
 		n.mac_address[0] = 0x0;
 		n.mac_address[1] = 0x0;
 		n.mac_address[2] = 0xde;
 		n.mac_address[3] = 0xad;
 		n.mac_address[4] = 0xbe;
 		n.mac_address[5] = 0xef;
 		n.phy_addr = 0x1;
 		n.res1 = 0x0;
 		n.sub_sid = 0x102;
 		n.sub_vid = 0x1106;
 		n.pid = 0x3065;
 		n.vid = 0x1106;
 		n.pmcc = 0x1f;
 		n.data_sel = 0x10;
 		n.pmu_data_reg = 0x0;
 		n.aux_curr = 0x0;
 		n.reserved = 0x0;
 		n.min_gnt = 0x3;
 		n.max_lat = 0x8;
 		n.bcr0 = 0x9;
 		n.bcr1 = 0xe;
 		n.cfg_a = 0x3;
 		n.cfg_b = 0x0;
 		n.cfg_c = 0x40;
 		n.cfg_d = 0x82;
 		n.checksum = 0x0;
 		rom = &n;
 	}
 
 	rom_write = (u16 *) rom;
 	checksum = 0;
 	/* Write all data except checksum and second to last byte. */
 	tmp &= 0xff000000;	/* Leave reserved bits in. */
 	for (i = 0; i < 15; i++) {
 		pci_write_config32(dev, 0x58, tmp | (i << 16) | rom_write[i]);
 		/* Lame code FIXME */
 		checksum += rom_write[i] & 0xff;
 		/* checksum %= 256; */
 		checksum += (rom_write[i] >> 8) & 0xff;
 		/* checksum %= 256; */
 	}
 
 	checksum += (rom_write[15] & 0xff);
 	checksum = ~(checksum & 0xff);
 	tmp |= (((checksum & 0xff) << 8) | rom_write[15]);
 
 	/* Write last byte and checksum. */
 	pci_write_config32(dev, 0x58, (15 << 16) | tmp);
 
 	tmp = pci_read_config32(dev, 0x5c);
 	pci_write_config32(dev, 0x5c, tmp | 0x01000000); /* Toggle SEEPR. */
 
 	/* Yes, this is a mess, but it's the easiest way to do it. */
 	/* XXX not so messy, but an explanation of the hack would have been better */
 	loops = 0;
 	while ((((pci_read_config32(dev, 0x5c) >> 25) & 1) == 0)
 	       && (loops < LAN_TIMEOUT)) {
 		++loops;
 	}
 
 	if (loops >= LAN_TIMEOUT) {
 		printk(BIOS_ERR, "Timeout - LAN controller didn't accept config\n");
 		return 0;
 	}
 
 	/* We are done, config will be used after PCIRST#. */
 	return 1;
 }
 #endif
diff --git a/src/southbridge/via/vt8237r/lpc.c b/src/southbridge/via/vt8237r/lpc.c
index dd3bcae..9d91749 100644
--- a/src/southbridge/via/vt8237r/lpc.c
+++ b/src/southbridge/via/vt8237r/lpc.c
@@ -1,694 +1,694 @@
 /*
  * This file is part of the coreboot project.
  *
  * Copyright (C) 2007, 2008 Rudolf Marek <r.marek@assembler.cz>
  * Copyright (C) 2009 Jon Harrison <bothlyn@blueyonder.co.uk>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; version 2 of the License.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  */
 
 /* Inspiration from other VIA SB code. */
 
 #include <arch/io.h>
 #include <console/console.h>
 #include <device/device.h>
 #include <device/pci.h>
 #include <device/pci_ids.h>
 #include <pc80/mc146818rtc.h>
 #include <arch/ioapic.h>
 #include <cpu/x86/lapic.h>
 #include <cpu/cpu.h>
 #include <pc80/keyboard.h>
 #include <pc80/i8259.h>
 #include <stdlib.h>
 #include <arch/acpi.h>
 #include "vt8237r.h"
 #include "chip.h"
 
 static void southbridge_init_common(struct device *dev);
 
 #if CONFIG_EPIA_VT8237R_INIT
                    /* Interrupts for  INT# A   B   C   D */
 static const unsigned char pciIrqs[4]  = { 10, 11, 12, 0};
 
             /* Interrupt Assignments for Pins   1   2   3   4  */
 static const unsigned char sataPins[4] =     { 'A','B','C','D'};
 static const unsigned char vgaPins[4] =      { 'A','B','C','D'};
 static const unsigned char usbPins[4] =      { 'A','B','C','D'};
 static const unsigned char enetPins[4] =     { 'A','B','C','D'};
 static const unsigned char vt8237Pins[4] =   { 'A','B','C','D'};
 static const unsigned char slotPins[4] =     { 'C','D','A','B'};
 static const unsigned char riserPins[4] =    { 'D','C','B','A'};
 
 static unsigned char *pin_to_irq(const unsigned char *pin)
 {
 	static unsigned char Irqs[4];
 	int i;
-	for (i = 0 ; i < 4 ; i++)
+	for (i = 0; i < 4; i++)
 		Irqs[i] = pciIrqs[ pin[i] - 'A' ];
 
 	return Irqs;
 }
 #endif
 
 /** Set up PCI IRQ routing, route everything through APIC. */
 static void pci_routing_fixup(struct device *dev)
 {
 #if CONFIG_EPIA_VT8237R_INIT
 	device_t pdev;
 #endif
 
 	/* PCI PNP Interrupt Routing INTE/F - disable */
 	pci_write_config8(dev, 0x44, 0x00);
 
 	/* PCI PNP Interrupt Routing INTG/H - disable */
 	pci_write_config8(dev, 0x45, 0x00);
 
 	/* Gate Interrupts until RAM Writes are flushed */
 	pci_write_config8(dev, 0x49, 0x20);
 
 #if CONFIG_EPIA_VT8237R_INIT
 
 	/* Share INTE-INTH with INTA-INTD as per stock BIOS. */
 	pci_write_config8(dev, 0x46, 0x00);
 
 	/* setup PCI IRQ routing (For PCI Slot)*/
 	pci_write_config8(dev, 0x55, pciIrqs[0] << 4);
 	pci_write_config8(dev, 0x56, pciIrqs[1] | (pciIrqs[2] << 4) );
 	pci_write_config8(dev, 0x57, pciIrqs[3] << 4);
 
 	/* PCI Routing Fixup */
 
 	//Setup MiniPCI Slot
 	pci_assign_irqs(0, 0x14, pin_to_irq(slotPins));
 
 	// Via 2 slot riser card 2nd slot
 	pci_assign_irqs(0, 0x13, pin_to_irq(riserPins));
 
 	//Setup USB
 	pci_assign_irqs(0, 0x10, pin_to_irq(usbPins));
 
 	//Setup VT8237R Sound
 	pci_assign_irqs(0, 0x11, pin_to_irq(vt8237Pins));
 
 	//Setup Ethernet
 	pci_assign_irqs(0, 0x12, pin_to_irq(enetPins));
 
 	//Setup VGA
 	pci_assign_irqs(1, 0x00, pin_to_irq(vgaPins));
 
 	/* APIC Routing Fixup */
 
 	// Setup SATA
 	pdev = dev_find_device(PCI_VENDOR_ID_VIA,
 				PCI_DEVICE_ID_VIA_VT6420_SATA, 0);
 	pci_write_config8(pdev, PCI_INTERRUPT_PIN, 0x02);
 	pci_assign_irqs(0, 0x0f, pin_to_irq(sataPins));
 
 
 	// Setup PATA Override
 	pdev = dev_find_device(PCI_VENDOR_ID_VIA,
 				PCI_DEVICE_ID_VIA_82C586_1, 0);
 	pci_write_config8(pdev, PCI_INTERRUPT_PIN, 0x01);
 	pci_write_config8(pdev, PCI_INTERRUPT_LINE, 0xFF);
 
 #else
 	/* Route INTE-INTH through registers above, no map to INTA-INTD. */
 	pci_write_config8(dev, 0x46, 0x10);
 
 	/* PCI Interrupt Polarity */
 	pci_write_config8(dev, 0x54, 0x00);
 
 	/* PCI INTA# Routing */
 	pci_write_config8(dev, 0x55, 0x00);
 
 	/* PCI INTB#/C# Routing */
 	pci_write_config8(dev, 0x56, 0x00);
 
 	/* PCI INTD# Routing */
 	pci_write_config8(dev, 0x57, 0x00);
 #endif
 }
 
 
 
 /**
  * Set up the power management capabilities directly into ACPI mode.
  * This avoids having to handle any System Management Interrupts (SMIs).
  */
 
 static void setup_pm(device_t dev)
 {
 	u16 tmp;
 	struct southbridge_via_vt8237r_config *cfg;
 
 	cfg = dev->chip_info;
 
 	/* Debounce LID and PWRBTN# Inputs for 16ms. */
 	pci_write_config8(dev, 0x80, 0x20);
 
 	/* Set ACPI base address to I/O VT8237R_ACPI_IO_BASE. */
 	pci_write_config16(dev, 0x88, VT8237R_ACPI_IO_BASE | 0x1);
 
 	/* Set ACPI to 9, must set IRQ 9 override to level! Set PSON gating. */
 	pci_write_config8(dev, 0x82, 0x40 | VT8237R_ACPI_IRQ);
 
 #if CONFIG_EPIA_VT8237R_INIT
 	/* Primary interrupt channel, define wake events 0=IRQ0 15=IRQ15 1=en. */
 	pci_write_config16(dev, 0x84, 0x3052);
 #else
 	/* Primary interrupt channel, define wake events 0=IRQ0 15=IRQ15 1=en. */
 	pci_write_config16(dev, 0x84, 0x30b2);
 
 #endif
 	/* SMI output level to low, 7.5us throttle clock */
 	pci_write_config8(dev, 0x8d, 0x18);
 
 	/* GP Timer Control 1s */
 	pci_write_config8(dev, 0x93, 0x88);
 
 	/*
 	 * 7 = SMBus clock from RTC 32.768KHz
 	 * 5 = Internal PLL reset from susp disabled
 	 * 2 = GPO2 is SUSA#
 	 */
 	tmp = 0xa0;
 	if (cfg && cfg->enable_gpo3)
 		tmp |= 0x10;
 	pci_write_config8(dev, 0x94, tmp);
 
 	/*
 	 * 7 = stp to sust delay 1msec
 	 * 6 = SUSST# Deasserted Before PWRGD for STD
 	 * 5 = Keyboard/Mouse Swap
 	 * 4 = PWRGOOD reset on VT8237A/S
 	 * 3 = GPO26/GPO27 is GPO
 	 * 2 = Disable Alert on Lan
 	 * 1 = SUSCLK/GPO4
 	 * 0 = USB Wakeup
 	 */
 
 #if CONFIG_EPIA_VT8237R_INIT
 	pci_write_config8(dev, 0x95, 0xc2);
 #else
 	tmp = 0xcc;
 	if (cfg) {
 		if (cfg->disable_gpo26_gpo27)
 			tmp &= ~0x08;
 		if (cfg->enable_aol_2_smb_slave)
 			tmp &= ~0x04;
 	}
 	pci_write_config8(dev, 0x95, tmp);
 #endif
 
 	/* Disable GP3 timer. */
 	pci_write_config8(dev, 0x98, 0);
 
 	/* Enable ACPI access RTC signal gated with PSON. */
 	pci_write_config8(dev, 0x81, 0x84);
 
 	/* Clear status events. */
 	outw(0xffff, VT8237R_ACPI_IO_BASE + 0x00);
 	outw(0xffff, VT8237R_ACPI_IO_BASE + 0x20);
 	outw(0xffff, VT8237R_ACPI_IO_BASE + 0x28);
 	outl(0xffffffff, VT8237R_ACPI_IO_BASE + 0x30);
 
 	/* Disable SCI on GPIO. */
 	outw(0x0, VT8237R_ACPI_IO_BASE + 0x22);
 
 	/* Disable SMI on GPIO. */
 	outw(0x0, VT8237R_ACPI_IO_BASE + 0x24);
 
 	/* Disable all global enable SMIs, except SW SMI */
 	outw(0x40, VT8237R_ACPI_IO_BASE + 0x2a);
 
 	/* Primary activity SMI disable. */
 	outl(0x0, VT8237R_ACPI_IO_BASE + 0x34);
 
 	/* GP timer reload on none. */
 	outl(0x0, VT8237R_ACPI_IO_BASE + 0x38);
 
 	/* Disable extended IO traps. */
 	outb(0x0, VT8237R_ACPI_IO_BASE + 0x42);
 
 	/* SCI is generated for RTC/pwrBtn/slpBtn. */
 	tmp = inw(VT8237R_ACPI_IO_BASE + 0x04);
 
 	/* All SMI on, both IDE buses ON, PSON rising edge. */
 	outw(0x1, VT8237R_ACPI_IO_BASE + 0x2c);
 
 	/* clear sleep */
 	tmp &= ~(7 << 10);
 	tmp |= 1;
 	outw(tmp, VT8237R_ACPI_IO_BASE + 0x04);
 }
 
 int acpi_get_sleep_type(void)
 {
 	u16 tmp = inw(VT8237R_ACPI_IO_BASE + 0x04);
-	return ((tmp & (7 << 10)) >> 10) == 1 ? 3 : 0 ;
+	return ((tmp & (7 << 10)) >> 10) == 1 ? 3 : 0;
 }
 
 static void vt8237r_init(struct device *dev)
 {
 	u8 enables;
 	struct southbridge_via_vt8237r_config *cfg;
 
 	cfg = dev->chip_info;
 
 #if CONFIG_EPIA_VT8237R_INIT
 	printk(BIOS_SPEW, "Entering vt8237r_init, for EPIA.\n");
 	/*
 	 * TODO: Looks like stock BIOS can do this but causes a hang
 	 * Enable SATA LED, disable special CPU Frequency Change -
 	 * GPIO28 GPIO22 GPIO29 GPIO23 are GPIOs.
 	 * Setup to match EPIA default
 	 * PCS0# on Pin U1
 	 */
 	enables = pci_read_config8(dev, 0xe5);
 	enables |= 0x23;
 	pci_write_config8(dev, 0xe5, enables);
 
 	/*
 	 * Enable Flash Write Access.
 	 * Note EPIA-N Does not use REQ5 or PCISTP#(Hang)
 	 */
 	enables = pci_read_config8(dev, 0xe4);
 	enables |= 0x2B;
 	pci_write_config8(dev, 0xe4, enables);
 
 	/* Enables Extra RTC Ports */
 	enables = pci_read_config8(dev, 0x4E);
 	enables |= 0x80;
 	pci_write_config8(dev, 0x4E, enables);
 
 #else
 	printk(BIOS_SPEW, "Entering vt8237r_init.\n");
 	/*
 	 * Enable SATA LED, disable special CPU Frequency Change -
 	 * GPIO28 GPIO22 GPIO29 GPIO23 are GPIOs.
 	 */
 	pci_write_config8(dev, 0xe5, 0x09);
 
 	enables = 0x4;
 	if (cfg) {
 		if (cfg->enable_gpo5)
 			enables |= 0x01;
 		if (cfg->gpio15_12_dir_output)
 			enables |= 0x10;
 	}
 	/* REQ5 as PCI request input - should be together with INTE-INTH. */
 	pci_write_config8(dev, 0xe4, enables);
 #endif
 
 	/* Set bit 3 of 0x4f (use INIT# as CPU reset). */
 	enables = pci_read_config8(dev, 0x4f);
 	enables |= 0x08;
 	pci_write_config8(dev, 0x4f, enables);
 
 #if CONFIG_EPIA_VT8237R_INIT
 	/*
 	 * Set Read Pass Write Control Enable
 	 */
 	pci_write_config8(dev, 0x48, 0x0c);
 #else
 
   #if CONFIG_SOUTHBRIDGE_VIA_SUBTYPE_K8T800 || CONFIG_SOUTHBRIDGE_VIA_SUBTYPE_K8T800_OLD
 	/* It seems that when we pair with the K8T800, we need to disable
 	 * the A2 mask
 	 */
 	pci_write_config8(dev, 0x48, 0x0c);
   #else
 	/*
 	 * Set Read Pass Write Control Enable
 	 * (force A2 from APIC FSB to low).
 	 */
 	pci_write_config8(dev, 0x48, 0x8c);
   #endif
 
 #endif
 
 	southbridge_init_common(dev);
 
 #if !CONFIG_EPIA_VT8237R_INIT
 	/* FIXME: Intel needs more bit set for C2/C3. */
 
 	/*
 	 * Allow SLP# signal to assert LDTSTOP_L.
 	 * Will work for C3 and for FID/VID change.
 	 */
 	outb(0x1, VT8237R_ACPI_IO_BASE + 0x11);
 #endif
 
 	printk(BIOS_SPEW, "Leaving %s.\n", __func__);
 	printk(BIOS_SPEW, "And taking a dump:\n");
 	dump_south(dev);
 }
 
 static void vt8237a_init(struct device *dev)
 {
 	/*
 	 * FIXME: This is based on vt8237s_init() and the values the AMI
 	 *        BIOS on my M2V wrote to these registers (by looking
 	 *        at lspci -nxxx output).
 	 *        Works for me.
 	 */
 	u32 tmp;
 
 	/* Set bit 3 of 0x4f (use INIT# as CPU reset). */
 	tmp = pci_read_config8(dev, 0x4f);
 	tmp |= 0x08;
 	pci_write_config8(dev, 0x4f, tmp);
 
 	/*
 	 * bit2: REQ5 as PCI request input - should be together with INTE-INTH.
 	 * bit5: usb power control lines as gpio
 	 */
 	pci_write_config8(dev, 0xe4, 0x24);
 	/*
 	 * Enable APIC wakeup from INTH
 	 * Enable SATA LED, disable special CPU Frequency Change -
 	 * GPIO28 GPIO22 GPIO29 GPIO23 are GPIOs.
 	 */
 	pci_write_config8(dev, 0xe5, 0x69);
 
 	/* Reduce further the STPCLK/LDTSTP signal to 5us. */
 	pci_write_config8(dev, 0xec, 0x4);
 
 	/* Host Bus Power Management Control, maybe not needed */
 	pci_write_config8(dev, 0x8c, 0x5);
 
 	/* Enable HPET */
 	pci_write_config32(dev, 0x68, (CONFIG_HPET_ADDRESS | 0x80));
 
 	southbridge_init_common(dev);
 
 	/* Share INTE-INTH with INTA-INTD for simplicity */
 	pci_write_config8(dev, 0x46, 0x00);
 
 	/* FIXME: Intel needs more bit set for C2/C3. */
 
 	/*
 	 * Allow SLP# signal to assert LDTSTOP_L.
 	 * Will work for C3 and for FID/VID change.
 	 */
 	outb(0x1, VT8237R_ACPI_IO_BASE + 0x11);
 
 	dump_south(dev);
 }
 
 static void vt8237s_init(struct device *dev)
 {
 	u32 tmp;
 
 	/* Put SPI base VT8237S_SPI_MEM_BASE. */
 	tmp = pci_read_config32(dev, 0xbc);
 	pci_write_config32(dev, 0xbc,
 			   (VT8237S_SPI_MEM_BASE >> 8) | (tmp & 0xFF000000));
 
 	/*
 	 * REQ5 as PCI request input - should be together with INTE-INTH.
 	 */
 	pci_write_config8(dev, 0xe4, 0x04);
 
 	/* Reduce further the STPCLK/LDTSTP signal to 5us. */
 	pci_write_config8(dev, 0xec, 0x4);
 
 	/* Host Bus Power Management Control, maybe not needed */
 	pci_write_config8(dev, 0x8c, 0x5);
 
 	/* Enable HPET, does not work correctly on R. */
 	pci_write_config32(dev, 0x68, (CONFIG_HPET_ADDRESS | 0x80));
 
 	southbridge_init_common(dev);
 
 	/* FIXME: Intel needs more bit set for C2/C3. */
 
 	/*
 	 * Allow SLP# signal to assert LDTSTOP_L.
 	 * Will work for C3 and for FID/VID change. FIXME FIXME, pre rev A2.
 	 */
 	outb(0xff, VT8237R_ACPI_IO_BASE + 0x50);
 
 	dump_south(dev);
 }
 
 static void vt8237_common_init(struct device *dev)
 {
 	u8 enables, byte;
 	struct southbridge_via_vt8237r_config *cfg;
 #if !CONFIG_EPIA_VT8237R_INIT
 	unsigned char pwr_on;
 #endif
 
 	cfg = dev->chip_info;
 
 	/* Enable addr/data stepping. */
 	byte = pci_read_config8(dev, PCI_COMMAND);
 	byte |= PCI_COMMAND_WAIT;
 	pci_write_config8(dev, PCI_COMMAND, byte);
 
 /* EPIA-N(L) Uses CN400 for BIOS Access */
 #if !CONFIG_EPIA_VT8237R_INIT
 	/* Enable the internal I/O decode. */
 	enables = pci_read_config8(dev, 0x6C);
 	enables |= 0x80;
 	pci_write_config8(dev, 0x6C, enables);
 
 	/*
 	 * ROM decode
 	 * bit range
 	 *   7 000E0000h-000EFFFFh
 	 *   6 FFF00000h-FFF7FFFFh
 	 *   5 FFE80000h-FFEFFFFFh
 	 *   4 FFE00000h-FFE7FFFFh
 	 *   3 FFD80000h-FFDFFFFFh
 	 *   2 FFD00000h-FFD7FFFFh
 	 *   1 FFC80000h-FFCFFFFFh
 	 *   0 FFC00000h-FFC7FFFFh
 	 * So 0x7f here sets ROM decode to FFC00000-FFFFFFFF or 4Mbyte.
 	 */
 	pci_write_config8(dev, 0x41, 0x7f);
 #endif
 
 	/*
 	 * Set bit 6 of 0x40 (I/O recovery time).
 	 * IMPORTANT FIX - EISA = ECLR reg at 0x4d0! Decoding must be on so
 	 * that PCI interrupts can be properly marked as level triggered.
 	 */
 	enables = pci_read_config8(dev, 0x40);
 	enables |= 0x44;
 	pci_write_config8(dev, 0x40, enables);
 
 	/* Line buffer control */
 	enables = pci_read_config8(dev, 0x42);
 	enables |= 0xf8;
 	pci_write_config8(dev, 0x42, enables);
 
 	/* Delay transaction control */
 	pci_write_config8(dev, 0x43, 0xb);
 
 #if CONFIG_EPIA_VT8237R_INIT
 	/* I/O recovery time, default IDE routing */
 	pci_write_config8(dev, 0x4c, 0x04);
 
 	/* ROM memory cycles go to LPC. */
 	pci_write_config8(dev, 0x59, 0x80);
 
 	/*
 	 * Bit | Meaning
 	 * -------------
 	 *   3 | Bypass APIC De-Assert Message (1=Enable)
 	 *   2 | APIC HyperTransport Mode (1=Enable)
 	 *   1 | possibly "INTE#, INTF#, INTG#, INTH# as PCI"
 	 *     | bit 1=1 works for Aaron at VIA, bit 1=0 works for jakllsch
 	 *   0 | Dynamic Clock Gating Main Switch (1=Enable)
 	 */
 	pci_write_config8(dev, 0x5b, 0x9);
 
 	/* Set 0x58 to 0x42 APIC On and RTC Write Protect.*/
 	pci_write_config8(dev, 0x58, 0x42);
 
 	/* Enable serial IRQ, 6PCI clocks. */
 	pci_write_config8(dev, 0x52, 0x9);
 #else
 	/* I/O recovery time, default IDE routing */
 	pci_write_config8(dev, 0x4c, 0x44);
 
 	/* ROM memory cycles go to LPC. */
  	pci_write_config8(dev, 0x59, 0x80);
 
 	/*
 	 * Bit | Meaning
 	 * -------------
 	 *   3 | Bypass APIC De-Assert Message (1=Enable)
 	 *   2 | APIC HyperTransport Mode (1=Enable)
 	 *   1 | possibly "INTE#, INTF#, INTG#, INTH# as PCI"
 	 *     | bit 1=1 works for Aaron at VIA, bit 1=0 works for jakllsch
 	 *   0 | Dynamic Clock Gating Main Switch (1=Enable)
 	 */
 	if (cfg && cfg->int_efgh_as_gpio) {
 		pci_write_config8(dev, 0x5b, 0x9);
 	} else {
 		pci_write_config8(dev, 0x5b, 0xb);
 	}
 
 	/* configure power state of the board after loss of power */
 	if (get_option(&pwr_on, "power_on_after_fail") != CB_SUCCESS)
 		pwr_on = 1;
 	enables = pci_read_config8(dev, 0x58);
 	pci_write_config8(dev, 0x58, enables & ~0x02);
 	outb(0x0d, 0x70);
 	outb(pwr_on ? 0x00 : 0x80, 0x71);
 	pci_write_config8(dev, 0x58, enables);
 
 	/* Set 0x58 to 0x43 APIC and RTC. */
 	pci_write_config8(dev, 0x58, 0x43);
 
 	/* Enable serial IRQ, 6PCI clocks. */
 	pci_write_config8(dev, 0x52, 0x9);
 #endif
 #if CONFIG_HAVE_SMI_HANDLER
 	smm_lock();
 #endif
 
 	/* Power management setup */
 	setup_pm(dev);
 
 	/* Start the RTC. */
 	cmos_init(0);
 }
 
 static void vt8237r_read_resources(device_t dev)
 {
 	struct resource *res;
 
 	pci_dev_read_resources(dev);
 
 	/* Fixed ACPI Base IO Base*/
 	res = new_resource(dev, 0x88);
 	res->base = VT8237R_ACPI_IO_BASE;
 	res->size = 128;
 	res->limit = 0xffffUL;
 	res->flags = IORESOURCE_IO | IORESOURCE_FIXED | IORESOURCE_RESERVE |
 		     IORESOURCE_STORED | IORESOURCE_ASSIGNED;
 
 	/* Fixed EISA ECLR I/O Regs	*/
 	res = new_resource(dev, 3);
 	res->base = 0x4d0;
 	res->size = 2;
 	res->limit = 0xffffUL;
 	res->flags = IORESOURCE_IO | IORESOURCE_FIXED | IORESOURCE_RESERVE |
 		     IORESOURCE_STORED | IORESOURCE_ASSIGNED;
 
 	/* Fixed System Management Bus I/O Resource */
 	res = new_resource(dev, 0xD0);
 	res->base = VT8237R_SMBUS_IO_BASE;
 	res->size = 16;
 	res->limit = 0xffffUL;
 	res->flags = IORESOURCE_IO | IORESOURCE_FIXED | IORESOURCE_RESERVE |
 		     IORESOURCE_STORED | IORESOURCE_ASSIGNED;
 
 	/* Fixed APIC resource */
 	res = new_resource(dev, 0x44);
 	res->base = IO_APIC_ADDR;
 	res->size = 256;
 	res->limit = 0xffffffffUL;
 	res->align = 8;
 	res->gran = 8;
 	res->flags = IORESOURCE_MEM | IORESOURCE_FIXED | IORESOURCE_RESERVE |
 		     IORESOURCE_STORED | IORESOURCE_ASSIGNED;
 
 	/* Fixed flashrom resource */
 	res = new_resource(dev, 4);
 	res->base = 0xff000000UL;
 	res->size = 0x01000000UL; /* 16MB */
 	res->limit = 0xffffffffUL;
 	res->flags = IORESOURCE_MEM | IORESOURCE_FIXED | IORESOURCE_RESERVE |
 		     IORESOURCE_STORED | IORESOURCE_ASSIGNED;
 
 	res = new_resource(dev, 1);
 	res->base = 0x0UL;
 	res->size = 0x1000UL;
 	res->limit = 0xffffUL;
 	res->flags = IORESOURCE_IO | IORESOURCE_ASSIGNED | IORESOURCE_FIXED;
 }
 
 static void init_keyboard(struct device *dev)
 {
 	u8 regval = pci_read_config8(dev, 0x51);
 	if (regval & 0x1)
 		pc_keyboard_init(NO_AUX_DEVICE);
 }
 
 static void southbridge_init_common(struct device *dev)
 {
 	vt8237_common_init(dev);
 	pci_routing_fixup(dev);
 	setup_ioapic(VIO_APIC_VADDR, VT8237R_APIC_ID);
 	setup_i8259();
 	init_keyboard(dev);
 }
 
 
 static void vt8237_set_subsystem(device_t dev, unsigned vendor, unsigned device)
 {
 	pci_write_config16(dev, 0x70, vendor);
 	pci_write_config16(dev, 0x72, device);
 }
 
 static struct pci_operations lops_pci = {
 	.set_subsystem = vt8237_set_subsystem,
 };
 
 static const struct device_operations vt8237r_lpc_ops_s = {
 	.read_resources		= vt8237r_read_resources,
 	.set_resources		= pci_dev_set_resources,
 	.enable_resources	= pci_dev_enable_resources,
 	.init			= vt8237s_init,
 	.scan_bus		= scan_lpc_bus,
 	.ops_pci		= &lops_pci,
 };
 
 static const struct device_operations vt8237r_lpc_ops_r = {
 	.read_resources		= vt8237r_read_resources,
 	.set_resources		= pci_dev_set_resources,
 	.enable_resources	= pci_dev_enable_resources,
 	.init			= vt8237r_init,
 	.scan_bus		= scan_lpc_bus,
 	.ops_pci		= &lops_pci,
 };
 
 static const struct device_operations vt8237r_lpc_ops_a = {
 	.read_resources		= vt8237r_read_resources,
 	.set_resources		= pci_dev_set_resources,
 	.enable_resources	= pci_dev_enable_resources,
 	.init			= vt8237a_init,
 	.scan_bus		= scan_lpc_bus,
 	.ops_pci		= &lops_pci,
 };
 
 static const struct pci_driver lpc_driver_r __pci_driver = {
 	.ops	= &vt8237r_lpc_ops_r,
 	.vendor	= PCI_VENDOR_ID_VIA,
 	.device	= PCI_DEVICE_ID_VIA_VT8237R_LPC,
 };
 
 static const struct pci_driver lpc_driver_a __pci_driver = {
 	.ops	= &vt8237r_lpc_ops_a,
 	.vendor	= PCI_VENDOR_ID_VIA,
 	.device	= PCI_DEVICE_ID_VIA_VT8237A_LPC,
 };
 
 static const struct pci_driver lpc_driver_s __pci_driver = {
 	.ops	= &vt8237r_lpc_ops_s,
 	.vendor	= PCI_VENDOR_ID_VIA,
 	.device	= PCI_DEVICE_ID_VIA_VT8237S_LPC,
 };
