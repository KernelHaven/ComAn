2003-06-24 19:51:38 +0000
diff --git a/src/mainboard/arima/hdama/Config.lb b/src/mainboard/arima/hdama/Config.lb
index ca84619..38cda39 100644
--- a/src/mainboard/arima/hdama/Config.lb
+++ b/src/mainboard/arima/hdama/Config.lb
@@ -1,132 +1,133 @@
 uses HAVE_MP_TABLE
 uses HAVE_PIRQ_TABLE
 uses USE_FALLBACK_IMAGE
 uses USE_NORMAL_IMAGE
+uses AMD8111_DEV
 #
 #
 ###
 ### Set all of the defaults for an x86 architecture
 ###
 #
 #
 ###
 ### Build the objects we have code for in this directory.
 ###
 ##object mainboard.o
 driver mainboard.o
 object static_devices.o
 if HAVE_MP_TABLE object mptable.o end
 if HAVE_PIRQ_TABLE object irq_tables.o end
 #
 arch i386 end
 cpu k8 end
 #
 ###
 ### Build our 16 bit and 32 bit linuxBIOS entry code
 ###
 mainboardinit cpu/i386/entry16.inc
 mainboardinit cpu/i386/entry32.inc
 ldscript /cpu/i386/entry16.lds
 ldscript /cpu/i386/entry32.lds
 #
 ###
 ### Build our reset vector (This is where linuxBIOS is entered)
 ###
 if USE_FALLBACK_IMAGE 
   mainboardinit cpu/i386/reset16.inc 
   ldscript /cpu/i386/reset16.lds 
 end
 
 if USE_NORMAL_IMAGE
   mainboardinit cpu/i386/reset32.inc 
   ldscript /cpu/i386/reset32.lds 
 end
 #
 #### Should this be in the northbridge code?
 #mainboardinit archi386/lib/cpu_reset.inc
 #
 ###
 ### Include an id string (For safe flashing)
 ###
 mainboardinit arch/i386/lib/id.inc
 ldscript /arch/i386/lib/id.lds
 #
 ####
 #### This is the early phase of linuxBIOS startup 
 #### Things are delicate and we test to see if we should
 #### failover to another image.
 ####
 #option MAX_REBOOT_CNT=2
 ##ldscript arch/i386/lib/failover.lds USE_FALLBACK_IMAGE
 #
 ###
 ### Setup our mtrrs
 ###
 mainboardinit cpu/k8/earlymtrr.inc
 #
 #
 ###
 ### Only the bootstrap cpu makes it here.
 ### Failover if we need to 
 ###
 #
 if USE_FALLBACK_IMAGE
   mainboardinit southbridge/amd/amd8111/cmos_boot_failover.inc 
 end
 #
 ####
 #### O.k. We aren't just an intermediary anymore!
 ####
 #
 ###
 ### When debugging disable the watchdog timer
 ###
 ##option MAXIMUM_CONSOLE_LOGLEVEL=7
 #default MAXIMUM_CONSOLE_LOGLEVEL=7
 #option DISABLE_WATCHDOG= (MAXIMUM_CONSOLE_LOGLEVEL >= 8) 
 #if DISABLE_WATCHDOG
 #  mainboardinit southbridgeamd/amd8111/disable_watchdog.inc 
 #end
 #
 ###
 ### Setup the serial port
 ###
 #mainboardinit superiowinbond/w83627hf/setup_serial.inc
 mainboardinit pc80/serial.inc
 mainboardinit arch/i386/lib/console.inc
 if USE_FALLBACK_IMAGE mainboardinit archi386/lib/noop_failover.inc  end
 #
 ###
 ### Romcc output
 ###
 #makerule ./failover.E dep "$(MAINBOARD)/failover.c" act "$(CPP) -I$(TOP)/src $(CPPFLAGS) $(MAINBOARD)/failover.c > ./failever.E"
 #makerule ./failover.inc dep "./romcc ./failover.E" act "./romcc -O ./failover.E > failover.inc"
 #mainboardinit .failover.inc
 makerule ./auto.E dep "$(MAINBOARD)/auto.c" act "$(CPP) -I$(TOP)/src -$(ROMCCPPFLAGS) $(CPPFLAGS) $(MAINBOARD)/auto.c > ./auto.E"
 makerule ./auto.inc dep "./romcc ./auto.E" act "./romcc -O ./auto.E > auto.inc"
 mainboardinit ./auto.inc
 #
 ###
 ### Setup RAM
 ###
 mainboardinit ram/ramtest.inc
 mainboardinit southbridge/amd/amd8111/smbus.inc
 mainboardinit sdram/generic_dump_spd.inc
 #
 ###
 ### Include the secondary Configuration files 
 ###
 northbridge amd/amdk8
 end
 southbridge amd/amd8111
 end
 #mainboardinit archi386/smp/secondary.inc
 superio NSC/pc87360
 	register "com1={1} com2={0} floppy=1 lpt=1 keyboard=1"
 end
 dir /pc80
 ##dir /src/superio/winbond/w83627hf
 cpu p5 end
 cpu p6 end
 cpu k7 end
 cpu k8 end
diff --git a/src/mainboard/arima/hdama/auto.c b/src/mainboard/arima/hdama/auto.c
index 61cf7cd..94ce39d 100644
--- a/src/mainboard/arima/hdama/auto.c
+++ b/src/mainboard/arima/hdama/auto.c
@@ -1,1125 +1,182 @@
 #define ASSEMBLY 1
+#include <stdint.h>
+#include <device/pci_def.h>
 #include "arch/romcc_io.h"
 #include "pc80/serial.c"
 #include "arch/i386/lib/console.c"
 #include "ram/ramtest.c"
+#include "northbridge/amd/amdk8/early_ht.c"
+#include "southbridge/amd/amd8111/amd8111_early_smbus.c"
+#include "northbridge/amd/amdk8/raminit.c"
+#include "northbridge/amd/amdk8/coherent_ht.c"
+#include "sdram/generic_sdram.c"
 
+#define NODE_ID		0x60
+#define	HT_INIT_CONTROL 0x6c
 
-#define MEMORY_512MB  0  /* SuSE Solo configuration */
-#define MEMORY_1024MB 1  /* LNXI Solo configuration */
-
-
+#define HTIC_ColdR_Detect  (1<<4)
+#define HTIC_BIOSR_Detect  (1<<5)
+#define HTIC_INIT_Detect   (1<<6)
 
-static void sdram_set_registers(void)
+static int boot_cpu(void)
 {
-	static const unsigned int register_values[] = {
-	/* Routing Table Node i 
-	 * F0:0x40 i = 0, 
-	 * F0:0x44 i = 1,
-	 * F0:0x48 i = 2, 
-	 * F0:0x4c i = 3,
-	 * F0:0x50 i = 4, 
-	 * F0:0x54 i = 5,
-	 * F0:0x58 i = 6, 
-	 * F0:0x5c i = 7
-	 * [ 0: 3] Request Route
-	 *     [0] Route to this node
-	 *     [1] Route to Link 0
-	 *     [2] Route to Link 1
-	 *     [3] Route to Link 2
-	 * [11: 8] Response Route
-	 *     [0] Route to this node
-	 *     [1] Route to Link 0
-	 *     [2] Route to Link 1
-	 *     [3] Route to Link 2
-	 * [19:16] Broadcast route
-	 *     [0] Route to this node
-	 *     [1] Route to Link 0
-	 *     [2] Route to Link 1
-	 *     [3] Route to Link 2
-	 */
-	0xc040, 0xfff0f0f0, 0x00010101,
-	0xc044, 0xfff0f0f0, 0x00010101,
-	0xc048, 0xfff0f0f0, 0x00010101,
-	0xc04c, 0xfff0f0f0, 0x00010101,
-	0xc050, 0xfff0f0f0, 0x00010101,
-	0xc054, 0xfff0f0f0, 0x00010101,
-	0xc058, 0xfff0f0f0, 0x00010101,
-	0xc05c, 0xfff0f0f0, 0x00010101,
-
-	/* Hypetransport Transaction Control Register 
-	 * F0:0x68
-	 * [ 0: 0] Disable read byte probe
-	 *         0 = Probes issues
-	 *         1 = Probes not issued
-	 * [ 1: 1] Disable Read Doubleword probe
-	 *         0 = Probes issued
-	 *         1 = Probes not issued
-	 * [ 2: 2] Disable write byte probes
-	 *         0 = Probes issued
-	 *         1 = Probes not issued
-	 * [ 3: 3] Disalbe Write Doubleword Probes
-	 *         0 = Probes issued
-	 *         1 = Probes not issued.
-	 * [ 4: 4] Disable Memroy Controller Target Start
-	 *         0 = TgtStart packets are generated
-	 *         1 = TgtStart packets are not generated.
-	 * [ 5: 5] CPU1 Enable
-	 *         0 = Second CPU disabled or not present
-	 *         1 = Second CPU enabled.
-	 * [ 6: 6] CPU Request PassPW
-	 *         0 = CPU requests do not pass posted writes
-	 *         1 = CPU requests pass posted writes.
-	 * [ 7: 7] CPU read Respons PassPW
-	 *         0 = CPU Responses do not pass posted writes
-	 *         1 = CPU responses pass posted writes.
-	 * [ 8: 8] Disable Probe Memory Cancel
-	 *         0 = Probes may generate MemCancels
-	 *         1 = Probes may not generate MemCancels
-	 * [ 9: 9] Disable Remote Probe Memory Cancel.
-	 *         0 = Probes hitting dirty blocks generate memory cancel packets
-	 *         1 = Only probed caches on the same node as the memory controller
-	 *              generate cancel packets.
-	 * [10:10] Disable Fill Probe
-	 *         0 = Probes issued for cache fills
-	 *         1 = Probes not issued for cache fills.
-	 * [11:11] Response PassPw
-	 *         0 = Downstream response PassPW based on original request
-	 *         1 = Downstream response PassPW set to 1
-	 * [12:12] Change ISOC to Ordered
-	 *         0 = Bit 1 of coherent HT RdSz/WrSz command used for iosynchronous prioritization
-	 *         1 = Bit 1 of coherent HT RdSz/WrSz command used for ordering.
-	 * [14:13] Buffer Release Priority select 
-	 *         00 = 64
-	 *         01 = 16
-	 *         10 = 8
-	 *         11 = 2
-	 * [15:15] Limit Coherent HT Configuration Space Range
-	 *         0 = No coherent HT configuration space restrictions
-	 *         1 = Limit coherent HT configuration space based on node count
-	 * [16:16] Local Interrupt Conversion Enable.
-	 *         0 = ExtInt/NMI interrups unaffected.
-	 *         1 = ExtInt/NMI broadcat interrupts converted to LINT0/1
-	 * [17:17] APIC Extended Broadcast Enable.
-	 *         0 = APIC broadcast is 0F
-	 *         1 = APIC broadcast is FF
-	 * [18:18] APIC Extended ID Enable
-	 *         0 = APIC ID is 4 bits.
-	 *         1 = APIC ID is 8 bits.
-	 * [19:19] APIC Extended Spurious Vector Enable
-	 *         0 = Lower 4 bits of spurious vector are read-only 1111
-	 *         1 = Lower 4 bits of spurious vecotr are writeable.
-	 * [20:20] Sequence ID Source Node Enable
-	 *         0 = Normal operation
-	 *         1 = Keep SeqID on routed packets for debugging.
-	 * [22:21] Downstream non-posted request limit
-	 *         00 = No limit
-	 *         01 = Limited to 1
-	 *         10 = Limited to 4
-	 *         11 = Limited to 8
-	 * [23:23] RESERVED
-	 * [25:24] Medium-Priority Bypass Count
-	 *         - Maximum # of times a medium priority access can pass a low
-	 *           priority access before Medium-Priority mode is disabled for one access.
-	 * [27:26] High-Priority Bypass Count
-	 *         - Maximum # of times a high prioirty access can pass a medium or low
-	 *           priority access before High-prioirty mode is disabled for one access.
-	 * [28:28] Enable High Priority CPU Reads
-	 *         0 = Cpu reads are medium prioirty
-	 *         1 = Cpu reads are high prioirty
-	 * [29:29] Disable Low Priority Writes
-	 *         0 = Non-isochronous writes are low priority
-	 *         1 = Non-isochronous writes are medium prioirty
-	 * [30:30] Disable High Priority Isochronous writes
-	 *         0 = Isochronous writes are high priority
-	 *         1 = Isochronous writes are medium priority
-	 * [31:31] Disable Medium Priority Isochronous writes
-	 *         0 = Isochronous writes are medium are high
-	 *         1 = With bit 30 set makes Isochrouns writes low priority.
-	 */
-	0xc068, 0x00800000, 0x0f00840f,
-	/* HT Initialization Control Register
-	 * F0:0x68
-	 * [ 0: 0] Routing Table Disable
-	 *         0 = Packets are routed according to routing tables
-	 *         1 = Packets are routed according to the default link field
-	 * [ 1: 1] Request Disable (BSP should clear this)
-	 *         0 = Request packets may be generated
-	 *         1 = Request packets may not be generated.
-	 * [ 3: 2] Default Link (Read-only)
-	 *         00 = LDT0
-	 *         01 = LDT1
-	 *         10 = LDT2
-	 *         11 = CPU on same node
-	 * [ 4: 4] Cold Reset
-	 *         - Scratch bit cleared by a cold reset
-	 * [ 5: 5] BIOS Reset Detect
-	 *         - Scratch bit cleared by a cold reset
-	 * [ 6: 6] INIT Detect
-	 *         - Scratch bit cleared by a warm or cold reset not by an INIT
-	 *
-	 */
-	0xc06C, 0xffffff8c, 0x00000000,
-	/* LDTi Capabilities Registers
-	 * F0:0x80 i = 0,
-	 * F0:0xA0 i = 1,
-	 * F0:0xC0 i = 2,
-	 */
-	/* LDTi Link Control Registrs
-	 * F0:0x84 i = 0,
-	 * F0:0xA4 i = 1,
-	 * F0:0xC4 i = 2,
-	 * [ 1: 1] CRC Flood Enable
-	 *         0 = Do not generate sync packets on CRC error
-	 *         1 = Generate sync packets on CRC error
-	 * [ 2: 2] CRC Start Test (Read-Only)
-	 * [ 3: 3] CRC Force Frame Error
-	 *         0 = Do not generate bad CRC
-	 *         1 = Generate bad CRC
-	 * [ 4: 4] Link Failure
-	 *         0 = No link failure detected
-	 *         1 = Link failure detected
-	 * [ 5: 5] Initialization Complete
-	 *         0 = Initialization not complete
-	 *         1 = Initialization complete
-	 * [ 6: 6] Receiver off
-	 *         0 = Recevier on
-	 *         1 = Receiver off
-	 * [ 7: 7] Transmitter Off
-	 *         0 = Transmitter on
-	 *         1 = Transmitter off
-	 * [ 9: 8] CRC_Error
-	 *         00 = No error
-	 *         [0] = 1 Error on byte lane 0
-	 *         [1] = 1 Error on byte lane 1
-	 * [12:12] Isochrnous Enable  (Read-Only)
-	 * [13:13] HT Stop Tristate Enable
-	 *         0 = Driven during an LDTSTOP_L
-	 *         1 = Tristated during and LDTSTOP_L
-	 * [14:14] Extended CTL Time 
-	 *         0 = CTL is asserted for 16 bit times during link initialization
-	 *         1 = CTL is asserted for 50us during link initialization
-	 * [18:16] Max Link Width In (Read-Only?)
-	 *         000 = 8 bit link
-	 *         001 = 16bit link
-	 * [19:19] Doubleword Flow Control in (Read-Only)
-	 *         0 = This link does not support doubleword flow control
-	 *         1 = This link supports doubleword flow control
-	 * [22:20] Max Link Width Out (Read-Only?)
-	 *         000 = 8 bit link
-	 *         001 = 16bit link
-	 * [23:23] Doubleworld Flow Control out (Read-Only)
-	 *         0 = This link does not support doubleword flow control
-	 *         1 = This link supports doubleworkd flow control
-	 * [26:24] Link Width In
-	 *         000 = Use 8 bits
-	 *         001 = Use 16 bits
-	 *         010 = reserved
-	 *         011 = Use 32 bits
-	 *         100 = Use 2 bits
-	 *         101 = Use 4 bits
-	 *         110 = reserved
-	 *         111 = Link physically not connected
-	 * [27:27] Doubleword Flow Control In Enable
-	 *         0 = Doubleword flow control disabled
-	 *         1 = Doubleword flow control enabled (Not currently supported)
-	 * [30:28] Link Width Out
-	 *         000 = Use 8 bits
-	 *         001 = Use 16 bits
-	 *         010 = reserved
-	 *         011 = Use 32 bits
-	 *         100 = Use 2 bits
-	 *         101 = Use 4 bits
-	 *         110 = reserved
-	 *         111 = Link physically not connected
-	 * [31:31] Doubleworld Flow Control Out Enable
-	 *         0 = Doubleworld flow control disabled
-	 *         1 = Doubleword flow control enabled (Not currently supported)
-	 */
-	0xc084, 0x00009c05, 0x11110020,
-	/* LDTi Frequency/Revision Registers
-	 * F0:0x88 i = 0,
-	 * F0:0xA8 i = 1,
-	 * F0:0xC8 i = 2,
-	 * [ 4: 0] Minor Revision
-	 *         Contains the HT Minor revision
-	 * [ 7: 5] Major Revision
-	 *         Contains the HT Major revision
-	 * [11: 8] Link Frequency  (Takes effect the next time the link is reconnected)
-	 *         0000 = 200Mhz
-	 *         0001 = reserved
-	 *         0010 = 400Mhz
-	 *         0011 = reserved
-	 *         0100 = 600Mhz
-	 *         0101 = 800Mhz
-	 *         0110 = 1000Mhz
-	 *         0111 = reserved
-	 *         1000 = reserved
-	 *         1001 = reserved
-	 *         1010 = reserved
-	 *         1011 = reserved
-	 *         1100 = reserved
-	 *         1101 = reserved
-	 *         1110 = reserved
-	 *         1111 = 100 Mhz
-	 * [15:12] Error (Not currently Implemented)
-	 * [31:16] Indicates the frequency capabilities of the link
-	 *         [16] = 1 encoding 0000 of freq supported
-	 *         [17] = 1 encoding 0001 of freq supported
-	 *         [18] = 1 encoding 0010 of freq supported
-	 *         [19] = 1 encoding 0011 of freq supported
-	 *         [20] = 1 encoding 0100 of freq supported
-	 *         [21] = 1 encoding 0101 of freq supported
-	 *         [22] = 1 encoding 0110 of freq supported
-	 *         [23] = 1 encoding 0111 of freq supported
-	 *         [24] = 1 encoding 1000 of freq supported
-	 *         [25] = 1 encoding 1001 of freq supported
-	 *         [26] = 1 encoding 1010 of freq supported
-	 *         [27] = 1 encoding 1011 of freq supported
-	 *         [28] = 1 encoding 1100 of freq supported
-	 *         [29] = 1 encoding 1101 of freq supported
-	 *         [30] = 1 encoding 1110 of freq supported
-	 *         [31] = 1 encoding 1111 of freq supported
-	 */
-	0xC088, 0xfffff0ff, 0x00000200,
-	/* LDTi Feature Capability
-	 * F0:0x8C i = 0,
-	 * F0:0xAC i = 1,
-	 * F0:0xCC i = 2,
-	 */
-	/* LDTi Buffer Count Registers
-	 * F0:0x90 i = 0,
-	 * F0:0xB0 i = 1,
-	 * F0:0xD0 i = 2,
-	 */
-	/* LDTi Bus Number Registers
-	 * F0:0x94 i = 0,
-	 * F0:0xB4 i = 1,
-	 * F0:0xD4 i = 2,
-	 * For NonCoherent HT specifies the bus number downstream (behind the host bridge)
-	 * [ 0: 7] Primary Bus Number
-	 * [15: 8] Secondary Bus Number
-	 * [23:15] Subordiante Bus Number
-	 * [31:24] reserved
-	 */
-	0xC094, 0xff000000, 0x00ff0000,
-	/* LDTi Type Registers
-	 * F0:0x98 i = 0,
-	 * F0:0xB8 i = 1,
-	 * F0:0xD8 i = 2,
-	 */
-	/* Careful set limit registers before base registers which contain the enables */
-	/* DRAM Limit i Registers
-	 * F1:0x44 i = 0
-	 * F1:0x4C i = 1
-	 * F1:0x54 i = 2
-	 * F1:0x5C i = 3
-	 * F1:0x64 i = 4
-	 * F1:0x6C i = 5
-	 * F1:0x74 i = 6
-	 * F1:0x7C i = 7
-	 * [ 2: 0] Destination Node ID
-	 *         000 = Node 0
-	 *         001 = Node 1
-	 *         010 = Node 2
-	 *         011 = Node 3
-	 *         100 = Node 4
-	 *         101 = Node 5
-	 *         110 = Node 6
-	 *         111 = Node 7
-	 * [ 7: 3] Reserved
-	 * [10: 8] Interleave select
-	 *         specifies the values of A[14:12] to use with interleave enable.
-	 * [15:11] Reserved
-	 * [31:16] DRAM Limit Address i Bits 39-24
-	 *         This field defines the upper address bits of a 40 bit  address
-	 *         that define the end of the DRAM region.
-	 */
-#if MEMORY_1024MB
-	0xC144, 0x0000f8f8, 0x003f0000,
-#endif
-#if MEMORY_512MB
-	0xC144, 0x0000f8f8, 0x001f0000,
-#endif
-	0xC14C, 0x0000f8f8, 0x00000001,
-	0xC154, 0x0000f8f8, 0x00000002,
-	0xC15C, 0x0000f8f8, 0x00000003,
-	0xC164, 0x0000f8f8, 0x00000004,
-	0xC16C, 0x0000f8f8, 0x00000005,
-	0xC174, 0x0000f8f8, 0x00000006,
-	0xC17C, 0x0000f8f8, 0x00000007,
-	/* DRAM Base i Registers
-	 * F1:0x40 i = 0
-	 * F1:0x48 i = 1
-	 * F1:0x50 i = 2
-	 * F1:0x58 i = 3
-	 * F1:0x60 i = 4
-	 * F1:0x68 i = 5
-	 * F1:0x70 i = 6
-	 * F1:0x78 i = 7
-	 * [ 0: 0] Read Enable
-	 *         0 = Reads Disabled
-	 *         1 = Reads Enabled
-	 * [ 1: 1] Write Enable
-	 *         0 = Writes Disabled
-	 *         1 = Writes Enabled
-	 * [ 7: 2] Reserved
-	 * [10: 8] Interleave Enable
-	 *         000 = No interleave
-	 *         001 = Interleave on A[12] (2 nodes)
-	 *         010 = reserved
-	 *         011 = Interleave on A[12] and A[14] (4 nodes)
-	 *         100 = reserved
-	 *         101 = reserved
-	 *         110 = reserved
-	 *         111 = Interleve on A[12] and A[13] and A[14] (8 nodes)
-	 * [15:11] Reserved
-	 * [13:16] DRAM Base Address i Bits 39-24
-	 *         This field defines the upper address bits of a 40-bit address
-	 *         that define the start of the DRAM region.
-	 */
-	0xC140, 0x0000f8fc, 0x00000003,
-#if MEMORY_1024MB
-	0xC148, 0x0000f8fc, 0x00400000,
-	0xC150, 0x0000f8fc, 0x00400000,
-	0xC158, 0x0000f8fc, 0x00400000,
-	0xC160, 0x0000f8fc, 0x00400000,
-	0xC168, 0x0000f8fc, 0x00400000,
-	0xC170, 0x0000f8fc, 0x00400000,
-	0xC178, 0x0000f8fc, 0x00400000,
-#endif
-#if MEMORY_512MB
-	0xC148, 0x0000f8fc, 0x00200000,
-	0xC150, 0x0000f8fc, 0x00200000,
-	0xC158, 0x0000f8fc, 0x00200000,
-	0xC160, 0x0000f8fc, 0x00200000,
-	0xC168, 0x0000f8fc, 0x00200000,
-	0xC170, 0x0000f8fc, 0x00200000,
-	0xC178, 0x0000f8fc, 0x00200000,
-#endif
-
-	/* Memory-Mapped I/O Limit i Registers
-	 * F1:0x84 i = 0
-	 * F1:0x8C i = 1
-	 * F1:0x94 i = 2
-	 * F1:0x9C i = 3
-	 * F1:0xA4 i = 4
-	 * F1:0xAC i = 5
-	 * F1:0xB4 i = 6
-	 * F1:0xBC i = 7
-	 * [ 2: 0] Destination Node ID
-	 *         000 = Node 0
-	 *         001 = Node 1
-	 *         010 = Node 2
-	 *         011 = Node 3
-	 *         100 = Node 4
-	 *         101 = Node 5
-	 *         110 = Node 6
-	 *         111 = Node 7
-	 * [ 3: 3] Reserved
-	 * [ 5: 4] Destination Link ID
-	 *         00 = Link 0
-	 *         01 = Link 1
-	 *         10 = Link 2
-	 *         11 = Reserved
-	 * [ 6: 6] Reserved
-	 * [ 7: 7] Non-Posted
-	 *         0 = CPU writes may be posted
-	 *         1 = CPU writes must be non-posted
-	 * [31: 8] Memory-Mapped I/O Limit Address i (39-16)
-	 *         This field defines the upp adddress bits of a 40-bit address that
-	 *         defines the end of a memory-mapped I/O region n
-	 */
-	0xC184, 0x00000048, 0x00e1ff00,
-	0xC18C, 0x00000048, 0x00dfff00,
-	0xC194, 0x00000048, 0x00e3ff00,
-	0xC19C, 0x00000048, 0x00000000,
-	0xC1A4, 0x00000048, 0x00000000,
-	0xC1AC, 0x00000048, 0x00000000,
-	0xC1B4, 0x00000048, 0x00000b00,
-	0xC1BC, 0x00000048, 0x00fe0b00,
-
-	/* Memory-Mapped I/O Base i Registers
-	 * F1:0x80 i = 0
-	 * F1:0x88 i = 1
-	 * F1:0x90 i = 2
-	 * F1:0x98 i = 3
-	 * F1:0xA0 i = 4
-	 * F1:0xA8 i = 5
-	 * F1:0xB0 i = 6
-	 * F1:0xB8 i = 7
-	 * [ 0: 0] Read Enable
-	 *         0 = Reads disabled
-	 *         1 = Reads Enabled
-	 * [ 1: 1] Write Enable
-	 *         0 = Writes disabled
-	 *         1 = Writes Enabled
-	 * [ 2: 2] Cpu Disable
-	 *         0 = Cpu can use this I/O range
-	 *         1 = Cpu requests do not use this I/O range
-	 * [ 3: 3] Lock
-	 *         0 = base/limit registers i are read/write
-	 *         1 = base/limit registers i are read-only
-	 * [ 7: 4] Reserved
-	 * [31: 8] Memory-Mapped I/O Base Address i (39-16)
-	 *         This field defines the upper address bits of a 40bit address 
-	 *         that defines the start of memory-mapped I/O region i
-	 */
-	0xC180, 0x000000f0, 0x00e00003,
-	0xC188, 0x000000f0, 0x00d80003,
-	0xC190, 0x000000f0, 0x00e20003,
-	0xC198, 0x000000f0, 0x00000000,
-	0xC1A0, 0x000000f0, 0x00000000,
-	0xC1A8, 0x000000f0, 0x00000000,
-	0xC1B0, 0x000000f0, 0x00000a03,
-#if MEMORY_1024MB
-	0xC1B8, 0x000000f0, 0x00400003,
-#endif
-#if MEMORY_512MB
-	0xC1B8, 0x000000f0, 0x00200003,
-#endif
-
-	/* PCI I/O Limit i Registers
-	 * F1:0xC4 i = 0
-	 * F1:0xCC i = 1
-	 * F1:0xD4 i = 2
-	 * F1:0xDC i = 3
-	 * [ 2: 0] Destination Node ID
-	 *         000 = Node 0
-	 *         001 = Node 1
-	 *         010 = Node 2
-	 *         011 = Node 3
-	 *         100 = Node 4
-	 *         101 = Node 5
-	 *         110 = Node 6
-	 *         111 = Node 7
-	 * [ 3: 3] Reserved
-	 * [ 5: 4] Destination Link ID
-	 *         00 = Link 0
-	 *         01 = Link 1
-	 *         10 = Link 2
-	 *         11 = reserved
-	 * [11: 6] Reserved
-	 * [24:12] PCI I/O Limit Address i
-	 *         This field defines the end of PCI I/O region n
-	 * [31:25] Reserved
-	 */
-	0xC1C4, 0xFE000FC8, 0x0000d000,
-	0xC1CC, 0xFE000FC8, 0x000ff000,
-	0xC1D4, 0xFE000FC8, 0x00000000,
-	0xC1DC, 0xFE000FC8, 0x00000000,
+	volatile unsigned long *local_apic;
+	unsigned long apic_id;
+	int bsp;
+	msr_t msr;
+	msr = rdmsr(0x1b);
+	bsp = !!(msr.lo & (1 << 8));
+	if (bsp) {
+		print_debug("Bootstrap processor\r\n");
+	} else {
+		print_debug("Application processor\r\n");
+	}
 
-	/* PCI I/O Base i Registers
-	 * F1:0xC0 i = 0
-	 * F1:0xC8 i = 1
-	 * F1:0xD0 i = 2
-	 * F1:0xD8 i = 3
-	 * [ 0: 0] Read Enable
-	 *         0 = Reads Disabled
-	 *         1 = Reads Enabled
-	 * [ 1: 1] Write Enable
-	 *         0 = Writes Disabled
-	 *         1 = Writes Enabled
-	 * [ 3: 2] Reserved
-	 * [ 4: 4] VGA Enable
-	 *         0 = VGA matches Disabled
-	 *         1 = matches all address < 64K and where A[9:0] is in the 
-	 *             range 3B0-3BB or 3C0-3DF independen of the base & limit registers
-	 * [ 5: 5] ISA Enable
-	 *         0 = ISA matches Disabled
-	 *         1 = Blocks address < 64K and in the last 768 bytes of eack 1K block
-	 *             from matching agains this base/limit pair
-	 * [11: 6] Reserved
-	 * [24:12] PCI I/O Base i
-	 *         This field defines the start of PCI I/O region n 
-	 * [31:25] Reserved
-	 */
-	0xC1C0, 0xFE000FCC, 0x0000d003,
-	0xC1C8, 0xFE000FCC, 0x00001013,
-	0xC1D0, 0xFE000FCC, 0x00000000,
-	0xC1D8, 0xFE000FCC, 0x00000000,
+	return bsp;
+}
 
-	/* Config Base and Limit i Registers
-	 * F1:0xE0 i = 0
-	 * F1:0xE4 i = 1
-	 * F1:0xE8 i = 2
-	 * F1:0xEC i = 3
-	 * [ 0: 0] Read Enable
-	 *         0 = Reads Disabled
-	 *         1 = Reads Enabled
-	 * [ 1: 1] Write Enable
-	 *         0 = Writes Disabled
-	 *         1 = Writes Enabled
-	 * [ 2: 2] Device Number Compare Enable
-	 *         0 = The ranges are based on bus number
-	 *         1 = The ranges are ranges of devices on bus 0
-	 * [ 3: 3] Reserved
-	 * [ 6: 4] Destination Node
-	 *         000 = Node 0
-	 *         001 = Node 1
-	 *         010 = Node 2
-	 *         011 = Node 3
-	 *         100 = Node 4
-	 *         101 = Node 5
-	 *         110 = Node 6
-	 *         111 = Node 7
-	 * [ 7: 7] Reserved
-	 * [ 9: 8] Destination Link
-	 *         00 = Link 0
-	 *         01 = Link 1
-	 *         10 = Link 2
-	 *         11 - Reserved
-	 * [15:10] Reserved
-	 * [23:16] Bus Number Base i
-	 *         This field defines the lowest bus number in configuration region i
-	 * [31:24] Bus Number Limit i
-	 *         This field defines the highest bus number in configuration regin i
-	 */
-	0xC1E0, 0x0000FC88, 0xff000003,
-	0xC1E4, 0x0000FC88, 0x00000000,
-	0xC1E8, 0x0000FC88, 0x00000000,
-	0xC1EC, 0x0000FC88, 0x00000000,
+static int cpu_init_detected(void)
+{
+	unsigned long dcl;
+	int cpu_init;
 
-	/* DRAM CS Base Address i Registers
-	 * F2:0x40 i = 0
-	 * F2:0x44 i = 1
-	 * F2:0x48 i = 2
-	 * F2:0x4C i = 3
-	 * F2:0x50 i = 4
-	 * F2:0x54 i = 5
-	 * F2:0x58 i = 6
-	 * F2:0x5C i = 7
-	 * [ 0: 0] Chip-Select Bank Enable
-	 *         0 = Bank Disabled
-	 *         1 = Bank Enabled
-	 * [ 8: 1] Reserved
-	 * [15: 9] Base Address (19-13)
-	 *         An optimization used when all DIMM are the same size...
-	 * [20:16] Reserved
-	 * [31:21] Base Address (35-25)
-	 *         This field defines the top 11 addresses bit of a 40-bit
-	 *         address that define the memory address space.  These
-	 *         bits decode 32-MByte blocks of memory.
-	 */
-	0xC240, 0x001f01fe, 0x00000001,
-#if MEMORY_1024MB
-	0xC244, 0x001f01fe, 0x01000001,
-	0xC248, 0x001f01fe, 0x02000001,
-	0xC24C, 0x001f01fe, 0x03000001,
-#endif
-#if MEMORY_512MB
-	0xC244, 0x001f01fe, 0x00800001,
-	0xC248, 0x001f01fe, 0x01000001,
-	0xC24C, 0x001f01fe, 0x01800001,
-#endif
-	0xC250, 0x001f01fe, 0x00000000,
-	0xC254, 0x001f01fe, 0x00000000,
-	0xC258, 0x001f01fe, 0x00000000,
-	0xC25C, 0x001f01fe, 0x00000000,
-	/* DRAM CS Mask Address i Registers
-	 * F2:0x60 i = 0
-	 * F2:0x64 i = 1
-	 * F2:0x68 i = 2
-	 * F2:0x6C i = 3
-	 * F2:0x70 i = 4
-	 * F2:0x74 i = 5
-	 * F2:0x78 i = 6
-	 * F2:0x7C i = 7
-	 * Select bits to exclude from comparison with the DRAM Base address register.
-	 * [ 8: 0] Reserved
-	 * [15: 9] Address Mask (19-13)
-	 *         Address to be excluded from the optimized case
-	 * [20:16] Reserved
-	 * [29:21] Address Mask (33-25)
-	 *         The bits with an address mask of 1 are excluded from address comparison
-	 * [31:30] Reserved
-	 * 
-	 */
-#if MEMORY_1024MB
-	0xC260, 0xC01f01ff, 0x00e0fe00,
-	0xC264, 0xC01f01ff, 0x00e0fe00,
-	0xC268, 0xC01f01ff, 0x00e0fe00,
-	0xC26C, 0xC01f01ff, 0x00e0fe00,
-#endif
-#if MEMORY_512MB
-	0xC260, 0xC01f01ff, 0x0060fe00,
-	0xC264, 0xC01f01ff, 0x0060fe00,
-	0xC268, 0xC01f01ff, 0x0060fe00,
-	0xC26C, 0xC01f01ff, 0x0060fe00,
-#endif
-	0xC270, 0xC01f01ff, 0x00000000,
-	0xC274, 0xC01f01ff, 0x00000000,
-	0xC278, 0xC01f01ff, 0x00000000,
-	0xC27C, 0xC01f01ff, 0x00000000,
-	/* DRAM Bank Address Mapping Register
-	 * F2:0x80
-	 * Specify the memory module size
-	 * [ 2: 0] CS1/0 
-	 * [ 6: 4] CS3/2
-	 * [10: 8] CS5/4
-	 * [14:12] CS7/6
-	 *         000 = 32Mbyte  (Rows = 12 & Col =  8)
-	 *         001 = 64Mbyte  (Rows = 12 & Col =  9)
-	 *         010 = 128Mbyte (Rows = 13 & Col =  9)|(Rows = 12 & Col = 10)
-	 *         011 = 256Mbyte (Rows = 13 & Col = 10)|(Rows = 12 & Col = 11)
-	 *         100 = 512Mbyte (Rows = 13 & Col = 11)|(Rows = 14 & Col = 10)
-	 *         101 = 1Gbyte   (Rows = 14 & Col = 11)|(Rows = 13 & Col = 12)
-	 *         110 = 2Gbyte   (Rows = 14 & Col = 12)
-	 *         111 = reserved 
-	 * [ 3: 3] Reserved
-	 * [ 7: 7] Reserved
-	 * [11:11] Reserved
-	 * [31:15]
-	 */
-#if MEMORY_1024MB
-	0xC280, 0xffff8888, 0x00000033,
-#endif
-#if MEMORY_512MB
-	0xC280, 0xffff8888, 0x00000022,
-#endif
-	/* DRAM Timing Low Register
-	 * F2:0x88
-	 * [ 2: 0] Tcl (Cas# Latency, Cas# to read-data-valid)
-	 *         000 = reserved
-	 *         001 = CL 2
-	 *         010 = CL 3
-	 *         011 = reserved
-	 *         100 = reserved
-	 *         101 = CL 2.5
-	 *         110 = reserved
-	 *         111 = reserved
-	 * [ 3: 3] Reserved
-	 * [ 7: 4] Trc (Row Cycle Time, Ras#-active to Ras#-active/bank auto refresh)
-	 *         0000 =  7 bus clocks
-	 *         0001 =  8 bus clocks
-	 *         ...
-	 *         1110 = 21 bus clocks
-	 *         1111 = 22 bus clocks
-	 * [11: 8] Trfc (Row refresh Cycle time, Auto-refresh-active to RAS#-active or RAS#auto-refresh)
-	 *         0000 = 9 bus clocks
-	 *         0010 = 10 bus clocks
-	 *         ....
-	 *         1110 = 23 bus clocks
-	 *         1111 = 24 bus clocks
-	 * [14:12] Trcd (Ras#-active to Case#-read/write Delay)
-	 *         000 = reserved
-	 *         001 = reserved
-	 *         010 = 2 bus clocks
-	 *         011 = 3 bus clocks
-	 *         100 = 4 bus clocks
-	 *         101 = 5 bus clocks
-	 *         110 = 6 bus clocks
-	 *         111 = reserved
-	 * [15:15] Reserved
-	 * [18:16] Trrd (Ras# to Ras# Delay)
-	 *         000 = reserved
-	 *         001 = reserved
-	 *         010 = 2 bus clocks
-	 *         011 = 3 bus clocks
-	 *         100 = 4 bus clocks
-	 *         101 = reserved
-	 *         110 = reserved
-	 *         111 = reserved
-	 * [19:19] Reserved
-	 * [23:20] Tras (Minmum Ras# Active Time)
-	 *         0000 to 0100 = reserved
-	 *         0101 = 5 bus clocks
-	 *         ...
-	 *         1111 = 15 bus clocks
-	 * [26:24] Trp (Row Precharge Time)
-	 *         000 = reserved
-	 *         001 = reserved
-	 *         010 = 2 bus clocks
-	 *         011 = 3 bus clocks
-	 *         100 = 4 bus clocks
-	 *         101 = 5 bus clocks
-	 *         110 = 6 bus clocks
-	 *         111 = reserved
-	 * [27:27] Reserved
-	 * [28:28] Twr (Write Recovery Time)
-	 *         0 = 2 bus clocks
-	 *         1 = 3 bus clocks
-	 * [31:29] Reserved
-	 */
-	0xC288, 0xe8088008, 0x03623125,
-	/* DRAM Timing High Register
-	 * F2:0x8C
-	 * [ 0: 0] Twtr (Write to Read Delay)
-	 *         0 = 1 bus Clocks
-	 *         1 = 2 bus Clocks
-	 * [ 3: 1] Reserved
-	 * [ 6: 4] Trwf (Read to Write Delay)
-	 *         000 = 1 bus clocks
-	 *         001 = 2 bus clocks
-	 *         010 = 3 bus clocks
-	 *         011 = 4 bus clocks
-	 *         100 = 5 bus clocks
-	 *         101 = 6 bus clocks
-	 *         110 = reserved
-	 *         111 = reserved
-	 * [ 7: 7] Reserved
-	 * [12: 8] Tref (Refresh Rate)
-	 *         00000 = 100Mhz 4K rows
-	 *         00001 = 133Mhz 4K rows
-	 *         00010 = 166Mhz 4K rows
-	 *         01000 = 100Mhz 8K/16K rows
-	 *         01001 = 133Mhz 8K/16K rows
-	 *         01010 = 166Mhz 8K/16K rows
-	 * [19:13] Reserved
-	 * [22:20] Twcl (Write CAS Latency)
-	 *         000 = 1 Mem clock after CAS# (Unbuffered Dimms)
-	 *         001 = 2 Mem clocks after CAS# (Registered Dimms)
-	 * [31:23] Reserved
-	 */
-#if MEMORY_1024MB
-	0xC28c, 0xff8fe08e, 0x00000930,
-#endif
-#if MEMORY_512MB
-	0xC28c, 0xff8fe08e, 0x00000130,
-#endif
+	unsigned long htic;
 
-	/* DRAM Config Low Register
-	 * F2:0x90
-	 * [ 0: 0] DLL Disable
-	 *         0 = Enabled
-	 *         1 = Disabled
-	 * [ 1: 1] D_DRV
-	 *         0 = Normal Drive
-	 *         1 = Weak Drive
-	 * [ 2: 2] QFC_EN
-	 *         0 = Disabled
-	 *         1 = Enabled
-	 * [ 3: 3] Disable DQS Hystersis  (FIXME handle this one carefully)
-	 *         0 = Enable DQS input filter 
-	 *         1 = Disable DQS input filtering 
-	 * [ 7: 4] Reserved
-	 * [ 8: 8] DRAM_Init
-	 *         0 = Initialization done or not yet started.
-	 *         1 = Initiate DRAM intialization sequence
-	 * [ 9: 9] SO-Dimm Enable
-	 *         0 = Do nothing
-	 *         1 = SO-Dimms present
-	 * [10:10] DramEnable
-	 *         0 = DRAM not enabled
-	 *         1 = DRAM initialized and enabled
-	 * [11:11] Memory Clear Status
-	 *         0 = Memory Clear function has not completed
-	 *         1 = Memory Clear function has completed
-	 * [12:12] Exit Self-Refresh
-	 *         0 = Exit from self-refresh done or not yet started
-	 *         1 = DRAM exiting from self refresh
-	 * [13:13] Self-Refresh Status
-	 *         0 = Normal Operation
-	 *         1 = Self-refresh mode active
-	 * [15:14] Read/Write Queue Bypass Count
-	 *         00 = 2
-	 *         01 = 4
-	 *         10 = 8
-	 *         11 = 16
-	 * [16:16] 128-bit/64-Bit
-	 *         0 = 64bit Interface to DRAM
-	 *         1 = 128bit Interface to DRAM
-	 * [17:17] DIMM ECC Enable
-	 *         0 = Some DIMMs do not have ECC
-	 *         1 = ALL DIMMS have ECC bits
-	 * [18:18] UnBuffered DIMMs
-	 *         0 = Buffered DIMMS
-	 *         1 = Unbuffered DIMMS
-	 * [19:19] Enable 32-Byte Granularity
-	 *         0 = Optimize for 64byte bursts
-	 *         1 = Optimize for 32byte bursts
-	 * [20:20] DIMM 0 is x4
-	 * [21:21] DIMM 1 is x4
-	 * [22:22] DIMM 2 is x4
-	 * [23:23] DIMM 3 is x4
-	 *         0 = DIMM is not x4
-	 *         1 = x4 DIMM present
-	 * [24:24] Disable DRAM Receivers
-	 *         0 = Receivers enabled
-	 *         1 = Receivers disabled
-	 * [27:25] Bypass Max
-	 *         000 = Arbiters chois is always respected
-	 *         001 = Oldest entry in DCQ can be bypassed 1 time
-	 *         010 = Oldest entry in DCQ can be bypassed 2 times
-	 *         011 = Oldest entry in DCQ can be bypassed 3 times
-	 *         100 = Oldest entry in DCQ can be bypassed 4 times
-	 *         101 = Oldest entry in DCQ can be bypassed 5 times
-	 *         110 = Oldest entry in DCQ can be bypassed 6 times
-	 *         111 = Oldest entry in DCQ can be bypassed 7 times
-	 * [31:28] Reserved
-	 */
-	0xC290, 0xf0000000, 
-	(4 << 25)|(0 << 24)| 
-	(0 << 23)|(0 << 22)|(0 << 21)|(0 << 20)| 
-	(1 << 19)|(1 << 18)|(0 << 17)|(0 << 16)| 
-	(2 << 14)|(0 << 13)|(0 << 12)| 
-	(0 << 11)|(0 << 10)|(0 << 9)|(0 << 8)| 
-	(0 << 3) |(0 << 1) |(0 << 0),
-	/* DRAM Config High Register
-	 * F2:0x94
-	 * [ 0: 3] Maximum Asynchronous Latency
-	 *         0000 = 0 ns
-	 *         ...
-	 *         1111 = 15 ns
-	 * [ 7: 4] Reserved
-	 * [11: 8] Read Preamble
-	 *         0000 = 2.0 ns
-	 *         0001 = 2.5 ns
-	 *         0010 = 3.0 ns
-	 *         0011 = 3.5 ns
-	 *         0100 = 4.0 ns
-	 *         0101 = 4.5 ns
-	 *         0110 = 5.0 ns
-	 *         0111 = 5.5 ns
-	 *         1000 = 6.0 ns
-	 *         1001 = 6.5 ns
-	 *         1010 = 7.0 ns
-	 *         1011 = 7.5 ns
-	 *         1100 = 8.0 ns
-	 *         1101 = 8.5 ns
-	 *         1110 = 9.0 ns
-	 *         1111 = 9.5 ns
-	 * [15:12] Reserved
-	 * [18:16] Idle Cycle Limit
-	 *         000 = 0 cycles
-	 *         001 = 4 cycles
-	 *         010 = 8 cycles
-	 *         011 = 16 cycles
-	 *         100 = 32 cycles
-	 *         101 = 64 cycles
-	 *         110 = 128 cycles
-	 *         111 = 256 cycles
-	 * [19:19] Dynamic Idle Cycle Center Enable
-	 *         0 = Use Idle Cycle Limit
-	 *         1 = Generate a dynamic Idle cycle limit
-	 * [22:20] DRAM MEMCLK Frequency
-	 *         000 = 100Mhz
-	 *         001 = reserved
-	 *         010 = 133Mhz
-	 *         011 = reserved
-	 *         100 = reserved
-	 *         101 = 166Mhz
-	 *         110 = reserved
-	 *         111 = reserved
-	 * [24:23] Reserved
-	 * [25:25] Memory Clock Ratio Valid (FIXME carefully enable memclk)
-	 *         0 = Disable MemClks
-	 *         1 = Enable MemClks
-	 * [26:26] Memory Clock 0 Enable
-	 *         0 = Disabled
-	 *         1 = Enabled
-	 * [27:27] Memory Clock 1 Enable
-	 *         0 = Disabled
-	 *         1 = Enabled
-	 * [28:28] Memory Clock 2 Enable
-	 *         0 = Disabled
-	 *         1 = Enabled
-	 * [29:29] Memory Clock 3 Enable
-	 *         0 = Disabled
-	 *         1 = Enabled
-	 * [31:30] Reserved
-	 */
-#if MEMORY_1024MB
-	0xC294, 0xc180f0f0, 0x0e2b0a05,
-#endif
-#if MEMORY_512MB
-	0xC294, 0xc180f0f0, 0x0e2b0a06,
-#endif
-	/* DRAM Delay Line Register
-	 * F2:0x98
-	 * Adjust the skew of the input DQS strobe relative to DATA
-	 * [15: 0] Reserved
-	 * [23:16] Delay Line Adjust
-	 *         Adjusts the DLL derived PDL delay by one or more delay stages
-	 *         in either the faster or slower direction.
-	 * [24:24} Adjust Slower
-	 *         0 = Do Nothing
-	 *         1 = Adj is used to increase the PDL delay
-	 * [25:25] Adjust Faster
-	 *         0 = Do Nothing
-	 *         1 = Adj is used to decrease the PDL delay
-	 * [31:26] Reserved
-	 */
-	0xC298, 0xfc00ffff, 0x00000000,
-	/* DRAM Scrub Control Register
-	 * F3:0x58
-	 * [ 4: 0] DRAM Scrube Rate
-	 * [ 7: 5] reserved
-	 * [12: 8] L2 Scrub Rate
-	 * [15:13] reserved
-	 * [20:16] Dcache Scrub
-	 * [31:21] reserved
-	 *         Scrub Rates
-	 *         00000 = Do not scrub
-	 *         00001 =  40.00 ns
-	 *         00010 =  80.00 ns
-	 *         00011 = 160.00 ns
-	 *         00100 = 320.00 ns
-	 *         00101 = 640.00 ns
-	 *         00110 =   1.28 us
-	 *         00111 =   2.56 us
-	 *         01000 =   5.12 us
-	 *         01001 =  10.20 us
-	 *         01011 =  41.00 us
-	 *         01100 =  81.90 us
-	 *         01101 = 163.80 us
-	 *         01110 = 327.70 us
-	 *         01111 = 655.40 us
-	 *         10000 =   1.31 ms
-	 *         10001 =   2.62 ms
-	 *         10010 =   5.24 ms
-	 *         10011 =  10.49 ms
-	 *         10100 =  20.97 ms
-	 *         10101 =  42.00 ms
-	 *         10110 =  84.00 ms
-	 *         All Others = Reserved
-	 */
-	0xC358, 0xffe0e0e0, 0x00000000,
-	/* DRAM Scrub Address Low Register
-	 * F3:0x5C
-	 * [ 0: 0] DRAM Scrubber Redirect Enable
-	 *         0 = Do nothing
-	 *         1 = Scrubber Corrects errors found in normal operation
-	 * [ 5: 1] Reserved
-	 * [31: 6] DRAM Scrub Address 31-6
-	 */
-	0xC35C, 0x0000003e, 0x00000000,
-	/* DRAM Scrub Address High Register
-	 * F3:0x60
-	 * [ 7: 0] DRAM Scrubb Address 39-32
-	 * [31: 8] Reserved
-	 */
-	0xC360, 0xffffff00, 0x00000000,
-	};
-	int i;
-	int max;
-	print_debug("setting up northbridge registers\r\n");
-	max = sizeof(register_values)/sizeof(register_values[0]);
-	for(i = 0; i < max; i += 3) {
-		unsigned long reg;
+	htic = pci_read_config32(PCI_DEV(0, 0x18, 0), HT_INIT_CONTROL);
 #if 0
-		print_debug_hex32(register_values[i]);
-		print_debug(" <-");
-		print_debug_hex32(register_values[i+2]);
-		print_debug("\r\n");
+	print_debug("htic: ");
+	print_debug_hex32(htic);
+	print_debug("\r\n");
+
+	if (!(htic & HTIC_ColdR_Detect)) {
+		print_debug("Cold Reset.\r\n");
+	}
+	if ((htic & HTIC_ColdR_Detect) && !(htic & HTIC_BIOSR_Detect)) {
+		print_debug("BIOS generated Reset.\r\n");
+	}
+	if (htic & HTIC_INIT_Detect) {
+		print_debug("Init event.\r\n");
+	}
 #endif
-		reg = pcibios_read_config_dword(
-			0, register_values[i] >> 8, register_values[i] & 0xff);
-		reg &= register_values[i+1];
-		reg |= register_values[i+2] & ~register_values[i+1];
-		pcibios_write_config_dword(
-			0, register_values[i] >> 8, register_values[i] & 0xff, reg);
+	cpu_init = (htic & HTIC_INIT_Detect);
+	if (cpu_init) {
+		print_debug("CPU INIT Detected.\r\n");
 	}
-	print_debug("setting up northbridge registers done. hurray!\r\n");
+	return cpu_init;
 }
 
-#define PCI_DEVFN(slot,func)	((((slot) & 0x1f) << 3) | ((func) & 0x07))
-
-#define DRAM_CONFIG_LOW 0x90
-#define  DCL_DLL_Disable   (1<<0)
-#define  DCL_D_DRV         (1<<1)
-#define  DCL_QFC_EN        (1<<2)
-#define  DCL_DisDqsHys     (1<<3)
-#define  DCL_DramInit      (1<<8)
-#define  DCL_DramEnable    (1<<10)
-#define  DCL_MemClrStatus  (1<<11)
-#define  DCL_DimmEcEn      (1<<17)
 
-static void sdram_set_spd_registers(void) 
+static void print_debug_pci_dev(unsigned dev)
 {
-	unsigned long dcl;
-	dcl = pcibios_read_config_dword(0, PCI_DEVFN(0x18,2), DRAM_CONFIG_LOW);
-	/* Until I know what is going on disable ECC support */
-	dcl &= ~DCL_DimmEcEn;
-	pcibios_write_config_dword(0, PCI_DEVFN(0x18,2), DRAM_CONFIG_LOW, dcl);
+	print_debug("PCI: ");
+	print_debug_hex8((dev >> 16) & 0xff);
+	print_debug_char(':');
+	print_debug_hex8((dev >> 11) & 0x1f);
+	print_debug_char('.');
+	print_debug_hex8((dev >> 8) & 7);
 }
 
-#define TIMEOUT_LOOPS 300000
-static void sdram_enable(void)
+static void print_pci_devices(void)
 {
-	unsigned long dcl;
+	device_t dev;
+	for(dev = PCI_DEV(0, 0, 0); 
+		dev <= PCI_DEV(0, 0x1f, 0x7); 
+		dev += PCI_DEV(0,0,1)) {
+		uint32_t id;
+		id = pci_read_config32(dev, PCI_VENDOR_ID);
+		if (((id & 0xffff) == 0x0000) || ((id & 0xffff) == 0xffff) ||
+			(((id >> 16) & 0xffff) == 0xffff) ||
+			(((id >> 16) & 0xffff) == 0x0000)) {
+			continue;
+		}
+		print_debug_pci_dev(dev);
+		print_debug("\r\n");
+	}
+}
 
-	/* Toggle DisDqsHys to get it working */
-	dcl = pcibios_read_config_dword(0, PCI_DEVFN(0x18,2), DRAM_CONFIG_LOW);
-	print_debug("dcl: ");
-	print_debug_hex32(dcl);
+
+static void dump_pci_device(unsigned dev)
+{
+	int i;
+	print_debug_pci_dev(dev);
 	print_debug("\r\n");
-	dcl |= DCL_DisDqsHys;
-	pcibios_write_config_dword(0, PCI_DEVFN(0x18, 2), DRAM_CONFIG_LOW, dcl);
-	dcl &= ~DCL_DisDqsHys;
-	dcl &= ~DCL_DLL_Disable;
-	dcl &= ~DCL_D_DRV;
-	dcl &= ~DCL_QFC_EN;
-	dcl |= DCL_DramInit;
-	pcibios_write_config_dword(0, PCI_DEVFN(0x18, 2), DRAM_CONFIG_LOW, dcl);
 	
-	print_debug("Initializing memory: ");
-	int loops = 0;
-	do {
-		dcl = pcibios_read_config_dword(0, PCI_DEVFN(0x18, 2), DRAM_CONFIG_LOW);
-		loops += 1;
-		if ((loops & 1023) == 0) {
-			print_debug(" ");
-			print_debug_hex32(loops);
+	for(i = 0; i <= 255; i++) {
+		unsigned char val;
+		if ((i & 0x0f) == 0) {
+			print_debug_hex8(i);
+			print_debug_char(':');
 		}
-	} while(((dcl & DCL_DramInit) != 0) && (loops < TIMEOUT_LOOPS));
-	if (loops >= TIMEOUT_LOOPS) {
-		print_debug(" failed\r\n");
-	} else {
-		print_debug(" done\r\n");
-	}
-
-#if 0
-	print_debug("Clearing memory: ");
-	loops = 0;
-	do {
-		dcl = pcibios_read_config_dword(0, PCI_DEVFN(0x18, 2), DRAM_CONFIG_LOW);
-		loops += 1;
-		if ((loops & 1023) == 0) {
-			print_debug(" ");
-			print_debug_hex32(loops);
+		val = pci_read_config8(dev, i);
+		print_debug_char(' ');
+		print_debug_hex8(val);
+		if ((i & 0x0f) == 0x0f) {
+			print_debug("\r\n");
 		}
-	} while(((dcl & DCL_MemClrStatus) == 0) && (loops < TIMEOUT_LOOPS));
-	if (loops >= TIMEOUT_LOOPS) {
-		print_debug("failed\r\n");
-	} else {
-		print_debug("done\r\n");
 	}
-#endif
 }
 
-static void sdram_first_normal_reference(void) {}
-static void sdram_enable_refresh(void) {}
-static void sdram_special_finishup(void) {}
-
-static int sdram_enabled(void)
+static void dump_spd_registers(void)
 {
-	unsigned long dcl;
-	int enabled;
-	dcl = pcibios_read_config_dword(0, PCI_DEVFN(0x18, 2), DRAM_CONFIG_LOW);
-	enabled = !!(dcl & DCL_DramEnable);
-	if (enabled) {
-		print_debug("DRAM already enabled.");
+	unsigned device;
+	device = SMBUS_MEM_DEVICE_START;
+	print_debug("\r\n");
+	while(device <= SMBUS_MEM_DEVICE_END) {
+		int i;
+		print_debug("dimm: "); 
+		print_debug_hex8(device); 
+		for(i = 0; i < 256; i++) {
+			int status;
+			unsigned char byte;
+			if ((i & 0xf) == 0) {
+				print_debug("\r\n");
+				print_debug_hex8(i);
+				print_debug(": ");
+			}
+			status = smbus_read_byte(device, i);
+			if (status < 0) {
+				print_debug("bad device\r\n");
+				break;
+			}
+			byte = status & 0xff;
+			print_debug_hex8(byte);
+			print_debug_char(' ');
+		}
+		device += SMBUS_MEM_DEVICE_INC;
+		print_debug("\r\n");
 	}
-	return enabled;
 }
 
 
-#include "sdram/generic_sdram.c"
-
 static void main(void)
 {
 	uart_init();
 	console_init();
-	if (!sdram_enabled()) {
-		sdram_initialize();
 #if 0
-		ram_fill(  0x00100000, 0x00180000);
-		ram_verify(0x00100000, 0x00180000);
-#endif
-#if 1
-		ram_fill(  0x00000000, 0x00001000);
-		ram_verify(0x00000000, 0x00001000);
+	print_debug(" XIP_ROM_BASE: ");
+	print_debug_hex32(XIP_ROM_BASE);
+	print_debug(" XIP_ROM_SIZE: ");
+	print_debug_hex32(XIP_ROM_SIZE);
+	print_debug("\r\n");
 #endif
+	if (boot_cpu() && !cpu_init_detected()) {
+		setup_default_resource_map();
+		setup_coherent_ht_domain();
+		enumerate_ht_chain();
+		print_pci_devices();
+		enable_smbus();
+		sdram_initialize();
+
+		dump_spd_registers();
+		dump_pci_device(PCI_DEV(0, 0x18, 2));
+		
+		/* Check the first 512M */
+		msr_t msr;
+		msr = rdmsr(TOP_MEM);
+		print_debug("TOP_MEM: ");
+		print_debug_hex32(msr.hi);
+		print_debug_hex32(msr.lo);
+		print_debug("\r\n");
+		ram_check(0x00000000, msr.lo);
 	}
 }
diff --git a/targets/arima/hdama/Config.lb b/targets/arima/hdama/Config.lb
index 514597f..9f13e4b 100644
--- a/targets/arima/hdama/Config.lb
+++ b/targets/arima/hdama/Config.lb
@@ -1,188 +1,189 @@
 # Sample config file for Motorola Sandpoint X3 Demo Board with
 # the Arima HDAMA
 # This will make a target directory of ./hdama
 
 loadoptions
 
 target ./hdama
 
+uses AMD8111_DEV
 uses CONFIG_COMPRESS
 uses CONFIG_IOAPIC
 uses CONFIG_ROM_STREAM
 uses CONFIG_ROM_STREAM_START
 uses CONFIG_UDELAY_TSC
 uses CPU_FIXUP
 uses ENABLE_FIXED_AND_VARIABLE_MTRRS
 uses FALLBACK_SIZE
 uses FINAL_MAINBOARD_FIXUP
 uses HAVE_FALLBACK_BOOT
 uses HAVE_MP_TABLE
 uses HAVE_PIRQ_TABLE
 uses i686
 uses INTEL_PPRO_MTRR
 uses HEAP_SIZE
 uses IRQ_SLOT_COUNT
 uses k7
 uses MAINBOARD_PART_NUMBER
 uses MAINBOARD_VENDOR
 uses MAX_CPUS
 uses MEMORY_HOLE
 uses PAYLOAD_SIZE
 uses _RAMBASE
 uses _ROMBASE
 uses ROM_IMAGE_SIZE
 uses ROM_SECTION_OFFSET
 uses ROM_SECTION_SIZE
 uses ROM_SIZE
 uses SIO_BASE
 uses SIO_SYSTEM_CLK_INPUT
 uses STACK_SIZE
 uses USE_ELF_BOOT
 uses USE_FALLBACK_IMAGE
 uses USE_OPTION_TABLE
 
 option HAVE_MP_TABLE=0
 option CPU_FIXUP=1
 option CONFIG_UDELAY_TSC=0
 option i686=1
 option INTEL_PPRO_MTRR=1
 option k7=1
 
 
 ### Customize our winbond superio chip for this motherboard
 ###
 option SIO_BASE=0x2e
 option SIO_SYSTEM_CLK_INPUT=0
 #
 ###
 ### Build code for the fallback boot
 ###
 option HAVE_FALLBACK_BOOT=1
 #
 ###
 ### Build code to export a programmable irq routing table
 ###
 option HAVE_PIRQ_TABLE=1
 option IRQ_SLOT_COUNT=7
 #
 ###
 ### Build code for SMP support
 ### Only worry about 2 micro processors
 ###
 ##option CONFIG_SMP=1
 option MAX_CPUS=1
 #
 ###
 ### Build code to setup a generic IOAPIC
 ###
 option CONFIG_IOAPIC=1
 #
 ###
 ### MEMORY_HOLE instructs earlymtrr.inc to
 ### enable caching from 0-640KB and to disable 
 ### caching from 640KB-1MB using fixed MTRRs 
 ###
 ### Enabling this option breaks SMP because secondary
 ### CPU identification depends on only variable MTRRs
 ### being enabled.
 ###
 option MEMORY_HOLE=0
 #
 ###
 ### Enable both fixed and variable MTRRS
 ### When we setup MTRRs in mtrr.c  
 ###
 ### We must setup the fixed mtrrs or we confuse SMP secondary
 ### processor identification
 ###
 option ENABLE_FIXED_AND_VARIABLE_MTRRS=1
 #
 ###
 ### Clean up the motherboard id strings
 ###
 #option MAINBOARD_PART_NUMBER="Solo7"
 #option MAINBOARD_VENDOR="AMD"
 #
 ###
 ### Call the final_mainboard_fixup function
 ###
 option FINAL_MAINBOARD_FIXUP=1
 option USE_FALLBACK_IMAGE=0
 
 ###
 ### Only use the option table in a normal image
 ###
 option USE_OPTION_TABLE=!USE_FALLBACK_IMAGE
 #
 ###
 ### Compute the location and size of where this firmware image
 ### (linuxBIOS plus bootloader) will live in the boot rom chip.
 ###
 #if USE_FALLBACK_IMAGE 
 #  option ROM_SECTION_SIZE  = FALLBACK_SIZE
 #  option ROM_SECTION_OFFSET= (ROM_SIZE - FALLBACK_SIZE)
 #end
 #if USE_NORMAL_IMAGE
 #  option ROM_SECTION_SIZE  = (ROM_SIZE - FALLBACK_SIZE)
 #  option ROM_SECTION_OFFSET= 0
 #end
 ###
 ### Compute where this copy of linuxBIOS will start in the boot rom
 ###
 #
 ###
 ### Compute a range of ROM that can cached to speed up linuxBIOS,
 ### execution speed.
 ###
 ##expr XIP_ROM_SIZE = 65536
 ##expr XIP_ROM_BASE = _ROMBASE + ROM_IMAGE_SIZE - XIP_ROM_SIZE
 ##option XIP_ROM_SIZE=65536
 ##option XIP_ROM_BASE=0xffff0000
 #
 ## XIP_ROM_SIZE && XIP_ROM_BASE values that work.
 ##option XIP_ROM_SIZE=0x8000
 ##option XIP_ROM_BASE=0xffff8000
 
 ## We don't use compressed image
 option CONFIG_COMPRESS=0
 
 option USE_ELF_BOOT=1
 
 option ROM_SIZE=524288
 
 ## ROM_IMAGE_SIZE is the amount of space to allow linuxBIOS to occupy.
 option ROM_IMAGE_SIZE=49152
 
 ## LinuxBIOS C code runs at this location in RAM
 option _RAMBASE=0x00100000
 
 ##
 ## Use a 64K stack
 ##
 option STACK_SIZE=0x10000
 
 ##
 ## Use a 64K heap
 ##
 option HEAP_SIZE=0x10000
 
 ## Compute the location and size of where this firmware image
 ## (linuxBIOS plus bootloader) will live in the boot rom chip.
 ##       
 option ROM_SECTION_SIZE=ROM_SIZE
 option ROM_SECTION_OFFSET=0
 
 #
 ###
 ### Compute the start location and size size of
 ### The linuxBIOS bootloader.
 ###
 option PAYLOAD_SIZE            = (ROM_SECTION_SIZE - ROM_IMAGE_SIZE)
 option CONFIG_ROM_STREAM_START = (0xffffffff - ROM_SIZE + ROM_SECTION_OFFSET + 1)
 option CONFIG_ROM_STREAM     = 1
 option _ROMBASE      = (CONFIG_ROM_STREAM_START + PAYLOAD_SIZE)
 #
 # Arima hdama
 mainboard arima/hdama
 	makedefine CFLAGS += -g
 end
