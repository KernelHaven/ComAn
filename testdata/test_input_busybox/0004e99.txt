2010-09-01 12:01:17 +0200
diff --git a/include/libbb.h b/include/libbb.h
index 6fb0438..4b69c85 100644
--- a/include/libbb.h
+++ b/include/libbb.h
@@ -1,1798 +1,1813 @@
 /* vi: set sw=4 ts=4: */
 /*
  * Busybox main internal header file
  *
  * Based in part on code from sash, Copyright (c) 1999 by David I. Bell
  * Permission has been granted to redistribute this code under GPL.
  *
  * Licensed under GPLv2, see file LICENSE in this source tree.
  */
 #ifndef LIBBB_H
 #define LIBBB_H 1
 
 #include "platform.h"
 
 #include <ctype.h>
 #include <dirent.h>
 #include <errno.h>
 #include <fcntl.h>
 #include <inttypes.h>
 #include <netdb.h>
 #include <setjmp.h>
 #include <signal.h>
 #include <stdint.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <stdarg.h>
 #include <stddef.h>
 #include <string.h>
 #include <sys/poll.h>
 #include <sys/ioctl.h>
 #include <sys/mman.h>
 #include <sys/socket.h>
 #include <sys/stat.h>
 #include <sys/time.h>
 #include <sys/types.h>
 #include <sys/wait.h>
 #include <termios.h>
 #include <time.h>
 #include <unistd.h>
 /* Try to pull in PATH_MAX */
 #include <limits.h>
 #include <sys/param.h>
 #ifdef HAVE_MNTENT_H
 # include <mntent.h>
 #endif
 #ifdef HAVE_SYS_STATFS_H
 # include <sys/statfs.h>
 #endif
 #if ENABLE_SELINUX
 # include <selinux/selinux.h>
 # include <selinux/context.h>
 # include <selinux/flask.h>
 # include <selinux/av_permissions.h>
 #endif
 #if ENABLE_LOCALE_SUPPORT
 # include <locale.h>
 #else
 # define setlocale(x,y) ((void)0)
 #endif
 #ifdef DMALLOC
 # include <dmalloc.h>
 #endif
 #include <pwd.h>
 #include <grp.h>
 #if ENABLE_FEATURE_SHADOWPASSWDS
 # if !ENABLE_USE_BB_SHADOW
 /* If using busybox's shadow implementation, do not include the shadow.h
  * header as the toolchain may not provide it at all.
  */
 #  include <shadow.h>
 # endif
 #endif
 #if defined __FreeBSD__ || defined __OpenBSD__
 # include <netinet/in.h>
 # include <arpa/inet.h>
 #elif defined __APPLE__
 # include <netinet/in.h>
 #else
 # include <arpa/inet.h>
 # if !defined(__socklen_t_defined) && !defined(_SOCKLEN_T_DECLARED)
 /* We #define socklen_t *after* includes, otherwise we get
  * typedef redefinition errors from system headers
  * (in case "is it defined already" detection above failed)
  */
 #  define socklen_t bb_socklen_t
    typedef unsigned socklen_t;
 # endif
 #endif
 
 
 /* Some libc's forget to declare these, do it ourself */
 
 extern char **environ;
 #if defined(__GLIBC__) && __GLIBC__ < 2
 int vdprintf(int d, const char *format, va_list ap);
 #endif
 /* klogctl is in libc's klog.h, but we cheat and not #include that */
 int klogctl(int type, char *b, int len);
 /* This is declared here rather than #including <libgen.h> in order to avoid
  * confusing the two versions of basename.  See the dirname/basename man page
  * for details. */
 #if !defined __FreeBSD__
 char *dirname(char *path);
 #endif
 /* Include our own copy of struct sysinfo to avoid binary compatibility
  * problems with Linux 2.4, which changed things.  Grumble, grumble. */
 struct sysinfo {
 	long uptime;			/* Seconds since boot */
 	unsigned long loads[3];		/* 1, 5, and 15 minute load averages */
 	unsigned long totalram;		/* Total usable main memory size */
 	unsigned long freeram;		/* Available memory size */
 	unsigned long sharedram;	/* Amount of shared memory */
 	unsigned long bufferram;	/* Memory used by buffers */
 	unsigned long totalswap;	/* Total swap space size */
 	unsigned long freeswap;		/* swap space still available */
 	unsigned short procs;		/* Number of current processes */
 	unsigned short pad;			/* Padding needed for m68k */
 	unsigned long totalhigh;	/* Total high memory size */
 	unsigned long freehigh;		/* Available high memory size */
 	unsigned int mem_unit;		/* Memory unit size in bytes */
 	char _f[20 - 2 * sizeof(long) - sizeof(int)]; /* Padding: libc5 uses this.. */
 };
 int sysinfo(struct sysinfo* info);
 #ifndef PATH_MAX
 # define PATH_MAX 256
 #endif
 #ifndef BUFSIZ
 # define BUFSIZ 4096
 #endif
 
 
 /* Make all declarations hidden (-fvisibility flag only affects definitions) */
 /* (don't include system headers after this until corresponding pop!) */
 PUSH_AND_SET_FUNCTION_VISIBILITY_TO_HIDDEN
 
 
 #if ENABLE_USE_BB_PWD_GRP
 # include "pwd_.h"
 # include "grp_.h"
 #endif
 #if ENABLE_FEATURE_SHADOWPASSWDS
 # if ENABLE_USE_BB_SHADOW
 #  include "shadow_.h"
 # endif
 #endif
 
 /* Tested to work correctly with all int types (IIRC :]) */
 #define MAXINT(T) (T)( \
 	((T)-1) > 0 \
 	? (T)-1 \
 	: (T)~((T)1 << (sizeof(T)*8-1)) \
 	)
 
 #define MININT(T) (T)( \
 	((T)-1) > 0 \
 	? (T)0 \
 	: ((T)1 << (sizeof(T)*8-1)) \
 	)
 
 /* Large file support */
 /* Note that CONFIG_LFS=y forces bbox to be built with all common ops
  * (stat, lseek etc) mapped to "largefile" variants by libc.
  * Practically it means that open() automatically has O_LARGEFILE added
  * and all filesize/file_offset parameters and struct members are "large"
  * (in today's world - signed 64bit). For full support of large files,
  * we need a few helper #defines (below) and careful use of off_t
  * instead of int/ssize_t. No lseek64(), O_LARGEFILE etc necessary */
 #if ENABLE_LFS
 /* CONFIG_LFS is on */
 # if ULONG_MAX > 0xffffffff
 /* "long" is long enough on this system */
 typedef unsigned long uoff_t;
 #  define XATOOFF(a) xatoul_range(a, 0, LONG_MAX)
 /* usage: sz = BB_STRTOOFF(s, NULL, 10); if (errno || sz < 0) die(); */
 #  define BB_STRTOOFF bb_strtoul
 #  define STRTOOFF strtoul
 /* usage: printf("size: %"OFF_FMT"d (%"OFF_FMT"x)\n", sz, sz); */
 #  define OFF_FMT "l"
 # else
 /* "long" is too short, need "long long" */
 typedef unsigned long long uoff_t;
 #  define XATOOFF(a) xatoull_range(a, 0, LLONG_MAX)
 #  define BB_STRTOOFF bb_strtoull
 #  define STRTOOFF strtoull
 #  define OFF_FMT "ll"
 # endif
 #else
 /* CONFIG_LFS is off */
 # if UINT_MAX == 0xffffffff
 /* While sizeof(off_t) == sizeof(int), off_t is typedef'ed to long anyway.
  * gcc will throw warnings on printf("%d", off_t). Crap... */
 typedef unsigned long uoff_t;
 #  define XATOOFF(a) xatoi_positive(a)
 #  define BB_STRTOOFF bb_strtou
 #  define STRTOOFF strtol
 #  define OFF_FMT "l"
 # else
 typedef unsigned long uoff_t;
 #  define XATOOFF(a) xatoul_range(a, 0, LONG_MAX)
 #  define BB_STRTOOFF bb_strtoul
 #  define STRTOOFF strtol
 #  define OFF_FMT "l"
 # endif
 #endif
 /* scary. better ideas? (but do *test* them first!) */
 #define OFF_T_MAX  ((off_t)~((off_t)1 << (sizeof(off_t)*8-1)))
 
 /* Some useful definitions */
 #undef FALSE
 #define FALSE   ((int) 0)
 #undef TRUE
 #define TRUE    ((int) 1)
 #undef SKIP
 #define SKIP	((int) 2)
 
 /* for mtab.c */
 #define MTAB_GETMOUNTPT '1'
 #define MTAB_GETDEVICE  '2'
 
 #define BUF_SIZE        8192
 #define EXPAND_ALLOC    1024
 
 /* Macros for min/max.  */
 #ifndef MIN
 #define	MIN(a,b) (((a)<(b))?(a):(b))
 #endif
 
 #ifndef MAX
 #define	MAX(a,b) (((a)>(b))?(a):(b))
 #endif
 
 /* buffer allocation schemes */
 #if ENABLE_FEATURE_BUFFERS_GO_ON_STACK
 #define RESERVE_CONFIG_BUFFER(buffer,len)  char buffer[len]
 #define RESERVE_CONFIG_UBUFFER(buffer,len) unsigned char buffer[len]
 #define RELEASE_CONFIG_BUFFER(buffer)      ((void)0)
 #else
 #if ENABLE_FEATURE_BUFFERS_GO_IN_BSS
 #define RESERVE_CONFIG_BUFFER(buffer,len)  static          char buffer[len]
 #define RESERVE_CONFIG_UBUFFER(buffer,len) static unsigned char buffer[len]
 #define RELEASE_CONFIG_BUFFER(buffer)      ((void)0)
 #else
 #define RESERVE_CONFIG_BUFFER(buffer,len)  char *buffer = xmalloc(len)
 #define RESERVE_CONFIG_UBUFFER(buffer,len) unsigned char *buffer = xmalloc(len)
 #define RELEASE_CONFIG_BUFFER(buffer)      free(buffer)
 #endif
 #endif
 
 #if defined(__GLIBC__)
 /* glibc uses __errno_location() to get a ptr to errno */
 /* We can just memorize it once - no multithreading in busybox :) */
 extern int *const bb_errno;
 #undef errno
 #define errno (*bb_errno)
 #endif
 
 unsigned long long monotonic_ns(void) FAST_FUNC;
 unsigned long long monotonic_us(void) FAST_FUNC;
 unsigned long long monotonic_ms(void) FAST_FUNC;
 unsigned monotonic_sec(void) FAST_FUNC;
 
 extern void chomp(char *s) FAST_FUNC;
 extern void trim(char *s) FAST_FUNC;
 extern char *skip_whitespace(const char *) FAST_FUNC;
 extern char *skip_non_whitespace(const char *) FAST_FUNC;
 extern char *skip_dev_pfx(const char *tty_name) FAST_FUNC;
 
 extern char *strrstr(const char *haystack, const char *needle) FAST_FUNC;
 
 //TODO: supply a pointer to char[11] buffer (avoid statics)?
 extern const char *bb_mode_string(mode_t mode) FAST_FUNC;
 extern int is_directory(const char *name, int followLinks, struct stat *statBuf) FAST_FUNC;
 enum {	/* DO NOT CHANGE THESE VALUES!  cp.c, mv.c, install.c depend on them. */
 	FILEUTILS_PRESERVE_STATUS = 1 << 0, /* -p */
 	FILEUTILS_DEREFERENCE     = 1 << 1, /* !-d */
 	FILEUTILS_RECUR           = 1 << 2, /* -R */
 	FILEUTILS_FORCE           = 1 << 3, /* -f */
 	FILEUTILS_INTERACTIVE     = 1 << 4, /* -i */
 	FILEUTILS_MAKE_HARDLINK   = 1 << 5, /* -l */
 	FILEUTILS_MAKE_SOFTLINK   = 1 << 6, /* -s */
 	FILEUTILS_DEREF_SOFTLINK  = 1 << 7, /* -L */
 	FILEUTILS_DEREFERENCE_L0  = 1 << 8, /* -H */
 #if ENABLE_SELINUX
 	FILEUTILS_PRESERVE_SECURITY_CONTEXT = 1 << 9, /* -c */
 	FILEUTILS_SET_SECURITY_CONTEXT = 1 << 10,
 #endif
 };
 #define FILEUTILS_CP_OPTSTR "pdRfilsLH" IF_SELINUX("c")
 extern int remove_file(const char *path, int flags) FAST_FUNC;
 /* NB: without FILEUTILS_RECUR in flags, it will basically "cat"
  * the source, not copy (unless "source" is a directory).
  * This makes "cp /dev/null file" and "install /dev/null file" (!!!)
  * work coreutils-compatibly. */
 extern int copy_file(const char *source, const char *dest, int flags) FAST_FUNC;
 
 enum {
 	ACTION_RECURSE        = (1 << 0),
 	ACTION_FOLLOWLINKS    = (1 << 1),
 	ACTION_FOLLOWLINKS_L0 = (1 << 2),
 	ACTION_DEPTHFIRST     = (1 << 3),
 	/*ACTION_REVERSE      = (1 << 4), - unused */
 	ACTION_QUIET          = (1 << 5),
 	ACTION_DANGLING_OK    = (1 << 6),
 };
 typedef uint8_t recurse_flags_t;
 extern int recursive_action(const char *fileName, unsigned flags,
 	int FAST_FUNC (*fileAction)(const char *fileName, struct stat* statbuf, void* userData, int depth),
 	int FAST_FUNC (*dirAction)(const char *fileName, struct stat* statbuf, void* userData, int depth),
 	void* userData, unsigned depth) FAST_FUNC;
 extern int device_open(const char *device, int mode) FAST_FUNC;
 enum { GETPTY_BUFSIZE = 16 }; /* more than enough for "/dev/ttyXXX" */
 extern int xgetpty(char *line) FAST_FUNC;
 extern int get_console_fd_or_die(void) FAST_FUNC;
 extern void console_make_active(int fd, const int vt_num) FAST_FUNC;
 extern char *find_block_device(const char *path) FAST_FUNC;
 /* bb_copyfd_XX print read/write errors and return -1 if they occur */
 extern off_t bb_copyfd_eof(int fd1, int fd2) FAST_FUNC;
 extern off_t bb_copyfd_size(int fd1, int fd2, off_t size) FAST_FUNC;
 extern void bb_copyfd_exact_size(int fd1, int fd2, off_t size) FAST_FUNC;
 /* "short" copy can be detected by return value < size */
 /* this helper yells "short read!" if param is not -1 */
 extern void complain_copyfd_and_die(off_t sz) NORETURN FAST_FUNC;
 extern char bb_process_escape_sequence(const char **ptr) FAST_FUNC;
 /* xxxx_strip version can modify its parameter:
  * "/"        -> "/"
  * "abc"      -> "abc"
  * "abc/def"  -> "def"
  * "abc/def/" -> "def" !!
  */
 extern char *bb_get_last_path_component_strip(char *path) FAST_FUNC;
 /* "abc/def/" -> "" and it never modifies 'path' */
 extern char *bb_get_last_path_component_nostrip(const char *path) FAST_FUNC;
 
 int ndelay_on(int fd) FAST_FUNC;
 int ndelay_off(int fd) FAST_FUNC;
 int close_on_exec_on(int fd) FAST_FUNC;
 void xdup2(int, int) FAST_FUNC;
 void xmove_fd(int, int) FAST_FUNC;
 
 
 DIR *xopendir(const char *path) FAST_FUNC;
 DIR *warn_opendir(const char *path) FAST_FUNC;
 
 char *xmalloc_realpath(const char *path) FAST_FUNC RETURNS_MALLOC;
 char *xmalloc_readlink(const char *path) FAST_FUNC RETURNS_MALLOC;
 char *xmalloc_readlink_or_warn(const char *path) FAST_FUNC RETURNS_MALLOC;
 /* !RETURNS_MALLOC: it's a realloc-like function */
 char *xrealloc_getcwd_or_warn(char *cwd) FAST_FUNC;
 
 char *xmalloc_follow_symlinks(const char *path) FAST_FUNC RETURNS_MALLOC;
 
 
 enum {
 	/* bb_signals(BB_FATAL_SIGS, handler) catches all signals which
 	 * otherwise would kill us, except for those resulting from bugs:
 	 * SIGSEGV, SIGILL, SIGFPE.
 	 * Other fatal signals not included (TODO?):
 	 * SIGBUS   Bus error (bad memory access)
 	 * SIGPOLL  Pollable event. Synonym of SIGIO
 	 * SIGPROF  Profiling timer expired
 	 * SIGSYS   Bad argument to routine
 	 * SIGTRAP  Trace/breakpoint trap
 	 *
 	 * The only known arch with some of these sigs not fitting
 	 * into 32 bits is parisc (SIGXCPU=33, SIGXFSZ=34, SIGSTKFLT=36).
 	 * Dance around with long long to guard against that...
 	 */
 	BB_FATAL_SIGS = (int)(0
 		+ (1LL << SIGHUP)
 		+ (1LL << SIGINT)
 		+ (1LL << SIGTERM)
 		+ (1LL << SIGPIPE)   // Write to pipe with no readers
 		+ (1LL << SIGQUIT)   // Quit from keyboard
 		+ (1LL << SIGABRT)   // Abort signal from abort(3)
 		+ (1LL << SIGALRM)   // Timer signal from alarm(2)
 		+ (1LL << SIGVTALRM) // Virtual alarm clock
 		+ (1LL << SIGXCPU)   // CPU time limit exceeded
 		+ (1LL << SIGXFSZ)   // File size limit exceeded
 		+ (1LL << SIGUSR1)   // Yes kids, these are also fatal!
 		+ (1LL << SIGUSR2)
 		+ 0),
 };
 void bb_signals(int sigs, void (*f)(int)) FAST_FUNC;
 /* Unlike signal() and bb_signals, sets handler with sigaction()
  * and in a way that while signal handler is run, no other signals
  * will be blocked; syscalls will not be restarted: */
 void bb_signals_recursive_norestart(int sigs, void (*f)(int)) FAST_FUNC;
 /* syscalls like read() will be interrupted with EINTR: */
 void signal_no_SA_RESTART_empty_mask(int sig, void (*handler)(int)) FAST_FUNC;
 /* syscalls like read() won't be interrupted (though select/poll will be): */
 void signal_SA_RESTART_empty_mask(int sig, void (*handler)(int)) FAST_FUNC;
 void wait_for_any_sig(void) FAST_FUNC;
 void kill_myself_with_sig(int sig) NORETURN FAST_FUNC;
 void sig_block(int sig) FAST_FUNC;
 void sig_unblock(int sig) FAST_FUNC;
 /* Will do sigaction(signum, act, NULL): */
 int sigaction_set(int sig, const struct sigaction *act) FAST_FUNC;
 /* SIG_BLOCK/SIG_UNBLOCK all signals: */
 int sigprocmask_allsigs(int how) FAST_FUNC;
 /* Standard handler which just records signo */
 extern smallint bb_got_signal;
 void record_signo(int signo); /* not FAST_FUNC! */
 
 
 void xsetgid(gid_t gid) FAST_FUNC;
 void xsetuid(uid_t uid) FAST_FUNC;
 void xchdir(const char *path) FAST_FUNC;
 void xchroot(const char *path) FAST_FUNC;
 void xsetenv(const char *key, const char *value) FAST_FUNC;
 void bb_unsetenv(const char *key) FAST_FUNC;
 void bb_unsetenv_and_free(char *key) FAST_FUNC;
 void xunlink(const char *pathname) FAST_FUNC;
 void xstat(const char *pathname, struct stat *buf) FAST_FUNC;
 void xfstat(int fd, struct stat *buf, const char *errmsg) FAST_FUNC;
 int xopen(const char *pathname, int flags) FAST_FUNC;
 int xopen_nonblocking(const char *pathname) FAST_FUNC;
 int xopen3(const char *pathname, int flags, int mode) FAST_FUNC;
 int open_or_warn(const char *pathname, int flags) FAST_FUNC;
 int open3_or_warn(const char *pathname, int flags, int mode) FAST_FUNC;
 int open_or_warn_stdin(const char *pathname) FAST_FUNC;
 int xopen_stdin(const char *pathname) FAST_FUNC;
 void xrename(const char *oldpath, const char *newpath) FAST_FUNC;
 int rename_or_warn(const char *oldpath, const char *newpath) FAST_FUNC;
 off_t xlseek(int fd, off_t offset, int whence) FAST_FUNC;
 off_t fdlength(int fd) FAST_FUNC;
 
 uoff_t FAST_FUNC get_volume_size_in_bytes(int fd,
                 const char *override,
                 unsigned override_units,
                 int extend);
 
 void xpipe(int filedes[2]) FAST_FUNC;
 /* In this form code with pipes is much more readable */
 struct fd_pair { int rd; int wr; };
 #define piped_pair(pair)  pipe(&((pair).rd))
 #define xpiped_pair(pair) xpipe(&((pair).rd))
 
 /* Useful for having small structure members/global variables */
 typedef int8_t socktype_t;
 typedef int8_t family_t;
 struct BUG_too_small {
 	char BUG_socktype_t_too_small[(0
 			| SOCK_STREAM
 			| SOCK_DGRAM
 			| SOCK_RDM
 			| SOCK_SEQPACKET
 			| SOCK_RAW
 			) <= 127 ? 1 : -1];
 	char BUG_family_t_too_small[(0
 			| AF_UNSPEC
 			| AF_INET
 			| AF_INET6
 			| AF_UNIX
 #ifdef AF_PACKET
 			| AF_PACKET
 #endif
 #ifdef AF_NETLINK
 			| AF_NETLINK
 #endif
 			/* | AF_DECnet */
 			/* | AF_IPX */
 			) <= 127 ? 1 : -1];
 };
 
 
 void parse_datestr(const char *date_str, struct tm *ptm) FAST_FUNC;
 time_t validate_tm_time(const char *date_str, struct tm *ptm) FAST_FUNC;
 
 
 int xsocket(int domain, int type, int protocol) FAST_FUNC;
 void xbind(int sockfd, struct sockaddr *my_addr, socklen_t addrlen) FAST_FUNC;
 void xlisten(int s, int backlog) FAST_FUNC;
 void xconnect(int s, const struct sockaddr *s_addr, socklen_t addrlen) FAST_FUNC;
 ssize_t xsendto(int s, const void *buf, size_t len, const struct sockaddr *to,
 				socklen_t tolen) FAST_FUNC;
 /* SO_REUSEADDR allows a server to rebind to an address that is already
  * "in use" by old connections to e.g. previous server instance which is
  * killed or crashed. Without it bind will fail until all such connections
  * time out. Linux does not allow multiple live binds on same ip:port
  * regardless of SO_REUSEADDR (unlike some other flavors of Unix).
  * Turn it on before you call bind(). */
 void setsockopt_reuseaddr(int fd) FAST_FUNC; /* On Linux this never fails. */
 int setsockopt_broadcast(int fd) FAST_FUNC;
 int setsockopt_bindtodevice(int fd, const char *iface) FAST_FUNC;
 /* NB: returns port in host byte order */
 unsigned bb_lookup_port(const char *port, const char *protocol, unsigned default_port) FAST_FUNC;
 typedef struct len_and_sockaddr {
 	socklen_t len;
 	union {
 		struct sockaddr sa;
 		struct sockaddr_in sin;
 #if ENABLE_FEATURE_IPV6
 		struct sockaddr_in6 sin6;
 #endif
 	} u;
 } len_and_sockaddr;
 enum {
 	LSA_LEN_SIZE = offsetof(len_and_sockaddr, u),
 	LSA_SIZEOF_SA = sizeof(
 		union {
 			struct sockaddr sa;
 			struct sockaddr_in sin;
 #if ENABLE_FEATURE_IPV6
 			struct sockaddr_in6 sin6;
 #endif
 		}
 	)
 };
 /* Create stream socket, and allocate suitable lsa.
  * (lsa of correct size and lsa->sa.sa_family (AF_INET/AF_INET6))
  * af == AF_UNSPEC will result in trying to create IPv6 socket,
  * and if kernel doesn't support it, fall back to IPv4.
  * This is useful if you plan to bind to resulting local lsa.
  */
 #if ENABLE_FEATURE_IPV6
 int xsocket_type(len_and_sockaddr **lsap, int af, int sock_type) FAST_FUNC;
 #else
 int xsocket_type(len_and_sockaddr **lsap, int sock_type) FAST_FUNC;
 #define xsocket_type(lsap, af, sock_type) xsocket_type((lsap), (sock_type))
 #endif
 int xsocket_stream(len_and_sockaddr **lsap) FAST_FUNC;
 /* Create server socket bound to bindaddr:port. bindaddr can be NULL,
  * numeric IP ("N.N.N.N") or numeric IPv6 address,
  * and can have ":PORT" suffix (for IPv6 use "[X:X:...:X]:PORT").
  * Only if there is no suffix, port argument is used */
 /* NB: these set SO_REUSEADDR before bind */
 int create_and_bind_stream_or_die(const char *bindaddr, int port) FAST_FUNC;
 int create_and_bind_dgram_or_die(const char *bindaddr, int port) FAST_FUNC;
 /* Create client TCP socket connected to peer:port. Peer cannot be NULL.
  * Peer can be numeric IP ("N.N.N.N"), numeric IPv6 address or hostname,
  * and can have ":PORT" suffix (for IPv6 use "[X:X:...:X]:PORT").
  * If there is no suffix, port argument is used */
 int create_and_connect_stream_or_die(const char *peer, int port) FAST_FUNC;
 /* Connect to peer identified by lsa */
 int xconnect_stream(const len_and_sockaddr *lsa) FAST_FUNC;
 /* Get local address of bound or accepted socket */
 len_and_sockaddr *get_sock_lsa(int fd) FAST_FUNC RETURNS_MALLOC;
 /* Get remote address of connected or accepted socket */
 len_and_sockaddr *get_peer_lsa(int fd) FAST_FUNC RETURNS_MALLOC;
 /* Return malloc'ed len_and_sockaddr with socket address of host:port
  * Currently will return IPv4 or IPv6 sockaddrs only
  * (depending on host), but in theory nothing prevents e.g.
  * UNIX socket address being returned, IPX sockaddr etc...
  * On error does bb_error_msg and returns NULL */
 len_and_sockaddr* host2sockaddr(const char *host, int port) FAST_FUNC RETURNS_MALLOC;
 /* Version which dies on error */
 len_and_sockaddr* xhost2sockaddr(const char *host, int port) FAST_FUNC RETURNS_MALLOC;
 len_and_sockaddr* xdotted2sockaddr(const char *host, int port) FAST_FUNC RETURNS_MALLOC;
 /* Same, useful if you want to force family (e.g. IPv6) */
 #if !ENABLE_FEATURE_IPV6
 #define host_and_af2sockaddr(host, port, af) host2sockaddr((host), (port))
 #define xhost_and_af2sockaddr(host, port, af) xhost2sockaddr((host), (port))
 #else
 len_and_sockaddr* host_and_af2sockaddr(const char *host, int port, sa_family_t af) FAST_FUNC RETURNS_MALLOC;
 len_and_sockaddr* xhost_and_af2sockaddr(const char *host, int port, sa_family_t af) FAST_FUNC RETURNS_MALLOC;
 #endif
 /* Assign sin[6]_port member if the socket is an AF_INET[6] one,
  * otherwise no-op. Useful for ftp.
  * NB: does NOT do htons() internally, just direct assignment. */
 void set_nport(len_and_sockaddr *lsa, unsigned port) FAST_FUNC;
 /* Retrieve sin[6]_port or return -1 for non-INET[6] lsa's */
 int get_nport(const struct sockaddr *sa) FAST_FUNC;
 /* Reverse DNS. Returns NULL on failure. */
 char* xmalloc_sockaddr2host(const struct sockaddr *sa) FAST_FUNC RETURNS_MALLOC;
 /* This one doesn't append :PORTNUM */
 char* xmalloc_sockaddr2host_noport(const struct sockaddr *sa) FAST_FUNC RETURNS_MALLOC;
 /* This one also doesn't fall back to dotted IP (returns NULL) */
 char* xmalloc_sockaddr2hostonly_noport(const struct sockaddr *sa) FAST_FUNC RETURNS_MALLOC;
 /* inet_[ap]ton on steroids */
 char* xmalloc_sockaddr2dotted(const struct sockaddr *sa) FAST_FUNC RETURNS_MALLOC;
 char* xmalloc_sockaddr2dotted_noport(const struct sockaddr *sa) FAST_FUNC RETURNS_MALLOC;
 // "old" (ipv4 only) API
 // users: traceroute.c hostname.c - use _list_ of all IPs
 struct hostent *xgethostbyname(const char *name) FAST_FUNC;
 // Also mount.c and inetd.c are using gethostbyname(),
 // + inet_common.c has additional IPv4-only stuff
 
 
 void socket_want_pktinfo(int fd) FAST_FUNC;
 ssize_t send_to_from(int fd, void *buf, size_t len, int flags,
 		const struct sockaddr *to,
 		const struct sockaddr *from,
 		socklen_t tolen) FAST_FUNC;
 ssize_t recv_from_to(int fd, void *buf, size_t len, int flags,
 		struct sockaddr *from,
 		struct sockaddr *to,
 		socklen_t sa_size) FAST_FUNC;
 
 
 char *xstrdup(const char *s) FAST_FUNC RETURNS_MALLOC;
 char *xstrndup(const char *s, int n) FAST_FUNC RETURNS_MALLOC;
 void overlapping_strcpy(char *dst, const char *src) FAST_FUNC;
 char *safe_strncpy(char *dst, const char *src, size_t size) FAST_FUNC;
 char *strncpy_IFNAMSIZ(char *dst, const char *src) FAST_FUNC;
 /* Guaranteed to NOT be a macro (smallest code). Saves nearly 2k on uclibc.
  * But potentially slow, don't use in one-billion-times loops */
 int bb_putchar(int ch) FAST_FUNC;
 /* Note: does not use stdio, writes to fd 2 directly */
 int bb_putchar_stderr(char ch) FAST_FUNC;
 char *xasprintf(const char *format, ...) __attribute__ ((format(printf, 1, 2))) FAST_FUNC RETURNS_MALLOC;
 // gcc-4.1.1 still isn't good enough at optimizing it
 // (+200 bytes compared to macro)
 //static ALWAYS_INLINE
 //int LONE_DASH(const char *s) { return s[0] == '-' && !s[1]; }
 //static ALWAYS_INLINE
 //int NOT_LONE_DASH(const char *s) { return s[0] != '-' || s[1]; }
 #define LONE_DASH(s)     ((s)[0] == '-' && !(s)[1])
 #define NOT_LONE_DASH(s) ((s)[0] != '-' || (s)[1])
 #define LONE_CHAR(s,c)     ((s)[0] == (c) && !(s)[1])
 #define NOT_LONE_CHAR(s,c) ((s)[0] != (c) || (s)[1])
 #define DOT_OR_DOTDOT(s) ((s)[0] == '.' && (!(s)[1] || ((s)[1] == '.' && !(s)[2])))
 
 typedef struct uni_stat_t {
 	unsigned byte_count;
 	unsigned unicode_count;
 	unsigned unicode_width;
 } uni_stat_t;
 /* Returns a string with unprintable chars replaced by '?' or
  * SUBST_WCHAR. This function is unicode-aware. */
 const char* FAST_FUNC printable_string(uni_stat_t *stats, const char *str);
 /* Prints unprintable char ch as ^C or M-c to file
  * (M-c is used only if ch is ORed with PRINTABLE_META),
  * else it is printed as-is (except for ch = 0x9b) */
 enum { PRINTABLE_META = 0x100 };
 void fputc_printable(int ch, FILE *file) FAST_FUNC;
 
 /* dmalloc will redefine these to it's own implementation. It is safe
  * to have the prototypes here unconditionally.  */
 void *malloc_or_warn(size_t size) FAST_FUNC RETURNS_MALLOC;
 void *xmalloc(size_t size) FAST_FUNC RETURNS_MALLOC;
 void *xzalloc(size_t size) FAST_FUNC RETURNS_MALLOC;
 void *xrealloc(void *old, size_t size) FAST_FUNC;
 /* After xrealloc_vector(v, 4, idx) it's ok to use
  * at least v[idx] and v[idx+1], for all idx values.
  * shift specifies how many new elements are added (1: 2, 2: 4... 8: 256...)
  * when all elements are used up. New elements are zeroed out. */
 #define xrealloc_vector(vector, shift, idx) \
 	xrealloc_vector_helper((vector), (sizeof((vector)[0]) << 8) + (shift), (idx))
 void* xrealloc_vector_helper(void *vector, unsigned sizeof_and_shift, int idx) FAST_FUNC;
 
 
 extern ssize_t safe_read(int fd, void *buf, size_t count) FAST_FUNC;
 extern ssize_t nonblock_safe_read(int fd, void *buf, size_t count) FAST_FUNC;
 // NB: will return short read on error, not -1,
 // if some data was read before error occurred
 extern ssize_t full_read(int fd, void *buf, size_t count) FAST_FUNC;
 extern void xread(int fd, void *buf, size_t count) FAST_FUNC;
 extern unsigned char xread_char(int fd) FAST_FUNC;
 extern ssize_t read_close(int fd, void *buf, size_t maxsz) FAST_FUNC;
 extern ssize_t open_read_close(const char *filename, void *buf, size_t maxsz) FAST_FUNC;
 // Reads one line a-la fgets (but doesn't save terminating '\n').
 // Reads byte-by-byte. Useful when it is important to not read ahead.
 // Bytes are appended to pfx (which must be malloced, or NULL).
 extern char *xmalloc_reads(int fd, char *pfx, size_t *maxsz_p) FAST_FUNC;
 /* Reads block up to *maxsz_p (default: INT_MAX - 4095) */
 extern void *xmalloc_read(int fd, size_t *maxsz_p) FAST_FUNC RETURNS_MALLOC;
 /* Returns NULL if file can't be opened (default max size: INT_MAX - 4095) */
 extern void *xmalloc_open_read_close(const char *filename, size_t *maxsz_p) FAST_FUNC RETURNS_MALLOC;
 /* Autodetects gzip/bzip2 formats. fd may be in the middle of the file! */
 #if ENABLE_FEATURE_SEAMLESS_LZMA \
  || ENABLE_FEATURE_SEAMLESS_BZ2 \
  || ENABLE_FEATURE_SEAMLESS_GZ \
  /* || ENABLE_FEATURE_SEAMLESS_Z */
 extern void setup_unzip_on_fd(int fd /*, int fail_if_not_detected*/) FAST_FUNC;
 #else
 # define setup_unzip_on_fd(...) ((void)0)
 #endif
 /* Autodetects .gz etc */
 extern int open_zipped(const char *fname) FAST_FUNC;
 extern void *xmalloc_open_zipped_read_close(const char *fname, size_t *maxsz_p) FAST_FUNC RETURNS_MALLOC;
 /* Never returns NULL */
 extern void *xmalloc_xopen_read_close(const char *filename, size_t *maxsz_p) FAST_FUNC RETURNS_MALLOC;
 
 extern ssize_t safe_write(int fd, const void *buf, size_t count) FAST_FUNC;
 // NB: will return short write on error, not -1,
 // if some data was written before error occurred
 extern ssize_t full_write(int fd, const void *buf, size_t count) FAST_FUNC;
 extern void xwrite(int fd, const void *buf, size_t count) FAST_FUNC;
 extern void xwrite_str(int fd, const char *str) FAST_FUNC;
 extern ssize_t full_write1_str(const char *str) FAST_FUNC;
 extern ssize_t full_write2_str(const char *str) FAST_FUNC;
 extern void xopen_xwrite_close(const char* file, const char *str) FAST_FUNC;
 
 /* Close fd, but check for failures (some types of write errors) */
 extern void xclose(int fd) FAST_FUNC;
 
 /* Reads and prints to stdout till eof, then closes FILE. Exits on error: */
 extern void xprint_and_close_file(FILE *file) FAST_FUNC;
 
 extern char *bb_get_chunk_from_file(FILE *file, int *end) FAST_FUNC;
 extern char *bb_get_chunk_with_continuation(FILE *file, int *end, int *lineno) FAST_FUNC;
 /* Reads up to (and including) TERMINATING_STRING: */
 extern char *xmalloc_fgets_str(FILE *file, const char *terminating_string) FAST_FUNC RETURNS_MALLOC;
 /* Same, with limited max size, and returns the length (excluding NUL): */
 extern char *xmalloc_fgets_str_len(FILE *file, const char *terminating_string, size_t *maxsz_p) FAST_FUNC RETURNS_MALLOC;
 /* Chops off TERMINATING_STRING from the end: */
 extern char *xmalloc_fgetline_str(FILE *file, const char *terminating_string) FAST_FUNC RETURNS_MALLOC;
 /* Reads up to (and including) "\n" or NUL byte: */
 extern char *xmalloc_fgets(FILE *file) FAST_FUNC RETURNS_MALLOC;
 /* Chops off '\n' from the end, unlike fgets: */
 extern char *xmalloc_fgetline(FILE *file) FAST_FUNC RETURNS_MALLOC;
 /* Same, but doesn't try to conserve space (may have some slack after the end) */
 /* extern char *xmalloc_fgetline_fast(FILE *file) FAST_FUNC RETURNS_MALLOC; */
 
 void die_if_ferror(FILE *file, const char *msg) FAST_FUNC;
 void die_if_ferror_stdout(void) FAST_FUNC;
 int fflush_all(void) FAST_FUNC;
 void fflush_stdout_and_exit(int retval) NORETURN FAST_FUNC;
 int fclose_if_not_stdin(FILE *file) FAST_FUNC;
 FILE* xfopen(const char *filename, const char *mode) FAST_FUNC;
 /* Prints warning to stderr and returns NULL on failure: */
 FILE* fopen_or_warn(const char *filename, const char *mode) FAST_FUNC;
 /* "Opens" stdin if filename is special, else just opens file: */
 FILE* xfopen_stdin(const char *filename) FAST_FUNC;
 FILE* fopen_or_warn_stdin(const char *filename) FAST_FUNC;
 FILE* fopen_for_read(const char *path) FAST_FUNC;
 FILE* xfopen_for_read(const char *path) FAST_FUNC;
 FILE* fopen_for_write(const char *path) FAST_FUNC;
 FILE* xfopen_for_write(const char *path) FAST_FUNC;
 FILE* xfdopen_for_read(int fd) FAST_FUNC;
 FILE* xfdopen_for_write(int fd) FAST_FUNC;
 
 int bb_pstrcmp(const void *a, const void *b) /* not FAST_FUNC! */;
 void qsort_string_vector(char **sv, unsigned count) FAST_FUNC;
 
 /* Wrapper which restarts poll on EINTR or ENOMEM.
  * On other errors complains [perror("poll")] and returns.
  * Warning! May take (much) longer than timeout_ms to return!
  * If this is a problem, use bare poll and open-code EINTR/ENOMEM handling */
 int safe_poll(struct pollfd *ufds, nfds_t nfds, int timeout_ms) FAST_FUNC;
 
 char *safe_gethostname(void) FAST_FUNC;
 char *safe_getdomainname(void) FAST_FUNC;
 
 /* Convert each alpha char in str to lower-case */
 char* str_tolower(char *str) FAST_FUNC;
 
 char *utoa(unsigned n) FAST_FUNC;
 char *itoa(int n) FAST_FUNC;
 /* Returns a pointer past the formatted number, does NOT null-terminate */
 char *utoa_to_buf(unsigned n, char *buf, unsigned buflen) FAST_FUNC;
 char *itoa_to_buf(int n, char *buf, unsigned buflen) FAST_FUNC;
 /* Intelligent formatters of bignums */
 void smart_ulltoa4(unsigned long long ul, char buf[5], const char *scale) FAST_FUNC;
 void smart_ulltoa5(unsigned long long ul, char buf[5], const char *scale) FAST_FUNC;
 /* If block_size == 0, display size without fractional part,
  * else display (size * block_size) with one decimal digit.
  * If display_unit == 0, show value no bigger than 1024 with suffix (K,M,G...),
  * else divide by display_unit and do not use suffix. */
 #define HUMAN_READABLE_MAX_WIDTH      7  /* "1024.0G" */
 #define HUMAN_READABLE_MAX_WIDTH_STR "7"
 //TODO: provide pointer to buf (avoid statics)?
 const char *make_human_readable_str(unsigned long long size,
 		unsigned long block_size, unsigned long display_unit) FAST_FUNC;
 /* Put a string of hex bytes ("1b2e66fe"...), return advanced pointer */
 char *bin2hex(char *buf, const char *cp, int count) FAST_FUNC;
 /* Reverse */
 char* hex2bin(char *dst, const char *str, int count) FAST_FUNC;
 
 /* Generate a UUID */
 void generate_uuid(uint8_t *buf) FAST_FUNC;
 
 /* Last element is marked by mult == 0 */
 struct suffix_mult {
 	char suffix[4];
 	unsigned mult;
 };
 #include "xatonum.h"
 /* Specialized: */
 
 /* Using xatoi() instead of naive atoi() is not always convenient -
  * in many places people want *non-negative* values, but store them
  * in signed int. Therefore we need this one:
  * dies if input is not in [0, INT_MAX] range. Also will reject '-0' etc.
  * It should really be named xatoi_nonnegative (since it allows 0),
  * but that would be too long.
  */
 int xatoi_positive(const char *numstr) FAST_FUNC;
 
 /* Useful for reading port numbers */
 uint16_t xatou16(const char *numstr) FAST_FUNC;
 
 
 /* These parse entries in /etc/passwd and /etc/group.  This is desirable
  * for BusyBox since we want to avoid using the glibc NSS stuff, which
  * increases target size and is often not needed on embedded systems.  */
 long xuname2uid(const char *name) FAST_FUNC;
 long xgroup2gid(const char *name) FAST_FUNC;
 /* wrapper: allows string to contain numeric uid or gid */
 unsigned long get_ug_id(const char *s, long FAST_FUNC (*xname2id)(const char *)) FAST_FUNC;
 /* from chpst. Does not die, returns 0 on failure */
 struct bb_uidgid_t {
 	uid_t uid;
 	gid_t gid;
 };
 /* always sets uid and gid */
 int get_uidgid(struct bb_uidgid_t*, const char*, int numeric_ok) FAST_FUNC;
 /* always sets uid and gid, allows numeric; exits on failure */
 void xget_uidgid(struct bb_uidgid_t*, const char*) FAST_FUNC;
 /* chown-like handling of "user[:[group]" */
 void parse_chown_usergroup_or_die(struct bb_uidgid_t *u, char *user_group) FAST_FUNC;
 struct passwd* xgetpwnam(const char *name) FAST_FUNC;
 struct group* xgetgrnam(const char *name) FAST_FUNC;
 struct passwd* xgetpwuid(uid_t uid) FAST_FUNC;
 struct group* xgetgrgid(gid_t gid) FAST_FUNC;
 char* xuid2uname(uid_t uid) FAST_FUNC;
 char* xgid2group(gid_t gid) FAST_FUNC;
 char* uid2uname(uid_t uid) FAST_FUNC;
 char* gid2group(gid_t gid) FAST_FUNC;
 char* uid2uname_utoa(long uid) FAST_FUNC;
 char* gid2group_utoa(long gid) FAST_FUNC;
 /* versions which cache results (useful for ps, ls etc) */
 const char* get_cached_username(uid_t uid) FAST_FUNC;
 const char* get_cached_groupname(gid_t gid) FAST_FUNC;
 void clear_username_cache(void) FAST_FUNC;
 /* internally usernames are saved in fixed-sized char[] buffers */
 enum { USERNAME_MAX_SIZE = 16 - sizeof(int) };
 #if ENABLE_FEATURE_CHECK_NAMES
 void die_if_bad_username(const char* name) FAST_FUNC;
 #else
 #define die_if_bad_username(name) ((void)(name))
 #endif
 
 #if ENABLE_FEATURE_UTMP
 void FAST_FUNC write_new_utmp(pid_t pid, int new_type, const char *tty_name, const char *username, const char *hostname);
 void FAST_FUNC update_utmp(pid_t pid, int new_type, const char *tty_name, const char *username, const char *hostname);
 #else
 # define write_new_utmp(pid, new_type, tty_name, username, hostname) ((void)0)
 # define update_utmp(pid, new_type, tty_name, username, hostname) ((void)0)
 #endif
 
 int execable_file(const char *name) FAST_FUNC;
 char *find_execable(const char *filename, char **PATHp) FAST_FUNC;
 int exists_execable(const char *filename) FAST_FUNC;
 
 /* BB_EXECxx always execs (it's not doing NOFORK/NOEXEC stuff),
  * but it may exec busybox and call applet instead of searching PATH.
  */
 #if ENABLE_FEATURE_PREFER_APPLETS
 int bb_execvp(const char *file, char *const argv[]) FAST_FUNC;
 #define BB_EXECVP(prog,cmd) bb_execvp(prog,cmd)
 #define BB_EXECLP(prog,cmd,...) \
 	execlp((find_applet_by_name(prog) >= 0) ? CONFIG_BUSYBOX_EXEC_PATH : prog, \
 		cmd, __VA_ARGS__)
 #else
 #define BB_EXECVP(prog,cmd)     execvp(prog,cmd)
 #define BB_EXECLP(prog,cmd,...) execlp(prog,cmd, __VA_ARGS__)
 #endif
 int BB_EXECVP_or_die(char **argv) NORETURN FAST_FUNC;
 
 /* xvfork() can't be a _function_, return after vfork mangles stack
  * in the parent. It must be a macro. */
 #define xvfork() \
 ({ \
 	pid_t bb__xvfork_pid = vfork(); \
 	if (bb__xvfork_pid < 0) \
 		bb_perror_msg_and_die("vfork"); \
 	bb__xvfork_pid; \
 })
 #if BB_MMU
 pid_t xfork(void) FAST_FUNC;
 #endif
 
 /* NOMMU friendy fork+exec: */
 pid_t spawn(char **argv) FAST_FUNC;
 pid_t xspawn(char **argv) FAST_FUNC;
 
 pid_t safe_waitpid(pid_t pid, int *wstat, int options) FAST_FUNC;
 pid_t wait_any_nohang(int *wstat) FAST_FUNC;
 /* wait4pid: unlike waitpid, waits ONLY for one process.
  * Returns sig + 0x180 if child is killed by signal.
  * It's safe to pass negative 'pids' from failed [v]fork -
  * wait4pid will return -1 (and will not clobber [v]fork's errno).
  * IOW: rc = wait4pid(spawn(argv));
  *      if (rc < 0) bb_perror_msg("%s", argv[0]);
  *      if (rc > 0) bb_error_msg("exit code: %d", rc & 0xff);
  */
 int wait4pid(pid_t pid) FAST_FUNC;
 /* Same as wait4pid(spawn(argv)), but with NOFORK/NOEXEC if configured: */
 int spawn_and_wait(char **argv) FAST_FUNC;
 struct nofork_save_area {
 	jmp_buf die_jmp;
 	const char *applet_name;
 	int xfunc_error_retval;
 	uint32_t option_mask32;
 	int die_sleep;
 	smallint saved;
 };
 void save_nofork_data(struct nofork_save_area *save) FAST_FUNC;
 void restore_nofork_data(struct nofork_save_area *save) FAST_FUNC;
 /* Does NOT check that applet is NOFORK, just blindly runs it */
 int run_nofork_applet(int applet_no, char **argv) FAST_FUNC;
 int run_nofork_applet_prime(struct nofork_save_area *old, int applet_no, char **argv) FAST_FUNC;
 
 /* Helpers for daemonization.
  *
  * bb_daemonize(flags) = daemonize, does not compile on NOMMU
  *
  * bb_daemonize_or_rexec(flags, argv) = daemonizes on MMU (and ignores argv),
  *      rexec's itself on NOMMU with argv passed as command line.
  * Thus bb_daemonize_or_rexec may cause your <applet>_main() to be re-executed
  * from the start. (It will detect it and not reexec again second time).
  * You have to audit carefully that you don't do something twice as a result
  * (opening files/sockets, parsing config files etc...)!
  *
  * Both of the above will redirect fd 0,1,2 to /dev/null and drop ctty
  * (will do setsid()).
  *
  * fork_or_rexec(argv) = bare-bones fork on MMU,
  *      "vfork + re-exec ourself" on NOMMU. No fd redirection, no setsid().
  *      On MMU ignores argv.
  *
  * Helper for network daemons in foreground mode:
  *
  * bb_sanitize_stdio() = make sure that fd 0,1,2 are opened by opening them
  * to /dev/null if they are not.
  */
 enum {
 	DAEMON_CHDIR_ROOT = 1,
 	DAEMON_DEVNULL_STDIO = 2,
 	DAEMON_CLOSE_EXTRA_FDS = 4,
 	DAEMON_ONLY_SANITIZE = 8, /* internal use */
 };
 #if BB_MMU
   enum { re_execed = 0 };
 # define fork_or_rexec(argv)                xfork()
 # define bb_daemonize_or_rexec(flags, argv) bb_daemonize_or_rexec(flags)
 # define bb_daemonize(flags)                bb_daemonize_or_rexec(flags, bogus)
 #else
   extern bool re_execed;
   void re_exec(char **argv) NORETURN FAST_FUNC;
   pid_t fork_or_rexec(char **argv) FAST_FUNC;
   int  BUG_fork_is_unavailable_on_nommu(void) FAST_FUNC;
   int  BUG_daemon_is_unavailable_on_nommu(void) FAST_FUNC;
   void BUG_bb_daemonize_is_unavailable_on_nommu(void) FAST_FUNC;
 # define fork()          BUG_fork_is_unavailable_on_nommu()
 # define xfork()         BUG_fork_is_unavailable_on_nommu()
 # define daemon(a,b)     BUG_daemon_is_unavailable_on_nommu()
 # define bb_daemonize(a) BUG_bb_daemonize_is_unavailable_on_nommu()
 #endif
 void bb_daemonize_or_rexec(int flags, char **argv) FAST_FUNC;
 void bb_sanitize_stdio(void) FAST_FUNC;
 /* Clear dangerous stuff, set PATH. Return 1 if was run by different user. */
 int sanitize_env_if_suid(void) FAST_FUNC;
 
 
 char* single_argv(char **argv) FAST_FUNC;
 extern const char *const bb_argv_dash[]; /* "-", NULL */
 extern const char *opt_complementary;
 #if ENABLE_LONG_OPTS || ENABLE_FEATURE_GETOPT_LONG
 #define No_argument "\0"
 #define Required_argument "\001"
 #define Optional_argument "\002"
 extern const char *applet_long_options;
 #endif
 extern uint32_t option_mask32;
 extern uint32_t getopt32(char **argv, const char *applet_opts, ...) FAST_FUNC;
 
 
 typedef struct llist_t {
 	char *data;
 	struct llist_t *link;
 } llist_t;
 void llist_add_to(llist_t **old_head, void *data) FAST_FUNC;
 void llist_add_to_end(llist_t **list_head, void *data) FAST_FUNC;
 void *llist_pop(llist_t **elm) FAST_FUNC;
 void llist_unlink(llist_t **head, llist_t *elm) FAST_FUNC;
 void llist_free(llist_t *elm, void (*freeit)(void *data)) FAST_FUNC;
 llist_t *llist_rev(llist_t *list) FAST_FUNC;
 llist_t *llist_find_str(llist_t *first, const char *str) FAST_FUNC;
 /* BTW, surprisingly, changing API to
  *   llist_t *llist_add_to(llist_t *old_head, void *data)
  * etc does not result in smaller code... */
 
 /* start_stop_daemon and udhcpc are special - they want
  * to create pidfiles regardless of FEATURE_PIDFILE */
 #if ENABLE_FEATURE_PIDFILE || defined(WANT_PIDFILE)
 /* True only if we created pidfile which is *file*, not /dev/null etc */
 extern smallint wrote_pidfile;
 void write_pidfile(const char *path) FAST_FUNC;
 #define remove_pidfile(path) do { if (wrote_pidfile) unlink(path); } while (0)
 #else
 enum { wrote_pidfile = 0 };
 #define write_pidfile(path)  ((void)0)
 #define remove_pidfile(path) ((void)0)
 #endif
 
 enum {
 	LOGMODE_NONE = 0,
 	LOGMODE_STDIO = (1 << 0),
 	LOGMODE_SYSLOG = (1 << 1) * ENABLE_FEATURE_SYSLOG,
 	LOGMODE_BOTH = LOGMODE_SYSLOG + LOGMODE_STDIO,
 };
 extern const char *msg_eol;
 extern smallint logmode;
 extern int die_sleep;
 extern int xfunc_error_retval;
 extern jmp_buf die_jmp;
 extern void xfunc_die(void) NORETURN FAST_FUNC;
 extern void bb_show_usage(void) NORETURN FAST_FUNC;
 extern void bb_error_msg(const char *s, ...) __attribute__ ((format (printf, 1, 2))) FAST_FUNC;
 extern void bb_error_msg_and_die(const char *s, ...) __attribute__ ((noreturn, format (printf, 1, 2))) FAST_FUNC;
 extern void bb_perror_msg(const char *s, ...) __attribute__ ((format (printf, 1, 2))) FAST_FUNC;
 extern void bb_simple_perror_msg(const char *s) FAST_FUNC;
 extern void bb_perror_msg_and_die(const char *s, ...) __attribute__ ((noreturn, format (printf, 1, 2))) FAST_FUNC;
 extern void bb_simple_perror_msg_and_die(const char *s) NORETURN FAST_FUNC;
 extern void bb_herror_msg(const char *s, ...) __attribute__ ((format (printf, 1, 2))) FAST_FUNC;
 extern void bb_herror_msg_and_die(const char *s, ...) __attribute__ ((noreturn, format (printf, 1, 2))) FAST_FUNC;
 extern void bb_perror_nomsg_and_die(void) NORETURN FAST_FUNC;
 extern void bb_perror_nomsg(void) FAST_FUNC;
 extern void bb_info_msg(const char *s, ...) __attribute__ ((format (printf, 1, 2))) FAST_FUNC;
 extern void bb_verror_msg(const char *s, va_list p, const char *strerr) FAST_FUNC;
 
 /* We need to export XXX_main from libbusybox
  * only if we build "individual" binaries
  */
 #if ENABLE_FEATURE_INDIVIDUAL
 #define MAIN_EXTERNALLY_VISIBLE EXTERNALLY_VISIBLE
 #else
 #define MAIN_EXTERNALLY_VISIBLE
 #endif
 
 
 /* Applets which are useful from another applets */
 int bb_cat(char** argv);
 /* If shell needs them, they exist even if not enabled as applets */
 int echo_main(int argc, char** argv) IF_ECHO(MAIN_EXTERNALLY_VISIBLE);
 int printf_main(int argc, char **argv) IF_PRINTF(MAIN_EXTERNALLY_VISIBLE);
 int test_main(int argc, char **argv) IF_TEST(MAIN_EXTERNALLY_VISIBLE);
 int kill_main(int argc, char **argv) IF_KILL(MAIN_EXTERNALLY_VISIBLE);
 /* Similar, but used by chgrp, not shell */
 int chown_main(int argc, char **argv) IF_CHOWN(MAIN_EXTERNALLY_VISIBLE);
 /* Used by ftpd */
 int ls_main(int argc, char **argv) IF_LS(MAIN_EXTERNALLY_VISIBLE);
 /* Don't need IF_xxx() guard for these */
 int gunzip_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 int bunzip2_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 
 #if ENABLE_ROUTE
 void bb_displayroutes(int noresolve, int netstatfmt) FAST_FUNC;
 #endif
 
 
 /* Networking */
 int create_icmp_socket(void) FAST_FUNC;
 int create_icmp6_socket(void) FAST_FUNC;
 /* interface.c */
 /* This structure defines protocol families and their handlers. */
 struct aftype {
 	const char *name;
 	const char *title;
 	int af;
 	int alen;
 	char*       FAST_FUNC (*print)(unsigned char *);
 	const char* FAST_FUNC (*sprint)(struct sockaddr *, int numeric);
 	int         FAST_FUNC (*input)(/*int type,*/ const char *bufp, struct sockaddr *);
 	void        FAST_FUNC (*herror)(char *text);
 	int         FAST_FUNC (*rprint)(int options);
 	int         FAST_FUNC (*rinput)(int typ, int ext, char **argv);
 	/* may modify src */
 	int         FAST_FUNC (*getmask)(char *src, struct sockaddr *mask, char *name);
 };
 /* This structure defines hardware protocols and their handlers. */
 struct hwtype {
 	const char *name;
 	const char *title;
 	int type;
 	int alen;
 	char* FAST_FUNC (*print)(unsigned char *);
 	int   FAST_FUNC (*input)(const char *, struct sockaddr *);
 	int   FAST_FUNC (*activate)(int fd);
 	int suppress_null_addr;
 };
 extern smallint interface_opt_a;
 int display_interfaces(char *ifname) FAST_FUNC;
 #if ENABLE_FEATURE_HWIB
 int in_ib(const char *bufp, struct sockaddr *sap) FAST_FUNC;
 #else
 #define in_ib(a, b) 1 /* fail */
 #endif
 const struct aftype *get_aftype(const char *name) FAST_FUNC;
 const struct hwtype *get_hwtype(const char *name) FAST_FUNC;
 const struct hwtype *get_hwntype(int type) FAST_FUNC;
 
 
 #ifndef BUILD_INDIVIDUAL
 extern int find_applet_by_name(const char *name) FAST_FUNC;
 /* Returns only if applet is not found. */
 extern void run_applet_and_exit(const char *name, char **argv) FAST_FUNC;
 extern void run_applet_no_and_exit(int a, char **argv) NORETURN FAST_FUNC;
 #endif
 
 #ifdef HAVE_MNTENT_H
 extern int match_fstype(const struct mntent *mt, const char *fstypes) FAST_FUNC;
 extern struct mntent *find_mount_point(const char *name, int subdir_too) FAST_FUNC;
 #endif
 extern void erase_mtab(const char * name) FAST_FUNC;
 extern unsigned int tty_baud_to_value(speed_t speed) FAST_FUNC;
 extern speed_t tty_value_to_baud(unsigned int value) FAST_FUNC;
 #if ENABLE_DESKTOP
 extern void bb_warn_ignoring_args(char *arg) FAST_FUNC;
 #else
 # define bb_warn_ignoring_args(arg) ((void)0)
 #endif
 
 extern int get_linux_version_code(void) FAST_FUNC;
 
 extern char *query_loop(const char *device) FAST_FUNC;
 extern int del_loop(const char *device) FAST_FUNC;
 /* If *devname is not NULL, use that name, otherwise try to find free one,
  * malloc and return it in *devname.
  * return value: 1: read-only loopdev was setup, 0: rw, < 0: error */
 extern int set_loop(char **devname, const char *file, unsigned long long offset) FAST_FUNC;
 
 /* Like bb_ask below, but asks on stdin with no timeout.  */
 char *bb_ask_stdin(const char * prompt) FAST_FUNC;
 //TODO: pass buf pointer or return allocated buf (avoid statics)?
 char *bb_ask(const int fd, int timeout, const char * prompt) FAST_FUNC;
 int bb_ask_confirmation(void) FAST_FUNC;
 
 int bb_parse_mode(const char* s, mode_t* theMode) FAST_FUNC;
 
 /*
  * Config file parser
  */
 enum {
 	PARSE_COLLAPSE  = 0x00010000, // treat consecutive delimiters as one
 	PARSE_TRIM      = 0x00020000, // trim leading and trailing delimiters
 // TODO: COLLAPSE and TRIM seem to always go in pair
 	PARSE_GREEDY    = 0x00040000, // last token takes entire remainder of the line
 	PARSE_MIN_DIE   = 0x00100000, // die if < min tokens found
 	// keep a copy of current line
 	PARSE_KEEP_COPY = 0x00200000 * ENABLE_FEATURE_CROND_D,
 //	PARSE_ESCAPE    = 0x00400000, // process escape sequences in tokens
 	// NORMAL is:
 	// * remove leading and trailing delimiters and collapse
 	//   multiple delimiters into one
 	// * warn and continue if less than mintokens delimiters found
 	// * grab everything into last token
 	PARSE_NORMAL    = PARSE_COLLAPSE | PARSE_TRIM | PARSE_GREEDY,
 };
 typedef struct parser_t {
 	FILE *fp;
 	char *line;
 	char *data;
 	int lineno;
 } parser_t;
 parser_t* config_open(const char *filename) FAST_FUNC;
 parser_t* config_open2(const char *filename, FILE* FAST_FUNC (*fopen_func)(const char *path)) FAST_FUNC;
 /* delims[0] is a comment char (use '\0' to disable), the rest are token delimiters */
 int config_read(parser_t *parser, char **tokens, unsigned flags, const char *delims) FAST_FUNC;
 #define config_read(parser, tokens, max, min, str, flags) \
 	config_read(parser, tokens, ((flags) | (((min) & 0xFF) << 8) | ((max) & 0xFF)), str)
 void config_close(parser_t *parser) FAST_FUNC;
 
 /* Concatenate path and filename to new allocated buffer.
  * Add "/" only as needed (no duplicate "//" are produced).
  * If path is NULL, it is assumed to be "/".
  * filename should not be NULL. */
 char *concat_path_file(const char *path, const char *filename) FAST_FUNC;
 char *concat_subpath_file(const char *path, const char *filename) FAST_FUNC;
 const char *bb_basename(const char *name) FAST_FUNC;
 /* NB: can violate const-ness (similarly to strchr) */
 char *last_char_is(const char *s, int c) FAST_FUNC;
 
 
 int bb_make_directory(char *path, long mode, int flags) FAST_FUNC;
 
 int get_signum(const char *name) FAST_FUNC;
 const char *get_signame(int number) FAST_FUNC;
 void print_signames(void) FAST_FUNC;
 
 char *bb_simplify_path(const char *path) FAST_FUNC;
 /* Returns ptr to NUL */
 char *bb_simplify_abs_path_inplace(char *path) FAST_FUNC;
 
 #define FAIL_DELAY 3
 extern void bb_do_delay(int seconds) FAST_FUNC;
 extern void change_identity(const struct passwd *pw) FAST_FUNC;
 extern void run_shell(const char *shell, int loginshell, const char *command, const char **additional_args) NORETURN FAST_FUNC;
 #if ENABLE_SELINUX
 extern void renew_current_security_context(void) FAST_FUNC;
 extern void set_current_security_context(security_context_t sid) FAST_FUNC;
 extern context_t set_security_context_component(security_context_t cur_context,
 						char *user, char *role, char *type, char *range) FAST_FUNC;
 extern void setfscreatecon_or_die(security_context_t scontext) FAST_FUNC;
 extern void selinux_preserve_fcontext(int fdesc) FAST_FUNC;
 #else
 #define selinux_preserve_fcontext(fdesc) ((void)0)
 #endif
 extern void selinux_or_die(void) FAST_FUNC;
 
 /* setup_environment:
  * if chdir pw->pw_dir: ok: else if to_tmp == 1: goto /tmp else: goto / or die
  * if clear_env = 1: cd(pw->pw_dir), clear environment, then set
  *   TERM=(old value)
  *   USER=pw->pw_name, LOGNAME=pw->pw_name
  *   PATH=bb_default_[root_]path
  *   HOME=pw->pw_dir
  *   SHELL=shell
  * else if change_env = 1:
  *   if not root (if pw->pw_uid != 0):
  *     USER=pw->pw_name, LOGNAME=pw->pw_name
  *   HOME=pw->pw_dir
  *   SHELL=shell
  * else does nothing
  */
 #define SETUP_ENV_CHANGEENV (1 << 0)
 #define SETUP_ENV_CLEARENV  (1 << 1)
 #define SETUP_ENV_TO_TMP    (1 << 2)
 extern void setup_environment(const char *shell, int flags, const struct passwd *pw) FAST_FUNC;
 extern int correct_password(const struct passwd *pw) FAST_FUNC;
 /* Returns a malloced string */
 #if !ENABLE_USE_BB_CRYPT
 #define pw_encrypt(clear, salt, cleanup) pw_encrypt(clear, salt)
 #endif
 extern char *pw_encrypt(const char *clear, const char *salt, int cleanup) FAST_FUNC;
 extern int obscure(const char *old, const char *newval, const struct passwd *pwdp) FAST_FUNC;
 /* rnd is additional random input. New one is returned.
  * Useful if you call crypt_make_salt many times in a row:
  * rnd = crypt_make_salt(buf1, 4, 0);
  * rnd = crypt_make_salt(buf2, 4, rnd);
  * rnd = crypt_make_salt(buf3, 4, rnd);
  * (otherwise we risk having same salt generated)
  */
 extern int crypt_make_salt(char *p, int cnt, int rnd) FAST_FUNC;
 
 /* Returns number of lines changed, or -1 on error */
 #if !(ENABLE_FEATURE_ADDUSER_TO_GROUP || ENABLE_FEATURE_DEL_USER_FROM_GROUP)
 #define update_passwd(filename, username, data, member) \
 	update_passwd(filename, username, data)
 #endif
 extern int update_passwd(const char *filename,
 		const char *username,
 		const char *data,
 		const char *member) FAST_FUNC;
 
 int index_in_str_array(const char *const string_array[], const char *key) FAST_FUNC;
 int index_in_strings(const char *strings, const char *key) FAST_FUNC;
 int index_in_substr_array(const char *const string_array[], const char *key) FAST_FUNC;
 int index_in_substrings(const char *strings, const char *key) FAST_FUNC;
 const char *nth_string(const char *strings, int n) FAST_FUNC;
 
 extern void print_login_issue(const char *issue_file, const char *tty) FAST_FUNC;
 extern void print_login_prompt(void) FAST_FUNC;
 
 char *xmalloc_ttyname(int fd) FAST_FUNC RETURNS_MALLOC;
 /* NB: typically you want to pass fd 0, not 1. Think 'applet | grep something' */
 int get_terminal_width_height(int fd, unsigned *width, unsigned *height) FAST_FUNC;
 
 int tcsetattr_stdin_TCSANOW(const struct termios *tp) FAST_FUNC;
 
 /* NB: "unsigned request" is crucial! "int request" will break some arches! */
 int ioctl_or_perror(int fd, unsigned request, void *argp, const char *fmt,...) __attribute__ ((format (printf, 4, 5))) FAST_FUNC;
 int ioctl_or_perror_and_die(int fd, unsigned request, void *argp, const char *fmt,...) __attribute__ ((format (printf, 4, 5))) FAST_FUNC;
 #if ENABLE_IOCTL_HEX2STR_ERROR
 int bb_ioctl_or_warn(int fd, unsigned request, void *argp, const char *ioctl_name) FAST_FUNC;
 int bb_xioctl(int fd, unsigned request, void *argp, const char *ioctl_name) FAST_FUNC;
 #define ioctl_or_warn(fd,request,argp) bb_ioctl_or_warn(fd,request,argp,#request)
 #define xioctl(fd,request,argp)        bb_xioctl(fd,request,argp,#request)
 #else
 int bb_ioctl_or_warn(int fd, unsigned request, void *argp) FAST_FUNC;
 int bb_xioctl(int fd, unsigned request, void *argp) FAST_FUNC;
 #define ioctl_or_warn(fd,request,argp) bb_ioctl_or_warn(fd,request,argp)
 #define xioctl(fd,request,argp)        bb_xioctl(fd,request,argp)
 #endif
 
 char *is_in_ino_dev_hashtable(const struct stat *statbuf) FAST_FUNC;
 void add_to_ino_dev_hashtable(const struct stat *statbuf, const char *name) FAST_FUNC;
 void reset_ino_dev_hashtable(void) FAST_FUNC;
 #ifdef __GLIBC__
 /* At least glibc has horrendously large inline for this, so wrap it */
 unsigned long long bb_makedev(unsigned int major, unsigned int minor) FAST_FUNC;
 #undef makedev
 #define makedev(a,b) bb_makedev(a,b)
 #endif
 
 
 /* "Keycodes" that report an escape sequence.
  * We use something which fits into signed char,
  * yet doesn't represent any valid Unicode character.
  * Also, -1 is reserved for error indication and we don't use it. */
 enum {
 	KEYCODE_UP       =  -2,
 	KEYCODE_DOWN     =  -3,
 	KEYCODE_RIGHT    =  -4,
 	KEYCODE_LEFT     =  -5,
 	KEYCODE_HOME     =  -6,
 	KEYCODE_END      =  -7,
 	KEYCODE_INSERT   =  -8,
 	KEYCODE_DELETE   =  -9,
 	KEYCODE_PAGEUP   = -10,
 	KEYCODE_PAGEDOWN = -11,
 
 	KEYCODE_CTRL_UP    = KEYCODE_UP    & ~0x40,
 	KEYCODE_CTRL_DOWN  = KEYCODE_DOWN  & ~0x40,
 	KEYCODE_CTRL_RIGHT = KEYCODE_RIGHT & ~0x40,
 	KEYCODE_CTRL_LEFT  = KEYCODE_LEFT  & ~0x40,
 #if 0
 	KEYCODE_FUN1     = -12,
 	KEYCODE_FUN2     = -13,
 	KEYCODE_FUN3     = -14,
 	KEYCODE_FUN4     = -15,
 	KEYCODE_FUN5     = -16,
 	KEYCODE_FUN6     = -17,
 	KEYCODE_FUN7     = -18,
 	KEYCODE_FUN8     = -19,
 	KEYCODE_FUN9     = -20,
 	KEYCODE_FUN10    = -21,
 	KEYCODE_FUN11    = -22,
 	KEYCODE_FUN12    = -23,
 #endif
 	KEYCODE_CURSOR_POS = -0x100, /* 0xfff..fff00 */
 	/* How long is the longest ESC sequence we know?
 	 * We want it big enough to be able to contain
 	 * cursor position sequence "ESC [ 9999 ; 9999 R"
 	 */
 	KEYCODE_BUFFER_SIZE = 16
 };
 /* Note: fd may be in blocking or non-blocking mode, both make sense.
  * For one, less uses non-blocking mode.
  * Only the first read syscall inside read_key may block indefinitely
  * (unless fd is in non-blocking mode),
  * subsequent reads will time out after a few milliseconds.
  * Return of -1 means EOF or error (errno == 0 on EOF).
  * buffer[0] is used as a counter of buffered chars and must be 0
  * on first call.
  * timeout:
  * -2: do not poll for input;
  * -1: poll(-1) (i.e. block);
  * >=0: poll for TIMEOUT milliseconds, return -1/EAGAIN on timeout
  */
 int64_t read_key(int fd, char *buffer, int timeout) FAST_FUNC;
 void read_key_ungets(char *buffer, const char *str, unsigned len) FAST_FUNC;
 
 
 #if ENABLE_FEATURE_EDITING
 /* It's NOT just ENABLEd or disabled. It's a number: */
 # ifdef CONFIG_FEATURE_EDITING_HISTORY
 #  define MAX_HISTORY (CONFIG_FEATURE_EDITING_HISTORY + 0)
 # else
 #  define MAX_HISTORY 0
 # endif
 typedef struct line_input_t {
 	int flags;
 	const char *path_lookup;
 # if MAX_HISTORY
 	int cnt_history;
 	int cur_history;
 #  if ENABLE_FEATURE_EDITING_SAVEHISTORY
 	unsigned cnt_history_in_file;
 	const char *hist_file;
 #  endif
 	char *history[MAX_HISTORY + 1];
 # endif
 } line_input_t;
 enum {
 	DO_HISTORY = 1 * (MAX_HISTORY > 0),
 	SAVE_HISTORY = 2 * (MAX_HISTORY > 0) * ENABLE_FEATURE_EDITING_SAVEHISTORY,
 	TAB_COMPLETION = 4 * ENABLE_FEATURE_TAB_COMPLETION,
 	USERNAME_COMPLETION = 8 * ENABLE_FEATURE_USERNAME_COMPLETION,
 	VI_MODE = 0x10 * ENABLE_FEATURE_EDITING_VI,
 	WITH_PATH_LOOKUP = 0x20,
 	FOR_SHELL = DO_HISTORY | SAVE_HISTORY | TAB_COMPLETION | USERNAME_COMPLETION,
 };
 line_input_t *new_line_input_t(int flags) FAST_FUNC;
 /* So far static: void free_line_input_t(line_input_t *n) FAST_FUNC; */
 /* maxsize must be >= 2.
  * Returns:
  * -1 on read errors or EOF, or on bare Ctrl-D,
  * 0  on ctrl-C (the line entered is still returned in 'command'),
  * >0 length of input string, including terminating '\n'
  */
 int read_line_input(const char* prompt, char* command, int maxsize, line_input_t *state) FAST_FUNC;
 #else
 #define MAX_HISTORY 0
 int read_line_input(const char* prompt, char* command, int maxsize) FAST_FUNC;
 #define read_line_input(prompt, command, maxsize, state) \
 	read_line_input(prompt, command, maxsize)
 #endif
 
 
 #ifndef COMM_LEN
 # ifdef TASK_COMM_LEN
 enum { COMM_LEN = TASK_COMM_LEN };
 # else
 /* synchronize with sizeof(task_struct.comm) in /usr/include/linux/sched.h */
 enum { COMM_LEN = 16 };
 # endif
 #endif
 
 struct smaprec {
 	unsigned long mapped_rw;
 	unsigned long mapped_ro;
 	unsigned long shared_clean;
 	unsigned long shared_dirty;
 	unsigned long private_clean;
 	unsigned long private_dirty;
 	unsigned long stack;
 	unsigned long smap_pss, smap_swap;
 	unsigned long smap_size;
 	unsigned long smap_start;
 	char smap_mode[5];
 	char *smap_name;
 };
 
 #if !ENABLE_PMAP
 #define procps_read_smaps(pid, total, cb, data) \
 	procps_read_smaps(pid, total)
 #endif
 int FAST_FUNC procps_read_smaps(pid_t pid, struct smaprec *total,
 		      void (*cb)(struct smaprec *, void *), void *data);
 
 typedef struct procps_status_t {
 	DIR *dir;
 	IF_FEATURE_SHOW_THREADS(DIR *task_dir;)
 	uint8_t shift_pages_to_bytes;
 	uint8_t shift_pages_to_kb;
 /* Fields are set to 0/NULL if failed to determine (or not requested) */
 	uint16_t argv_len;
 	char *argv0;
 	char *exe;
 	IF_SELINUX(char *context;)
 	/* Everything below must contain no ptrs to malloc'ed data:
 	 * it is memset(0) for each process in procps_scan() */
 	unsigned long vsz, rss; /* we round it to kbytes */
 	unsigned long stime, utime;
 	unsigned long start_time;
 	unsigned pid;
 	unsigned ppid;
 	unsigned pgid;
 	unsigned sid;
 	unsigned uid;
 	unsigned gid;
 #if ENABLE_FEATURE_PS_ADDITIONAL_COLUMNS
 	unsigned ruid;
 	unsigned rgid;
 	int niceness;
 #endif
 	unsigned tty_major,tty_minor;
 #if ENABLE_FEATURE_TOPMEM
 	struct smaprec smaps;
 #endif
 	char state[4];
 	/* basename of executable in exec(2), read from /proc/N/stat
 	 * (if executable is symlink or script, it is NOT replaced
 	 * by link target or interpreter name) */
 	char comm[COMM_LEN];
 	/* user/group? - use passwd/group parsing functions */
 #if ENABLE_FEATURE_TOP_SMP_PROCESS
 	int last_seen_on_cpu;
 #endif
 } procps_status_t;
 /* flag bits for procps_scan(xx, flags) calls */
 enum {
 	PSSCAN_PID      = 1 << 0,
 	PSSCAN_PPID     = 1 << 1,
 	PSSCAN_PGID     = 1 << 2,
 	PSSCAN_SID      = 1 << 3,
 	PSSCAN_UIDGID   = 1 << 4,
 	PSSCAN_COMM     = 1 << 5,
 	/* PSSCAN_CMD      = 1 << 6, - use read_cmdline instead */
 	PSSCAN_ARGV0    = 1 << 7,
 	PSSCAN_EXE      = 1 << 8,
 	PSSCAN_STATE    = 1 << 9,
 	PSSCAN_VSZ      = 1 << 10,
 	PSSCAN_RSS      = 1 << 11,
 	PSSCAN_STIME    = 1 << 12,
 	PSSCAN_UTIME    = 1 << 13,
 	PSSCAN_TTY      = 1 << 14,
 	PSSCAN_SMAPS	= (1 << 15) * ENABLE_FEATURE_TOPMEM,
 	/* NB: used by find_pid_by_name(). Any applet using it
 	 * needs to be mentioned here. */
 	PSSCAN_ARGVN    = (1 << 16) * (ENABLE_KILLALL
 				|| ENABLE_PGREP || ENABLE_PKILL
 				|| ENABLE_PIDOF
 				|| ENABLE_SESTATUS
 				),
 	PSSCAN_CONTEXT  = (1 << 17) * ENABLE_SELINUX,
 	PSSCAN_START_TIME = 1 << 18,
 	PSSCAN_CPU      = (1 << 19) * ENABLE_FEATURE_TOP_SMP_PROCESS,
 	PSSCAN_NICE     = (1 << 20) * ENABLE_FEATURE_PS_ADDITIONAL_COLUMNS,
 	PSSCAN_RUIDGID  = (1 << 21) * ENABLE_FEATURE_PS_ADDITIONAL_COLUMNS,
 	PSSCAN_TASKS	= (1 << 22) * ENABLE_FEATURE_SHOW_THREADS,
 	/* These are all retrieved from proc/NN/stat in one go: */
 	PSSCAN_STAT     = PSSCAN_PPID | PSSCAN_PGID | PSSCAN_SID
 	/**/            | PSSCAN_COMM | PSSCAN_STATE
 	/**/            | PSSCAN_VSZ | PSSCAN_RSS
 	/**/            | PSSCAN_STIME | PSSCAN_UTIME | PSSCAN_START_TIME
 	/**/            | PSSCAN_TTY | PSSCAN_NICE
 	/**/            | PSSCAN_CPU
 };
 //procps_status_t* alloc_procps_scan(void) FAST_FUNC;
 void free_procps_scan(procps_status_t* sp) FAST_FUNC;
 procps_status_t* procps_scan(procps_status_t* sp, int flags) FAST_FUNC;
 /* Format cmdline (up to col chars) into char buf[size] */
 /* Puts [comm] if cmdline is empty (-> process is a kernel thread) */
 void read_cmdline(char *buf, int size, unsigned pid, const char *comm) FAST_FUNC;
 pid_t *find_pid_by_name(const char* procName) FAST_FUNC;
 pid_t *pidlist_reverse(pid_t *pidList) FAST_FUNC;
 int starts_with_cpu(const char *str) FAST_FUNC;
 unsigned get_cpu_count(void) FAST_FUNC;
 
 
 extern const char bb_uuenc_tbl_base64[];
 extern const char bb_uuenc_tbl_std[];
 void bb_uuencode(char *store, const void *s, int length, const char *tbl) FAST_FUNC;
 
 typedef struct sha1_ctx_t {
 	uint32_t hash[8];    /* 5, +3 elements for sha256 */
 	uint64_t total64;
 	uint8_t wbuffer[64]; /* NB: always correctly aligned for uint64_t */
 	void (*process_block)(struct sha1_ctx_t*) FAST_FUNC;
 } sha1_ctx_t;
 void sha1_begin(sha1_ctx_t *ctx) FAST_FUNC;
 void sha1_hash(const void *data, size_t length, sha1_ctx_t *ctx) FAST_FUNC;
 void sha1_end(void *resbuf, sha1_ctx_t *ctx) FAST_FUNC;
 typedef struct sha1_ctx_t sha256_ctx_t;
 void sha256_begin(sha256_ctx_t *ctx) FAST_FUNC;
 #define sha256_hash sha1_hash
 #define sha256_end sha1_end
 typedef struct sha512_ctx_t {
 	uint64_t hash[8];
 	uint64_t total64[2];
 	uint8_t wbuffer[128]; /* NB: always correctly aligned for uint64_t */
 } sha512_ctx_t;
 void sha512_begin(sha512_ctx_t *ctx) FAST_FUNC;
 void sha512_hash(const void *buffer, size_t len, sha512_ctx_t *ctx) FAST_FUNC;
 void sha512_end(void *resbuf, sha512_ctx_t *ctx) FAST_FUNC;
 #if 1
 typedef struct md5_ctx_t {
 	uint32_t A;
 	uint32_t B;
 	uint32_t C;
 	uint32_t D;
 	uint64_t total;
 	uint32_t buflen;
 	char buffer[128];
 } md5_ctx_t;
 #else
 /* libbb/md5prime.c uses a bit different one: */
 typedef struct md5_ctx_t {
 	uint32_t state[4];	/* state (ABCD) */
 	uint32_t count[2];	/* number of bits, modulo 2^64 (lsb first) */
 	unsigned char buffer[64];	/* input buffer */
 } md5_ctx_t;
 #endif
 void md5_begin(md5_ctx_t *ctx) FAST_FUNC;
 void md5_hash(const void *data, size_t length, md5_ctx_t *ctx) FAST_FUNC;
 void md5_end(void *resbuf, md5_ctx_t *ctx) FAST_FUNC;
 
 
 uint32_t *crc32_filltable(uint32_t *tbl256, int endian) FAST_FUNC;
 
 typedef struct masks_labels_t {
 	const char *labels;
 	const int masks[];
 } masks_labels_t;
 int print_flags_separated(const int *masks, const char *labels,
 		int flags, const char *separator) FAST_FUNC;
 int print_flags(const masks_labels_t *ml, int flags) FAST_FUNC;
 
 typedef struct bb_progress_t {
 	off_t lastsize;
 	unsigned lastupdate_sec;
 	unsigned start_sec;
 	smallint inited;
 } bb_progress_t;
 
 void bb_progress_init(bb_progress_t *p) FAST_FUNC;
 void bb_progress_update(bb_progress_t *p, const char *curfile,
 			off_t beg_range, off_t transferred,
 			off_t totalsize) FAST_FUNC;
 
 extern const char *applet_name;
+
+/* Some older linkers don't perform string merging, we used to have common strings
+ * as global arrays to do it by hand. But:
+ * (1) newer linkers do it themselves,
+ * (2) however, they DONT merge string constants with global arrays,
+ * even if the value is the same (!). Thus global arrays actually
+ * increased size a bit: for example, "/etc/passwd" string from libc
+ * wasn't merged with bb_path_passwd_file[] array!
+ * Therefore now we use #defines.
+ */
 /* "BusyBox vN.N.N (timestamp or extra_version)" */
 extern const char bb_banner[];
 extern const char bb_msg_memory_exhausted[];
 extern const char bb_msg_invalid_date[];
-extern const char bb_msg_read_error[];
-extern const char bb_msg_write_error[];
+#define bb_msg_read_error "read error"
+#define bb_msg_write_error "write error"
 extern const char bb_msg_unknown[];
 extern const char bb_msg_can_not_create_raw_socket[];
 extern const char bb_msg_perm_denied_are_you_root[];
 extern const char bb_msg_you_must_be_root[];
 extern const char bb_msg_requires_arg[];
 extern const char bb_msg_invalid_arg[];
 extern const char bb_msg_standard_input[];
 extern const char bb_msg_standard_output[];
 
-extern const char bb_str_default[];
 /* NB: (bb_hexdigits_upcase[i] | 0x20) -> lowercase hex digit */
 extern const char bb_hexdigits_upcase[];
 
-extern const char bb_path_mtab_file[];
-extern const char bb_path_passwd_file[];
-extern const char bb_path_shadow_file[];
-extern const char bb_path_gshadow_file[];
-extern const char bb_path_group_file[];
-extern const char bb_path_motd_file[];
 extern const char bb_path_wtmp_file[];
-extern const char bb_dev_null[];
+
+/* Busybox mount uses either /proc/mounts or /etc/mtab to
+ * get the list of currently mounted filesystems */
+#define bb_path_mtab_file IF_FEATURE_MTAB_SUPPORT("/etc/mtab")IF_NOT_FEATURE_MTAB_SUPPORT("/proc/mounts")
+
+#define bb_path_passwd_file "/etc/passwd"
+#define bb_path_shadow_file "/etc/shadow"
+#define bb_path_gshadow_file "/etc/gshadow"
+#define bb_path_group_file "/etc/group"
+
+#define bb_path_motd_file "/etc/motd"
+
+#define bb_dev_null "/dev/null"
 extern const char bb_busybox_exec_path[];
 /* util-linux manpage says /sbin:/bin:/usr/sbin:/usr/bin,
  * but I want to save a few bytes here */
 extern const char bb_PATH_root_path[]; /* "PATH=/sbin:/usr/sbin:/bin:/usr/bin" */
 #define bb_default_root_path (bb_PATH_root_path + sizeof("PATH"))
 #define bb_default_path      (bb_PATH_root_path + sizeof("PATH=/sbin:/usr/sbin"))
 
 extern const int const_int_0;
 extern const int const_int_1;
 
 
 /* Providing hard guarantee on minimum size (think of BUFSIZ == 128) */
 enum { COMMON_BUFSIZE = (BUFSIZ >= 256*sizeof(void*) ? BUFSIZ+1 : 256*sizeof(void*)) };
 extern char bb_common_bufsiz1[COMMON_BUFSIZE];
 /* This struct is deliberately not defined. */
 /* See docs/keep_data_small.txt */
 struct globals;
 /* '*const' ptr makes gcc optimize code much better.
  * Magic prevents ptr_to_globals from going into rodata.
  * If you want to assign a value, use SET_PTR_TO_GLOBALS(x) */
 extern struct globals *const ptr_to_globals;
 /* At least gcc 3.4.6 on mipsel system needs optimization barrier */
 #define barrier() __asm__ __volatile__("":::"memory")
 #define SET_PTR_TO_GLOBALS(x) do { \
 	(*(struct globals**)&ptr_to_globals) = (void*)(x); \
 	barrier(); \
 } while (0)
 
 /* You can change LIBBB_DEFAULT_LOGIN_SHELL, but don't use it,
  * use bb_default_login_shell and following defines.
  * If you change LIBBB_DEFAULT_LOGIN_SHELL,
  * don't forget to change increment constant. */
 #define LIBBB_DEFAULT_LOGIN_SHELL  "-/bin/sh"
 extern const char bb_default_login_shell[];
 /* "/bin/sh" */
 #define DEFAULT_SHELL              (bb_default_login_shell+1)
 /* "sh" */
 #define DEFAULT_SHELL_SHORT_NAME   (bb_default_login_shell+6)
 
 /* The following devices are the same on all systems.  */
 #define CURRENT_TTY "/dev/tty"
 #define DEV_CONSOLE "/dev/console"
 
 #if defined(__FreeBSD_kernel__)
 # define CURRENT_VC CURRENT_TTY
 # define VC_1 "/dev/ttyv0"
 # define VC_2 "/dev/ttyv1"
 # define VC_3 "/dev/ttyv2"
 # define VC_4 "/dev/ttyv3"
 # define VC_5 "/dev/ttyv4"
 # define VC_FORMAT "/dev/ttyv%d"
 #elif defined(__GNU__)
 # define CURRENT_VC CURRENT_TTY
 # define VC_1 "/dev/tty1"
 # define VC_2 "/dev/tty2"
 # define VC_3 "/dev/tty3"
 # define VC_4 "/dev/tty4"
 # define VC_5 "/dev/tty5"
 # define VC_FORMAT "/dev/tty%d"
 #elif ENABLE_FEATURE_DEVFS /* from now on, assume Linux naming */
 # define CURRENT_VC "/dev/vc/0"
 # define VC_1 "/dev/vc/1"
 # define VC_2 "/dev/vc/2"
 # define VC_3 "/dev/vc/3"
 # define VC_4 "/dev/vc/4"
 # define VC_5 "/dev/vc/5"
 # if defined(__sh__) || defined(__H8300H__) || defined(__H8300S__)
 /* Yes, this sucks, but both SH (including sh64) and H8 have a SCI(F) for their
    respective serial ports .. as such, we can't use the common device paths for
    these. -- PFM */
 #  define SC_0 "/dev/ttsc/0"
 #  define SC_1 "/dev/ttsc/1"
 #  define SC_FORMAT "/dev/ttsc/%d"
 # else
 #  define SC_0 "/dev/tts/0"
 #  define SC_1 "/dev/tts/1"
 #  define SC_FORMAT "/dev/tts/%d"
 # endif
 # define VC_FORMAT "/dev/vc/%d"
 # define LOOP_FORMAT "/dev/loop/%d"
 # define LOOP_NAMESIZE (sizeof("/dev/loop/") + sizeof(int)*3 + 1)
 # define LOOP_NAME "/dev/loop/"
 # define FB_0 "/dev/fb/0"
 #else
 # define CURRENT_VC "/dev/tty0"
 # define VC_1 "/dev/tty1"
 # define VC_2 "/dev/tty2"
 # define VC_3 "/dev/tty3"
 # define VC_4 "/dev/tty4"
 # define VC_5 "/dev/tty5"
 # if defined(__sh__) || defined(__H8300H__) || defined(__H8300S__)
 #  define SC_0 "/dev/ttySC0"
 #  define SC_1 "/dev/ttySC1"
 #  define SC_FORMAT "/dev/ttySC%d"
 # else
 #  define SC_0 "/dev/ttyS0"
 #  define SC_1 "/dev/ttyS1"
 #  define SC_FORMAT "/dev/ttyS%d"
 # endif
 # define VC_FORMAT "/dev/tty%d"
 # define LOOP_FORMAT "/dev/loop%d"
 # define LOOP_NAMESIZE (sizeof("/dev/loop") + sizeof(int)*3 + 1)
 # define LOOP_NAME "/dev/loop"
 # define FB_0 "/dev/fb0"
 #endif
 
 
 #define ARRAY_SIZE(x) ((unsigned)(sizeof(x) / sizeof((x)[0])))
 
 
 /* We redefine ctype macros. Unicode-correct handling of char types
  * can't be done with such byte-oriented operations anyway,
  * we don't lose anything.
  */
 #undef isalnum
 #undef isalpha
 #undef isascii
 #undef isblank
 #undef iscntrl
 #undef isdigit
 #undef isgraph
 #undef islower
 #undef isprint
 #undef ispunct
 #undef isspace
 #undef isupper
 #undef isxdigit
 #undef toupper
 #undef tolower
 
 /* We save ~500 bytes on isdigit alone.
  * BTW, x86 likes (unsigned char) cast more than (unsigned). */
 
 /* These work the same for ASCII and Unicode,
  * assuming no one asks "is this a *Unicode* letter?" using isalpha(letter) */
 #define isascii(a) ((unsigned char)(a) <= 0x7f)
 #define isdigit(a) ((unsigned char)((a) - '0') <= 9)
 #define isupper(a) ((unsigned char)((a) - 'A') <= ('Z' - 'A'))
 #define islower(a) ((unsigned char)((a) - 'a') <= ('z' - 'a'))
 #define isalpha(a) ((unsigned char)(((a)|0x20) - 'a') <= ('z' - 'a'))
 #define isblank(a) ({ unsigned char bb__isblank = (a); bb__isblank == ' ' || bb__isblank == '\t'; })
 #define iscntrl(a) ({ unsigned char bb__iscntrl = (a); bb__iscntrl < ' ' || bb__iscntrl == 0x7f; })
 /* In POSIX/C locale isspace is only these chars: "\t\n\v\f\r" and space.
  * "\t\n\v\f\r" happen to have ASCII codes 9,10,11,12,13.
  */
 #define isspace(a) ({ unsigned char bb__isspace = (a) - 9; bb__isspace == (' ' - 9) || bb__isspace <= (13 - 9); })
 // Unsafe wrt NUL: #define ispunct(a) (strchr("!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~", (a)) != NULL)
 #define ispunct(a) (strchrnul("!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~", (a))[0])
 // Bigger code: #define isalnum(a) ({ unsigned char bb__isalnum = (a) - '0'; bb__isalnum <= 9 || ((bb__isalnum - ('A' - '0')) & 0xdf) <= 25; })
 #define isalnum(a) bb_ascii_isalnum(a)
 static ALWAYS_INLINE int bb_ascii_isalnum(unsigned char a)
 {
 	unsigned char b = a - '0';
 	if (b <= 9)
 		return (b <= 9);
 	b = (a|0x20) - 'a';
 	return b <= 'z' - 'a';
 }
 #define isxdigit(a) bb_ascii_isxdigit(a)
 static ALWAYS_INLINE int bb_ascii_isxdigit(unsigned char a)
 {
 	unsigned char b = a - '0';
 	if (b <= 9)
 		return (b <= 9);
 	b = (a|0x20) - 'a';
 	return b <= 'f' - 'a';
 }
 #define toupper(a) bb_ascii_toupper(a)
 static ALWAYS_INLINE unsigned char bb_ascii_toupper(unsigned char a)
 {
 	unsigned char b = a - 'a';
 	if (b <= ('z' - 'a'))
 		a -= 'a' - 'A';
 	return a;
 }
 #define tolower(a) bb_ascii_tolower(a)
 static ALWAYS_INLINE unsigned char bb_ascii_tolower(unsigned char a)
 {
 	unsigned char b = a - 'A';
 	if (b <= ('Z' - 'A'))
 		a += 'a' - 'A';
 	return a;
 }
 
 /* In ASCII and Unicode, these are likely to be very different.
  * Let's prevent ambiguous usage from the start */
 #define isgraph(a) isgraph_is_ambiguous_dont_use(a)
 #define isprint(a) isprint_is_ambiguous_dont_use(a)
 /* NB: must not treat EOF as isgraph or isprint */
 #define isgraph_asciionly(a) ((unsigned)((a) - 0x21) <= 0x7e - 0x21)
 #define isprint_asciionly(a) ((unsigned)((a) - 0x20) <= 0x7e - 0x20)
 
 
 POP_SAVED_FUNCTION_VISIBILITY
 
 #endif
diff --git a/libbb/Kbuild.src b/libbb/Kbuild.src
index 5db4d8a..b02fcfe 100644
--- a/libbb/Kbuild.src
+++ b/libbb/Kbuild.src
@@ -1,176 +1,175 @@
 # Makefile for busybox
 #
 # Copyright (C) 1999-2005 by Erik Andersen <andersen@codepoet.org>
 #
 # Licensed under GPLv2, see file LICENSE in this source tree.
 
 libbb/appletlib.o: include/usage_compressed.h
 
 lib-y:=
 
 INSERT
 
 lib-y += appletlib.o
 lib-y += ask_confirmation.o
 lib-y += bb_askpass.o
 lib-y += bb_basename.o
 lib-y += bb_do_delay.o
 lib-y += bb_pwd.o
 lib-y += bb_qsort.o
 #lib-y += bb_strtod.o
 lib-y += bb_strtonum.o
 lib-y += change_identity.o
 lib-y += chomp.o
 lib-y += compare_string_array.o
 lib-y += concat_path_file.o
 lib-y += concat_subpath_file.o
 lib-y += copy_file.o
 lib-y += copyfd.o
 lib-y += crc32.o
 lib-y += create_icmp6_socket.o
 lib-y += create_icmp_socket.o
 lib-y += default_error_retval.o
 lib-y += device_open.o
 lib-y += dump.o
 lib-y += execable.o
 lib-y += fclose_nonstdin.o
 lib-y += fflush_stdout_and_exit.o
 lib-y += fgets_str.o
 lib-y += find_pid_by_name.o
 lib-y += find_root_device.o
 lib-y += full_write.o
 lib-y += get_console.o
 lib-y += get_last_path_component.o
 lib-y += get_line_from_file.o
 lib-y += getopt32.o
 lib-y += getpty.o
 lib-y += get_volsize.o
 lib-y += herror_msg.o
 lib-y += human_readable.o
 lib-y += inet_common.o
 lib-y += info_msg.o
 lib-y += inode_hash.o
 lib-y += isdirectory.o
 lib-y += kernel_version.o
 lib-y += last_char_is.o
 lib-y += lineedit.o lineedit_ptr_hack.o
 lib-y += llist.o
 lib-y += login.o
 lib-y += make_directory.o
 lib-y += makedev.o
 lib-y += match_fstype.o
 lib-y += md5.o
 # Alternative (disabled) implementation
 #lib-y += md5prime.o
 lib-y += messages.o
 lib-y += mode_string.o
-lib-y += mtab_file.o
 lib-y += obscure.o
 lib-y += parse_mode.o
 lib-y += parse_config.o
 lib-y += perror_msg.o
 lib-y += perror_nomsg.o
 lib-y += perror_nomsg_and_die.o
 lib-y += pidfile.o
 lib-y += platform.o
 lib-y += printable.o
 lib-y += printable_string.o
 lib-y += print_flags.o
 lib-y += process_escape_sequence.o
 lib-y += procps.o
 lib-y += progress.o
 lib-y += ptr_to_globals.o
 lib-y += read.o
 lib-y += read_printf.o
 lib-y += read_key.o
 lib-y += recursive_action.o
 lib-y += remove_file.o
 lib-y += run_shell.o
 lib-y += safe_gethostname.o
 lib-y += safe_poll.o
 lib-y += safe_strncpy.o
 lib-y += safe_write.o
 lib-y += setup_environment.o
 lib-y += sha1.o
 lib-y += signals.o
 lib-y += simplify_path.o
 lib-y += single_argv.o
 lib-y += skip_whitespace.o
 lib-y += speed_table.o
 lib-y += str_tolower.o
 lib-y += strrstr.o
 lib-y += time.o
 lib-y += trim.o
 lib-y += u_signal_names.o
 lib-y += udp_io.o
 lib-y += uuencode.o
 lib-y += vdprintf.o
 lib-y += verror_msg.o
 lib-y += vfork_daemon_rexec.o
 lib-y += warn_ignoring_args.o
 lib-y += wfopen.o
 lib-y += wfopen_input.o
 lib-y += write.o
 lib-y += xatonum.o
 lib-y += xconnect.o
 lib-y += xfuncs.o
 lib-y += xfuncs_printf.o
 lib-y += xfunc_die.o
 lib-y += xgetcwd.o
 lib-y += xgethostbyname.o
 lib-y += xreadlink.o
 lib-y += xrealloc_vector.o
 
 lib-$(CONFIG_FEATURE_UTMP) += utmp.o
 
 # A mix of optimizations (why build stuff we know won't be used)
 # and objects which may fail to build (SELinux on selinux-less system)
 lib-$(CONFIG_SELINUX) += selinux_common.o
 lib-$(CONFIG_FEATURE_MTAB_SUPPORT) += mtab.o
 lib-$(CONFIG_UNICODE_SUPPORT) += unicode.o
 lib-$(CONFIG_FEATURE_CHECK_NAMES) += die_if_bad_username.o
 
 lib-$(CONFIG_LOSETUP) += loop.o
 lib-$(CONFIG_FEATURE_MOUNT_LOOP) += loop.o
 
 lib-$(CONFIG_ADDGROUP) += update_passwd.o
 lib-$(CONFIG_ADDUSER) += update_passwd.o
 lib-$(CONFIG_DELGROUP) += update_passwd.o
 lib-$(CONFIG_DELUSER) += update_passwd.o
 
 lib-$(CONFIG_PASSWD) += pw_encrypt.o update_passwd.o
 lib-$(CONFIG_CHPASSWD) += pw_encrypt.o update_passwd.o
 lib-$(CONFIG_CRYPTPW) += pw_encrypt.o
 lib-$(CONFIG_SULOGIN) += pw_encrypt.o
 lib-$(CONFIG_VLOCK) += pw_encrypt.o correct_password.o
 lib-$(CONFIG_SU) += pw_encrypt.o correct_password.o
 lib-$(CONFIG_LOGIN) += pw_encrypt.o correct_password.o
 lib-$(CONFIG_FEATURE_HTTPD_AUTH_MD5) += pw_encrypt.o
 
 lib-$(CONFIG_DF) += find_mount_point.o
 lib-$(CONFIG_MKFS_MINIX) += find_mount_point.o
 lib-$(CONFIG_MKFS_EXT2) += find_mount_point.o
 lib-$(CONFIG_MKFS_REISER) += find_mount_point.o
 lib-$(CONFIG_FSCK_MINIX) += find_mount_point.o
 lib-$(CONFIG_MOUNT) += find_mount_point.o
 
 lib-$(CONFIG_HWCLOCK) += rtc.o
 lib-$(CONFIG_RTCWAKE) += rtc.o
 
 lib-$(CONFIG_IOSTAT) += get_cpu_count.o
 lib-$(CONFIG_MPSTAT) += get_cpu_count.o
 
 # We shouldn't build xregcomp.c if we don't need it - this ensures we don't
 # require regex.h to be in the include dir even if we don't need it thereby
 # allowing us to build busybox even if uclibc regex support is disabled.
 
 lib-$(CONFIG_AWK) += xregcomp.o
 lib-$(CONFIG_SED) += xregcomp.o
 lib-$(CONFIG_GREP) += xregcomp.o
 lib-$(CONFIG_EXPR) += xregcomp.o
 lib-$(CONFIG_MDEV) += xregcomp.o
 lib-$(CONFIG_LESS) += xregcomp.o
 lib-$(CONFIG_PGREP) += xregcomp.o
 lib-$(CONFIG_PKILL) += xregcomp.o
 lib-$(CONFIG_DEVFSD) += xregcomp.o
 lib-$(CONFIG_FEATURE_FIND_REGEX) += xregcomp.o
diff --git a/libbb/inet_common.c b/libbb/inet_common.c
index b472590..e031ddf 100644
--- a/libbb/inet_common.c
+++ b/libbb/inet_common.c
@@ -1,221 +1,221 @@
 /* vi: set sw=4 ts=4: */
 /*
  * stolen from net-tools-1.59 and stripped down for busybox by
  *                      Erik Andersen <andersen@codepoet.org>
  *
  * Heavily modified by Manuel Novoa III       Mar 12, 2001
  *
  * Licensed under GPLv2, see file LICENSE in this source tree.
  */
 
 #include "libbb.h"
 #include "inet_common.h"
 
 int FAST_FUNC INET_resolve(const char *name, struct sockaddr_in *s_in, int hostfirst)
 {
 	struct hostent *hp;
 #if ENABLE_FEATURE_ETC_NETWORKS
 	struct netent *np;
 #endif
 
 	/* Grmpf. -FvK */
 	s_in->sin_family = AF_INET;
 	s_in->sin_port = 0;
 
 	/* Default is special, meaning 0.0.0.0. */
-	if (!strcmp(name, bb_str_default)) {
+	if (strcmp(name, "default") == 0) {
 		s_in->sin_addr.s_addr = INADDR_ANY;
 		return 1;
 	}
 	/* Look to see if it's a dotted quad. */
 	if (inet_aton(name, &s_in->sin_addr)) {
 		return 0;
 	}
 	/* If we expect this to be a hostname, try hostname database first */
 #ifdef DEBUG
 	if (hostfirst) {
 		bb_error_msg("gethostbyname(%s)", name);
 	}
 #endif
 	if (hostfirst) {
 		hp = gethostbyname(name);
 		if (hp != NULL) {
 			memcpy(&s_in->sin_addr, hp->h_addr_list[0],
 				sizeof(struct in_addr));
 			return 0;
 		}
 	}
 #if ENABLE_FEATURE_ETC_NETWORKS
 	/* Try the NETWORKS database to see if this is a known network. */
 #ifdef DEBUG
 	bb_error_msg("getnetbyname(%s)", name);
 #endif
 	np = getnetbyname(name);
 	if (np != NULL) {
 		s_in->sin_addr.s_addr = htonl(np->n_net);
 		return 1;
 	}
 #endif
 	if (hostfirst) {
 		/* Don't try again */
 		return -1;
 	}
 #ifdef DEBUG
 	res_init();
 	_res.options |= RES_DEBUG;
 	bb_error_msg("gethostbyname(%s)", name);
 #endif
 	hp = gethostbyname(name);
 	if (hp == NULL) {
 		return -1;
 	}
 	memcpy(&s_in->sin_addr, hp->h_addr_list[0], sizeof(struct in_addr));
 	return 0;
 }
 
 
 /* numeric: & 0x8000: default instead of *,
  *          & 0x4000: host instead of net,
  *          & 0x0fff: don't resolve
  */
 char* FAST_FUNC INET_rresolve(struct sockaddr_in *s_in, int numeric, uint32_t netmask)
 {
 	/* addr-to-name cache */
 	struct addr {
 		struct addr *next;
 		struct sockaddr_in addr;
 		int host;
 		char name[1];
 	};
 	static struct addr *cache = NULL;
 
 	struct addr *pn;
 	char *name;
 	uint32_t ad, host_ad;
 	int host = 0;
 
 	if (s_in->sin_family != AF_INET) {
 #ifdef DEBUG
 		bb_error_msg("rresolve: unsupported address family %d!",
 				  s_in->sin_family);
 #endif
 		errno = EAFNOSUPPORT;
 		return NULL;
 	}
 	ad = s_in->sin_addr.s_addr;
 #ifdef DEBUG
 	bb_error_msg("rresolve: %08x, mask %08x, num %08x", (unsigned)ad, netmask, numeric);
 #endif
 	if (ad == INADDR_ANY) {
 		if ((numeric & 0x0FFF) == 0) {
 			if (numeric & 0x8000)
-				return xstrdup(bb_str_default);
+				return xstrdup("default");
 			return xstrdup("*");
 		}
 	}
 	if (numeric & 0x0FFF)
 		return xstrdup(inet_ntoa(s_in->sin_addr));
 
 	if ((ad & (~netmask)) != 0 || (numeric & 0x4000))
 		host = 1;
 	pn = cache;
 	while (pn) {
 		if (pn->addr.sin_addr.s_addr == ad && pn->host == host) {
 #ifdef DEBUG
 			bb_error_msg("rresolve: found %s %08x in cache",
 					  (host ? "host" : "net"), (unsigned)ad);
 #endif
 			return xstrdup(pn->name);
 		}
 		pn = pn->next;
 	}
 
 	host_ad = ntohl(ad);
 	name = NULL;
 	if (host) {
 		struct hostent *ent;
 #ifdef DEBUG
 		bb_error_msg("gethostbyaddr (%08x)", (unsigned)ad);
 #endif
 		ent = gethostbyaddr((char *) &ad, 4, AF_INET);
 		if (ent)
 			name = xstrdup(ent->h_name);
 	} else if (ENABLE_FEATURE_ETC_NETWORKS) {
 		struct netent *np;
 #ifdef DEBUG
 		bb_error_msg("getnetbyaddr (%08x)", (unsigned)host_ad);
 #endif
 		np = getnetbyaddr(host_ad, AF_INET);
 		if (np)
 			name = xstrdup(np->n_name);
 	}
 	if (!name)
 		name = xstrdup(inet_ntoa(s_in->sin_addr));
 	pn = xmalloc(sizeof(*pn) + strlen(name)); /* no '+ 1', it's already accounted for */
 	pn->next = cache;
 	pn->addr = *s_in;
 	pn->host = host;
 	strcpy(pn->name, name);
 	cache = pn;
 	return name;
 }
 
 #if ENABLE_FEATURE_IPV6
 
 int FAST_FUNC INET6_resolve(const char *name, struct sockaddr_in6 *sin6)
 {
 	struct addrinfo req, *ai;
 	int s;
 
 	memset(&req, '\0', sizeof req);
 	req.ai_family = AF_INET6;
 	s = getaddrinfo(name, NULL, &req, &ai);
 	if (s) {
 		bb_error_msg("getaddrinfo: %s: %d", name, s);
 		return -1;
 	}
 	memcpy(sin6, ai->ai_addr, sizeof(struct sockaddr_in6));
 	freeaddrinfo(ai);
 	return 0;
 }
 
 #ifndef IN6_IS_ADDR_UNSPECIFIED
 # define IN6_IS_ADDR_UNSPECIFIED(a) \
 	(((uint32_t *) (a))[0] == 0 && ((uint32_t *) (a))[1] == 0 && \
 	 ((uint32_t *) (a))[2] == 0 && ((uint32_t *) (a))[3] == 0)
 #endif
 
 
 char* FAST_FUNC INET6_rresolve(struct sockaddr_in6 *sin6, int numeric)
 {
 	char name[128];
 	int s;
 
 	if (sin6->sin6_family != AF_INET6) {
 #ifdef DEBUG
 		bb_error_msg("rresolve: unsupported address family %d!",
 				  sin6->sin6_family);
 #endif
 		errno = EAFNOSUPPORT;
 		return NULL;
 	}
 	if (numeric & 0x7FFF) {
 		inet_ntop(AF_INET6, &sin6->sin6_addr, name, sizeof(name));
 		return xstrdup(name);
 	}
 	if (IN6_IS_ADDR_UNSPECIFIED(&sin6->sin6_addr)) {
 		if (numeric & 0x8000)
-			return xstrdup(bb_str_default);
+			return xstrdup("default");
 		return xstrdup("*");
 	}
 
 	s = getnameinfo((struct sockaddr *) sin6, sizeof(struct sockaddr_in6),
 				name, sizeof(name), NULL, 0, 0);
 	if (s) {
 		bb_error_msg("getnameinfo failed");
 		return NULL;
 	}
 	return xstrdup(name);
 }
 
 #endif		/* CONFIG_FEATURE_IPV6 */
diff --git a/libbb/messages.c b/libbb/messages.c
index 44b3994..66e466f 100644
--- a/libbb/messages.c
+++ b/libbb/messages.c
@@ -1,74 +1,65 @@
 /* vi: set sw=4 ts=4: */
 /*
  * Copyright (C) 1999-2004 by Erik Andersen <andersen@codepoet.org>
  *
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 
 #include "libbb.h"
 
 /* allow default system PATH to be extended via CFLAGS */
 #ifndef BB_ADDITIONAL_PATH
 #define BB_ADDITIONAL_PATH ""
 #endif
 
 /* allow version to be extended, via CFLAGS */
 #ifndef BB_EXTRA_VERSION
 #define BB_EXTRA_VERSION BB_BT
 #endif
 
 #define BANNER "BusyBox v" BB_VER " (" BB_EXTRA_VERSION ")"
 
 const char bb_banner[] ALIGN1 = BANNER;
 
 
 const char bb_msg_memory_exhausted[] ALIGN1 = "memory exhausted";
 const char bb_msg_invalid_date[] ALIGN1 = "invalid date '%s'";
-const char bb_msg_write_error[] ALIGN1 = "write error";
-const char bb_msg_read_error[] ALIGN1 = "read error";
 const char bb_msg_unknown[] ALIGN1 = "(unknown)";
 const char bb_msg_can_not_create_raw_socket[] ALIGN1 = "can't create raw socket";
 const char bb_msg_perm_denied_are_you_root[] ALIGN1 = "permission denied (are you root?)";
 const char bb_msg_you_must_be_root[] ALIGN1 = "you must be root";
 const char bb_msg_requires_arg[] ALIGN1 = "%s requires an argument";
 const char bb_msg_invalid_arg[] ALIGN1 = "invalid argument '%s' to '%s'";
 const char bb_msg_standard_input[] ALIGN1 = "standard input";
 const char bb_msg_standard_output[] ALIGN1 = "standard output";
 
-const char bb_str_default[] ALIGN1 = "default";
 const char bb_hexdigits_upcase[] ALIGN1 = "0123456789ABCDEF";
 
-const char bb_path_passwd_file[] ALIGN1 = "/etc/passwd";
-const char bb_path_shadow_file[] ALIGN1 = "/etc/shadow";
-const char bb_path_group_file[] ALIGN1 = "/etc/group";
-const char bb_path_gshadow_file[] ALIGN1 = "/etc/gshadow";
-const char bb_path_motd_file[] ALIGN1 = "/etc/motd";
-const char bb_dev_null[] ALIGN1 = "/dev/null";
 const char bb_busybox_exec_path[] ALIGN1 = CONFIG_BUSYBOX_EXEC_PATH;
 const char bb_default_login_shell[] ALIGN1 = LIBBB_DEFAULT_LOGIN_SHELL;
 /* util-linux manpage says /sbin:/bin:/usr/sbin:/usr/bin,
  * but I want to save a few bytes here. Check libbb.h before changing! */
 const char bb_PATH_root_path[] ALIGN1 =
 	"PATH=/sbin:/usr/sbin:/bin:/usr/bin" BB_ADDITIONAL_PATH;
 
 
 const int const_int_1 = 1;
 /* explicitly = 0, otherwise gcc may make it a common variable
  * and it will end up in bss */
 const int const_int_0 = 0;
 
 #include <utmp.h>
 /* This is usually something like "/var/adm/wtmp" or "/var/log/wtmp" */
 const char bb_path_wtmp_file[] ALIGN1 =
 #if defined _PATH_WTMP
 	_PATH_WTMP;
 #elif defined WTMP_FILE
 	WTMP_FILE;
 #else
 #error unknown path to wtmp file
 #endif
 
 /* We use it for "global" data via *(struct global*)&bb_common_bufsiz1.
  * Since gcc insists on aligning struct global's members, it would be a pity
  * (and an alignment fault on some CPUs) to mess it up. */
 char bb_common_bufsiz1[COMMON_BUFSIZE] ALIGNED(sizeof(long long));
diff --git a/libbb/mtab_file.c b/libbb/mtab_file.c
deleted file mode 100644
index add990d..0000000
--- a/libbb/mtab_file.c
+++ /dev/null
@@ -1,15 +0,0 @@
-/* vi: set sw=4 ts=4: */
-/*
- * Utility routines.
- *
- * Copyright (C) 1999-2004 by Erik Andersen <andersen@codepoet.org>
- *
- * Licensed under GPLv2 or later, see file LICENSE in this source tree.
- */
-
-#include "libbb.h"
-
-/* Busybox mount uses either /proc/mounts or /etc/mtab to
- * get the list of currently mounted filesystems */
-const char bb_path_mtab_file[] ALIGN1 =
-IF_FEATURE_MTAB_SUPPORT("/etc/mtab")IF_NOT_FEATURE_MTAB_SUPPORT("/proc/mounts");
diff --git a/networking/ifconfig.c b/networking/ifconfig.c
index 853910f..da2635c 100644
--- a/networking/ifconfig.c
+++ b/networking/ifconfig.c
@@ -1,538 +1,538 @@
 /* vi: set sw=4 ts=4: */
 /* ifconfig
  *
  * Similar to the standard Unix ifconfig, but with only the necessary
  * parts for AF_INET, and without any printing of if info (for now).
  *
  * Bjorn Wesen, Axis Communications AB
  *
  *
  * Authors of the original ifconfig was:
  *              Fred N. van Kempen, <waltje@uwalt.nl.mugnet.org>
  *
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 
 /*
  * Heavily modified by Manuel Novoa III       Mar 6, 2001
  *
  * From initial port to busybox, removed most of the redundancy by
  * converting to a table-driven approach.  Added several (optional)
  * args missing from initial port.
  *
  * Still missing:  media, tunnel.
  *
  * 2002-04-20
  * IPV6 support added by Bart Visscher <magick@linux-fan.com>
  */
 
 #include <net/if.h>
 #include <net/if_arp.h>
 #include <netinet/in.h>
 #if defined(__GLIBC__) && __GLIBC__ >=2 && __GLIBC_MINOR__ >= 1
 #include <netpacket/packet.h>
 #include <net/ethernet.h>
 #else
 #include <sys/types.h>
 #include <netinet/if_ether.h>
 #endif
 #include "libbb.h"
 #include "inet_common.h"
 
 #if ENABLE_FEATURE_IFCONFIG_SLIP
 # include <net/if_slip.h>
 #endif
 
 /* I don't know if this is needed for busybox or not.  Anyone? */
 #define QUESTIONABLE_ALIAS_CASE
 
 
 /* Defines for glibc2.0 users. */
 #ifndef SIOCSIFTXQLEN
 # define SIOCSIFTXQLEN      0x8943
 # define SIOCGIFTXQLEN      0x8942
 #endif
 
 /* ifr_qlen is ifru_ivalue, but it isn't present in 2.0 kernel headers */
 #ifndef ifr_qlen
 # define ifr_qlen        ifr_ifru.ifru_mtu
 #endif
 
 #ifndef IFF_DYNAMIC
 # define IFF_DYNAMIC     0x8000	/* dialup device with changing addresses */
 #endif
 
 #if ENABLE_FEATURE_IPV6
 struct in6_ifreq {
 	struct in6_addr ifr6_addr;
 	uint32_t ifr6_prefixlen;
 	int ifr6_ifindex;
 };
 #endif
 
 /*
  * Here are the bit masks for the "flags" member of struct options below.
  * N_ signifies no arg prefix; M_ signifies arg prefixed by '-'.
  * CLR clears the flag; SET sets the flag; ARG signifies (optional) arg.
  */
 #define N_CLR            0x01
 #define M_CLR            0x02
 #define N_SET            0x04
 #define M_SET            0x08
 #define N_ARG            0x10
 #define M_ARG            0x20
 
 #define M_MASK           (M_CLR | M_SET | M_ARG)
 #define N_MASK           (N_CLR | N_SET | N_ARG)
 #define SET_MASK         (N_SET | M_SET)
 #define CLR_MASK         (N_CLR | M_CLR)
 #define SET_CLR_MASK     (SET_MASK | CLR_MASK)
 #define ARG_MASK         (M_ARG | N_ARG)
 
 /*
  * Here are the bit masks for the "arg_flags" member of struct options below.
  */
 
 /*
  * cast type:
  *   00 int
  *   01 char *
  *   02 HOST_COPY in_ether
  *   03 HOST_COPY INET_resolve
  */
 #define A_CAST_TYPE      0x03
 /*
  * map type:
  *   00 not a map type (mem_start, io_addr, irq)
  *   04 memstart (unsigned long)
  *   08 io_addr  (unsigned short)
  *   0C irq      (unsigned char)
  */
 #define A_MAP_TYPE       0x0C
 #define A_ARG_REQ        0x10	/* Set if an arg is required. */
 #define A_NETMASK        0x20	/* Set if netmask (check for multiple sets). */
 #define A_SET_AFTER      0x40	/* Set a flag at the end. */
 #define A_COLON_CHK      0x80	/* Is this needed?  See below. */
 #if ENABLE_FEATURE_IFCONFIG_BROADCAST_PLUS
 #define A_HOSTNAME      0x100	/* Set if it is ip addr. */
 #define A_BROADCAST     0x200	/* Set if it is broadcast addr. */
 #else
 #define A_HOSTNAME          0
 #define A_BROADCAST         0
 #endif
 
 /*
  * These defines are for dealing with the A_CAST_TYPE field.
  */
 #define A_CAST_CHAR_PTR  0x01
 #define A_CAST_RESOLVE   0x01
 #define A_CAST_HOST_COPY 0x02
 #define A_CAST_HOST_COPY_IN_ETHER    A_CAST_HOST_COPY
 #define A_CAST_HOST_COPY_RESOLVE     (A_CAST_HOST_COPY | A_CAST_RESOLVE)
 
 /*
  * These defines are for dealing with the A_MAP_TYPE field.
  */
 #define A_MAP_ULONG      0x04	/* memstart */
 #define A_MAP_USHORT     0x08	/* io_addr */
 #define A_MAP_UCHAR      0x0C	/* irq */
 
 /*
  * Define the bit masks signifying which operations to perform for each arg.
  */
 
 #define ARG_METRIC       (A_ARG_REQ /*| A_CAST_INT*/)
 #define ARG_MTU          (A_ARG_REQ /*| A_CAST_INT*/)
 #define ARG_TXQUEUELEN   (A_ARG_REQ /*| A_CAST_INT*/)
 #define ARG_MEM_START    (A_ARG_REQ | A_MAP_ULONG)
 #define ARG_IO_ADDR      (A_ARG_REQ | A_MAP_ULONG)
 #define ARG_IRQ          (A_ARG_REQ | A_MAP_UCHAR)
 #define ARG_DSTADDR      (A_ARG_REQ | A_CAST_HOST_COPY_RESOLVE)
 #define ARG_NETMASK      (A_ARG_REQ | A_CAST_HOST_COPY_RESOLVE | A_NETMASK)
 #define ARG_BROADCAST    (A_ARG_REQ | A_CAST_HOST_COPY_RESOLVE | A_SET_AFTER | A_BROADCAST)
 #define ARG_HW           (A_ARG_REQ | A_CAST_HOST_COPY_IN_ETHER)
 #define ARG_POINTOPOINT  (A_ARG_REQ | A_CAST_HOST_COPY_RESOLVE | A_SET_AFTER)
 #define ARG_KEEPALIVE    (A_ARG_REQ | A_CAST_CHAR_PTR)
 #define ARG_OUTFILL      (A_ARG_REQ | A_CAST_CHAR_PTR)
 #define ARG_HOSTNAME     (A_CAST_HOST_COPY_RESOLVE | A_SET_AFTER | A_COLON_CHK | A_HOSTNAME)
 #define ARG_ADD_DEL      (A_CAST_HOST_COPY_RESOLVE | A_SET_AFTER)
 
 
 /*
  * Set up the tables.  Warning!  They must have corresponding order!
  */
 
 struct arg1opt {
 	const char *name;
 	unsigned short selector;
 	unsigned short ifr_offset;
 };
 
 struct options {
 	const char *name;
 #if ENABLE_FEATURE_IFCONFIG_BROADCAST_PLUS
 	const unsigned int flags:6;
 	const unsigned int arg_flags:10;
 #else
 	const unsigned char flags;
 	const unsigned char arg_flags;
 #endif
 	const unsigned short selector;
 };
 
 #define ifreq_offsetof(x)  offsetof(struct ifreq, x)
 
 static const struct arg1opt Arg1Opt[] = {
 	{ "SIFMETRIC",  SIOCSIFMETRIC,  ifreq_offsetof(ifr_metric) },
 	{ "SIFMTU",     SIOCSIFMTU,     ifreq_offsetof(ifr_mtu) },
 	{ "SIFTXQLEN",  SIOCSIFTXQLEN,  ifreq_offsetof(ifr_qlen) },
 	{ "SIFDSTADDR", SIOCSIFDSTADDR, ifreq_offsetof(ifr_dstaddr) },
 	{ "SIFNETMASK", SIOCSIFNETMASK, ifreq_offsetof(ifr_netmask) },
 	{ "SIFBRDADDR", SIOCSIFBRDADDR, ifreq_offsetof(ifr_broadaddr) },
 #if ENABLE_FEATURE_IFCONFIG_HW
 	{ "SIFHWADDR",  SIOCSIFHWADDR,  ifreq_offsetof(ifr_hwaddr) },
 #endif
 	{ "SIFDSTADDR", SIOCSIFDSTADDR, ifreq_offsetof(ifr_dstaddr) },
 #ifdef SIOCSKEEPALIVE
 	{ "SKEEPALIVE", SIOCSKEEPALIVE, ifreq_offsetof(ifr_data) },
 #endif
 #ifdef SIOCSOUTFILL
 	{ "SOUTFILL",   SIOCSOUTFILL,   ifreq_offsetof(ifr_data) },
 #endif
 #if ENABLE_FEATURE_IFCONFIG_MEMSTART_IOADDR_IRQ
 	{ "SIFMAP",     SIOCSIFMAP,     ifreq_offsetof(ifr_map.mem_start) },
 	{ "SIFMAP",     SIOCSIFMAP,     ifreq_offsetof(ifr_map.base_addr) },
 	{ "SIFMAP",     SIOCSIFMAP,     ifreq_offsetof(ifr_map.irq) },
 #endif
 	/* Last entry if for unmatched (possibly hostname) arg. */
 #if ENABLE_FEATURE_IPV6
 	{ "SIFADDR",    SIOCSIFADDR,    ifreq_offsetof(ifr_addr) }, /* IPv6 version ignores the offset */
 	{ "DIFADDR",    SIOCDIFADDR,    ifreq_offsetof(ifr_addr) }, /* IPv6 version ignores the offset */
 #endif
 	{ "SIFADDR",    SIOCSIFADDR,    ifreq_offsetof(ifr_addr) },
 };
 
 static const struct options OptArray[] = {
 	{ "metric",      N_ARG,         ARG_METRIC,      0 },
 	{ "mtu",         N_ARG,         ARG_MTU,         0 },
 	{ "txqueuelen",  N_ARG,         ARG_TXQUEUELEN,  0 },
 	{ "dstaddr",     N_ARG,         ARG_DSTADDR,     0 },
 	{ "netmask",     N_ARG,         ARG_NETMASK,     0 },
 	{ "broadcast",   N_ARG | M_CLR, ARG_BROADCAST,   IFF_BROADCAST },
 #if ENABLE_FEATURE_IFCONFIG_HW
 	{ "hw",          N_ARG,         ARG_HW,          0 },
 #endif
 	{ "pointopoint", N_ARG | M_CLR, ARG_POINTOPOINT, IFF_POINTOPOINT },
 #ifdef SIOCSKEEPALIVE
 	{ "keepalive",   N_ARG,         ARG_KEEPALIVE,   0 },
 #endif
 #ifdef SIOCSOUTFILL
 	{ "outfill",     N_ARG,         ARG_OUTFILL,     0 },
 #endif
 #if ENABLE_FEATURE_IFCONFIG_MEMSTART_IOADDR_IRQ
 	{ "mem_start",   N_ARG,         ARG_MEM_START,   0 },
 	{ "io_addr",     N_ARG,         ARG_IO_ADDR,     0 },
 	{ "irq",         N_ARG,         ARG_IRQ,         0 },
 #endif
 #if ENABLE_FEATURE_IPV6
 	{ "add",         N_ARG,         ARG_ADD_DEL,     0 },
 	{ "del",         N_ARG,         ARG_ADD_DEL,     0 },
 #endif
 	{ "arp",         N_CLR | M_SET, 0,               IFF_NOARP },
 	{ "trailers",    N_CLR | M_SET, 0,               IFF_NOTRAILERS },
 	{ "promisc",     N_SET | M_CLR, 0,               IFF_PROMISC },
 	{ "multicast",   N_SET | M_CLR, 0,               IFF_MULTICAST },
 	{ "allmulti",    N_SET | M_CLR, 0,               IFF_ALLMULTI },
 	{ "dynamic",     N_SET | M_CLR, 0,               IFF_DYNAMIC },
 	{ "up",          N_SET,         0,               (IFF_UP | IFF_RUNNING) },
 	{ "down",        N_CLR,         0,               IFF_UP },
 	{ NULL,          0,             ARG_HOSTNAME,    (IFF_UP | IFF_RUNNING) }
 };
 
 /*
  * A couple of prototypes.
  */
 #if ENABLE_FEATURE_IFCONFIG_HW
 static int in_ether(const char *bufp, struct sockaddr *sap);
 #endif
 
 /*
  * Our main function.
  */
 int ifconfig_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 int ifconfig_main(int argc UNUSED_PARAM, char **argv)
 {
 	struct ifreq ifr;
 	struct sockaddr_in sai;
 #if ENABLE_FEATURE_IFCONFIG_HW
 	struct sockaddr sa;
 #endif
 	const struct arg1opt *a1op;
 	const struct options *op;
 	int sockfd;			/* socket fd we use to manipulate stuff with */
 	int selector;
 #if ENABLE_FEATURE_IFCONFIG_BROADCAST_PLUS
 	unsigned int mask;
 	unsigned int did_flags;
 	unsigned int sai_hostname, sai_netmask;
 #else
 	unsigned char mask;
 	unsigned char did_flags;
 #endif
 	char *p;
 	/*char host[128];*/
 	const char *host = NULL; /* make gcc happy */
 
 	did_flags = 0;
 #if ENABLE_FEATURE_IFCONFIG_BROADCAST_PLUS
 	sai_hostname = 0;
 	sai_netmask = 0;
 #endif
 
 	/* skip argv[0] */
 	++argv;
 
 #if ENABLE_FEATURE_IFCONFIG_STATUS
 	if (argv[0] && (argv[0][0] == '-' && argv[0][1] == 'a' && !argv[0][2])) {
 		interface_opt_a = 1;
 		++argv;
 	}
 #endif
 
 	if (!argv[0] || !argv[1]) { /* one or no args */
 #if ENABLE_FEATURE_IFCONFIG_STATUS
 		return display_interfaces(argv[0] /* can be NULL */);
 #else
 		bb_error_msg_and_die("no support for status display");
 #endif
 	}
 
 	/* Create a channel to the NET kernel. */
 	sockfd = xsocket(AF_INET, SOCK_DGRAM, 0);
 
 	/* get interface name */
 	strncpy_IFNAMSIZ(ifr.ifr_name, *argv);
 
 	/* Process the remaining arguments. */
 	while (*++argv != (char *) NULL) {
 		p = *argv;
 		mask = N_MASK;
 		if (*p == '-') {	/* If the arg starts with '-'... */
 			++p;		/*    advance past it and */
 			mask = M_MASK;	/*    set the appropriate mask. */
 		}
 		for (op = OptArray; op->name; op++) {	/* Find table entry. */
 			if (strcmp(p, op->name) == 0) {	/* If name matches... */
 				mask &= op->flags;
 				if (mask)	/* set the mask and go. */
 					goto FOUND_ARG;
 				/* If we get here, there was a valid arg with an */
 				/* invalid '-' prefix. */
 				bb_error_msg_and_die("bad: '%s'", p-1);
 			}
 		}
 
 		/* We fell through, so treat as possible hostname. */
 		a1op = Arg1Opt + ARRAY_SIZE(Arg1Opt) - 1;
 		mask = op->arg_flags;
 		goto HOSTNAME;
 
  FOUND_ARG:
 		if (mask & ARG_MASK) {
 			mask = op->arg_flags;
 			a1op = Arg1Opt + (op - OptArray);
 			if (mask & A_NETMASK & did_flags)
 				bb_show_usage();
 			if (*++argv == NULL) {
 				if (mask & A_ARG_REQ)
 					bb_show_usage();
 				--argv;
 				mask &= A_SET_AFTER;	/* just for broadcast */
 			} else {	/* got an arg so process it */
  HOSTNAME:
 				did_flags |= (mask & (A_NETMASK|A_HOSTNAME));
 				if (mask & A_CAST_HOST_COPY) {
 #if ENABLE_FEATURE_IFCONFIG_HW
 					if (mask & A_CAST_RESOLVE) {
 #endif
 #if ENABLE_FEATURE_IPV6
 						char *prefix;
 						int prefix_len = 0;
 #endif
 						/*safe_strncpy(host, *argv, (sizeof host));*/
 						host = *argv;
 #if ENABLE_FEATURE_IPV6
 						prefix = strchr(host, '/');
 						if (prefix) {
 							prefix_len = xatou_range(prefix + 1, 0, 128);
 							*prefix = '\0';
 						}
 #endif
 						sai.sin_family = AF_INET;
 						sai.sin_port = 0;
-						if (!strcmp(host, bb_str_default)) {
+						if (strcmp(host, "default") == 0) {
 							/* Default is special, meaning 0.0.0.0. */
 							sai.sin_addr.s_addr = INADDR_ANY;
 						}
 #if ENABLE_FEATURE_IFCONFIG_BROADCAST_PLUS
 						else if ((host[0] == '+' && !host[1]) && (mask & A_BROADCAST)
 						 && (did_flags & (A_NETMASK|A_HOSTNAME)) == (A_NETMASK|A_HOSTNAME)
 						) {
 							/* + is special, meaning broadcast is derived. */
 							sai.sin_addr.s_addr = (~sai_netmask) | (sai_hostname & sai_netmask);
 						}
 #endif
 						else {
 							len_and_sockaddr *lsa;
 							if (strcmp(host, "inet") == 0)
 								continue; /* compat stuff */
 							lsa = xhost2sockaddr(host, 0);
 #if ENABLE_FEATURE_IPV6
 							if (lsa->u.sa.sa_family == AF_INET6) {
 								int sockfd6;
 								struct in6_ifreq ifr6;
 
 								memcpy((char *) &ifr6.ifr6_addr,
 										(char *) &(lsa->u.sin6.sin6_addr),
 										sizeof(struct in6_addr));
 
 								/* Create a channel to the NET kernel. */
 								sockfd6 = xsocket(AF_INET6, SOCK_DGRAM, 0);
 								xioctl(sockfd6, SIOGIFINDEX, &ifr);
 								ifr6.ifr6_ifindex = ifr.ifr_ifindex;
 								ifr6.ifr6_prefixlen = prefix_len;
 								ioctl_or_perror_and_die(sockfd6, a1op->selector, &ifr6, "SIOC%s", a1op->name);
 								if (ENABLE_FEATURE_CLEAN_UP)
 									free(lsa);
 								continue;
 							}
 #endif
 							sai.sin_addr = lsa->u.sin.sin_addr;
 							if (ENABLE_FEATURE_CLEAN_UP)
 								free(lsa);
 						}
 #if ENABLE_FEATURE_IFCONFIG_BROADCAST_PLUS
 						if (mask & A_HOSTNAME)
 							sai_hostname = sai.sin_addr.s_addr;
 						if (mask & A_NETMASK)
 							sai_netmask = sai.sin_addr.s_addr;
 #endif
 						p = (char *) &sai;
 #if ENABLE_FEATURE_IFCONFIG_HW
 					} else {	/* A_CAST_HOST_COPY_IN_ETHER */
 						/* This is the "hw" arg case. */
 						smalluint hw_class= index_in_substrings("ether\0"
 								IF_FEATURE_HWIB("infiniband\0"), *argv) + 1;
 						if (!hw_class || !*++argv)
 							bb_show_usage();
 						/*safe_strncpy(host, *argv, sizeof(host));*/
 						host = *argv;
 						if (hw_class == 1 ? in_ether(host, &sa) : in_ib(host, &sa))
 							bb_error_msg_and_die("invalid hw-addr %s", host);
 						p = (char *) &sa;
 					}
 #endif
 					memcpy( (((char *)&ifr) + a1op->ifr_offset),
 						   p, sizeof(struct sockaddr));
 				} else {
 					/* FIXME: error check?? */
 					unsigned long i = strtoul(*argv, NULL, 0);
 					p = ((char *)&ifr) + a1op->ifr_offset;
 #if ENABLE_FEATURE_IFCONFIG_MEMSTART_IOADDR_IRQ
 					if (mask & A_MAP_TYPE) {
 						xioctl(sockfd, SIOCGIFMAP, &ifr);
 						if ((mask & A_MAP_UCHAR) == A_MAP_UCHAR)
 							*((unsigned char *) p) = i;
 						else if (mask & A_MAP_USHORT)
 							*((unsigned short *) p) = i;
 						else
 							*((unsigned long *) p) = i;
 					} else
 #endif
 					if (mask & A_CAST_CHAR_PTR)
 						*((caddr_t *) p) = (caddr_t) i;
 					else	/* A_CAST_INT */
 						*((int *) p) = i;
 				}
 
 				ioctl_or_perror_and_die(sockfd, a1op->selector, &ifr, "SIOC%s", a1op->name);
 #ifdef QUESTIONABLE_ALIAS_CASE
 				if (mask & A_COLON_CHK) {
 					/*
 					 * Don't do the set_flag() if the address is an alias with
 					 * a '-' at the end, since it's deleted already! - Roman
 					 *
 					 * Should really use regex.h here, not sure though how well
 					 * it'll go with the cross-platform support etc.
 					 */
 					char *ptr;
 					short int found_colon = 0;
 					for (ptr = ifr.ifr_name; *ptr; ptr++)
 						if (*ptr == ':')
 							found_colon++;
 					if (found_colon && ptr[-1] == '-')
 						continue;
 				}
 #endif
 			}
 			if (!(mask & A_SET_AFTER))
 				continue;
 			mask = N_SET;
 		}
 
 		xioctl(sockfd, SIOCGIFFLAGS, &ifr);
 		selector = op->selector;
 		if (mask & SET_MASK)
 			ifr.ifr_flags |= selector;
 		else
 			ifr.ifr_flags &= ~selector;
 		xioctl(sockfd, SIOCSIFFLAGS, &ifr);
 	} /* while () */
 
 	if (ENABLE_FEATURE_CLEAN_UP)
 		close(sockfd);
 	return 0;
 }
 
 #if ENABLE_FEATURE_IFCONFIG_HW
 /* Input an Ethernet address and convert to binary. */
 static int in_ether(const char *bufp, struct sockaddr *sap)
 {
 	char *ptr;
 	int i, j;
 	unsigned char val;
 	unsigned char c;
 
 	sap->sa_family = ARPHRD_ETHER;
 	ptr = (char *) sap->sa_data;
 
 	i = 0;
 	do {
 		j = val = 0;
 
 		/* We might get a semicolon here - not required. */
 		if (i && (*bufp == ':')) {
 			bufp++;
 		}
 
 		do {
 			c = *bufp;
 			if (((unsigned char)(c - '0')) <= 9) {
 				c -= '0';
 			} else if (((unsigned char)((c|0x20) - 'a')) <= 5) {
 				c = (c|0x20) - ('a'-10);
 			} else if (j && (c == ':' || c == 0)) {
 				break;
 			} else {
 				return -1;
 			}
 			++bufp;
 			val <<= 4;
 			val += c;
 		} while (++j < 2);
 		*ptr++ = val;
 	} while (++i < ETH_ALEN);
 
 	return *bufp; /* Error if we don't end at end of string. */
 }
 #endif
diff --git a/networking/libiproute/utils.c b/networking/libiproute/utils.c
index 5125617..2b646f0 100644
--- a/networking/libiproute/utils.c
+++ b/networking/libiproute/utils.c
@@ -1,276 +1,276 @@
 /* vi: set sw=4 ts=4: */
 /*
  * utils.c
  *
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  *
  * Authors:	Alexey Kuznetsov, <kuznet@ms2.inr.ac.ru>
  *
  * Changes:
  *
  * Rani Assaf <rani@magic.metawire.com> 980929:	resolve addresses
  */
 
 #include "libbb.h"
 #include "utils.h"
 #include "inet_common.h"
 
 unsigned get_unsigned(char *arg, const char *errmsg)
 {
 	unsigned long res;
 	char *ptr;
 
 	if (*arg) {
 		res = strtoul(arg, &ptr, 0);
 //FIXME: "" will be accepted too, is it correct?!
 		if (!*ptr && res <= UINT_MAX) {
 			return res;
 		}
 	}
 	invarg(arg, errmsg); /* does not return */
 }
 
 uint32_t get_u32(char *arg, const char *errmsg)
 {
 	unsigned long res;
 	char *ptr;
 
 	if (*arg) {
 		res = strtoul(arg, &ptr, 0);
 //FIXME: "" will be accepted too, is it correct?!
 		if (!*ptr && res <= 0xFFFFFFFFUL) {
 			return res;
 		}
 	}
 	invarg(arg, errmsg); /* does not return */
 }
 
 uint16_t get_u16(char *arg, const char *errmsg)
 {
 	unsigned long res;
 	char *ptr;
 
 	if (*arg) {
 		res = strtoul(arg, &ptr, 0);
 //FIXME: "" will be accepted too, is it correct?!
 		if (!*ptr && res <= 0xFFFF) {
 			return res;
 		}
 	}
 	invarg(arg, errmsg); /* does not return */
 }
 
 int get_addr_1(inet_prefix *addr, char *name, int family)
 {
 	memset(addr, 0, sizeof(*addr));
 
-	if (strcmp(name, bb_str_default) == 0
+	if (strcmp(name, "default") == 0
 	 || strcmp(name, "all") == 0
 	 || strcmp(name, "any") == 0
 	) {
 		addr->family = family;
 		addr->bytelen = (family == AF_INET6 ? 16 : 4);
 		addr->bitlen = -1;
 		return 0;
 	}
 
 	if (strchr(name, ':')) {
 		addr->family = AF_INET6;
 		if (family != AF_UNSPEC && family != AF_INET6)
 			return -1;
 		if (inet_pton(AF_INET6, name, addr->data) <= 0)
 			return -1;
 		addr->bytelen = 16;
 		addr->bitlen = -1;
 		return 0;
 	}
 
 	addr->family = AF_INET;
 	if (family != AF_UNSPEC && family != AF_INET)
 		return -1;
 	if (inet_pton(AF_INET, name, addr->data) <= 0)
 		return -1;
 	addr->bytelen = 4;
 	addr->bitlen = -1;
 	return 0;
 }
 
 static int get_prefix_1(inet_prefix *dst, char *arg, int family)
 {
 	int err;
 	unsigned plen;
 	char *slash;
 
 	memset(dst, 0, sizeof(*dst));
 
-	if (strcmp(arg, bb_str_default) == 0
+	if (strcmp(arg, "default") == 0
 	 || strcmp(arg, "all") == 0
 	 || strcmp(arg, "any") == 0
 	) {
 		dst->family = family;
 		/*dst->bytelen = 0; - done by memset */
 		/*dst->bitlen = 0;*/
 		return 0;
 	}
 
 	slash = strchr(arg, '/');
 	if (slash)
 		*slash = '\0';
 	err = get_addr_1(dst, arg, family);
 	if (err == 0) {
 		dst->bitlen = (dst->family == AF_INET6) ? 128 : 32;
 		if (slash) {
 			inet_prefix netmask_pfx;
 
 			netmask_pfx.family = AF_UNSPEC;
 			plen = bb_strtou(slash + 1, NULL, 0);
 			if ((errno || plen > dst->bitlen)
 			 && (get_addr_1(&netmask_pfx, slash + 1, family)))
 				err = -1;
 			else if (netmask_pfx.family == AF_INET) {
 				/* fill in prefix length of dotted quad */
 				uint32_t mask = ntohl(netmask_pfx.data[0]);
 				uint32_t host = ~mask;
 
 				/* a valid netmask must be 2^n - 1 */
 				if (!(host & (host + 1))) {
 					for (plen = 0; mask; mask <<= 1)
 						++plen;
 					if (plen <= dst->bitlen) {
 						dst->bitlen = plen;
 						/* dst->flags |= PREFIXLEN_SPECIFIED; */
 					} else
 						err = -1;
 				} else
 					err = -1;
 			} else {
 				/* plain prefix */
 				dst->bitlen = plen;
 			}
 		}
 	}
 	if (slash)
 		*slash = '/';
 	return err;
 }
 
 int get_addr(inet_prefix *dst, char *arg, int family)
 {
 	if (family == AF_PACKET) {
 		bb_error_msg_and_die("\"%s\" may be inet %s, but it is not allowed in this context", arg, "address");
 	}
 	if (get_addr_1(dst, arg, family)) {
 		bb_error_msg_and_die("an %s %s is expected rather than \"%s\"", "inet", "address", arg);
 	}
 	return 0;
 }
 
 int get_prefix(inet_prefix *dst, char *arg, int family)
 {
 	if (family == AF_PACKET) {
 		bb_error_msg_and_die("\"%s\" may be inet %s, but it is not allowed in this context", arg, "prefix");
 	}
 	if (get_prefix_1(dst, arg, family)) {
 		bb_error_msg_and_die("an %s %s is expected rather than \"%s\"", "inet", "prefix", arg);
 	}
 	return 0;
 }
 
 uint32_t get_addr32(char *name)
 {
 	inet_prefix addr;
 
 	if (get_addr_1(&addr, name, AF_INET)) {
 		bb_error_msg_and_die("an %s %s is expected rather than \"%s\"", "IP", "address", name);
 	}
 	return addr.data[0];
 }
 
 void incomplete_command(void)
 {
 	bb_error_msg_and_die("command line is not complete, try option \"help\"");
 }
 
 void invarg(const char *arg, const char *opt)
 {
 	bb_error_msg_and_die(bb_msg_invalid_arg, arg, opt);
 }
 
 void duparg(const char *key, const char *arg)
 {
 	bb_error_msg_and_die("duplicate \"%s\": \"%s\" is the second value", key, arg);
 }
 
 void duparg2(const char *key, const char *arg)
 {
 	bb_error_msg_and_die("either \"%s\" is duplicate, or \"%s\" is garbage", key, arg);
 }
 
 int inet_addr_match(inet_prefix *a, inet_prefix *b, int bits)
 {
 	uint32_t *a1 = a->data;
 	uint32_t *a2 = b->data;
 	int words = bits >> 5;
 
 	bits &= 0x1f;
 
 	if (words)
 		if (memcmp(a1, a2, words << 2))
 			return -1;
 
 	if (bits) {
 		uint32_t w1, w2;
 		uint32_t mask;
 
 		w1 = a1[words];
 		w2 = a2[words];
 
 		mask = htonl((0xffffffff) << (0x20 - bits));
 
 		if ((w1 ^ w2) & mask)
 			return 1;
 	}
 
 	return 0;
 }
 
 const char *rt_addr_n2a(int af,
 		void *addr, char *buf, int buflen)
 {
 	switch (af) {
 	case AF_INET:
 	case AF_INET6:
 		return inet_ntop(af, addr, buf, buflen);
 	default:
 		return "???";
 	}
 }
 
 #ifdef RESOLVE_HOSTNAMES
 const char *format_host(int af, int len, void *addr, char *buf, int buflen)
 {
 	if (resolve_hosts) {
 		struct hostent *h_ent;
 
 		if (len <= 0) {
 			switch (af) {
 			case AF_INET:
 				len = 4;
 				break;
 			case AF_INET6:
 				len = 16;
 				break;
 			default:;
 			}
 		}
 		if (len > 0) {
 			h_ent = gethostbyaddr(addr, len, af);
 			if (h_ent != NULL) {
 				safe_strncpy(buf, h_ent->h_name, buflen);
 				return buf;
 			}
 		}
 	}
 	return rt_addr_n2a(af, addr, buf, buflen);
 }
 #endif
diff --git a/networking/route.c b/networking/route.c
index c72e945..98567aa 100644
--- a/networking/route.c
+++ b/networking/route.c
@@ -1,699 +1,699 @@
 /* vi: set sw=4 ts=4: */
 /* route
  *
  * Similar to the standard Unix route, but with only the necessary
  * parts for AF_INET and AF_INET6
  *
  * Bjorn Wesen, Axis Communications AB
  *
  * Author of the original route:
  *              Fred N. van Kempen, <waltje@uwalt.nl.mugnet.org>
  *              (derived from FvK's 'route.c     1.70    01/04/94')
  *
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  *
  *
  * displayroute() code added by Vladimir N. Oleynik <dzo@simtreas.ru>
  * adjustments by Larry Doolittle  <LRDoolittle@lbl.gov>
  *
  * IPV6 support added by Bart Visscher <magick@linux-fan.com>
  */
 
 /* 2004/03/09  Manuel Novoa III <mjn3@codepoet.org>
  *
  * Rewritten to fix several bugs, add additional error checking, and
  * remove ridiculous amounts of bloat.
  */
 
 #include <net/route.h>
 #include <net/if.h>
 
 #include "libbb.h"
 #include "inet_common.h"
 
 
 #ifndef RTF_UP
 /* Keep this in sync with /usr/src/linux/include/linux/route.h */
 #define RTF_UP          0x0001	/* route usable                 */
 #define RTF_GATEWAY     0x0002	/* destination is a gateway     */
 #define RTF_HOST        0x0004	/* host entry (net otherwise)   */
 #define RTF_REINSTATE   0x0008	/* reinstate route after tmout  */
 #define RTF_DYNAMIC     0x0010	/* created dyn. (by redirect)   */
 #define RTF_MODIFIED    0x0020	/* modified dyn. (by redirect)  */
 #define RTF_MTU         0x0040	/* specific MTU for this route  */
 #ifndef RTF_MSS
 #define RTF_MSS         RTF_MTU	/* Compatibility :-(            */
 #endif
 #define RTF_WINDOW      0x0080	/* per route window clamping    */
 #define RTF_IRTT        0x0100	/* Initial round trip time      */
 #define RTF_REJECT      0x0200	/* Reject route                 */
 #endif
 
 #if defined(SIOCADDRTOLD) || defined(RTF_IRTT)	/* route */
 #define HAVE_NEW_ADDRT 1
 #endif
 
 #if HAVE_NEW_ADDRT
 #define mask_in_addr(x) (((struct sockaddr_in *)&((x).rt_genmask))->sin_addr.s_addr)
 #define full_mask(x) (x)
 #else
 #define mask_in_addr(x) ((x).rt_genmask)
 #define full_mask(x) (((struct sockaddr_in *)&(x))->sin_addr.s_addr)
 #endif
 
 /* The RTACTION entries must agree with tbl_verb[] below! */
 #define RTACTION_ADD 1
 #define RTACTION_DEL 2
 
 /* For the various tbl_*[] arrays, the 1st byte is the offset to
  * the next entry and the 2nd byte is return value. */
 
 #define NET_FLAG  1
 #define HOST_FLAG 2
 
 /* We remap '-' to '#' to avoid problems with getopt. */
 static const char tbl_hash_net_host[] ALIGN1 =
 	"\007\001#net\0"
 /*	"\010\002#host\0" */
 	"\007\002#host"				/* Since last, we can save a byte. */
 ;
 
 #define KW_TAKES_ARG            020
 #define KW_SETS_FLAG            040
 
 #define KW_IPVx_METRIC          020
 #define KW_IPVx_NETMASK         021
 #define KW_IPVx_GATEWAY         022
 #define KW_IPVx_MSS             023
 #define KW_IPVx_WINDOW          024
 #define KW_IPVx_IRTT            025
 #define KW_IPVx_DEVICE          026
 
 #define KW_IPVx_FLAG_ONLY       040
 #define KW_IPVx_REJECT          040
 #define KW_IPVx_MOD             041
 #define KW_IPVx_DYN             042
 #define KW_IPVx_REINSTATE       043
 
 static const char tbl_ipvx[] ALIGN1 =
 	/* 020 is the "takes an arg" bit */
 #if HAVE_NEW_ADDRT
 	"\011\020metric\0"
 #endif
 	"\012\021netmask\0"
 	"\005\022gw\0"
 	"\012\022gateway\0"
 	"\006\023mss\0"
 	"\011\024window\0"
 #ifdef RTF_IRTT
 	"\007\025irtt\0"
 #endif
 	"\006\026dev\0"
 	"\011\026device\0"
 	/* 040 is the "sets a flag" bit - MUST match flags_ipvx[] values below. */
 #ifdef RTF_REJECT
 	"\011\040reject\0"
 #endif
 	"\006\041mod\0"
 	"\006\042dyn\0"
 /*	"\014\043reinstate\0" */
 	"\013\043reinstate"			/* Since last, we can save a byte. */
 ;
 
 static const int flags_ipvx[] = { /* MUST match tbl_ipvx[] values above. */
 #ifdef RTF_REJECT
 	RTF_REJECT,
 #endif
 	RTF_MODIFIED,
 	RTF_DYNAMIC,
 	RTF_REINSTATE
 };
 
 static int kw_lookup(const char *kwtbl, char ***pargs)
 {
 	if (**pargs) {
 		do {
 			if (strcmp(kwtbl+2, **pargs) == 0) { /* Found a match. */
 				*pargs += 1;
 				if (kwtbl[1] & KW_TAKES_ARG) {
 					if (!**pargs) {	/* No more args! */
 						bb_show_usage();
 					}
 					*pargs += 1; /* Calling routine will use args[-1]. */
 				}
 				return kwtbl[1];
 			}
 			kwtbl += *kwtbl;
 		} while (*kwtbl);
 	}
 	return 0;
 }
 
 /* Add or delete a route, depending on action. */
 
 static NOINLINE void INET_setroute(int action, char **args)
 {
 	struct rtentry rt;
 	const char *netmask = NULL;
 	int skfd, isnet, xflag;
 
 	/* Grab the -net or -host options.  Remember they were transformed. */
 	xflag = kw_lookup(tbl_hash_net_host, &args);
 
 	/* If we did grab -net or -host, make sure we still have an arg left. */
 	if (*args == NULL) {
 		bb_show_usage();
 	}
 
 	/* Clean out the RTREQ structure. */
 	memset(&rt, 0, sizeof(rt));
 
 	{
 		const char *target = *args++;
 		char *prefix;
 
 		/* recognize x.x.x.x/mask format. */
 		prefix = strchr(target, '/');
 		if (prefix) {
 			int prefix_len;
 
 			prefix_len = xatoul_range(prefix+1, 0, 32);
 			mask_in_addr(rt) = htonl( ~(0xffffffffUL >> prefix_len));
 			*prefix = '\0';
 #if HAVE_NEW_ADDRT
 			rt.rt_genmask.sa_family = AF_INET;
 #endif
 		} else {
 			/* Default netmask. */
-			netmask = bb_str_default;
+			netmask = "default";
 		}
 		/* Prefer hostname lookup is -host flag (xflag==1) was given. */
 		isnet = INET_resolve(target, (struct sockaddr_in *) &rt.rt_dst,
 							 (xflag & HOST_FLAG));
 		if (isnet < 0) {
 			bb_error_msg_and_die("resolving %s", target);
 		}
 		if (prefix) {
 			/* do not destroy prefix for process args */
 			*prefix = '/';
 		}
 	}
 
 	if (xflag) {		/* Reinit isnet if -net or -host was specified. */
 		isnet = (xflag & NET_FLAG);
 	}
 
 	/* Fill in the other fields. */
 	rt.rt_flags = ((isnet) ? RTF_UP : (RTF_UP | RTF_HOST));
 
 	while (*args) {
 		int k = kw_lookup(tbl_ipvx, &args);
 		const char *args_m1 = args[-1];
 
 		if (k & KW_IPVx_FLAG_ONLY) {
 			rt.rt_flags |= flags_ipvx[k & 3];
 			continue;
 		}
 
 #if HAVE_NEW_ADDRT
 		if (k == KW_IPVx_METRIC) {
 			rt.rt_metric = xatoul(args_m1) + 1;
 			continue;
 		}
 #endif
 
 		if (k == KW_IPVx_NETMASK) {
 			struct sockaddr mask;
 
 			if (mask_in_addr(rt)) {
 				bb_show_usage();
 			}
 
 			netmask = args_m1;
 			isnet = INET_resolve(netmask, (struct sockaddr_in *) &mask, 0);
 			if (isnet < 0) {
 				bb_error_msg_and_die("resolving %s", netmask);
 			}
 			rt.rt_genmask = full_mask(mask);
 			continue;
 		}
 
 		if (k == KW_IPVx_GATEWAY) {
 			if (rt.rt_flags & RTF_GATEWAY) {
 				bb_show_usage();
 			}
 
 			isnet = INET_resolve(args_m1,
 								 (struct sockaddr_in *) &rt.rt_gateway, 1);
 			rt.rt_flags |= RTF_GATEWAY;
 
 			if (isnet) {
 				if (isnet < 0) {
 					bb_error_msg_and_die("resolving %s", args_m1);
 				}
 				bb_error_msg_and_die("gateway %s is a NETWORK", args_m1);
 			}
 			continue;
 		}
 
 		if (k == KW_IPVx_MSS) {	/* Check valid MSS bounds. */
 			rt.rt_flags |= RTF_MSS;
 			rt.rt_mss = xatoul_range(args_m1, 64, 32768);
 			continue;
 		}
 
 		if (k == KW_IPVx_WINDOW) {	/* Check valid window bounds. */
 			rt.rt_flags |= RTF_WINDOW;
 			rt.rt_window = xatoul_range(args_m1, 128, INT_MAX);
 			continue;
 		}
 
 #ifdef RTF_IRTT
 		if (k == KW_IPVx_IRTT) {
 			rt.rt_flags |= RTF_IRTT;
 			rt.rt_irtt = xatoul(args_m1);
 			rt.rt_irtt *= (sysconf(_SC_CLK_TCK) / 100);	/* FIXME */
 #if 0					/* FIXME: do we need to check anything of this? */
 			if (rt.rt_irtt < 1 || rt.rt_irtt > (120 * HZ)) {
 				bb_error_msg_and_die("bad irtt");
 			}
 #endif
 			continue;
 		}
 #endif
 
 		/* Device is special in that it can be the last arg specified
 		 * and doesn't requre the dev/device keyword in that case. */
 		if (!rt.rt_dev && ((k == KW_IPVx_DEVICE) || (!k && !*++args))) {
 			/* Don't use args_m1 here since args may have changed! */
 			rt.rt_dev = args[-1];
 			continue;
 		}
 
 		/* Nothing matched. */
 		bb_show_usage();
 	}
 
 #ifdef RTF_REJECT
 	if ((rt.rt_flags & RTF_REJECT) && !rt.rt_dev) {
 		rt.rt_dev = (char*)"lo";
 	}
 #endif
 
 	/* sanity checks.. */
 	if (mask_in_addr(rt)) {
 		uint32_t mask = mask_in_addr(rt);
 
 		mask = ~ntohl(mask);
 		if ((rt.rt_flags & RTF_HOST) && mask != 0xffffffff) {
 			bb_error_msg_and_die("netmask %.8x and host route conflict",
 								 (unsigned int) mask);
 		}
 		if (mask & (mask + 1)) {
 			bb_error_msg_and_die("bogus netmask %s", netmask);
 		}
 		mask = ((struct sockaddr_in *) &rt.rt_dst)->sin_addr.s_addr;
 		if (mask & ~(uint32_t)mask_in_addr(rt)) {
 			bb_error_msg_and_die("netmask and route address conflict");
 		}
 	}
 
 	/* Fill out netmask if still unset */
 	if ((action == RTACTION_ADD) && (rt.rt_flags & RTF_HOST)) {
 		mask_in_addr(rt) = 0xffffffff;
 	}
 
 	/* Create a socket to the INET kernel. */
 	skfd = xsocket(AF_INET, SOCK_DGRAM, 0);
 
 	if (action == RTACTION_ADD)
 		xioctl(skfd, SIOCADDRT, &rt);
 	else
 		xioctl(skfd, SIOCDELRT, &rt);
 
 	if (ENABLE_FEATURE_CLEAN_UP) close(skfd);
 }
 
 #if ENABLE_FEATURE_IPV6
 
 static NOINLINE void INET6_setroute(int action, char **args)
 {
 	struct sockaddr_in6 sa6;
 	struct in6_rtmsg rt;
 	int prefix_len, skfd;
 	const char *devname;
 
 		/* We know args isn't NULL from the check in route_main. */
 		const char *target = *args++;
 
-		if (strcmp(target, bb_str_default) == 0) {
+		if (strcmp(target, "default") == 0) {
 			prefix_len = 0;
 			memset(&sa6, 0, sizeof(sa6));
 		} else {
 			char *cp;
 			cp = strchr(target, '/'); /* Yes... const to non is ok. */
 			if (cp) {
 				*cp = '\0';
 				prefix_len = xatoul_range(cp + 1, 0, 128);
 			} else {
 				prefix_len = 128;
 			}
 			if (INET6_resolve(target, (struct sockaddr_in6 *) &sa6) < 0) {
 				bb_error_msg_and_die("resolving %s", target);
 			}
 		}
 
 	/* Clean out the RTREQ structure. */
 	memset(&rt, 0, sizeof(rt));
 
 	memcpy(&rt.rtmsg_dst, sa6.sin6_addr.s6_addr, sizeof(struct in6_addr));
 
 	/* Fill in the other fields. */
 	rt.rtmsg_dst_len = prefix_len;
 	rt.rtmsg_flags = ((prefix_len == 128) ? (RTF_UP|RTF_HOST) : RTF_UP);
 	rt.rtmsg_metric = 1;
 
 	devname = NULL;
 
 	while (*args) {
 		int k = kw_lookup(tbl_ipvx, &args);
 		const char *args_m1 = args[-1];
 
 		if ((k == KW_IPVx_MOD) || (k == KW_IPVx_DYN)) {
 			rt.rtmsg_flags |= flags_ipvx[k & 3];
 			continue;
 		}
 
 		if (k == KW_IPVx_METRIC) {
 			rt.rtmsg_metric = xatoul(args_m1);
 			continue;
 		}
 
 		if (k == KW_IPVx_GATEWAY) {
 			if (rt.rtmsg_flags & RTF_GATEWAY) {
 				bb_show_usage();
 			}
 
 			if (INET6_resolve(args_m1, (struct sockaddr_in6 *) &sa6) < 0) {
 				bb_error_msg_and_die("resolving %s", args_m1);
 			}
 			memcpy(&rt.rtmsg_gateway, sa6.sin6_addr.s6_addr,
 				   sizeof(struct in6_addr));
 			rt.rtmsg_flags |= RTF_GATEWAY;
 			continue;
 		}
 
 		/* Device is special in that it can be the last arg specified
 		 * and doesn't requre the dev/device keyword in that case. */
 		if (!devname && ((k == KW_IPVx_DEVICE) || (!k && !*++args))) {
 			/* Don't use args_m1 here since args may have changed! */
 			devname = args[-1];
 			continue;
 		}
 
 		/* Nothing matched. */
 		bb_show_usage();
 	}
 
 	/* Create a socket to the INET6 kernel. */
 	skfd = xsocket(AF_INET6, SOCK_DGRAM, 0);
 
 	rt.rtmsg_ifindex = 0;
 
 	if (devname) {
 		struct ifreq ifr;
 		memset(&ifr, 0, sizeof(ifr));
 		strncpy_IFNAMSIZ(ifr.ifr_name, devname);
 		xioctl(skfd, SIOGIFINDEX, &ifr);
 		rt.rtmsg_ifindex = ifr.ifr_ifindex;
 	}
 
 	/* Tell the kernel to accept this route. */
 	if (action == RTACTION_ADD)
 		xioctl(skfd, SIOCADDRT, &rt);
 	else
 		xioctl(skfd, SIOCDELRT, &rt);
 
 	if (ENABLE_FEATURE_CLEAN_UP) close(skfd);
 }
 #endif
 
 static const unsigned flagvals[] = { /* Must agree with flagchars[]. */
 	RTF_GATEWAY,
 	RTF_HOST,
 	RTF_REINSTATE,
 	RTF_DYNAMIC,
 	RTF_MODIFIED,
 #if ENABLE_FEATURE_IPV6
 	RTF_DEFAULT,
 	RTF_ADDRCONF,
 	RTF_CACHE
 #endif
 };
 
 #define IPV4_MASK (RTF_GATEWAY|RTF_HOST|RTF_REINSTATE|RTF_DYNAMIC|RTF_MODIFIED)
 #define IPV6_MASK (RTF_GATEWAY|RTF_HOST|RTF_DEFAULT|RTF_ADDRCONF|RTF_CACHE)
 
 /* Must agree with flagvals[]. */
 static const char flagchars[] ALIGN1 =
 	"GHRDM"
 #if ENABLE_FEATURE_IPV6
 	"DAC"
 #endif
 ;
 
 static void set_flags(char *flagstr, int flags)
 {
 	int i;
 
 	*flagstr++ = 'U';
 
 	for (i = 0; (*flagstr = flagchars[i]) != 0; i++) {
 		if (flags & flagvals[i]) {
 			++flagstr;
 		}
 	}
 }
 
 /* also used in netstat */
 void FAST_FUNC bb_displayroutes(int noresolve, int netstatfmt)
 {
 	char devname[64], flags[16], *sdest, *sgw;
 	unsigned long d, g, m;
 	int flgs, ref, use, metric, mtu, win, ir;
 	struct sockaddr_in s_addr;
 	struct in_addr mask;
 
 	FILE *fp = xfopen_for_read("/proc/net/route");
 
 	printf("Kernel IP routing table\n"
 	       "Destination     Gateway         Genmask         Flags %s Iface\n",
 			netstatfmt ? "  MSS Window  irtt" : "Metric Ref    Use");
 
 	if (fscanf(fp, "%*[^\n]\n") < 0) { /* Skip the first line. */
 		goto ERROR;		   /* Empty or missing line, or read error. */
 	}
 	while (1) {
 		int r;
 		r = fscanf(fp, "%63s%lx%lx%X%d%d%d%lx%d%d%d\n",
 				   devname, &d, &g, &flgs, &ref, &use, &metric, &m,
 				   &mtu, &win, &ir);
 		if (r != 11) {
 			if ((r < 0) && feof(fp)) { /* EOF with no (nonspace) chars read. */
 				break;
 			}
  ERROR:
 			bb_error_msg_and_die("fscanf");
 		}
 
 		if (!(flgs & RTF_UP)) { /* Skip interfaces that are down. */
 			continue;
 		}
 
 		set_flags(flags, (flgs & IPV4_MASK));
 #ifdef RTF_REJECT
 		if (flgs & RTF_REJECT) {
 			flags[0] = '!';
 		}
 #endif
 
 		memset(&s_addr, 0, sizeof(struct sockaddr_in));
 		s_addr.sin_family = AF_INET;
 		s_addr.sin_addr.s_addr = d;
 		sdest = INET_rresolve(&s_addr, (noresolve | 0x8000), m); /* 'default' instead of '*' */
 		s_addr.sin_addr.s_addr = g;
 		sgw = INET_rresolve(&s_addr, (noresolve | 0x4000), m); /* Host instead of net */
 		mask.s_addr = m;
 		/* "%15.15s" truncates hostnames, do we really want that? */
 		printf("%-15.15s %-15.15s %-16s%-6s", sdest, sgw, inet_ntoa(mask), flags);
 		free(sdest);
 		free(sgw);
 		if (netstatfmt) {
 			printf("%5d %-5d %6d %s\n", mtu, win, ir, devname);
 		} else {
 			printf("%-6d %-2d %7d %s\n", metric, ref, use, devname);
 		}
 	}
 }
 
 #if ENABLE_FEATURE_IPV6
 
 static void INET6_displayroutes(void)
 {
 	char addr6[128], *naddr6;
 	/* In addr6x, we store both 40-byte ':'-delimited ipv6 addresses.
 	 * We read the non-delimited strings into the tail of the buffer
 	 * using fscanf and then modify the buffer by shifting forward
 	 * while inserting ':'s and the nul terminator for the first string.
 	 * Hence the strings are at addr6x and addr6x+40.  This generates
 	 * _much_ less code than the previous (upstream) approach. */
 	char addr6x[80];
 	char iface[16], flags[16];
 	int iflags, metric, refcnt, use, prefix_len, slen;
 	struct sockaddr_in6 snaddr6;
 
 	FILE *fp = xfopen_for_read("/proc/net/ipv6_route");
 
 	printf("Kernel IPv6 routing table\n%-44s%-40s"
 			  "Flags Metric Ref    Use Iface\n",
 			  "Destination", "Next Hop");
 
 	while (1) {
 		int r;
 		r = fscanf(fp, "%32s%x%*s%x%32s%x%x%x%x%s\n",
 				addr6x+14, &prefix_len, &slen, addr6x+40+7,
 				&metric, &use, &refcnt, &iflags, iface);
 		if (r != 9) {
 			if ((r < 0) && feof(fp)) { /* EOF with no (nonspace) chars read. */
 				break;
 			}
  ERROR:
 			bb_error_msg_and_die("fscanf");
 		}
 
 		/* Do the addr6x shift-and-insert changes to ':'-delimit addresses.
 		 * For now, always do this to validate the proc route format, even
 		 * if the interface is down. */
 		{
 			int i = 0;
 			char *p = addr6x+14;
 
 			do {
 				if (!*p) {
 					if (i == 40) { /* nul terminator for 1st address? */
 						addr6x[39] = 0;	/* Fixup... need 0 instead of ':'. */
 						++p;	/* Skip and continue. */
 						continue;
 					}
 					goto ERROR;
 				}
 				addr6x[i++] = *p++;
 				if (!((i+1) % 5)) {
 					addr6x[i++] = ':';
 				}
 			} while (i < 40+28+7);
 		}
 
 		if (!(iflags & RTF_UP)) { /* Skip interfaces that are down. */
 			continue;
 		}
 
 		set_flags(flags, (iflags & IPV6_MASK));
 
 		r = 0;
 		do {
 			inet_pton(AF_INET6, addr6x + r,
 					  (struct sockaddr *) &snaddr6.sin6_addr);
 			snaddr6.sin6_family = AF_INET6;
 			naddr6 = INET6_rresolve((struct sockaddr_in6 *) &snaddr6,
 						   0x0fff /* Apparently, upstream never resolves. */
 						   );
 
 			if (!r) {			/* 1st pass */
 				snprintf(addr6, sizeof(addr6), "%s/%d", naddr6, prefix_len);
 				r += 40;
 				free(naddr6);
 			} else {			/* 2nd pass */
 				/* Print the info. */
 				printf("%-43s %-39s %-5s %-6d %-2d %7d %-8s\n",
 						addr6, naddr6, flags, metric, refcnt, use, iface);
 				free(naddr6);
 				break;
 			}
 		} while (1);
 	}
 }
 
 #endif
 
 #define ROUTE_OPT_A     0x01
 #define ROUTE_OPT_n     0x02
 #define ROUTE_OPT_e     0x04
 #define ROUTE_OPT_INET6 0x08 /* Not an actual option. See below. */
 
 /* 1st byte is offset to next entry offset.  2nd byte is return value. */
 /* 2nd byte matches RTACTION_* code */
 static const char tbl_verb[] ALIGN1 =
 	"\006\001add\0"
 	"\006\002del\0"
 /*	"\011\002delete\0" */
 	"\010\002delete"  /* Since it's last, we can save a byte. */
 ;
 
 int route_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 int route_main(int argc UNUSED_PARAM, char **argv)
 {
 	unsigned opt;
 	int what;
 	char *family;
 	char **p;
 
 	/* First, remap '-net' and '-host' to avoid getopt problems. */
 	p = argv;
 	while (*++p) {
 		if (strcmp(*p, "-net") == 0 || strcmp(*p, "-host") == 0) {
 			p[0][0] = '#';
 		}
 	}
 
 	opt = getopt32(argv, "A:ne", &family);
 
 	if ((opt & ROUTE_OPT_A) && strcmp(family, "inet") != 0) {
 #if ENABLE_FEATURE_IPV6
 		if (strcmp(family, "inet6") == 0) {
 			opt |= ROUTE_OPT_INET6;	/* Set flag for ipv6. */
 		} else
 #endif
 		bb_show_usage();
 	}
 
 	argv += optind;
 
 	/* No more args means display the routing table. */
 	if (!*argv) {
 		int noresolve = (opt & ROUTE_OPT_n) ? 0x0fff : 0;
 #if ENABLE_FEATURE_IPV6
 		if (opt & ROUTE_OPT_INET6)
 			INET6_displayroutes();
 		else
 #endif
 			bb_displayroutes(noresolve, opt & ROUTE_OPT_e);
 
 		fflush_stdout_and_exit(EXIT_SUCCESS);
 	}
 
 	/* Check verb.  At the moment, must be add, del, or delete. */
 	what = kw_lookup(tbl_verb, &argv);
 	if (!what || !*argv) {		/* Unknown verb or no more args. */
 		bb_show_usage();
 	}
 
 #if ENABLE_FEATURE_IPV6
 	if (opt & ROUTE_OPT_INET6)
 		INET6_setroute(what, argv);
 	else
 #endif
 		INET_setroute(what, argv);
 
 	return EXIT_SUCCESS;
 }
