2015-10-18 22:40:23 +0200
diff --git a/e2fsprogs/Config.src b/e2fsprogs/Config.src
index 743e1e1..a20d849 100644
--- a/e2fsprogs/Config.src
+++ b/e2fsprogs/Config.src
@@ -1,71 +1,43 @@
 #
 # For a description of the syntax of this configuration file,
 # see scripts/kbuild/config-language.txt.
 #
 
 menu "Linux Ext2 FS Progs"
 
 INSERT
 
-config CHATTR
-	bool "chattr"
-	default y
-	help
-	  chattr changes the file attributes on a second extended file system.
-
 ### config E2FSCK
 ###	bool "e2fsck"
 ###	default y
 ###	help
 ###	  e2fsck is used to check Linux second extended file systems (ext2fs).
 ###	  e2fsck also supports ext2 filesystems countaining a journal (ext3).
 ###	  The normal compat symlinks 'fsck.ext2' and 'fsck.ext3' are also
 ###	  provided.
 
-config FSCK
-	bool "fsck"
-	default y
-	help
-	  fsck is used to check and optionally repair one or more filesystems.
-	  In actuality, fsck is simply a front-end for the various file system
-	  checkers (fsck.fstype) available under Linux.
-
-config LSATTR
-	bool "lsattr"
-	default y
-	select PLATFORM_LINUX
-	help
-	  lsattr lists the file attributes on a second extended file system.
-
 ### config MKE2FS
 ###	bool "mke2fs"
 ###	default y
 ###	help
 ###	  mke2fs is used to create an ext2/ext3 filesystem. The normal compat
 ###	  symlinks 'mkfs.ext2' and 'mkfs.ext3' are also provided.
 
-config TUNE2FS
-	bool "tune2fs"
-	default n  # off: it is too limited compared to upstream version
-	help
-	  tune2fs allows the system administrator to adjust various tunable
-	  filesystem parameters on Linux ext2/ext3 filesystems.
-
 ### config E2LABEL
 ###	bool "e2label"
 ###	default y
 ###	depends on TUNE2FS
 ###	help
 ###	  e2label will display or change the filesystem label on the ext2
 ###	  filesystem located on device.
 
 ### NB: this one is now provided by util-linux/volume_id/*
 ### config FINDFS
 ###	bool "findfs"
 ###	default y
 ###	depends on TUNE2FS
 ###	help
 ###	  findfs will search the disks in the system looking for a filesystem
 ###	  which has a label matching label or a UUID equal to uuid.
 
 endmenu
diff --git a/e2fsprogs/Kbuild.src b/e2fsprogs/Kbuild.src
index b7a14c3..6b4fb74 100644
--- a/e2fsprogs/Kbuild.src
+++ b/e2fsprogs/Kbuild.src
@@ -1,15 +1,9 @@
 # Makefile for busybox
 #
 # Copyright (C) 1999-2005 by Erik Andersen <andersen@codepoet.org>
 #
 # Licensed under GPLv2, see file LICENSE in this source tree.
 
 lib-y:=
 
 INSERT
-
-lib-$(CONFIG_CHATTR) += chattr.o e2fs_lib.o
-lib-$(CONFIG_LSATTR) += lsattr.o e2fs_lib.o
-
-lib-$(CONFIG_FSCK)    += fsck.o
-lib-$(CONFIG_TUNE2FS) += tune2fs.o
diff --git a/e2fsprogs/chattr.c b/e2fsprogs/chattr.c
index f1cc838..c4e2415 100644
--- a/e2fsprogs/chattr.c
+++ b/e2fsprogs/chattr.c
@@ -1,195 +1,195 @@
 /* vi: set sw=4 ts=4: */
 /*
  * chattr.c		- Change file attributes on an ext2 file system
  *
  * Copyright (C) 1993, 1994  Remy Card <card@masi.ibp.fr>
  *                           Laboratoire MASI, Institut Blaise Pascal
  *                           Universite Pierre et Marie Curie (Paris VI)
  *
  * This file can be redistributed under the terms of the GNU General
  * Public License
  */
+//config:config CHATTR
+//config:	bool "chattr"
+//config:	default y
+//config:	help
+//config:	  chattr changes the file attributes on a second extended file system.
 
-/*
- * History:
- * 93/10/30	- Creation
- * 93/11/13	- Replace stat() calls by lstat() to avoid loops
- * 94/02/27	- Integrated in Ted's distribution
- * 98/12/29	- Ignore symlinks when working recursively (G M Sipe)
- * 98/12/29	- Display version info only when -V specified (G M Sipe)
- */
+//applet:IF_CHATTR(APPLET(chattr, BB_DIR_BIN, BB_SUID_DROP))
+
+//kbuild:lib-$(CONFIG_CHATTR) += chattr.o e2fs_lib.o
 
 //usage:#define chattr_trivial_usage
 //usage:       "[-R] [-+=AacDdijsStTu] [-v VERSION] [FILE]..."
 //usage:#define chattr_full_usage "\n\n"
 //usage:       "Change file attributes on an ext2 fs\n"
 //usage:     "\nModifiers:"
 //usage:     "\n	-	Remove attributes"
 //usage:     "\n	+	Add attributes"
 //usage:     "\n	=	Set attributes"
 //usage:     "\nAttributes:"
 //usage:     "\n	A	Don't track atime"
 //usage:     "\n	a	Append mode only"
 //usage:     "\n	c	Enable compress"
 //usage:     "\n	D	Write dir contents synchronously"
 //usage:     "\n	d	Don't backup with dump"
 //usage:     "\n	i	Cannot be modified (immutable)"
 //usage:     "\n	j	Write all data to journal first"
 //usage:     "\n	s	Zero disk storage when deleted"
 //usage:     "\n	S	Write file contents synchronously"
 //usage:     "\n	t	Disable tail-merging of partial blocks with other files"
 //usage:     "\n	u	Allow file to be undeleted"
 //usage:     "\n	-R	Recurse"
 //usage:     "\n	-v	Set the file's version/generation number"
 
 #include "libbb.h"
 #include "e2fs_lib.h"
 
 #define OPT_ADD 1
 #define OPT_REM 2
 #define OPT_SET 4
 #define OPT_SET_VER 8
 
 struct globals {
 	unsigned long version;
 	unsigned long af;
 	unsigned long rf;
 	smallint flags;
 	smallint recursive;
 };
 
 static unsigned long get_flag(char c)
 {
 	const char *fp = strchr(e2attr_flags_sname_chattr, c);
 	if (fp)
 		return e2attr_flags_value_chattr[fp - e2attr_flags_sname_chattr];
 	bb_show_usage();
 }
 
 static int decode_arg(const char *arg, struct globals *gp)
 {
 	unsigned long *fl;
 	char opt = *arg++;
 
 	fl = &gp->af;
 	if (opt == '-') {
 		gp->flags |= OPT_REM;
 		fl = &gp->rf;
 	} else if (opt == '+') {
 		gp->flags |= OPT_ADD;
 	} else if (opt == '=') {
 		gp->flags |= OPT_SET;
 	} else
 		return 0;
 
 	while (*arg)
 		*fl |= get_flag(*arg++);
 
 	return 1;
 }
 
 static void change_attributes(const char *name, struct globals *gp);
 
 static int FAST_FUNC chattr_dir_proc(const char *dir_name, struct dirent *de, void *gp)
 {
 	char *path = concat_subpath_file(dir_name, de->d_name);
 	/* path is NULL if de->d_name is "." or "..", else... */
 	if (path) {
 		change_attributes(path, gp);
 		free(path);
 	}
 	return 0;
 }
 
 static void change_attributes(const char *name, struct globals *gp)
 {
 	unsigned long fsflags;
 	struct stat st;
 
 	if (lstat(name, &st) != 0) {
 		bb_perror_msg("stat %s", name);
 		return;
 	}
 	if (S_ISLNK(st.st_mode) && gp->recursive)
 		return;
 
 	/* Don't try to open device files, fifos etc.  We probably
 	 * ought to display an error if the file was explicitly given
 	 * on the command line (whether or not recursive was
 	 * requested).  */
 	if (!S_ISREG(st.st_mode) && !S_ISLNK(st.st_mode) && !S_ISDIR(st.st_mode))
 		return;
 
 	if (gp->flags & OPT_SET_VER)
 		if (fsetversion(name, gp->version) != 0)
 			bb_perror_msg("setting version on %s", name);
 
 	if (gp->flags & OPT_SET) {
 		fsflags = gp->af;
 	} else {
 		if (fgetflags(name, &fsflags) != 0) {
 			bb_perror_msg("reading flags on %s", name);
 			goto skip_setflags;
 		}
 		/*if (gp->flags & OPT_REM) - not needed, rf is zero otherwise */
 			fsflags &= ~gp->rf;
 		/*if (gp->flags & OPT_ADD) - not needed, af is zero otherwise */
 			fsflags |= gp->af;
 		/* What is this? And why it's not done for SET case? */
 		if (!S_ISDIR(st.st_mode))
 			fsflags &= ~EXT2_DIRSYNC_FL;
 	}
 	if (fsetflags(name, fsflags) != 0)
 		bb_perror_msg("setting flags on %s", name);
 
  skip_setflags:
 	if (gp->recursive && S_ISDIR(st.st_mode))
 		iterate_on_dir(name, chattr_dir_proc, gp);
 }
 
 int chattr_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 int chattr_main(int argc UNUSED_PARAM, char **argv)
 {
 	struct globals g;
 	char *arg;
 
 	memset(&g, 0, sizeof(g));
 
 	/* parse the args */
 	while ((arg = *++argv)) {
 		/* take care of -R and -v <version> */
 		if (arg[0] == '-'
 		 && (arg[1] == 'R' || arg[1] == 'v')
 		 && !arg[2]
 		) {
 			if (arg[1] == 'R') {
 				g.recursive = 1;
 				continue;
 			}
 			/* arg[1] == 'v' */
 			if (!*++argv)
 				bb_show_usage();
 			g.version = xatoul(*argv);
 			g.flags |= OPT_SET_VER;
 			continue;
 		}
 
 		if (!decode_arg(arg, &g))
 			break;
 	}
 
 	/* run sanity checks on all the arguments given us */
 	if (!*argv)
 		bb_show_usage();
 	if ((g.flags & OPT_SET) && (g.flags & (OPT_ADD|OPT_REM)))
 		bb_error_msg_and_die("= is incompatible with - and +");
 	if (g.rf & g.af)
 		bb_error_msg_and_die("can't set and unset a flag");
 	if (!g.flags)
 		bb_error_msg_and_die("must use '-v', =, - or +");
 
 	/* now run chattr on all the files passed to us */
 	do change_attributes(*argv, &g); while (*++argv);
 
 	return EXIT_SUCCESS;
 }
diff --git a/e2fsprogs/fsck.c b/e2fsprogs/fsck.c
index d2d312e..adaf0c5 100644
--- a/e2fsprogs/fsck.c
+++ b/e2fsprogs/fsck.c
@@ -1,1096 +1,1107 @@
 /* vi: set sw=4 ts=4: */
 /*
  * fsck --- A generic, parallelizing front-end for the fsck program.
  * It will automatically try to run fsck programs in parallel if the
  * devices are on separate spindles.  It is based on the same ideas as
  * the generic front end for fsck by David Engel and Fred van Kempen,
  * but it has been completely rewritten from scratch to support
  * parallel execution.
  *
  * Written by Theodore Ts'o, <tytso@mit.edu>
  *
  * Miquel van Smoorenburg (miquels@drinkel.ow.org) 20-Oct-1994:
  *   o Changed -t fstype to behave like with mount when -A (all file
  *     systems) or -M (like mount) is specified.
  *   o fsck looks if it can find the fsck.type program to decide
  *     if it should ignore the fs type. This way more fsck programs
  *     can be added without changing this front-end.
  *   o -R flag skip root file system.
  *
  * Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
  *      2001, 2002, 2003, 2004, 2005 by  Theodore Ts'o.
  *
  * Licensed under GPLv2, see file LICENSE in this source tree.
  */
 
 /* All filesystem specific hooks have been removed.
  * If filesystem cannot be determined, we will execute
  * "fsck.auto". Currently this also happens if you specify
  * UUID=xxx or LABEL=xxx as an object to check.
  * Detection code for that is also probably has to be in fsck.auto.
  *
  * In other words, this is _really_ is just a driver program which
  * spawns actual fsck.something for each filesystem to check.
  * It doesn't guess filesystem types from on-disk format.
  */
+//config:config FSCK
+//config:	bool "fsck"
+//config:	default y
+//config:	help
+//config:	  fsck is used to check and optionally repair one or more filesystems.
+//config:	  In actuality, fsck is simply a front-end for the various file system
+//config:	  checkers (fsck.fstype) available under Linux.
+
+//applet:IF_FSCK(APPLET(fsck, BB_DIR_SBIN, BB_SUID_DROP))
+
+//kbuild:lib-$(CONFIG_FSCK) += fsck.o
 
 //usage:#define fsck_trivial_usage
 //usage:       "[-ANPRTV] [-C FD] [-t FSTYPE] [FS_OPTS] [BLOCKDEV]..."
 //usage:#define fsck_full_usage "\n\n"
 //usage:       "Check and repair filesystems\n"
 //usage:     "\n	-A	Walk /etc/fstab and check all filesystems"
 //usage:     "\n	-N	Don't execute, just show what would be done"
 //usage:     "\n	-P	With -A, check filesystems in parallel"
 //usage:     "\n	-R	With -A, skip the root filesystem"
 //usage:     "\n	-T	Don't show title on startup"
 //usage:     "\n	-V	Verbose"
 //usage:     "\n	-C n	Write status information to specified filedescriptor"
 //usage:     "\n	-t TYPE	List of filesystem types to check"
 
 #include "libbb.h"
 
 /* "progress indicator" code is somewhat buggy and ext[23] specific.
  * We should be filesystem agnostic. IOW: there should be a well-defined
  * API for fsck.something, NOT ad-hoc hacks in generic fsck. */
 #define DO_PROGRESS_INDICATOR 0
 
 /* fsck 1.41.4 (27-Jan-2009) manpage says:
  * 0   - No errors
  * 1   - File system errors corrected
  * 2   - System should be rebooted
  * 4   - File system errors left uncorrected
  * 8   - Operational error
  * 16  - Usage or syntax error
  * 32  - Fsck canceled by user request
  * 128 - Shared library error
  */
 #define EXIT_OK          0
 #define EXIT_NONDESTRUCT 1
 #define EXIT_DESTRUCT    2
 #define EXIT_UNCORRECTED 4
 #define EXIT_ERROR       8
 #define EXIT_USAGE       16
 #define FSCK_CANCELED    32     /* Aborted with a signal or ^C */
 
 /*
  * Internal structure for mount table entries.
  */
 struct fs_info {
 	struct fs_info *next;
 	char	*device;
 	char	*mountpt;
 	char	*type;
 	char	*opts;
 	int	passno;
 	int	flags;
 };
 
 #define FLAG_DONE 1
 #define FLAG_PROGRESS 2
 /*
  * Structure to allow exit codes to be stored
  */
 struct fsck_instance {
 	struct fsck_instance *next;
 	int	pid;
 	int	flags;
 #if DO_PROGRESS_INDICATOR
 	time_t	start_time;
 #endif
 	char	*prog;
 	char	*device;
 	char	*base_device; /* /dev/hda for /dev/hdaN etc */
 };
 
 static const char ignored_types[] ALIGN1 =
 	"ignore\0"
 	"iso9660\0"
 	"nfs\0"
 	"proc\0"
 	"sw\0"
 	"swap\0"
 	"tmpfs\0"
 	"devpts\0";
 
 #if 0
 static const char really_wanted[] ALIGN1 =
 	"minix\0"
 	"ext2\0"
 	"ext3\0"
 	"jfs\0"
 	"reiserfs\0"
 	"xiafs\0"
 	"xfs\0";
 #endif
 
 #define BASE_MD "/dev/md"
 
 static char **args;
 static int num_args;
 static int verbose;
 
 #define FS_TYPE_FLAG_NORMAL 0
 #define FS_TYPE_FLAG_OPT    1
 #define FS_TYPE_FLAG_NEGOPT 2
 static char **fs_type_list;
 static uint8_t *fs_type_flag;
 static smallint fs_type_negated;
 
 static smallint noexecute;
 static smallint serialize;
 static smallint skip_root;
 /* static smallint like_mount; */
 static smallint parallel_root;
 static smallint force_all_parallel;
 
 #if DO_PROGRESS_INDICATOR
 static smallint progress;
 static int progress_fd;
 #endif
 
 static int num_running;
 static int max_running;
 static char *fstype;
 static struct fs_info *filesys_info;
 static struct fs_info *filesys_last;
 static struct fsck_instance *instance_list;
 
 /*
  * Return the "base device" given a particular device; this is used to
  * assure that we only fsck one partition on a particular drive at any
  * one time.  Otherwise, the disk heads will be seeking all over the
  * place.  If the base device cannot be determined, return NULL.
  *
  * The base_device() function returns an allocated string which must
  * be freed.
  */
 #if ENABLE_FEATURE_DEVFS
 /*
  * Required for the uber-silly devfs /dev/ide/host1/bus2/target3/lun3
  * pathames.
  */
 static const char *const devfs_hier[] = {
 	"host", "bus", "target", "lun", NULL
 };
 #endif
 
 static char *base_device(const char *device)
 {
 	char *str, *cp;
 #if ENABLE_FEATURE_DEVFS
 	const char *const *hier;
 	const char *disk;
 	int len;
 #endif
 	str = xstrdup(device);
 
 	/* Skip over "/dev/"; if it's not present, give up */
 	cp = skip_dev_pfx(str);
 	if (cp == str)
 		goto errout;
 
 	/*
 	 * For md devices, we treat them all as if they were all
 	 * on one disk, since we don't know how to parallelize them.
 	 */
 	if (cp[0] == 'm' && cp[1] == 'd') {
 		cp[2] = 0;
 		return str;
 	}
 
 	/* Handle DAC 960 devices */
 	if (is_prefixed_with(cp, "rd/")) {
 		cp += 3;
 		if (cp[0] != 'c' || !isdigit(cp[1])
 		 || cp[2] != 'd' || !isdigit(cp[3]))
 			goto errout;
 		cp[4] = 0;
 		return str;
 	}
 
 	/* Now let's handle /dev/hd* and /dev/sd* devices.... */
 	if ((cp[0] == 'h' || cp[0] == 's') && cp[1] == 'd') {
 		cp += 2;
 		/* If there's a single number after /dev/hd, skip it */
 		if (isdigit(*cp))
 			cp++;
 		/* What follows must be an alpha char, or give up */
 		if (!isalpha(*cp))
 			goto errout;
 		cp[1] = 0;
 		return str;
 	}
 
 #if ENABLE_FEATURE_DEVFS
 	/* Now let's handle devfs (ugh) names */
 	len = 0;
 	if (is_prefixed_with(cp, "ide/"))
 		len = 4;
 	if (is_prefixed_with(cp, "scsi/"))
 		len = 5;
 	if (len) {
 		cp += len;
 		/*
 		 * Now we proceed down the expected devfs hierarchy.
 		 * i.e., .../host1/bus2/target3/lun4/...
 		 * If we don't find the expected token, followed by
 		 * some number of digits at each level, abort.
 		 */
 		for (hier = devfs_hier; *hier; hier++) {
 			cp = is_prefixed_with(cp, *hier);
 			if (!cp)
 				goto errout;
 			while (*cp != '/' && *cp != '\0') {
 				if (!isdigit(*cp))
 					goto errout;
 				cp++;
 			}
 //FIXME: what if *cp = '\0' now? cp++ moves past it!!!
 			cp++;
 		}
 		cp[-1] = '\0';
 		return str;
 	}
 
 	/* Now handle devfs /dev/disc or /dev/disk names */
 	disk = NULL;
 	if (is_prefixed_with(cp, "discs/"))
 		disk = "disc";
 	else if (is_prefixed_with(cp, "disks/"))
 		disk = "disk";
 	if (disk) {
 		cp += 6;
 		cp = is_prefixed_with(cp, disk);
 		if (!cp)
 			goto errout;
 		while (*cp != '/' && *cp != '\0') {
 			if (!isdigit(*cp))
 				goto errout;
 			cp++;
 		}
 		*cp = '\0';
 		return str;
 	}
 #endif
  errout:
 	free(str);
 	return NULL;
 }
 
 static void free_instance(struct fsck_instance *p)
 {
 	free(p->prog);
 	free(p->device);
 	free(p->base_device);
 	free(p);
 }
 
 static struct fs_info *create_fs_device(const char *device, const char *mntpnt,
 					const char *type, const char *opts,
 					int passno)
 {
 	struct fs_info *fs;
 
 	fs = xzalloc(sizeof(*fs));
 	fs->device = xstrdup(device);
 	fs->mountpt = xstrdup(mntpnt);
 	if (strchr(type, ','))
 		type = (char *)"auto";
 	fs->type = xstrdup(type);
 	fs->opts = xstrdup(opts ? opts : "");
 	fs->passno = passno < 0 ? 1 : passno;
 	/*fs->flags = 0; */
 	/*fs->next = NULL; */
 
 	if (!filesys_info)
 		filesys_info = fs;
 	else
 		filesys_last->next = fs;
 	filesys_last = fs;
 
 	return fs;
 }
 
 /* Load the filesystem database from /etc/fstab */
 static void load_fs_info(const char *filename)
 {
 	FILE *fstab;
 	struct mntent mte;
 
 	fstab = setmntent(filename, "r");
 	if (!fstab) {
 		bb_perror_msg("can't read '%s'", filename);
 		return;
 	}
 
 	// Loop through entries
 	while (getmntent_r(fstab, &mte, bb_common_bufsiz1, COMMON_BUFSIZE)) {
 		//bb_info_msg("CREATE[%s][%s][%s][%s][%d]", mte.mnt_fsname, mte.mnt_dir,
 		//	mte.mnt_type, mte.mnt_opts,
 		//	mte.mnt_passno);
 		create_fs_device(mte.mnt_fsname, mte.mnt_dir,
 			mte.mnt_type, mte.mnt_opts,
 			mte.mnt_passno);
 	}
 	endmntent(fstab);
 }
 
 /* Lookup filesys in /etc/fstab and return the corresponding entry. */
 static struct fs_info *lookup(char *filesys)
 {
 	struct fs_info *fs;
 
 	for (fs = filesys_info; fs; fs = fs->next) {
 		if (strcmp(filesys, fs->device) == 0
 		 || (fs->mountpt && strcmp(filesys, fs->mountpt) == 0)
 		)
 			break;
 	}
 
 	return fs;
 }
 
 #if DO_PROGRESS_INDICATOR
 static int progress_active(void)
 {
 	struct fsck_instance *inst;
 
 	for (inst = instance_list; inst; inst = inst->next) {
 		if (inst->flags & FLAG_DONE)
 			continue;
 		if (inst->flags & FLAG_PROGRESS)
 			return 1;
 	}
 	return 0;
 }
 #endif
 
 
 /*
  * Send a signal to all outstanding fsck child processes
  */
 static void kill_all_if_got_signal(void)
 {
 	static smallint kill_sent;
 
 	struct fsck_instance *inst;
 
 	if (!bb_got_signal || kill_sent)
 		return;
 
 	for (inst = instance_list; inst; inst = inst->next) {
 		if (inst->flags & FLAG_DONE)
 			continue;
 		kill(inst->pid, SIGTERM);
 	}
 	kill_sent = 1;
 }
 
 /*
  * Wait for one child process to exit; when it does, unlink it from
  * the list of executing child processes, free, and return its exit status.
  * If there is no exited child, return -1.
  */
 static int wait_one(int flags)
 {
 	int status;
 	int sig;
 	struct fsck_instance *inst, *prev;
 	pid_t pid;
 
 	if (!instance_list)
 		return -1;
 	/* if (noexecute) { already returned -1; } */
 
 	while (1) {
 		pid = waitpid(-1, &status, flags);
 		kill_all_if_got_signal();
 		if (pid == 0) /* flags == WNOHANG and no children exited */
 			return -1;
 		if (pid < 0) {
 			if (errno == EINTR)
 				continue;
 			if (errno == ECHILD) { /* paranoia */
 				bb_error_msg("wait: no more children");
 				return -1;
 			}
 			bb_perror_msg("wait");
 			continue;
 		}
 		prev = NULL;
 		inst = instance_list;
 		do {
 			if (inst->pid == pid)
 				goto child_died;
 			prev = inst;
 			inst = inst->next;
 		} while (inst);
 	}
  child_died:
 
 	if (WIFEXITED(status))
 		status = WEXITSTATUS(status);
 	else if (WIFSIGNALED(status)) {
 		sig = WTERMSIG(status);
 		status = EXIT_UNCORRECTED;
 		if (sig != SIGINT) {
 			printf("Warning: %s %s terminated "
 				"by signal %d\n",
 				inst->prog, inst->device, sig);
 			status = EXIT_ERROR;
 		}
 	} else {
 		printf("%s %s: status is %x, should never happen\n",
 			inst->prog, inst->device, status);
 		status = EXIT_ERROR;
 	}
 
 #if DO_PROGRESS_INDICATOR
 	if (progress && (inst->flags & FLAG_PROGRESS) && !progress_active()) {
 		struct fsck_instance *inst2;
 		for (inst2 = instance_list; inst2; inst2 = inst2->next) {
 			if (inst2->flags & FLAG_DONE)
 				continue;
 			if (strcmp(inst2->type, "ext2") != 0
 			 && strcmp(inst2->type, "ext3") != 0
 			) {
 				continue;
 			}
 			/* ext[23], we will send USR1
 			 * (request to start displaying progress bar)
 			 *
 			 * If we've just started the fsck, wait a tiny
 			 * bit before sending the kill, to give it
 			 * time to set up the signal handler
 			 */
 			if (inst2->start_time >= time(NULL) - 1)
 				sleep(1);
 			kill(inst2->pid, SIGUSR1);
 			inst2->flags |= FLAG_PROGRESS;
 			break;
 		}
 	}
 #endif
 
 	if (prev)
 		prev->next = inst->next;
 	else
 		instance_list = inst->next;
 	if (verbose > 1)
 		printf("Finished with %s (exit status %d)\n",
 			inst->device, status);
 	num_running--;
 	free_instance(inst);
 
 	return status;
 }
 
 /*
  * Wait until all executing child processes have exited; return the
  * logical OR of all of their exit code values.
  */
 #define FLAG_WAIT_ALL           0
 #define FLAG_WAIT_ATLEAST_ONE   WNOHANG
 static int wait_many(int flags)
 {
 	int exit_status;
 	int global_status = 0;
 	int wait_flags = 0;
 
 	while ((exit_status = wait_one(wait_flags)) != -1) {
 		global_status |= exit_status;
 		wait_flags |= flags;
 	}
 	return global_status;
 }
 
 /*
  * Execute a particular fsck program, and link it into the list of
  * child processes we are waiting for.
  */
 static void execute(const char *type, const char *device,
 		const char *mntpt /*, int interactive */)
 {
 	int i;
 	struct fsck_instance *inst;
 	pid_t pid;
 
 	args[0] = xasprintf("fsck.%s", type);
 
 #if DO_PROGRESS_INDICATOR
 	if (progress && !progress_active()) {
 		if (strcmp(type, "ext2") == 0
 		 || strcmp(type, "ext3") == 0
 		) {
 			args[XXX] = xasprintf("-C%d", progress_fd); /* 1 */
 			inst->flags |= FLAG_PROGRESS;
 		}
 	}
 #endif
 
 	args[num_args - 2] = (char*)device;
 	/* args[num_args - 1] = NULL; - already is */
 
 	if (verbose || noexecute) {
 		printf("[%s (%d) -- %s]", args[0], num_running,
 					mntpt ? mntpt : device);
 		for (i = 0; args[i]; i++)
 			printf(" %s", args[i]);
 		bb_putchar('\n');
 	}
 
 	/* Fork and execute the correct program. */
 	pid = -1;
 	if (!noexecute) {
 		pid = spawn(args);
 		if (pid < 0)
 			bb_simple_perror_msg(args[0]);
 	}
 
 #if DO_PROGRESS_INDICATOR
 	free(args[XXX]);
 #endif
 
 	/* No child, so don't record an instance */
 	if (pid <= 0) {
 		free(args[0]);
 		return;
 	}
 
 	inst = xzalloc(sizeof(*inst));
 	inst->pid = pid;
 	inst->prog = args[0];
 	inst->device = xstrdup(device);
 	inst->base_device = base_device(device);
 #if DO_PROGRESS_INDICATOR
 	inst->start_time = time(NULL);
 #endif
 
 	/* Add to the list of running fsck's.
 	 * (was adding to the end, but adding to the front is simpler...) */
 	inst->next = instance_list;
 	instance_list = inst;
 }
 
 /*
  * Run the fsck program on a particular device
  *
  * If the type is specified using -t, and it isn't prefixed with "no"
  * (as in "noext2") and only one filesystem type is specified, then
  * use that type regardless of what is specified in /etc/fstab.
  *
  * If the type isn't specified by the user, then use either the type
  * specified in /etc/fstab, or "auto".
  */
 static void fsck_device(struct fs_info *fs /*, int interactive */)
 {
 	const char *type;
 
 	if (strcmp(fs->type, "auto") != 0) {
 		type = fs->type;
 		if (verbose > 2)
 			bb_info_msg("using filesystem type '%s' %s",
 					type, "from fstab");
 	} else if (fstype
 	 && (fstype[0] != 'n' || fstype[1] != 'o') /* != "no" */
 	 && !is_prefixed_with(fstype, "opts=")
 	 && !is_prefixed_with(fstype, "loop")
 	 && !strchr(fstype, ',')
 	) {
 		type = fstype;
 		if (verbose > 2)
 			bb_info_msg("using filesystem type '%s' %s",
 					type, "from -t");
 	} else {
 		type = "auto";
 		if (verbose > 2)
 			bb_info_msg("using filesystem type '%s' %s",
 					type, "(default)");
 	}
 
 	num_running++;
 	execute(type, fs->device, fs->mountpt /*, interactive */);
 }
 
 /*
  * Returns TRUE if a partition on the same disk is already being
  * checked.
  */
 static int device_already_active(char *device)
 {
 	struct fsck_instance *inst;
 	char *base;
 
 	if (force_all_parallel)
 		return 0;
 
 #ifdef BASE_MD
 	/* Don't check a soft raid disk with any other disk */
 	if (instance_list
 	 && (is_prefixed_with(instance_list->device, BASE_MD)
 	     || is_prefixed_with(device, BASE_MD))
 	) {
 		return 1;
 	}
 #endif
 
 	base = base_device(device);
 	/*
 	 * If we don't know the base device, assume that the device is
 	 * already active if there are any fsck instances running.
 	 */
 	if (!base)
 		return (instance_list != NULL);
 
 	for (inst = instance_list; inst; inst = inst->next) {
 		if (!inst->base_device || !strcmp(base, inst->base_device)) {
 			free(base);
 			return 1;
 		}
 	}
 
 	free(base);
 	return 0;
 }
 
 /*
  * This function returns true if a particular option appears in a
  * comma-delimited options list
  */
 static int opt_in_list(char *opt, char *optlist)
 {
 	char *s;
 	int len;
 
 	if (!optlist)
 		return 0;
 
 	len = strlen(opt);
 	s = optlist - 1;
 	while (1) {
 		s = strstr(s + 1, opt);
 		if (!s)
 			return 0;
 		/* neither "opt.." nor "xxx,opt.."? */
 		if (s != optlist && s[-1] != ',')
 			continue;
 		/* neither "..opt" nor "..opt,xxx"? */
 		if (s[len] != '\0' && s[len] != ',')
 			continue;
 		return 1;
 	}
 }
 
 /* See if the filesystem matches the criteria given by the -t option */
 static int fs_match(struct fs_info *fs)
 {
 	int n, ret, checked_type;
 	char *cp;
 
 	if (!fs_type_list)
 		return 1;
 
 	ret = 0;
 	checked_type = 0;
 	n = 0;
 	while (1) {
 		cp = fs_type_list[n];
 		if (!cp)
 			break;
 		switch (fs_type_flag[n]) {
 		case FS_TYPE_FLAG_NORMAL:
 			checked_type++;
 			if (strcmp(cp, fs->type) == 0)
 				ret = 1;
 			break;
 		case FS_TYPE_FLAG_NEGOPT:
 			if (opt_in_list(cp, fs->opts))
 				return 0;
 			break;
 		case FS_TYPE_FLAG_OPT:
 			if (!opt_in_list(cp, fs->opts))
 				return 0;
 			break;
 		}
 		n++;
 	}
 	if (checked_type == 0)
 		return 1;
 
 	return (fs_type_negated ? !ret : ret);
 }
 
 /* Check if we should ignore this filesystem. */
 static int ignore(struct fs_info *fs)
 {
 	/*
 	 * If the pass number is 0, ignore it.
 	 */
 	if (fs->passno == 0)
 		return 1;
 
 	/*
 	 * If a specific fstype is specified, and it doesn't match,
 	 * ignore it.
 	 */
 	if (!fs_match(fs))
 		return 1;
 
 	/* Are we ignoring this type? */
 	if (index_in_strings(ignored_types, fs->type) >= 0)
 		return 1;
 
 	/* We can and want to check this file system type. */
 	return 0;
 }
 
 /* Check all file systems, using the /etc/fstab table. */
 static int check_all(void)
 {
 	struct fs_info *fs;
 	int status = EXIT_OK;
 	smallint not_done_yet;
 	smallint pass_done;
 	int passno;
 
 	if (verbose)
 		puts("Checking all filesystems");
 
 	/*
 	 * Do an initial scan over the filesystem; mark filesystems
 	 * which should be ignored as done, and resolve any "auto"
 	 * filesystem types (done as a side-effect of calling ignore()).
 	 */
 	for (fs = filesys_info; fs; fs = fs->next)
 		if (ignore(fs))
 			fs->flags |= FLAG_DONE;
 
 	/*
 	 * Find and check the root filesystem.
 	 */
 	if (!parallel_root) {
 		for (fs = filesys_info; fs; fs = fs->next) {
 			if (LONE_CHAR(fs->mountpt, '/')) {
 				if (!skip_root && !ignore(fs)) {
 					fsck_device(fs /*, 1*/);
 					status |= wait_many(FLAG_WAIT_ALL);
 					if (status > EXIT_NONDESTRUCT)
 						return status;
 				}
 				fs->flags |= FLAG_DONE;
 				break;
 			}
 		}
 	}
 	/*
 	 * This is for the bone-headed user who has root
 	 * filesystem listed twice.
 	 * "Skip root" will skip _all_ root entries.
 	 */
 	if (skip_root)
 		for (fs = filesys_info; fs; fs = fs->next)
 			if (LONE_CHAR(fs->mountpt, '/'))
 				fs->flags |= FLAG_DONE;
 
 	not_done_yet = 1;
 	passno = 1;
 	while (not_done_yet) {
 		not_done_yet = 0;
 		pass_done = 1;
 
 		for (fs = filesys_info; fs; fs = fs->next) {
 			if (bb_got_signal)
 				break;
 			if (fs->flags & FLAG_DONE)
 				continue;
 			/*
 			 * If the filesystem's pass number is higher
 			 * than the current pass number, then we didn't
 			 * do it yet.
 			 */
 			if (fs->passno > passno) {
 				not_done_yet = 1;
 				continue;
 			}
 			/*
 			 * If a filesystem on a particular device has
 			 * already been spawned, then we need to defer
 			 * this to another pass.
 			 */
 			if (device_already_active(fs->device)) {
 				pass_done = 0;
 				continue;
 			}
 			/*
 			 * Spawn off the fsck process
 			 */
 			fsck_device(fs /*, serialize*/);
 			fs->flags |= FLAG_DONE;
 
 			/*
 			 * Only do one filesystem at a time, or if we
 			 * have a limit on the number of fsck's extant
 			 * at one time, apply that limit.
 			 */
 			if (serialize
 			 || (max_running && (num_running >= max_running))
 			) {
 				pass_done = 0;
 				break;
 			}
 		}
 		if (bb_got_signal)
 			break;
 		if (verbose > 1)
 			printf("--waiting-- (pass %d)\n", passno);
 		status |= wait_many(pass_done ? FLAG_WAIT_ALL :
 				FLAG_WAIT_ATLEAST_ONE);
 		if (pass_done) {
 			if (verbose > 1)
 				puts("----------------------------------");
 			passno++;
 		} else
 			not_done_yet = 1;
 	}
 	kill_all_if_got_signal();
 	status |= wait_many(FLAG_WAIT_ATLEAST_ONE);
 	return status;
 }
 
 /*
  * Deal with the fsck -t argument.
  * Huh, for mount "-t novfat,nfs" means "neither vfat nor nfs"!
  * Why here we require "-t novfat,nonfs" ??
  */
 static void compile_fs_type(char *fs_type)
 {
 	char *s;
 	int num = 2;
 	smallint negate;
 
 	s = fs_type;
 	while ((s = strchr(s, ','))) {
 		num++;
 		s++;
 	}
 
 	fs_type_list = xzalloc(num * sizeof(fs_type_list[0]));
 	fs_type_flag = xzalloc(num * sizeof(fs_type_flag[0]));
 	fs_type_negated = -1; /* not yet known is it negated or not */
 
 	num = 0;
 	s = fs_type;
 	while (1) {
 		char *comma;
 
 		negate = 0;
 		if (s[0] == 'n' && s[1] == 'o') { /* "no.." */
 			s += 2;
 			negate = 1;
 		} else if (s[0] == '!') {
 			s++;
 			negate = 1;
 		}
 
 		if (strcmp(s, "loop") == 0)
 			/* loop is really short-hand for opts=loop */
 			goto loop_special_case;
 		if (is_prefixed_with(s, "opts=")) {
 			s += 5;
  loop_special_case:
 			fs_type_flag[num] = negate ? FS_TYPE_FLAG_NEGOPT : FS_TYPE_FLAG_OPT;
 		} else {
 			if (fs_type_negated == -1)
 				fs_type_negated = negate;
 			if (fs_type_negated != negate)
 				bb_error_msg_and_die(
 "either all or none of the filesystem types passed to -t must be prefixed "
 "with 'no' or '!'");
 		}
 		comma = strchr(s, ',');
 		fs_type_list[num++] = comma ? xstrndup(s, comma-s) : xstrdup(s);
 		if (!comma)
 			break;
 		s = comma + 1;
 	}
 }
 
 static char **new_args(void)
 {
 	args = xrealloc_vector(args, 2, num_args);
 	return &args[num_args++];
 }
 
 int fsck_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 int fsck_main(int argc UNUSED_PARAM, char **argv)
 {
 	int i, status;
 	/*int interactive;*/
 	struct fs_info *fs;
 	const char *fstab;
 	char *tmp;
 	char **devices;
 	int num_devices;
 	smallint opts_for_fsck;
 	smallint doall;
 	smallint notitle;
 
 	/* we want wait() to be interruptible */
 	signal_no_SA_RESTART_empty_mask(SIGINT, record_signo);
 	signal_no_SA_RESTART_empty_mask(SIGTERM, record_signo);
 
 	setbuf(stdout, NULL);
 
 	opts_for_fsck = doall = notitle = 0;
 	devices = NULL;
 	num_devices = 0;
 	new_args(); /* args[0] = NULL, will be replaced by fsck.<type> */
 	/* instance_list = NULL; - in bss, so already zeroed */
 
 	while (*++argv) {
 		int j;
 		int optpos;
 		char *options;
 		char *arg = *argv;
 
 		/* "/dev/blk" or "/path" or "UUID=xxx" or "LABEL=xxx" */
 		if ((arg[0] == '/' && !opts_for_fsck) || strchr(arg, '=')) {
 // FIXME: must check that arg is a blkdev, or resolve
 // "/path", "UUID=xxx" or "LABEL=xxx" into block device name
 // ("UUID=xxx"/"LABEL=xxx" can probably shifted to fsck.auto duties)
 			devices = xrealloc_vector(devices, 2, num_devices);
 			devices[num_devices++] = arg;
 			continue;
 		}
 
 		if (arg[0] != '-' || opts_for_fsck) {
 			*new_args() = arg;
 			continue;
 		}
 
 		if (LONE_CHAR(arg + 1, '-')) { /* "--" ? */
 			opts_for_fsck = 1;
 			continue;
 		}
 
 		optpos = 0;
 		options = NULL;
 		for (j = 1; arg[j]; j++) {
 			switch (arg[j]) {
 			case 'A':
 				doall = 1;
 				break;
 #if DO_PROGRESS_INDICATOR
 			case 'C':
 				progress = 1;
 				if (arg[++j]) { /* -Cn */
 					progress_fd = xatoi_positive(&arg[j]);
 					goto next_arg;
 				}
 				/* -C n */
 				if (!*++argv)
 					bb_show_usage();
 				progress_fd = xatoi_positive(*argv);
 				goto next_arg;
 #endif
 			case 'V':
 				verbose++;
 				break;
 			case 'N':
 				noexecute = 1;
 				break;
 			case 'R':
 				skip_root = 1;
 				break;
 			case 'T':
 				notitle = 1;
 				break;
 /*			case 'M':
 				like_mount = 1;
 				break; */
 			case 'P':
 				parallel_root = 1;
 				break;
 			case 's':
 				serialize = 1;
 				break;
 			case 't':
 				if (fstype)
 					bb_show_usage();
 				if (arg[++j])
 					tmp = &arg[j];
 				else if (*++argv)
 					tmp = *argv;
 				else
 					bb_show_usage();
 				fstype = xstrdup(tmp);
 				compile_fs_type(fstype);
 				goto next_arg;
 			case '?':
 				bb_show_usage();
 				break;
 			default:
 				optpos++;
 				/* one extra for '\0' */
 				options = xrealloc(options, optpos + 2);
 				options[optpos] = arg[j];
 				break;
 			}
 		}
  next_arg:
 		if (optpos) {
 			options[0] = '-';
 			options[optpos + 1] = '\0';
 			*new_args() = options;
 		}
 	}
 	if (getenv("FSCK_FORCE_ALL_PARALLEL"))
 		force_all_parallel = 1;
 	tmp = getenv("FSCK_MAX_INST");
 	if (tmp)
 		max_running = xatoi(tmp);
 	new_args(); /* args[num_args - 2] will be replaced by <device> */
 	new_args(); /* args[num_args - 1] is the last, NULL element */
 
 	if (!notitle)
 		puts("fsck (busybox "BB_VER", "BB_BT")");
 
 	/* Even plain "fsck /dev/hda1" needs fstab to get fs type,
 	 * so we are scanning it anyway */
 	fstab = getenv("FSTAB_FILE");
 	if (!fstab)
 		fstab = "/etc/fstab";
 	load_fs_info(fstab);
 
 	/*interactive = (num_devices == 1) | serialize;*/
 
 	if (num_devices == 0)
 		/*interactive =*/ serialize = doall = 1;
 	if (doall)
 		return check_all();
 
 	status = 0;
 	for (i = 0; i < num_devices; i++) {
 		if (bb_got_signal) {
 			kill_all_if_got_signal();
 			break;
 		}
 
 		fs = lookup(devices[i]);
 		if (!fs)
 			fs = create_fs_device(devices[i], "", "auto", NULL, -1);
 		fsck_device(fs /*, interactive */);
 
 		if (serialize
 		 || (max_running && (num_running >= max_running))
 		) {
 			int exit_status = wait_one(0);
 			if (exit_status >= 0)
 				status |= exit_status;
 			if (verbose > 1)
 				puts("----------------------------------");
 		}
 	}
 	status |= wait_many(FLAG_WAIT_ALL);
 	return status;
 }
diff --git a/e2fsprogs/lsattr.c b/e2fsprogs/lsattr.c
index 1312fe7..3a7dd6b 100644
--- a/e2fsprogs/lsattr.c
+++ b/e2fsprogs/lsattr.c
@@ -1,120 +1,122 @@
 /* vi: set sw=4 ts=4: */
 /*
  * lsattr.c		- List file attributes on an ext2 file system
  *
  * Copyright (C) 1993, 1994  Remy Card <card@masi.ibp.fr>
  *                           Laboratoire MASI, Institut Blaise Pascal
  *                           Universite Pierre et Marie Curie (Paris VI)
  *
  * This file can be redistributed under the terms of the GNU General
  * Public License
  */
+//config:config LSATTR
+//config:	bool "lsattr"
+//config:	default y
+//config:	select PLATFORM_LINUX
+//config:	help
+//config:	  lsattr lists the file attributes on a second extended file system.
 
-/*
- * History:
- * 93/10/30	- Creation
- * 93/11/13	- Replace stat() calls by lstat() to avoid loops
- * 94/02/27	- Integrated in Ted's distribution
- * 98/12/29	- Display version info only when -V specified (G M Sipe)
- */
+//applet:IF_LSATTR(APPLET(lsattr, BB_DIR_BIN, BB_SUID_DROP))
+
+//kbuild:lib-$(CONFIG_LSATTR) += lsattr.o e2fs_lib.o
 
 //usage:#define lsattr_trivial_usage
 //usage:       "[-Radlv] [FILE]..."
 //usage:#define lsattr_full_usage "\n\n"
 //usage:       "List file attributes on an ext2 fs\n"
 //usage:     "\n	-R	Recurse"
 //usage:     "\n	-a	Don't hide entries starting with ."
 //usage:     "\n	-d	List directory entries instead of contents"
 //usage:     "\n	-l	List long flag names"
 //usage:     "\n	-v	List the file's version/generation number"
 
 #include "libbb.h"
 #include "e2fs_lib.h"
 
 enum {
 	OPT_RECUR      = 0x1,
 	OPT_ALL        = 0x2,
 	OPT_DIRS_OPT   = 0x4,
 	OPT_PF_LONG    = 0x8,
 	OPT_GENERATION = 0x10,
 };
 
 static void list_attributes(const char *name)
 {
 	unsigned long fsflags;
 	unsigned long generation;
 
 	if (fgetflags(name, &fsflags) != 0)
 		goto read_err;
 
 	if (option_mask32 & OPT_GENERATION) {
 		if (fgetversion(name, &generation) != 0)
 			goto read_err;
 		printf("%5lu ", generation);
 	}
 
 	if (option_mask32 & OPT_PF_LONG) {
 		printf("%-28s ", name);
 		print_e2flags(stdout, fsflags, PFOPT_LONG);
 		bb_putchar('\n');
 	} else {
 		print_e2flags(stdout, fsflags, 0);
 		printf(" %s\n", name);
 	}
 
 	return;
  read_err:
 	bb_perror_msg("reading %s", name);
 }
 
 static int FAST_FUNC lsattr_dir_proc(const char *dir_name,
 		struct dirent *de,
 		void *private UNUSED_PARAM)
 {
 	struct stat st;
 	char *path;
 
 	path = concat_path_file(dir_name, de->d_name);
 
 	if (lstat(path, &st) != 0)
 		bb_perror_msg("stat %s", path);
 	else if (de->d_name[0] != '.' || (option_mask32 & OPT_ALL)) {
 		list_attributes(path);
 		if (S_ISDIR(st.st_mode) && (option_mask32 & OPT_RECUR)
 		 && !DOT_OR_DOTDOT(de->d_name)
 		) {
 			printf("\n%s:\n", path);
 			iterate_on_dir(path, lsattr_dir_proc, NULL);
 			bb_putchar('\n');
 		}
 	}
 
 	free(path);
 	return 0;
 }
 
 static void lsattr_args(const char *name)
 {
 	struct stat st;
 
 	if (lstat(name, &st) == -1) {
 		bb_perror_msg("stat %s", name);
 	} else if (S_ISDIR(st.st_mode) && !(option_mask32 & OPT_DIRS_OPT)) {
 		iterate_on_dir(name, lsattr_dir_proc, NULL);
 	} else {
 		list_attributes(name);
 	}
 }
 
 int lsattr_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 int lsattr_main(int argc UNUSED_PARAM, char **argv)
 {
 	getopt32(argv, "Radlv");
 	argv += optind;
 
 	if (!*argv)
 		*--argv = (char*)".";
 	do lsattr_args(*argv++); while (*argv);
 
 	return EXIT_SUCCESS;
 }
diff --git a/e2fsprogs/tune2fs.c b/e2fsprogs/tune2fs.c
index 46a745e..c9f88b3 100644
--- a/e2fsprogs/tune2fs.c
+++ b/e2fsprogs/tune2fs.c
@@ -1,107 +1,118 @@
 /* vi: set sw=4 ts=4: */
 /*
  * tune2fs: utility to modify EXT2 filesystem
  *
  * Busybox'ed (2009) by Vladimir Dronnikov <dronnikov@gmail.com>
  *
  * Licensed under GPLv2, see file LICENSE in this source tree.
  */
+//config:config TUNE2FS
+//config:	bool "tune2fs"
+//config:	default n  # off: it is too limited compared to upstream version
+//config:	help
+//config:	  tune2fs allows the system administrator to adjust various tunable
+//config:	  filesystem parameters on Linux ext2/ext3 filesystems.
+
+//applet:IF_TUNE2FS(APPLET(tune2fs, BB_DIR_SBIN, BB_SUID_DROP))
+
+//kbuild:lib-$(CONFIG_TUNE2FS) += tune2fs.o
+
+//usage:#define tune2fs_trivial_usage
+//usage:       "[-c MAX_MOUNT_COUNT] "
+////usage:     "[-e errors-behavior] [-g group] "
+//usage:       "[-i DAYS] "
+////usage:     "[-j] [-J journal-options] [-l] [-s sparse-flag] "
+////usage:     "[-m reserved-blocks-percent] [-o [^]mount-options[,...]] "
+////usage:     "[-r reserved-blocks-count] [-u user] "
+//usage:       "[-C MOUNT_COUNT] "
+//usage:       "[-L LABEL] "
+////usage:     "[-M last-mounted-dir] [-O [^]feature[,...]] "
+////usage:     "[-T last-check-time] [-U UUID] "
+//usage:       "BLOCKDEV"
+//usage:
+//usage:#define tune2fs_full_usage "\n\n"
+//usage:       "Adjust filesystem options on ext[23] filesystems"
+
 #include "libbb.h"
 #include <linux/fs.h>
 #include "bb_e2fs_defs.h"
 
 // storage helpers
 char BUG_wrong_field_size(void);
 #define STORE_LE(field, value) \
 do { \
 	if (sizeof(field) == 4) \
 		field = SWAP_LE32(value); \
 	else if (sizeof(field) == 2) \
 		field = SWAP_LE16(value); \
 	else if (sizeof(field) == 1) \
 		field = (value); \
 	else \
 		BUG_wrong_field_size(); \
 } while (0)
 
 #define FETCH_LE32(field) \
 	(sizeof(field) == 4 ? SWAP_LE32(field) : BUG_wrong_field_size())
 
-//usage:#define tune2fs_trivial_usage
-//usage:       "[-c MAX_MOUNT_COUNT] "
-////usage:     "[-e errors-behavior] [-g group] "
-//usage:       "[-i DAYS] "
-////usage:     "[-j] [-J journal-options] [-l] [-s sparse-flag] "
-////usage:     "[-m reserved-blocks-percent] [-o [^]mount-options[,...]] "
-////usage:     "[-r reserved-blocks-count] [-u user] "
-//usage:       "[-C MOUNT_COUNT] "
-//usage:       "[-L LABEL] "
-////usage:     "[-M last-mounted-dir] [-O [^]feature[,...]] "
-////usage:     "[-T last-check-time] [-U UUID] "
-//usage:       "BLOCKDEV"
-//usage:
-//usage:#define tune2fs_full_usage "\n\n"
-//usage:       "Adjust filesystem options on ext[23] filesystems"
-
 enum {
 	OPT_L = 1 << 0, // label
 	OPT_c = 1 << 1, // max mount count
 	OPT_i = 1 << 2, // check interval
 	OPT_C = 1 << 3, // current mount count
 };
 
 int tune2fs_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 int tune2fs_main(int argc UNUSED_PARAM, char **argv)
 {
 	unsigned opts;
 	const char *label, *str_c, *str_i, *str_C;
 	struct ext2_super_block *sb;
 	int fd;
 
 	opt_complementary = "=1";
 	opts = getopt32(argv, "L:c:i:C:", &label, &str_c, &str_i, &str_C);
 	if (!opts)
 		bb_show_usage();
 	argv += optind; // argv[0] -- device
 
 	// read superblock
 	fd = xopen(argv[0], O_RDWR);
 	xlseek(fd, 1024, SEEK_SET);
 	sb = xzalloc(1024);
 	xread(fd, sb, 1024);
 
 	// mangle superblock
 	//STORE_LE(sb->s_wtime, time(NULL)); - why bother?
 
 	if (opts & OPT_C) {
 		int n = xatoi_range(str_C, 1, 0xfffe);
 		STORE_LE(sb->s_mnt_count, (unsigned)n);
 	}
 
 	// set the label
 	if (opts & OPT_L)
 		safe_strncpy((char *)sb->s_volume_name, label, sizeof(sb->s_volume_name));
 
 	if (opts & OPT_c) {
 		int n = xatoi_range(str_c, -1, 0xfffe);
 		if (n == 0)
 			n = -1;
 		STORE_LE(sb->s_max_mnt_count, (unsigned)n);
 	}
 
 	if (opts & OPT_i) {
 		unsigned n = xatou_range(str_i, 0, (unsigned)0xffffffff / (24*60*60)) * 24*60*60;
 		STORE_LE(sb->s_checkinterval, n);
 	}
 
 	// write superblock
 	xlseek(fd, 1024, SEEK_SET);
 	xwrite(fd, sb, 1024);
 
 	if (ENABLE_FEATURE_CLEAN_UP) {
 		free(sb);
 	}
 
 	xclose(fd);
 	return EXIT_SUCCESS;
 }
diff --git a/include/applets.src.h b/include/applets.src.h
index c1b8017..c1ed0e8 100644
--- a/include/applets.src.h
+++ b/include/applets.src.h
@@ -1,394 +1,390 @@
 /* vi: set sw=4 ts=4: */
 /*
  * applets.h - a listing of all busybox applets.
  *
  * If you write a new applet, you need to add an entry to this list to make
  * busybox aware of it.
  */
 
 /*
 name  - applet name as it is typed on command line
 help  - applet name, converted to C (ether-wake: help = ether_wake)
 main  - corresponding <applet>_main to call (bzcat: main = bunzip2)
 l     - location to install link to: [/usr]/[s]bin
 s     - suid type:
         BB_SUID_REQUIRE: will complain if busybox isn't suid
         and is run by non-root (applet_main() will not be called at all)
         BB_SUID_DROP: will drop suid prior to applet_main()
         BB_SUID_MAYBE: neither of the above
         (every instance of BB_SUID_REQUIRE and BB_SUID_MAYBE
         needs to be justified in comment)
         NB: please update FEATURE_SUID help text whenever you add/remove
         BB_SUID_REQUIRE or BB_SUID_MAYBE applet.
 */
 
 #if defined(PROTOTYPES)
 # define APPLET(name,l,s)                    int name##_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 # define APPLET_ODDNAME(name,main,l,s,help)  int main##_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 # define APPLET_NOEXEC(name,main,l,s,help)   int main##_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 # define APPLET_NOFORK(name,main,l,s,help)   int main##_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 
 #elif defined(NAME_MAIN)
 # define APPLET(name,l,s)                    name name##_main
 # define APPLET_ODDNAME(name,main,l,s,help)  name main##_main
 # define APPLET_NOEXEC(name,main,l,s,help)   name main##_main
 # define APPLET_NOFORK(name,main,l,s,help)   name main##_main
 
 #elif defined(MAKE_USAGE) && ENABLE_FEATURE_VERBOSE_USAGE
 # define APPLET(name,l,s)                    MAKE_USAGE(#name, name##_trivial_usage name##_full_usage)
 # define APPLET_ODDNAME(name,main,l,s,help)  MAKE_USAGE(#name, help##_trivial_usage help##_full_usage)
 # define APPLET_NOEXEC(name,main,l,s,help)   MAKE_USAGE(#name, help##_trivial_usage help##_full_usage)
 # define APPLET_NOFORK(name,main,l,s,help)   MAKE_USAGE(#name, help##_trivial_usage help##_full_usage)
 
 #elif defined(MAKE_USAGE) && !ENABLE_FEATURE_VERBOSE_USAGE
 # define APPLET(name,l,s)                    MAKE_USAGE(#name, name##_trivial_usage)
 # define APPLET_ODDNAME(name,main,l,s,help)  MAKE_USAGE(#name, help##_trivial_usage)
 # define APPLET_NOEXEC(name,main,l,s,help)   MAKE_USAGE(#name, help##_trivial_usage)
 # define APPLET_NOFORK(name,main,l,s,help)   MAKE_USAGE(#name, help##_trivial_usage)
 
 #elif defined(MAKE_LINKS)
 # define APPLET(name,l,c)                    LINK l name
 # define APPLET_ODDNAME(name,main,l,s,help)  LINK l name
 # define APPLET_NOEXEC(name,main,l,s,help)   LINK l name
 # define APPLET_NOFORK(name,main,l,s,help)   LINK l name
 
 #elif defined(MAKE_SUID)
 # define APPLET(name,l,s)                    SUID s l name
 # define APPLET_ODDNAME(name,main,l,s,help)  SUID s l name
 # define APPLET_NOEXEC(name,main,l,s,help)   SUID s l name
 # define APPLET_NOFORK(name,main,l,s,help)   SUID s l name
 
 #else
   static struct bb_applet applets[] = { /*    name, main, location, need_suid */
 # define APPLET(name,l,s)                    { #name, #name, l, s },
 # define APPLET_ODDNAME(name,main,l,s,help)  { #name, #main, l, s },
 # define APPLET_NOEXEC(name,main,l,s,help)   { #name, #main, l, s, 1 },
 # define APPLET_NOFORK(name,main,l,s,help)   { #name, #main, l, s, 1, 1 },
 #endif
 
 #if ENABLE_INSTALL_NO_USR
 # define BB_DIR_USR_BIN BB_DIR_BIN
 # define BB_DIR_USR_SBIN BB_DIR_SBIN
 #endif
 
 
 INSERT
 IF_TEST(APPLET_NOFORK([,  test, BB_DIR_USR_BIN, BB_SUID_DROP, test))
 IF_TEST(APPLET_NOFORK([[, test, BB_DIR_USR_BIN, BB_SUID_DROP, test))
 IF_ACPID(APPLET(acpid, BB_DIR_SBIN, BB_SUID_DROP))
 IF_ADDGROUP(APPLET(addgroup, BB_DIR_USR_SBIN, BB_SUID_DROP))
 IF_ADDUSER(APPLET(adduser, BB_DIR_USR_SBIN, BB_SUID_DROP))
 IF_ADJTIMEX(APPLET(adjtimex, BB_DIR_SBIN, BB_SUID_DROP))
 IF_ARP(APPLET(arp, BB_DIR_SBIN, BB_SUID_DROP))
 IF_ARPING(APPLET(arping, BB_DIR_USR_SBIN, BB_SUID_DROP))
 IF_BASENAME(APPLET_NOFORK(basename, basename, BB_DIR_USR_BIN, BB_SUID_DROP, basename))
 IF_BBCONFIG(APPLET(bbconfig, BB_DIR_BIN, BB_SUID_DROP))
 IF_BEEP(APPLET(beep, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_BLKID(APPLET(blkid, BB_DIR_SBIN, BB_SUID_DROP))
 IF_BRCTL(APPLET(brctl, BB_DIR_USR_SBIN, BB_SUID_DROP))
 IF_CAL(APPLET(cal, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_CAT(APPLET_NOFORK(cat, cat, BB_DIR_BIN, BB_SUID_DROP, cat))
 IF_CATV(APPLET(catv, BB_DIR_BIN, BB_SUID_DROP))
 IF_CHAT(APPLET(chat, BB_DIR_USR_SBIN, BB_SUID_DROP))
-IF_CHATTR(APPLET(chattr, BB_DIR_BIN, BB_SUID_DROP))
 IF_CHCON(APPLET(chcon, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_CHGRP(APPLET_NOEXEC(chgrp, chgrp, BB_DIR_BIN, BB_SUID_DROP, chgrp))
 IF_CHMOD(APPLET_NOEXEC(chmod, chmod, BB_DIR_BIN, BB_SUID_DROP, chmod))
 IF_CHOWN(APPLET_NOEXEC(chown, chown, BB_DIR_BIN, BB_SUID_DROP, chown))
 IF_CHPASSWD(APPLET(chpasswd, BB_DIR_USR_SBIN, BB_SUID_DROP))
 IF_CHPST(APPLET(chpst, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_CHROOT(APPLET(chroot, BB_DIR_USR_SBIN, BB_SUID_DROP))
 IF_CHRT(APPLET(chrt, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_CHVT(APPLET(chvt, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_CKSUM(APPLET_NOEXEC(cksum, cksum, BB_DIR_USR_BIN, BB_SUID_DROP, cksum))
 IF_CLEAR(APPLET(clear, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_COMM(APPLET(comm, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_CP(APPLET_NOEXEC(cp, cp, BB_DIR_BIN, BB_SUID_DROP, cp))
 /* Needs to be run by root or be suid root - needs to change /var/spool/cron* files: */
 IF_CRONTAB(APPLET(crontab, BB_DIR_USR_BIN, BB_SUID_REQUIRE))
 IF_CRYPTPW(APPLET(cryptpw, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_CUT(APPLET_NOEXEC(cut, cut, BB_DIR_USR_BIN, BB_SUID_DROP, cut))
 IF_DC(APPLET(dc, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_DD(APPLET_NOEXEC(dd, dd, BB_DIR_BIN, BB_SUID_DROP, dd))
 IF_DEALLOCVT(APPLET(deallocvt, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_DELGROUP(APPLET_ODDNAME(delgroup, deluser, BB_DIR_USR_SBIN, BB_SUID_DROP, delgroup))
 IF_DELUSER(APPLET(deluser, BB_DIR_USR_SBIN, BB_SUID_DROP))
 IF_DEVFSD(APPLET(devfsd, BB_DIR_SBIN, BB_SUID_DROP))
 IF_DEVMEM(APPLET(devmem, BB_DIR_SBIN, BB_SUID_DROP))
 IF_DF(APPLET(df, BB_DIR_BIN, BB_SUID_DROP))
 IF_DHCPRELAY(APPLET(dhcprelay, BB_DIR_USR_SBIN, BB_SUID_DROP))
 IF_DIRNAME(APPLET_NOFORK(dirname, dirname, BB_DIR_USR_BIN, BB_SUID_DROP, dirname))
 IF_DMESG(APPLET(dmesg, BB_DIR_BIN, BB_SUID_DROP))
 IF_DNSD(APPLET(dnsd, BB_DIR_USR_SBIN, BB_SUID_DROP))
 IF_HOSTNAME(APPLET_ODDNAME(dnsdomainname, hostname, BB_DIR_BIN, BB_SUID_DROP, dnsdomainname))
 IF_DOS2UNIX(APPLET_NOEXEC(dos2unix, dos2unix, BB_DIR_USR_BIN, BB_SUID_DROP, dos2unix))
 IF_DU(APPLET(du, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_DUMPKMAP(APPLET(dumpkmap, BB_DIR_BIN, BB_SUID_DROP))
 IF_DUMPLEASES(APPLET(dumpleases, BB_DIR_USR_BIN, BB_SUID_DROP))
 //IF_E2FSCK(APPLET(e2fsck, BB_DIR_SBIN, BB_SUID_DROP))
 //IF_E2LABEL(APPLET_ODDNAME(e2label, tune2fs, BB_DIR_SBIN, BB_SUID_DROP, e2label))
 IF_ECHO(APPLET_NOFORK(echo, echo, BB_DIR_BIN, BB_SUID_DROP, echo))
 IF_EJECT(APPLET(eject, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_ENV(APPLET_NOEXEC(env, env, BB_DIR_USR_BIN, BB_SUID_DROP, env))
 IF_ENVDIR(APPLET_ODDNAME(envdir, chpst, BB_DIR_USR_BIN, BB_SUID_DROP, envdir))
 IF_ENVUIDGID(APPLET_ODDNAME(envuidgid, chpst, BB_DIR_USR_BIN, BB_SUID_DROP, envuidgid))
 IF_ETHER_WAKE(APPLET_ODDNAME(ether-wake, ether_wake, BB_DIR_USR_SBIN, BB_SUID_DROP, ether_wake))
 IF_EXPAND(APPLET(expand, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_EXPR(APPLET(expr, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_FAKEIDENTD(APPLET(fakeidentd, BB_DIR_USR_SBIN, BB_SUID_DROP))
 IF_FALSE(APPLET_NOFORK(false, false, BB_DIR_BIN, BB_SUID_DROP, false))
 IF_FBSET(APPLET(fbset, BB_DIR_USR_SBIN, BB_SUID_DROP))
 IF_FBSPLASH(APPLET(fbsplash, BB_DIR_SBIN, BB_SUID_DROP))
 IF_FDFLUSH(APPLET_ODDNAME(fdflush, freeramdisk, BB_DIR_BIN, BB_SUID_DROP, fdflush))
 IF_FDFORMAT(APPLET(fdformat, BB_DIR_USR_SBIN, BB_SUID_DROP))
 IF_FDISK(APPLET(fdisk, BB_DIR_SBIN, BB_SUID_DROP))
 IF_FGCONSOLE(APPLET(fgconsole, BB_DIR_USR_BIN, BB_SUID_DROP))
 /* Benefits from suid root: better access to /dev/BLOCKDEVs: */
 IF_FINDFS(APPLET(findfs, BB_DIR_SBIN, BB_SUID_MAYBE))
 IF_FLASH_ERASEALL(APPLET(flash_eraseall, BB_DIR_USR_SBIN, BB_SUID_DROP))
 IF_FLASH_LOCK(APPLET_ODDNAME(flash_lock, flash_lock_unlock, BB_DIR_USR_SBIN, BB_SUID_DROP, flash_lock))
 IF_FLASH_UNLOCK(APPLET_ODDNAME(flash_unlock, flash_lock_unlock, BB_DIR_USR_SBIN, BB_SUID_DROP, flash_unlock))
 IF_FLASHCP(APPLET(flashcp, BB_DIR_USR_SBIN, BB_SUID_DROP))
 IF_FLOCK(APPLET(flock, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_FOLD(APPLET_NOEXEC(fold, fold, BB_DIR_USR_BIN, BB_SUID_DROP, fold))
 IF_FREE(APPLET(free, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_FREERAMDISK(APPLET(freeramdisk, BB_DIR_SBIN, BB_SUID_DROP))
-IF_FSCK(APPLET(fsck, BB_DIR_SBIN, BB_SUID_DROP))
 //IF_E2FSCK(APPLET_ODDNAME(fsck.ext2, e2fsck, BB_DIR_SBIN, BB_SUID_DROP, fsck_ext2))
 //IF_E2FSCK(APPLET_ODDNAME(fsck.ext3, e2fsck, BB_DIR_SBIN, BB_SUID_DROP, fsck_ext3))
 IF_FSCK_MINIX(APPLET_ODDNAME(fsck.minix, fsck_minix, BB_DIR_SBIN, BB_SUID_DROP, fsck_minix))
 IF_FSYNC(APPLET_NOFORK(fsync, fsync, BB_DIR_BIN, BB_SUID_DROP, fsync))
 IF_FTPD(APPLET(ftpd, BB_DIR_USR_SBIN, BB_SUID_DROP))
 IF_FTPGET(APPLET_ODDNAME(ftpget, ftpgetput, BB_DIR_USR_BIN, BB_SUID_DROP, ftpget))
 IF_FTPPUT(APPLET_ODDNAME(ftpput, ftpgetput, BB_DIR_USR_BIN, BB_SUID_DROP, ftpput))
 IF_FUSER(APPLET(fuser, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_GETENFORCE(APPLET(getenforce, BB_DIR_USR_SBIN, BB_SUID_DROP))
 IF_GETOPT(APPLET(getopt, BB_DIR_BIN, BB_SUID_DROP))
 IF_GETSEBOOL(APPLET(getsebool, BB_DIR_USR_SBIN, BB_SUID_DROP))
 IF_GETTY(APPLET(getty, BB_DIR_SBIN, BB_SUID_DROP))
 IF_HD(APPLET_NOEXEC(hd, hexdump, BB_DIR_USR_BIN, BB_SUID_DROP, hd))
 IF_HDPARM(APPLET(hdparm, BB_DIR_SBIN, BB_SUID_DROP))
 IF_HEAD(APPLET_NOEXEC(head, head, BB_DIR_USR_BIN, BB_SUID_DROP, head))
 IF_HEXDUMP(APPLET_NOEXEC(hexdump, hexdump, BB_DIR_USR_BIN, BB_SUID_DROP, hexdump))
 IF_HOSTNAME(APPLET(hostname, BB_DIR_BIN, BB_SUID_DROP))
 IF_HTTPD(APPLET(httpd, BB_DIR_USR_SBIN, BB_SUID_DROP))
 IF_HWCLOCK(APPLET(hwclock, BB_DIR_SBIN, BB_SUID_DROP))
 IF_IFCONFIG(APPLET(ifconfig, BB_DIR_SBIN, BB_SUID_DROP))
 IF_IFUPDOWN(APPLET_ODDNAME(ifdown, ifupdown, BB_DIR_SBIN, BB_SUID_DROP, ifdown))
 IF_IFENSLAVE(APPLET(ifenslave, BB_DIR_SBIN, BB_SUID_DROP))
 IF_IFPLUGD(APPLET(ifplugd, BB_DIR_USR_SBIN, BB_SUID_DROP))
 IF_IFUPDOWN(APPLET_ODDNAME(ifup, ifupdown, BB_DIR_SBIN, BB_SUID_DROP, ifup))
 IF_INETD(APPLET(inetd, BB_DIR_USR_SBIN, BB_SUID_DROP))
 IF_INOTIFYD(APPLET(inotifyd, BB_DIR_SBIN, BB_SUID_DROP))
 IF_INSTALL(APPLET(install, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_IONICE(APPLET(ionice, BB_DIR_BIN, BB_SUID_DROP))
 #if ENABLE_FEATURE_IP_ADDRESS \
  || ENABLE_FEATURE_IP_ROUTE \
  || ENABLE_FEATURE_IP_LINK \
  || ENABLE_FEATURE_IP_TUNNEL \
  || ENABLE_FEATURE_IP_RULE
 IF_IP(APPLET(ip, BB_DIR_SBIN, BB_SUID_DROP))
 #endif
 IF_IPADDR(APPLET(ipaddr, BB_DIR_SBIN, BB_SUID_DROP))
 IF_IPCALC(APPLET(ipcalc, BB_DIR_BIN, BB_SUID_DROP))
 IF_IPCRM(APPLET(ipcrm, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_IPCS(APPLET(ipcs, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_IPLINK(APPLET(iplink, BB_DIR_SBIN, BB_SUID_DROP))
 IF_IPROUTE(APPLET(iproute, BB_DIR_SBIN, BB_SUID_DROP))
 IF_IPRULE(APPLET(iprule, BB_DIR_SBIN, BB_SUID_DROP))
 IF_IPTUNNEL(APPLET(iptunnel, BB_DIR_SBIN, BB_SUID_DROP))
 IF_KBD_MODE(APPLET(kbd_mode, BB_DIR_BIN, BB_SUID_DROP))
 IF_KILL(APPLET(kill, BB_DIR_BIN, BB_SUID_DROP))
 IF_KILLALL(APPLET_ODDNAME(killall, kill, BB_DIR_USR_BIN, BB_SUID_DROP, killall))
 IF_KILLALL5(APPLET_ODDNAME(killall5, kill, BB_DIR_USR_SBIN, BB_SUID_DROP, killall5))
 IF_LAST(APPLET(last, BB_DIR_USR_BIN, BB_SUID_DROP))
 //IF_LENGTH(APPLET_NOFORK(length, length, BB_DIR_USR_BIN, BB_SUID_DROP, length))
 IF_LESS(APPLET(less, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_SETARCH(APPLET_ODDNAME(linux32, setarch, BB_DIR_BIN, BB_SUID_DROP, linux32))
 IF_SETARCH(APPLET_ODDNAME(linux64, setarch, BB_DIR_BIN, BB_SUID_DROP, linux64))
 IF_LN(APPLET_NOEXEC(ln, ln, BB_DIR_BIN, BB_SUID_DROP, ln))
 IF_LOAD_POLICY(APPLET(load_policy, BB_DIR_USR_SBIN, BB_SUID_DROP))
 IF_LOADFONT(APPLET(loadfont, BB_DIR_USR_SBIN, BB_SUID_DROP))
 IF_LOADKMAP(APPLET(loadkmap, BB_DIR_SBIN, BB_SUID_DROP))
 /* Needs to be run by root or be suid root - needs to change uid and gid: */
 IF_LOGIN(APPLET(login, BB_DIR_BIN, BB_SUID_REQUIRE))
 IF_LOGNAME(APPLET_NOFORK(logname, logname, BB_DIR_USR_BIN, BB_SUID_DROP, logname))
 IF_LOSETUP(APPLET(losetup, BB_DIR_SBIN, BB_SUID_DROP))
 IF_LPD(APPLET(lpd, BB_DIR_USR_SBIN, BB_SUID_DROP))
 IF_LPQ(APPLET_ODDNAME(lpq, lpqr, BB_DIR_USR_BIN, BB_SUID_DROP, lpq))
 IF_LPR(APPLET_ODDNAME(lpr, lpqr, BB_DIR_USR_BIN, BB_SUID_DROP, lpr))
 IF_LS(APPLET_NOEXEC(ls, ls, BB_DIR_BIN, BB_SUID_DROP, ls))
-IF_LSATTR(APPLET(lsattr, BB_DIR_BIN, BB_SUID_DROP))
 IF_LSPCI(APPLET(lspci, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_LSUSB(APPLET(lsusb, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_MAKEDEVS(APPLET(makedevs, BB_DIR_SBIN, BB_SUID_DROP))
 IF_MAKEMIME(APPLET(makemime, BB_DIR_BIN, BB_SUID_DROP))
 IF_MAN(APPLET(man, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_MATCHPATHCON(APPLET(matchpathcon, BB_DIR_USR_SBIN, BB_SUID_DROP))
 IF_MD5SUM(APPLET_NOEXEC(md5sum, md5_sha1_sum, BB_DIR_USR_BIN, BB_SUID_DROP, md5sum))
 IF_MICROCOM(APPLET(microcom, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_MKDIR(APPLET_NOFORK(mkdir, mkdir, BB_DIR_BIN, BB_SUID_DROP, mkdir))
 IF_MKFS_VFAT(APPLET_ODDNAME(mkdosfs, mkfs_vfat, BB_DIR_SBIN, BB_SUID_DROP, mkfs_vfat))
 IF_MKFS_EXT2(APPLET_ODDNAME(mke2fs, mkfs_ext2, BB_DIR_SBIN, BB_SUID_DROP, mkfs_ext2))
 IF_MKFIFO(APPLET_NOEXEC(mkfifo, mkfifo, BB_DIR_USR_BIN, BB_SUID_DROP, mkfifo))
 IF_MKFS_EXT2(APPLET_ODDNAME(mkfs.ext2, mkfs_ext2, BB_DIR_SBIN, BB_SUID_DROP, mkfs_ext2))
 //IF_MKE2FS(APPLET_ODDNAME(mkfs.ext3, mke2fs, BB_DIR_SBIN, BB_SUID_DROP, mkfs_ext3))
 IF_MKFS_MINIX(APPLET_ODDNAME(mkfs.minix, mkfs_minix, BB_DIR_SBIN, BB_SUID_DROP, mkfs_minix))
 IF_MKFS_REISER(APPLET_ODDNAME(mkfs.reiser, mkfs_reiser, BB_DIR_SBIN, BB_SUID_DROP, mkfs_reiser))
 IF_MKFS_VFAT(APPLET_ODDNAME(mkfs.vfat, mkfs_vfat, BB_DIR_SBIN, BB_SUID_DROP, mkfs_vfat))
 IF_MKNOD(APPLET_NOEXEC(mknod, mknod, BB_DIR_BIN, BB_SUID_DROP, mknod))
 IF_CRYPTPW(APPLET_ODDNAME(mkpasswd, cryptpw, BB_DIR_USR_BIN, BB_SUID_DROP, mkpasswd))
 IF_MKSWAP(APPLET(mkswap, BB_DIR_SBIN, BB_SUID_DROP))
 IF_MKTEMP(APPLET(mktemp, BB_DIR_BIN, BB_SUID_DROP))
 IF_MORE(APPLET(more, BB_DIR_BIN, BB_SUID_DROP))
 /* On full-blown systems, requires suid for user mounts.
  * But it's not unthinkable to have it available in non-suid flavor on some systems,
  * for viewing mount table.
  * Therefore we use BB_SUID_MAYBE instead of BB_SUID_REQUIRE: */
 IF_MOUNT(APPLET(mount, BB_DIR_BIN, IF_DESKTOP(BB_SUID_MAYBE) IF_NOT_DESKTOP(BB_SUID_DROP)))
 IF_MOUNTPOINT(APPLET(mountpoint, BB_DIR_BIN, BB_SUID_DROP))
 IF_MT(APPLET(mt, BB_DIR_BIN, BB_SUID_DROP))
 IF_MV(APPLET(mv, BB_DIR_BIN, BB_SUID_DROP))
 IF_NAMEIF(APPLET(nameif, BB_DIR_SBIN, BB_SUID_DROP))
 IF_NC(APPLET(nc, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_NETSTAT(APPLET(netstat, BB_DIR_BIN, BB_SUID_DROP))
 IF_NICE(APPLET(nice, BB_DIR_BIN, BB_SUID_DROP))
 IF_NOHUP(APPLET(nohup, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_NSLOOKUP(APPLET(nslookup, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_NTPD(APPLET(ntpd, BB_DIR_USR_SBIN, BB_SUID_DROP))
 IF_OD(APPLET(od, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_OPENVT(APPLET(openvt, BB_DIR_USR_BIN, BB_SUID_DROP))
 //IF_PARSE(APPLET(parse, BB_DIR_USR_BIN, BB_SUID_DROP))
 /* Needs to be run by root or be suid root - needs to change /etc/{passwd,shadow}: */
 IF_PASSWD(APPLET(passwd, BB_DIR_USR_BIN, BB_SUID_REQUIRE))
 IF_PGREP(APPLET(pgrep, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_PIDOF(APPLET(pidof, BB_DIR_BIN, BB_SUID_DROP))
 IF_PIPE_PROGRESS(APPLET(pipe_progress, BB_DIR_BIN, BB_SUID_DROP))
 IF_PIVOT_ROOT(APPLET(pivot_root, BB_DIR_SBIN, BB_SUID_DROP))
 IF_PKILL(APPLET_ODDNAME(pkill, pgrep, BB_DIR_USR_BIN, BB_SUID_DROP, pkill))
 IF_POPMAILDIR(APPLET(popmaildir, BB_DIR_USR_SBIN, BB_SUID_DROP))
 IF_PRINTENV(APPLET_NOFORK(printenv, printenv, BB_DIR_BIN, BB_SUID_DROP, printenv))
 IF_PRINTF(APPLET_NOFORK(printf, printf, BB_DIR_USR_BIN, BB_SUID_DROP, printf))
 IF_PS(APPLET(ps, BB_DIR_BIN, BB_SUID_DROP))
 IF_PSCAN(APPLET(pscan, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_PWD(APPLET_NOFORK(pwd, pwd, BB_DIR_BIN, BB_SUID_DROP, pwd))
 IF_RAIDAUTORUN(APPLET(raidautorun, BB_DIR_SBIN, BB_SUID_DROP))
 IF_RDATE(APPLET(rdate, BB_DIR_USR_SBIN, BB_SUID_DROP))
 IF_RDEV(APPLET(rdev, BB_DIR_USR_SBIN, BB_SUID_DROP))
 IF_READAHEAD(APPLET(readahead, BB_DIR_USR_SBIN, BB_SUID_DROP))
 IF_READLINK(APPLET(readlink, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_READPROFILE(APPLET(readprofile, BB_DIR_USR_SBIN, BB_SUID_DROP))
 IF_REALPATH(APPLET(realpath, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_REFORMIME(APPLET(reformime, BB_DIR_BIN, BB_SUID_DROP))
 IF_RENICE(APPLET(renice, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_RESET(APPLET(reset, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_RESIZE(APPLET(resize, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_RESTORECON(APPLET_ODDNAME(restorecon, setfiles, BB_DIR_SBIN, BB_SUID_DROP, restorecon))
 IF_RM(APPLET_NOFORK(rm, rm, BB_DIR_BIN, BB_SUID_DROP, rm))
 IF_RMDIR(APPLET_NOFORK(rmdir, rmdir, BB_DIR_BIN, BB_SUID_DROP, rmdir))
 IF_ROUTE(APPLET(route, BB_DIR_SBIN, BB_SUID_DROP))
 IF_RTCWAKE(APPLET(rtcwake, BB_DIR_USR_SBIN, BB_SUID_DROP))
 IF_RUN_PARTS(APPLET_ODDNAME(run-parts, run_parts, BB_DIR_BIN, BB_SUID_DROP, run_parts))
 IF_RUNCON(APPLET(runcon, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_RUNLEVEL(APPLET(runlevel, BB_DIR_SBIN, BB_SUID_DROP))
 IF_RUNSV(APPLET(runsv, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_RUNSVDIR(APPLET(runsvdir, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_RX(APPLET(rx, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_SCRIPT(APPLET(script, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_SCRIPTREPLAY(APPLET(scriptreplay, BB_DIR_BIN, BB_SUID_DROP))
 IF_SELINUXENABLED(APPLET(selinuxenabled, BB_DIR_USR_SBIN, BB_SUID_DROP))
 IF_SENDMAIL(APPLET(sendmail, BB_DIR_USR_SBIN, BB_SUID_DROP))
 IF_SEQ(APPLET_NOFORK(seq, seq, BB_DIR_USR_BIN, BB_SUID_DROP, seq))
 IF_SESTATUS(APPLET(sestatus, BB_DIR_USR_SBIN, BB_SUID_DROP))
 IF_SETARCH(APPLET(setarch, BB_DIR_BIN, BB_SUID_DROP))
 IF_SETCONSOLE(APPLET(setconsole, BB_DIR_SBIN, BB_SUID_DROP))
 IF_SETENFORCE(APPLET(setenforce, BB_DIR_USR_SBIN, BB_SUID_DROP))
 IF_SETFILES(APPLET(setfiles, BB_DIR_SBIN, BB_SUID_DROP))
 IF_SETFONT(APPLET(setfont, BB_DIR_USR_SBIN, BB_SUID_DROP))
 IF_SETKEYCODES(APPLET(setkeycodes, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_SETLOGCONS(APPLET(setlogcons, BB_DIR_USR_SBIN, BB_SUID_DROP))
 IF_SETSEBOOL(APPLET(setsebool, BB_DIR_USR_SBIN, BB_SUID_DROP))
 IF_SETSID(APPLET(setsid, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_SETUIDGID(APPLET_ODDNAME(setuidgid, chpst, BB_DIR_USR_BIN, BB_SUID_DROP, setuidgid))
 IF_SHA1SUM(APPLET_NOEXEC(sha1sum, md5_sha1_sum, BB_DIR_USR_BIN, BB_SUID_DROP, sha1sum))
 IF_SHA3SUM(APPLET_NOEXEC(sha3sum, md5_sha1_sum, BB_DIR_USR_BIN, BB_SUID_DROP, sha3sum))
 IF_SHA256SUM(APPLET_NOEXEC(sha256sum, md5_sha1_sum, BB_DIR_USR_BIN, BB_SUID_DROP, sha256sum))
 IF_SHA512SUM(APPLET_NOEXEC(sha512sum, md5_sha1_sum, BB_DIR_USR_BIN, BB_SUID_DROP, sha512sum))
 IF_SHOWKEY(APPLET(showkey, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_SLATTACH(APPLET(slattach, BB_DIR_SBIN, BB_SUID_DROP))
 /* Do not make this applet NOFORK. It breaks ^C-ing of pauses in shells: */
 IF_SLEEP(APPLET(sleep, BB_DIR_BIN, BB_SUID_DROP))
 IF_SOFTLIMIT(APPLET_ODDNAME(softlimit, chpst, BB_DIR_USR_BIN, BB_SUID_DROP, softlimit))
 IF_SORT(APPLET_NOEXEC(sort, sort, BB_DIR_USR_BIN, BB_SUID_DROP, sort))
 IF_SPLIT(APPLET(split, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_START_STOP_DAEMON(APPLET_ODDNAME(start-stop-daemon, start_stop_daemon, BB_DIR_SBIN, BB_SUID_DROP, start_stop_daemon))
 IF_STAT(APPLET(stat, BB_DIR_BIN, BB_SUID_DROP))
 IF_STRINGS(APPLET(strings, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_STTY(APPLET(stty, BB_DIR_BIN, BB_SUID_DROP))
 /* Needs to be run by root or be suid root - needs to change uid and gid: */
 IF_SU(APPLET(su, BB_DIR_BIN, BB_SUID_REQUIRE))
 IF_SULOGIN(APPLET(sulogin, BB_DIR_SBIN, BB_SUID_DROP))
 IF_SUM(APPLET(sum, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_SV(APPLET(sv, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_SVLOGD(APPLET(svlogd, BB_DIR_USR_SBIN, BB_SUID_DROP))
 IF_SWAPONOFF(APPLET_ODDNAME(swapoff, swap_on_off, BB_DIR_SBIN, BB_SUID_DROP, swapoff))
 IF_SWAPONOFF(APPLET_ODDNAME(swapon, swap_on_off, BB_DIR_SBIN, BB_SUID_DROP, swapon))
 IF_SWITCH_ROOT(APPLET(switch_root, BB_DIR_SBIN, BB_SUID_DROP))
 IF_BB_SYSCTL(APPLET(sysctl, BB_DIR_SBIN, BB_SUID_DROP))
 IF_TAC(APPLET_NOEXEC(tac, tac, BB_DIR_USR_BIN, BB_SUID_DROP, tac))
 IF_TAIL(APPLET(tail, BB_DIR_USR_BIN, BB_SUID_DROP))
 /* IF_TC(APPLET(tc, BB_DIR_SBIN, BB_SUID_DROP)) */
 IF_TCPSVD(APPLET_ODDNAME(tcpsvd, tcpudpsvd, BB_DIR_USR_BIN, BB_SUID_DROP, tcpsvd))
 IF_TEE(APPLET(tee, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_TELNET(APPLET(telnet, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_TELNETD(APPLET(telnetd, BB_DIR_USR_SBIN, BB_SUID_DROP))
 IF_TEST(APPLET_NOFORK(test, test, BB_DIR_USR_BIN, BB_SUID_DROP, test))
 #if ENABLE_FEATURE_TFTP_GET || ENABLE_FEATURE_TFTP_PUT
 IF_TFTP(APPLET(tftp, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_TFTPD(APPLET(tftpd, BB_DIR_USR_SBIN, BB_SUID_DROP))
 #endif
 IF_TIME(APPLET(time, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_TIMEOUT(APPLET(timeout, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_TOP(APPLET(top, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_TR(APPLET(tr, BB_DIR_USR_BIN, BB_SUID_DROP))
 /* Needs socket(AF_INET, SOCK_RAW, IPPROTO_ICMP), therefore BB_SUID_MAYBE: */
 IF_TRACEROUTE(APPLET(traceroute, BB_DIR_USR_BIN, BB_SUID_MAYBE))
 IF_TRACEROUTE6(APPLET(traceroute6, BB_DIR_USR_BIN, BB_SUID_MAYBE))
 IF_TRUE(APPLET_NOFORK(true, true, BB_DIR_BIN, BB_SUID_DROP, true))
 IF_TTY(APPLET(tty, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_TTYSIZE(APPLET(ttysize, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_TUNCTL(APPLET(tunctl, BB_DIR_SBIN, BB_SUID_DROP))
-IF_TUNE2FS(APPLET(tune2fs, BB_DIR_SBIN, BB_SUID_DROP))
 IF_UDHCPC(APPLET(udhcpc, BB_DIR_SBIN, BB_SUID_DROP))
 IF_UDHCPD(APPLET(udhcpd, BB_DIR_USR_SBIN, BB_SUID_DROP))
 IF_UDPSVD(APPLET_ODDNAME(udpsvd, tcpudpsvd, BB_DIR_USR_BIN, BB_SUID_DROP, udpsvd))
 IF_UMOUNT(APPLET(umount, BB_DIR_BIN, BB_SUID_DROP))
 IF_UNAME(APPLET(uname, BB_DIR_BIN, BB_SUID_DROP))
 IF_UNEXPAND(APPLET_ODDNAME(unexpand, expand, BB_DIR_USR_BIN, BB_SUID_DROP, unexpand))
 IF_UNIQ(APPLET(uniq, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_UNIX2DOS(APPLET_NOEXEC(unix2dos, dos2unix, BB_DIR_USR_BIN, BB_SUID_DROP, unix2dos))
 IF_UPTIME(APPLET(uptime, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_USLEEP(APPLET_NOFORK(usleep, usleep, BB_DIR_BIN, BB_SUID_DROP, usleep))
 IF_UUDECODE(APPLET(uudecode, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_UUENCODE(APPLET(uuencode, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_VCONFIG(APPLET(vconfig, BB_DIR_SBIN, BB_SUID_DROP))
 /* Needs to be run by root or be suid root - needs to change uid and gid: */
 IF_VLOCK(APPLET(vlock, BB_DIR_USR_BIN, BB_SUID_REQUIRE))
 IF_VOLNAME(APPLET(volname, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_WATCH(APPLET(watch, BB_DIR_BIN, BB_SUID_DROP))
 IF_WATCHDOG(APPLET(watchdog, BB_DIR_SBIN, BB_SUID_DROP))
 IF_WC(APPLET(wc, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_WHICH(APPLET(which, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_WHOAMI(APPLET_NOFORK(whoami, whoami, BB_DIR_USR_BIN, BB_SUID_DROP, whoami))
 IF_YES(APPLET_NOFORK(yes, yes, BB_DIR_USR_BIN, BB_SUID_DROP, yes))
 IF_ZCIP(APPLET(zcip, BB_DIR_SBIN, BB_SUID_DROP))
 
 #if !defined(PROTOTYPES) && !defined(NAME_MAIN) && !defined(MAKE_USAGE) \
 	&& !defined(MAKE_LINKS) && !defined(MAKE_SUID)
 };
 #endif
 
 #undef APPLET
 #undef APPLET_ODDNAME
 #undef APPLET_NOEXEC
 #undef APPLET_NOFORK
