2001-05-21 20:30:51 +0000
diff --git a/Config.h b/Config.h
index 15209be..d35f1a4 100644
--- a/Config.h
+++ b/Config.h
@@ -1,430 +1,429 @@
 /* vi: set sw=4 ts=4: */
 // This file defines the feature set to be compiled into busybox.
 // When you turn things off here, they won't be compiled in at all.
 //
 //// This file is parsed by sed. You MUST use single line comments.
 //   i.e.  //#define BB_BLAH
 //
 //
 // BusyBox Applications
 //#define BB_ADJTIMEX
 //#define BB_AR
 #define BB_BASENAME
 #define BB_CAT
 #define BB_CHGRP
 #define BB_CHMOD
 #define BB_CHOWN
 #define BB_CHROOT
 #define BB_CHVT
 #define BB_CLEAR
 //#define BB_CMP
 #define BB_CP
 #define BB_CUT
 #define BB_DATE
 //#define BB_DC
 #define BB_DD
 //#define BB_DEALLOCVT
 #define BB_DF
 #define BB_DIRNAME
 #define BB_DMESG
 //#define BB_DOS2UNIX
 //#define BB_DPKG
 //#define BB_DPKG_DEB
 //#define BB_DUTMP
 #define BB_DU
 //#define BB_DUMPKMAP
 #define BB_ECHO
 #define BB_ENV
 //#define BB_EXPR
 //#define BB_FBSET
 //#define BB_FDFLUSH
 #define BB_FIND
 #define BB_FREE
 //#define BB_FREERAMDISK
 //#define BB_FSCK_MINIX
 //#define BB_GETOPT
 #define BB_GREP
 #define BB_GUNZIP
 #define BB_GZIP
 #define BB_HALT
 #define BB_HEAD
 //#define BB_HOSTID
 //#define BB_HOSTNAME
 #define BB_ID
 //#define BB_IFCONFIG
 #define BB_INIT
 //#define BB_INSMOD
 #define BB_KILL
 #define BB_KILLALL
 #define BB_KLOGD
 //#define BB_LASH
 //#define BB_LENGTH
 #define BB_LN
 //#define BB_LOADACM
 //#define BB_LOADFONT
 //#define BB_LOADKMAP
 #define BB_LOGGER
 //#define BB_LOGNAME
 #define BB_LS
 #define BB_LSMOD
 //#define BB_MAKEDEVS
 //#define BB_MD5SUM
 #define BB_MKDIR
 //#define BB_MKFIFO
 //#define BB_MKFS_MINIX
 #define BB_MKNOD
 #define BB_MKSWAP
 //#define BB_MKTEMP
 //#define BB_NC
 #define BB_MORE
 #define BB_MOUNT
 //#define BB_MT
 #define BB_MV
 //#define BB_NSLOOKUP
 //#define BB_PING
 //#define BB_PIVOT_ROOT
 #define BB_POWEROFF
 //#define BB_PRINTF
 #define BB_PS
 #define BB_PWD
 //#define BB_RDATE
 //#define BB_READLINK
 #define BB_REBOOT
 //#define BB_RENICE
 #define BB_RESET
 #define BB_RM
 #define BB_RMDIR
 //#define BB_RMMOD
 //#define BB_ROUTE
 //#define BB_RPMUNPACK
 #define BB_SED
 //#define BB_SETKEYCODES
 #define BB_SH
 #define BB_SLEEP
 #define BB_SORT
 //#define BB_STTY
 #define BB_SWAPONOFF
 #define BB_SYNC
 #define BB_SYSLOGD
 #define BB_TAIL
 #define BB_TAR
 //#define BB_TEE
 //#define BB_TEST
 //#define BB_TELNET
 //#define BB_TFTP
 #define BB_TOUCH
 //#define BB_TR
 #define BB_TRUE_FALSE
 #define BB_TTY
 //#define BB_UNIX2DOS
 //#define BB_UUENCODE
 //#define BB_UUDECODE
 #define BB_UMOUNT
 #define BB_UNIQ
 #define BB_UNAME
 //#define BB_UPDATE
 #define BB_UPTIME
 //#define BB_USLEEP
 //#define BB_VI
 //#define BB_WATCHDOG
 #define BB_WC
 //#define BB_WGET
 #define BB_WHICH
 #define BB_WHOAMI
 #define BB_XARGS
 #define BB_YES
 // End of Applications List
 //
 //
 //
 // ---------------------------------------------------------
 // This is where feature definitions go.  Generally speaking,
 // turning this stuff off makes things a bit smaller (and less 
 // pretty/useful).
 //
 //
 // BusyBox will, by default, malloc space for its buffers.  This costs code
 // size for the call to xmalloc.  You can use the following feature to have
 // them put on the stack.  For some very small machines with limited stack
 // space, this can be deadly.  For most folks, this works just fine...
 //#define BB_FEATURE_BUFFERS_GO_ON_STACK
 // The third alternative for buffer allocation is to use BSS.  This works
 // beautifully for computers with a real MMU (and OS support), but wastes
 // runtime RAM for uCLinux.  This behavior was the only one available for
 // BusyBox versions 0.48 and earlier.
 //#define BB_FEATURE_BUFFERS_GO_IN_BSS
 //
 // Turn this on to use Erik's very cool devps, and devmtab kernel drivers,
 // thereby eliminating the need for the /proc filesystem and thereby saving
 // lots and lots memory for more important things.  NOTE:  If you enable this
 // feature, you _must_ have patched the kernel to include the devps patch that
 // is included in the busybox/kernel-patches directory.  You will also need to
 // create some device special files in /dev on your embedded system:
 //        mknod /dev/mtab c 10 22
 //        mknod /dev/ps c 10 21
 // I emailed Linus and this patch will not be going into the stock kernel.
 //#define BB_FEATURE_USE_DEVPS_PATCH
 //
 // show verbose usage messages
 //#define BB_FEATURE_VERBOSE_USAGE
 //
 // Use termios to manipulate the screen ('more' is prettier with this on)
 //#define BB_FEATURE_USE_TERMIOS
 //
 // calculate terminal & column widths (for more and ls)
 #define BB_FEATURE_AUTOWIDTH
 //
 // show username/groupnames for ls
 #define BB_FEATURE_LS_USERNAME
 //
 // show file timestamps in ls
 #define BB_FEATURE_LS_TIMESTAMPS
 //
 // enable ls -p and -F
 #define BB_FEATURE_LS_FILETYPES
 //
 // sort the file names
 #define BB_FEATURE_LS_SORTFILES
 //
 // enable ls -R
 #define BB_FEATURE_LS_RECURSIVE
 //
 // enable ls -L
 #define BB_FEATURE_LS_FOLLOWLINKS
 //
-// Change ping implementation -- simplified, featureless, but really small.
-//#define BB_FEATURE_SIMPLE_PING
+// Disable for a smaller (but less functional) ping
+#define BB_FEATURE_FANCY_PING
 //
 // Make init use a simplified /etc/inittab file (recommended).
 #define BB_FEATURE_USE_INITTAB
 //
 //Enable init being called as /linuxrc
 #define BB_FEATURE_LINUXRC
 //
 //Have init enable core dumping for child processes (for debugging only) 
 //#define BB_FEATURE_INIT_COREDUMPS
 //
 //Make sure nothing is printed to the console on boot
 //#define BB_FEATURE_EXTRA_QUIET
 //
 // enable syslogd -R remotehost
 #define BB_FEATURE_REMOTE_LOG
 //
 // enable syslogd -C
 //#define BB_FEATURE_IPC_SYSLOG
 //
-//Simple tail implementation (2.34k vs 3k for the full one).
+//Disable for a simple tail implementation (2.34k vs 3k for the full one).
 //Both provide 'tail -f', but this cuts out -c, -q, -s, and -v. 
-#define BB_FEATURE_SIMPLE_TAIL
+#define BB_FEATURE_FANCY_TAIL
 //
 // Enable support for loop devices in mount
 #define BB_FEATURE_MOUNT_LOOP
 //
 // Enable support for a real /etc/mtab file instead of /proc/mounts
 //#define BB_FEATURE_MTAB_SUPPORT
 //
 // Enable support for mounting remote NFS volumes. 
 // You may need to mount with "-o nolock" if you are
 // not running a local portmapper daemon...
 #define BB_FEATURE_NFSMOUNT
 //
 // Enable support forced filesystem unmounting 
 // (i.e. in case of an unreachable NFS system).
 #define BB_FEATURE_MOUNT_FORCE
 //
 // Enable support for creation of tar files.
 #define BB_FEATURE_TAR_CREATE
 //
 // Enable support for "--exclude" and "-X" for excluding files
 #define BB_FEATURE_TAR_EXCLUDE
 //
 // Enable support for tar -z option (currently only works for inflating)
 #define BB_FEATURE_TAR_GZIP 
 //
 // Enable reverse sort
 #define BB_FEATURE_SORT_REVERSE
 //
 // Enable uniqe sort
 #define BB_FEATURE_SORT_UNIQUE
 //
 // Enable command line editing in the shell.  
 // Only relevant if BB_SH is enabled. On by default.
 #define BB_FEATURE_COMMAND_EDITING
 //
 // Enable tab completion in the shell.  This is now working quite nicely.
 // This feature adds a bit over 4k. Only relevant if BB_SH is enabled.
 #define BB_FEATURE_COMMAND_TAB_COMPLETION
 //
 // Attempts to match usernames in a ~-prefixed path
 //#define BB_FEATURE_COMMAND_USERNAME_COMPLETION
 //
 //Allow the shell to invoke all the compiled in BusyBox applets as if they
 //were shell builtins.  Nice for staticly linking an emergency rescue shell,
 //among other things. Off by default.
 // Only relevant if BB_SH is enabled.
 //#define BB_FEATURE_SH_STANDALONE_SHELL
 //
 //When this is enabled, busybox shell applets can be called using full path
 //names.  This causes applets (i.e., most busybox commands) to override
 //real commands on the filesystem.  For example, if you run run /bin/cat, it
 //will use BusyBox cat even if /bin/cat exists on the filesystem and is _not_
 //busybox.  Some systems want this, others do not.  Choose wisely.  :-) This
 //only has meaning when BB_FEATURE_SH_STANDALONE_SHELL is enabled.
 // Only relevant if BB_SH is enabled. Off by default.
 //#define BB_FEATURE_SH_APPLETS_ALWAYS_WIN
 //
-// Some deeply embedded systems don't have usernames or even hostnames,
-// and the default prompt can look rather hideous on them. Uncomment
-// this option for a simpler, path-only prompt (which was the default until
-// around BusyBox-0.48). On by default.
+// Uncomment this option for a fancy shell prompt that includes the
+// current username and hostname.  On systems that don't have usernames
+// or hostnames, this can look hideous.
 // Only relevant if BB_SH is enabled.
-#define BB_FEATURE_SH_SIMPLE_PROMPT
+//#define BB_FEATURE_SH_FANCY_PROMPT
 //
 //Turn on extra fbset options
 //#define BB_FEATURE_FBSET_FANCY
 //
 //Turn on fbset readmode support
 //#define BB_FEATURE_FBSET_READMODE
 //
 // Support insmod/lsmod/rmmod for post 2.1 kernels
 //#define BB_FEATURE_NEW_MODULE_INTERFACE
 //
 // Support insmod/lsmod/rmmod for pre 2.1 kernels
 //#define BB_FEATURE_OLD_MODULE_INTERFACE
 //
 // Support module version checking
 //#define BB_FEATURE_INSMOD_VERSION_CHECKING
 //
 // Support for uClinux memory usage optimization, which will load the image
 // directly into the kernel memory.  This divides memory requrements by three.
 // If you are not running uClinux (i.e. your CPU has an MMU) leave this
 // disabled...
 //#define BB_FEATURE_INSMOD_LOADINKMEM
 //
 // Support for Minix filesystem, version 2
 //#define BB_FEATURE_MINIX2
 //
 // Enable ifconfig status reporting output -- this feature adds 12k.
 //#define BB_FEATURE_IFCONFIG_STATUS
 //
 // Enable ifconfig slip-specific options "keepalive" and "outfill"
 //#define BB_FEATURE_IFCONFIG_SLIP
 //
 // Enable ifconfig options "mem_start", "io_addr", and "irq".
 //#define BB_FEATURE_IFCONFIG_MEMSTART_IOADDR_IRQ
 //
 // Enable ifconfig option "hw".  Currently works for only with "ether".
 //#define BB_FEATURE_IFCONFIG_HW
 //
 // Enable busybox --install [-s]
 // to create links (or symlinks) for all the commands that are 
 // compiled into the binary.  (needs /proc filesystem)
 // #define BB_FEATURE_INSTALLER
 //
 // Enable a nifty progress meter in wget (adds just under 2k)
 #define BB_FEATURE_WGET_STATUSBAR
 //
 // Enable HTTP authentication in wget
 #define BB_FEATURE_WGET_AUTHENTICATION
 //
 // Clean up all memory before exiting -- usually not needed
 // as the OS can clean up...  Don't enable this unless you
 // have a really good reason for cleaning things up manually.
 //#define BB_FEATURE_CLEAN_UP
 //
 // Support for human readable output by ls, du, etc.(example 13k, 23M, 235G)
 #define BB_FEATURE_HUMAN_READABLE
 //
 // Support for the find -type option.
 #define BB_FEATURE_FIND_TYPE
 //
 // Support for the find -perm option.
 #define BB_FEATURE_FIND_PERM
 //
 // Support for the find -mtine option.
 #define BB_FEATURE_FIND_MTIME
 //
 // Support for the -A -B and -C context flags in grep
 //#define BB_FEATURE_GREP_CONTEXT
 //
 // Support for the EGREP applet (alias to the grep applet)
 //#define BB_FEATURE_GREP_EGREP_ALIAS
 //
 // Tell tftp what commands that should be supported.
 #define BB_FEATURE_TFTP_PUT
 #define BB_FEATURE_TFTP_GET
 //
 // features for vi
 #define BB_FEATURE_VI_COLON		// ":" colon commands, no "ex" mode
 #define BB_FEATURE_VI_YANKMARK		// Yank/Put commands and Mark cmds
 #define BB_FEATURE_VI_SEARCH		// search and replace cmds
 #define BB_FEATURE_VI_USE_SIGNALS	// catch signals
 #define BB_FEATURE_VI_DOT_CMD		// remember previous cmd and "." cmd
 #define BB_FEATURE_VI_READONLY		// vi -R and "view" mode
 #define BB_FEATURE_VI_SETOPTS		// set-able options,  ai ic showmatch
 #define BB_FEATURE_VI_SET		// :set
 #define BB_FEATURE_VI_WIN_RESIZE	// handle window resize
 //
 // Enable a if you system have setuped locale
 //#define BB_LOCALE_SUPPORT
 //
 // Support for TELNET to pass TERM type to remote host.  Adds 384 bytes.
 #define BB_FEATURE_TELNET_TTYPE
 //
 // End of Features List
 //
 //
 //
 //
 //
 //
 //---------------------------------------------------
 // Nothing beyond this point should ever be touched by 
 // mere mortals so leave this stuff alone.
 //
 #if defined BB_SH
 	#if defined BB_FEATURE_COMMAND_EDITING 
 		#define BB_CMDEDIT
 	#else
 		#undef BB_FEATURE_COMMAND_EDITING
 		#undef BB_FEATURE_COMMAND_TAB_COMPLETION
 		#undef BB_FEATURE_COMMAND_USERNAME_COMPLETION
-		#define BB_FEATURE_SH_SIMPLE_PROMPT
+		#undef BB_FEATURE_SH_FANCY_PROMPT
 	#endif
 #else
 	#undef BB_FEATURE_SH_APPLETS_ALWAYS_WIN
 	#undef BB_FEATURE_SH_STANDALONE_SHELL
-	#undef BB_FEATURE_SH_SIMPLE_PROMPT
+	#undef BB_FEATURE_SH_FANCY_PROMPT
 #endif
 //
 #ifdef BB_KILLALL
 	#ifndef BB_KILL
 		#define BB_KILL
 	#endif
 #endif
 //
 #ifndef BB_INIT
 	#undef BB_FEATURE_LINUXRC
 #endif
 //
 #if defined BB_MOUNT && defined BB_FEATURE_NFSMOUNT
 	#define BB_NFSMOUNT
 #endif
 //
 #if defined BB_FEATURE_AUTOWIDTH
 	#ifndef BB_FEATURE_USE_TERMIOS
 		#define BB_FEATURE_USE_TERMIOS
 	#endif
 #endif
 //
 #if defined BB_INSMOD || defined BB_LSMOD
 	#if ! defined BB_FEATURE_NEW_MODULE_INTERFACE && ! defined BB_FEATURE_OLD_MODULE_INTERFACE
 		#define BB_FEATURE_NEW_MODULE_INTERFACE
 	#endif
 #endif
 //
 #ifdef BB_SYSLOGD
 	#if defined BB_FEATURE_IPC_SYSLOG
 		#define BB_LOGREAD
 	#endif
 #endif
diff --git a/applets/usage.h b/applets/usage.h
index b442e8b..63c00c6 100644
--- a/applets/usage.h
+++ b/applets/usage.h
@@ -1,1770 +1,1770 @@
 #define adjtimex_trivial_usage \
 	"[-q] [-o offset] [-f frequency] [-p timeconstant] [-t tick]"
 #define adjtimex_full_usage \
 	"Reads and optionally sets system timebase parameters.\n" \
 	"See adjtimex(2).\n\n" \
 	"Options:\n" \
 	"\t-q\t\tquiet mode - do not print\n" \
 	"\t-o offset\ttime offset, microseconds\n" \
 	"\t-f frequency\tfrequency adjust, integer kernel units (65536 is 1ppm)\n" \
 	"\t\t\t(positive values make the system clock run fast)\n" \
 	"\t-t tick\t\tmicroseconds per tick, usually 10000\n" \
 	"\t-p timeconstant\n"
 
 #define ar_trivial_usage \
 	"-[ovR]{ptx} ARCHIVE FILES"
 #define ar_full_usage \
 	"Extract or list FILES from an ar archive.\n\n" \
 	"Options:\n" \
 	"\t-o\t\tpreserve original dates\n" \
 	"\t-p\t\textract to stdout\n" \
 	"\t-t\t\tlist\n" \
 	"\t-x\t\textract\n" \
 	"\t-v\t\tverbosely list files processed\n" \
 	"\t-R\t\trecursive action"
 
 #define basename_trivial_usage \
 	"FILE [SUFFIX]"
 #define basename_full_usage \
 	"Strips directory path and suffixes from FILE.\n" \
 	"If specified, also removes any trailing SUFFIX."
 #define basename_example_usage \
 	"$ basename /usr/local/bin/foo\n" \
 	"foo\n" \
 	"$ basename /usr/local/bin/\n" \
 	"bin\n" \
 	"$ basename /foo/bar.txt .txt\n" \
 	"bar"
 
 #define cat_trivial_usage \
 	"[FILE]..."
 #define cat_full_usage \
 	"Concatenates FILE(s) and prints them to stdout."
 #define cat_example_usage \
 	"$ cat /proc/uptime\n" \
 	"110716.72 17.67"
 
 #define chgrp_trivial_usage \
 	"[OPTION]... GROUP FILE..."
 #define chgrp_full_usage \
 	"Change the group membership of each FILE to GROUP.\n" \
 	"\nOptions:\n" \
 	"\t-R\tChanges files and directories recursively."
 #define chgrp_example_usage \
 	"$ ls -l /tmp/foo\n" \
 	"-r--r--r--    1 andersen andersen        0 Apr 12 18:25 /tmp/foo\n" \
 	"$ chgrp root /tmp/foo\n" \
 	"$ ls -l /tmp/foo\n" \
 	"-r--r--r--    1 andersen root            0 Apr 12 18:25 /tmp/foo\n"
 
 #define chmod_trivial_usage \
 	"[-R] MODE[,MODE]... FILE..."
 #define chmod_full_usage \
 	"Each MODE is one or more of the letters ugoa, one of the\n" \
 	"symbols +-= and one or more of the letters rwxst.\n\n" \
 	"Options:\n" \
 	"\t-R\tChanges files and directories recursively."
 #define chmod_example_usage \
 	"$ ls -l /tmp/foo\n" \
 	"-rw-rw-r--    1 root     root            0 Apr 12 18:25 /tmp/foo\n" \
 	"$ chmod u+x /tmp/foo\n" \
 	"$ ls -l /tmp/foo\n" \
 	"-rwxrw-r--    1 root     root            0 Apr 12 18:25 /tmp/foo*\n" \
 	"$ chmod 444 /tmp/foo\n" \
 	"$ ls -l /tmp/foo\n" \
 	"-r--r--r--    1 root     root            0 Apr 12 18:25 /tmp/foo\n"
 
 #define chown_trivial_usage \
 	"[ -Rh ]...  OWNER[<.|:>[GROUP]] FILE..."
 #define chown_full_usage \
 	"Change the owner and/or group of each FILE to OWNER and/or GROUP.\n" \
 	"\nOptions:\n" \
 	"\t-R\tChanges files and directories recursively.\n" \
 	"\t-h\tDo not dereference symbolic links."
 #define chown_example_usage \
 	"$ ls -l /tmp/foo\n" \
 	"-r--r--r--    1 andersen andersen        0 Apr 12 18:25 /tmp/foo\n" \
 	"$ chown root /tmp/foo\n" \
 	"$ ls -l /tmp/foo\n" \
 	"-r--r--r--    1 root     andersen        0 Apr 12 18:25 /tmp/foo\n" \
 	"$ chown root.root /tmp/foo\n" \
 	"ls -l /tmp/foo\n" \
 	"-r--r--r--    1 root     root            0 Apr 12 18:25 /tmp/foo\n"
 
 #define chroot_trivial_usage \
 	"NEWROOT [COMMAND...]"
 #define chroot_full_usage \
 	"Run COMMAND with root directory set to NEWROOT."
 #define chroot_example_usage \
 	"$ ls -l /bin/ls\n" \
 	"lrwxrwxrwx    1 root     root          12 Apr 13 00:46 /bin/ls -> /BusyBox\n" \
 	"$ mount /dev/hdc1 /mnt -t minix\n" \
 	"$ chroot /mnt\n" \
 	"$ ls -l /bin/ls\n" \
 	"-rwxr-xr-x    1 root     root        40816 Feb  5 07:45 /bin/ls*\n"
 
 #define chvt_trivial_usage \
 	"N"
 #define chvt_full_usage \
 	"Changes the foreground virtual terminal to /dev/ttyN"
 
 #define clear_trivial_usage \
 	""
 #define clear_full_usage \
 	"Clear screen."
 
 #define cmp_trivial_usage \
 	"FILE1 [FILE2]"
 #define cmp_full_usage \
 	"\t-s\tquiet mode - do not print\n" \
 	"Compare files."
 
 #define cp_trivial_usage \
 	"[OPTION]... SOURCE DEST"
 #define cp_full_usage \
 	"Copies SOURCE to DEST, or multiple SOURCE(s) to DIRECTORY.\n" \
 	"\n" \
 	"\t-a\tSame as -dpR\n" \
 	"\t-d\tPreserves links\n" \
 	"\t-p\tPreserves file attributes if possible\n" \
 	"\t-f\tforce (implied; ignored) - always set\n" \
 	"\t-R\tCopies directories recursively"
 
 #define cut_trivial_usage \
 	"[OPTION]... [FILE]..."
 #define cut_full_usage \
 	"Prints selected fields from each input FILE to standard output.\n\n" \
 	"Options:\n" \
 	"\t-b LIST\t\tOutput only bytes from LIST\n" \
 	"\t-c LIST\t\tOutput only characters from LIST\n" \
 	"\t-d CHAR\t\tUse CHAR instead of tab as the field delimiter\n" \
 	"\t-s\t\tOutput only the lines containing delimiter\n" \
 	"\t-f N\t\tPrint only these fields\n" \
 	"\t-n\t\tIgnored"
 #define cut_example_usage \
 	"$ echo "Hello world" | cut -f 1 -d ' '\n" \
 	"Hello\n" \
 	"$ echo "Hello world" | cut -f 2 -d ' '\n" \
 	"world\n"
 
 #define date_trivial_usage \
 	"[OPTION]... [+FORMAT]"
 #define date_full_usage \
 	"Displays the current time in the given FORMAT, or sets the system date.\n" \
 	"\nOptions:\n" \
 	"\t-R\t\tOutputs RFC-822 compliant date string\n" \
 	"\t-d STRING\tdisplay time described by STRING, not `now'\n" \
 	"\t-s\t\tSets time described by STRING\n" \
 	"\t-u\t\tPrints or sets Coordinated Universal Time"
 #define date_example_usage \
 	"$ date\n" \
 	"Wed Apr 12 18:52:41 MDT 2000\n"
 
 #define dc_trivial_usage \
 	"expression ..."
 #define dc_full_usage \
 	"This is a Tiny RPN calculator that understands the\n" \
 	"following operations: +, -, /, *, and, or, not, eor.\n" \
 	"i.e. 'dc 2 2 add' -> 4, and 'dc 8 8 \\* 2 2 + /' -> 16"
 #define dc_example_usage \
 	"$ dc 2 2 +\n" \
 	"4\n" \
 	"$ dc 8 8 \* 2 2 + /\n" \
 	"16\n" \
 	"$ dc 0 1 and\n" \
 	"0\n" \
 	"$ dc 0 1 or\n" \
 	"1\n" \
 	"$ echo 72 9 div 8 mul | dc\n" \
 	"64\n"
 
 #define dd_trivial_usage \
 	"[if=FILE] [of=FILE] [bs=N] [count=N] [skip=N]\n" \
 	"\t  [seek=N] [conv=notrunc|sync]"
 #define dd_full_usage \
 	"Copy a file, converting and formatting according to options\n\n" \
 	"\tif=FILE\t\tread from FILE instead of stdin\n" \
 	"\tof=FILE\t\twrite to FILE instead of stdout\n" \
 	"\tbs=N\t\tread and write N bytes at a time\n" \
 	"\tcount=N\t\tcopy only N input blocks\n" \
 	"\tskip=N\t\tskip N input blocks\n" \
 	"\tseek=N\t\tskip N output blocks\n" \
 	"\tconv=notrunc\tdon't truncate output file\n" \
 	"\tconv=sync\tpad blocks with zeros\n" \
 	"\n" \
 	"Numbers may be suffixed by c (x1), w (x2), b (x512), kD (x1000), k (x1024),\n" \
 	"MD (x1000000), M (x1048576), GD (x1000000000) or G (x1073741824)."
 #define dd_example_usage \
 	"$ dd if=/dev/zero of=/dev/ram1 bs=1M count=4\n" \
 	"4+0 records in\n" \
 	"4+0 records out\n"
 
 #define deallocvt_trivial_usage \
 	"N"
 #define deallocvt_full_usage \
 	 "Deallocate unused virtual terminal /dev/ttyN"
 
 
 #ifdef BB_FEATURE_HUMAN_READABLE
   #define USAGE_HUMAN_READABLE(a) a
   #define USAGE_NOT_HUMAN_READABLE(a)
 #else
   #define USAGE_HUMAN_READABLE(a) 
   #define USAGE_NOT_HUMAN_READABLE(a) a
 #endif
 #define df_trivial_usage \
 	"[-" USAGE_HUMAN_READABLE("hm") USAGE_NOT_HUMAN_READABLE("") "k] [FILESYSTEM ...]"
 #define df_full_usage \
 	"Print the filesystem space used and space available.\n\n" \
 	"Options:\n" \
 	USAGE_HUMAN_READABLE( \
 	"\n\t-h\tprint sizes in human readable format (e.g., 1K 243M 2G )\n" \
 	"\t-m\tprint sizes in megabytes\n" \
 	"\t-k\tprint sizes in kilobytes(default)") USAGE_NOT_HUMAN_READABLE( \
 	"\n\t-k\tprint sizes in kilobytes(compatability)")
 #define df_example_usage \
 	"$ df\n" \
 	"Filesystem           1k-blocks      Used Available Use% Mounted on\n" \
 	"/dev/sda3              8690864   8553540    137324  98% /\n" \
 	"/dev/sda1                64216     36364     27852  57% /boot\n" \
 	"$ df /dev/sda3\n" \
 	"Filesystem           1k-blocks      Used Available Use% Mounted on\n" \
 	"/dev/sda3              8690864   8553540    137324  98% /\n"
 
 #define dirname_trivial_usage \
 	"[FILENAME ...]"
 #define dirname_full_usage \
 	"Strips non-directory suffix from FILENAME"
 #define dirname_example_usage \
 	"$ dirname /tmp/foo\n" \
 	"/tmp\n" \
 	"$ dirname /tmp/foo/\n" \
 	"/tmp\n"
 
 #define dmesg_trivial_usage \
 	"[-c] [-n LEVEL] [-s SIZE]"
 #define dmesg_full_usage \
 	"Prints or controls the kernel ring buffer\n\n" \
 	"Options:\n" \
 	"\t-c\t\tClears the ring buffer's contents after printing\n" \
 	"\t-n LEVEL\tSets console logging level\n" \
 	"\t-s SIZE\t\tUse a buffer of size SIZE"
 
 #define dos2unix_trivial_usage \
 	"[option] [FILE]"
 #define dos2unix_full_usage \
 	"Converts FILE from dos format to unix format.  When no option\n" \
 	"is given, the input is converted to the opposite output format.\n" \
 	"When no file is given, uses stdin for input and stdout for output." \
 	"Options:\n" \
 	"\t-u\toutput will be in UNIX format\n" \
 	"\t-d\toutput will be in DOS format\n\n" \
 
 #define dpkg_trivial_usage \
 	"[-i|-r|--unpack|--configure] my.deb"
 #define dpkg_full_usage \
 	"WORK IN PROGRESS, only useful for debian-installer"
 
 #define dpkg_deb_trivial_usage \
 	"[-cefItxX] FILE [argument]"
 #define dpkg_deb_full_usage \
 	"Perform actions on debian packages (.debs)\n\n" \
 	"Options:\n" \
 	"\t-c\tList contents of filesystem tree\n" \
 	"\t-e\tExtract control files to [argument] directory\n" \
 	"\t-f\tDisplay control field name starting with [argument]\n" \
 	"\t-I\tDisplay the control filenamed [argument]\n" \
 	"\t-t\tExtract filesystem tree to stdout in tar format\n" \
 	"\t-x\tExctract packages filesystem tree to directory\n" \
 	"\t-X\tVerbose extract"
 #define dpkg_deb_example_usage \
 	"$ dpkg-deb -X ./busybox_0.48-1_i386.deb /tmp\n"
 
 #define du_trivial_usage \
 	"[-ls" USAGE_HUMAN_READABLE("hm") USAGE_NOT_HUMAN_READABLE("") "k] [FILE]..."
 #define du_full_usage \
 	"Summarizes disk space used for each FILE and/or directory.\n" \
 	"Disk space is printed in units of 1024 bytes.\n\n" \
 	"Options:\n" \
 	"\t-l\tcount sizes many times if hard linked\n" \
 	"\t-s\tdisplay only a total for each argument" \
 	USAGE_HUMAN_READABLE( \
 	"\n\t-h\tprint sizes in human readable format (e.g., 1K 243M 2G )\n" \
 	"\t-m\tprint sizes in megabytes\n" \
 	"\t-k\tprint sizes in kilobytes(default)") USAGE_NOT_HUMAN_READABLE( \
 	"\n\t-k\tprint sizes in kilobytes(compatability)")
 #define du_example_usage \
 	"$ du\n" \
 	"16      ./CVS\n" \
 	"12      ./kernel-patches/CVS\n" \
 	"80      ./kernel-patches\n" \
 	"12      ./tests/CVS\n" \
 	"36      ./tests\n" \
 	"12      ./scripts/CVS\n" \
 	"16      ./scripts\n" \
 	"12      ./docs/CVS\n" \
 	"104     ./docs\n" \
 	"2417    .\n"
 
 #define dumpkmap_trivial_usage \
 	"> keymap"
 #define dumpkmap_full_usage \
 	"Prints out a binary keyboard translation table to standard output."
 #define dumpkmap_example_usage \
 	"$ dumpkmap > keymap\n"
 
 #define dutmp_trivial_usage \
 	"[FILE]"
 #define dutmp_full_usage \
 	"Dump utmp file format (pipe delimited) from FILE\n" \
 	"or stdin to stdout.  (i.e. 'dutmp /var/run/utmp')"
 #define dutmp_example_usage \
 	"$ dutmp /var/run/utmp\n" \
 	"8|7||si|||0|0|0|955637625|760097|0\n" \
 	"2|0|~|~~|reboot||0|0|0|955637625|782235|0\n" \
 	"1|20020|~|~~|runlevel||0|0|0|955637625|800089|0\n" \
 	"8|125||l4|||0|0|0|955637629|998367|0\n" \
 	"6|245|tty1|1|LOGIN||0|0|0|955637630|998974|0\n" \
 	"6|246|tty2|2|LOGIN||0|0|0|955637630|999498|0\n" \
 	"7|336|pts/0|vt00andersen|andersen|:0.0|0|0|0|955637763|0|0\n"
 
 #define echo_trivial_usage \
 	"[-neE] [ARG ...]"
 #define echo_full_usage \
 	"Prints the specified ARGs to stdout\n\n" \
 	"Options:\n" \
 	"\t-n\tsuppress trailing newline\n" \
 	"\t-e\tinterpret backslash-escaped characters (i.e. \\t=tab etc)\n" \
 	"\t-E\tdisable interpretation of backslash-escaped characters"
 #define echo_example_usage \
 	"$ echo "Erik is cool"\n" \
 	"Erik is cool\n" \
 	"$  echo -e "Erik\\nis\\ncool"\n" \
 	"Erik\n" \
 	"is\n" \
 	"cool\n" \
 	"$ echo "Erik\\nis\\ncool"\n" \
 	"Erik\\nis\\ncool\n"
 
 #define env_trivial_usage \
 	"[-iu] [-] [name=value]... [command]"
 #define env_full_usage \
 	"Prints the current environment or runs a program after setting\n" \
 	"up the specified environment.\n\n" \
 	"Options:\n" \
 	"\t-, -i\tstart with an empty environment\n" \
 	"\t-u\tremove variable from the environment\n"
 
 #define expr_trivial_usage \
 	"EXPRESSION"
 #define expr_full_usage \
 	"Prints the value of EXPRESSION to standard output.\n\n" \
 	"EXPRESSION may be:\n" \
 	"\tARG1 |  ARG2	ARG1 if it is neither null nor 0, otherwise ARG2\n" \
 	"\tARG1 &  ARG2	ARG1 if neither argument is null or 0, otherwise 0\n" \
 	"\tARG1 <  ARG2	ARG1 is less than ARG2\n" \
 	"\tARG1 <= ARG2	ARG1 is less than or equal to ARG2\n" \
 	"\tARG1 =  ARG2	ARG1 is equal to ARG2\n" \
 	"\tARG1 != ARG2	ARG1 is unequal to ARG2\n" \
 	"\tARG1 >= ARG2	ARG1 is greater than or equal to ARG2\n" \
 	"\tARG1 >  ARG2	ARG1 is greater than ARG2\n" \
 	"\tARG1 +  ARG2	arithmetic sum of ARG1 and ARG2\n" \
 	"\tARG1 -  ARG2	arithmetic difference of ARG1 and ARG2\n" \
 	"\tARG1 *  ARG2	arithmetic product of ARG1 and ARG2\n" \
 	"\tARG1 /  ARG2	arithmetic quotient of ARG1 divided by ARG2\n" \
 	"\tARG1 %  ARG2	arithmetic remainder of ARG1 divided by ARG2\n" \
 	"\tSTRING : REGEXP             anchored pattern match of REGEXP in STRING\n" \
 	"\tmatch STRING REGEXP         same as STRING : REGEXP\n" \
 	"\tsubstr STRING POS LENGTH    substring of STRING, POS counted from 1\n" \
 	"\tindex STRING CHARS          index in STRING where any CHARS is found,\n" \
 	"\t                            or 0\n" \
 	"\tlength STRING               length of STRING\n" \
 	"\tquote TOKEN                 interpret TOKEN as a string, even if\n" \
 	"\t                            it is a keyword like `match' or an\n" \
 	"\t                            operator like `/'\n" \
 	"\t( EXPRESSION )              value of EXPRESSION\n\n" \
 	"Beware that many operators need to be escaped or quoted for shells.\n" \
 	"Comparisons are arithmetic if both ARGs are numbers, else\n" \
 	"lexicographical.  Pattern matches return the string matched between \n" \
 	"\\( and \\) or null; if \\( and \\) are not used, they return the number \n" \
 	"of characters matched or 0."
 
 #define false_trivial_usage \
 	""
 #define false_full_usage \
 	"Return an exit code of FALSE (1)."
 #define false_example_usage \
 	"$ false\n" \
 	"$ echo $?\n" \
 	"1\n"
 
 #define fbset_trivial_usage \
 	"[options] [mode]"
 #define fbset_full_usage \
 	"Show and modify frame buffer settings"
 #define fbset_example_usage \
 	"$ fbset\n" \
 	"mode "1024x768-76"\n" \
 	"\t# D: 78.653 MHz, H: 59.949 kHz, V: 75.694 Hz\n" \
 	"\tgeometry 1024 768 1024 768 16\n" \
 	"\ttimings 12714 128 32 16 4 128 4\n" \
 	"\taccel false\n" \
 	"\trgba 5/11,6/5,5/0,0/0\n" \
 	"endmode\n"
 
 #define fdflush_trivial_usage \
 	"DEVICE"
 #define fdflush_full_usage \
 	"Forces floppy disk drive to detect disk change"
 
 #ifdef BB_FEATURE_FIND_TYPE
   #define USAGE_FIND_TYPE(a) a
 #else
   #define USAGE_FIND_TYPE(a)
 #endif
 #ifdef BB_FEATURE_FIND_PERM
   #define USAGE_FIND_PERM(a) a
 #else
   #define USAGE_FIND_PERM(a)
 #endif
 #ifdef BB_FEATURE_FIND_MTIME
   #define USAGE_FIND_MTIME(a) a
 #else
   #define USAGE_FIND_MTIME(a)
 #endif
 
 #define find_trivial_usage \
 	"[PATH...] [EXPRESSION]"
 #define find_full_usage \
 	"Search for files in a directory hierarchy.  The default PATH is\n" \
 	"the current directory; default EXPRESSION is '-print'\n" \
 	"\nEXPRESSION may consist of:\n" \
 	"\t-follow\t\tDereference symbolic links.\n" \
 	"\t-name PATTERN\tFile name (leading directories removed) matches PATTERN.\n" \
 	"\t-print\t\tPrint (default and assumed).\n" \
 	USAGE_FIND_TYPE( \
 	"\n\t-type X\t\tFiletype matches X (where X is one of: f,d,l,b,c,...)" \
 ) USAGE_FIND_PERM( \
 	"\n\t-perm PERMS\tPermissions match any of (+NNN); all of (-NNN);\n\t\t\tor exactly (NNN)" \
 ) USAGE_FIND_MTIME( \
 	"\n\t-mtime TIME\tModified time is greater than (+N); less than (-N);\n\t\t\tor exactly (N) days")
 #define find_example_usage \
 	"$ find / -name /etc/passwd\n" \
 	"/etc/passwd\n"
 
 #define free_trivial_usage \
 	""
 #define free_full_usage \
 	"Displays the amount of free and used system memory"
 #define free_example_usage \
 	"$ free\n" \
 	"              total         used         free       shared      buffers\n" \
 	"  Mem:       257628       248724         8904        59644        93124\n" \
 	" Swap:       128516         8404       120112\n" \
 	"Total:       386144       257128       129016\n" \
 
 #define freeramdisk_trivial_usage \
 	"DEVICE"
 #define freeramdisk_full_usage \
 	"Frees all memory used by the specified ramdisk."
 #define freeramdisk_example_usage \
 	"$ freeramdisk /dev/ram2\n"
 
 #define fsck_minix_trivial_usage \
 	"[-larvsmf] /dev/name"
 #define fsck_minix_full_usage \
 	"Performs a consistency check for MINIX filesystems.\n\n" \
 	"Options:\n" \
 	"\t-l\tLists all filenames\n" \
 	"\t-r\tPerform interactive repairs\n" \
 	"\t-a\tPerform automatic repairs\n" \
 	"\t-v\tverbose\n" \
 	"\t-s\tOutputs super-block information\n" \
 	"\t-m\tActivates MINIX-like \"mode not cleared\" warnings\n" \
 	"\t-f\tForce file system check."
 
 #define getopt_trivial_usage \
 	"[OPTIONS]..."
 #define getopt_full_usage \
 	"Parse command options\n" \
 	"\t-a, --alternative		Allow long options starting with single -\n" \
 	"\t-l, --longoptions=longopts	Long options to be recognized\n" \
 	"\t-n, --name=progname		The name under which errors are reported\n" \
 	"\t-o, --options=optstring	Short options to be recognized\n" \
 	"\t-q, --quiet			Disable error reporting by getopt(3)\n" \
 	"\t-Q, --quiet-output		No normal output\n" \
 	"\t-s, --shell=shell		Set shell quoting conventions\n" \
 	"\t-T, --test			Test for getopt(1) version\n" \
 	"\t-u, --unqote			Do not quote the output"
 #define getopt_example_usage \
         "$ cat getopt.test\n" \
         "#!/bin/sh\n" \
         "GETOPT=`getopt -o ab:c:: --long a-long,b-long:,c-long:: \\\n" \
         "       -n 'example.busybox' -- "$@"`\n" \
         "if [ $? != 0 ] ; then  exit 1 ; fi\n" \
         "eval set -- "$GETOPT"\n" \
         "while true ; do\n" \
         " case $1 in\n" \
         "   -a|--a-long) echo \"Option a\" ; shift ;;\n" \
         "   -b|--b-long) echo \"Option b, argument \`$2'\" ; shift 2 ;;\n" \
         "   -c|--c-long)\n" \
         "     case "$2" in\n" \
         "       \"\") echo \"Option c, no argument\"; shift 2 ;;\n" \
         "       *)  echo \"Option c, argument \`$2'\" ; shift 2 ;;\n" \
         "     esac ;;\n" \
         "   --) shift ; break ;;\n" \
         "   *) echo \"Internal error!\" ; exit 1 ;;\n" \
         " esac\n" \
         "done\n"
 
 #define grep_trivial_usage \
 	"[-ihHnqvs] PATTERN [FILEs...]"
 #define grep_full_usage \
 	"Search for PATTERN in each FILE or standard input.\n\n" \
 	"Options:\n" \
 	"\t-H\tprefix output lines with filename where match was found\n" \
 	"\t-h\tsuppress the prefixing filename on output\n" \
 	"\t-i\tignore case distinctions\n" \
 	"\t-l\tlist names of files that match\n" \
 	"\t-n\tprint line number with output lines\n" \
 	"\t-q\tbe quiet. Returns 0 if result was found, 1 otherwise\n" \
 	"\t-v\tselect non-matching lines\n" \
 	"\t-s\tsuppress file open/read error messages"
 #define grep_example_usage \
 	"$ grep root /etc/passwd\n" \
 	"root:x:0:0:root:/root:/bin/bash\n" \
 	"$ grep ^[rR]oo. /etc/passwd\n" \
 	"root:x:0:0:root:/root:/bin/bash\n"
 
 #define gunzip_trivial_usage \
 	"[OPTION]... FILE"
 #define gunzip_full_usage \
 	"Uncompress FILE (or standard input if FILE is '-').\n\n" \
 	"Options:\n" \
 	"\t-c\tWrite output to standard output\n" \
 	"\t-t\tTest compressed file integrity"
 #define gunzip_example_usage \
 	"$ ls -la /tmp/BusyBox*\n" \
 	"-rw-rw-r--    1 andersen andersen   557009 Apr 11 10:55 /tmp/BusyBox-0.43.tar.gz\n" \
 	"$ gunzip /tmp/BusyBox-0.43.tar.gz\n" \
 	"$ ls -la /tmp/BusyBox*\n" \
 	"-rw-rw-r--    1 andersen andersen  1761280 Apr 14 17:47 /tmp/BusyBox-0.43.tar\n"
 
 #define gzip_trivial_usage \
 	"[OPTION]... FILE"
 #define gzip_full_usage \
 	"Compress FILE with maximum compression.\n" \
 	"When FILE is '-', reads standard input.  Implies -c.\n\n" \
 	"Options:\n" \
 	"\t-c\tWrite output to standard output instead of FILE.gz\n" \
 	"\t-d\tdecompress"
 #define gzip_example_usage \
 	"$ ls -la /tmp/busybox*\n" \
 	"-rw-rw-r--    1 andersen andersen  1761280 Apr 14 17:47 /tmp/busybox.tar\n" \
 	"$ gzip /tmp/busybox.tar\n" \
 	"$ ls -la /tmp/busybox*\n" \
 	"-rw-rw-r--    1 andersen andersen   554058 Apr 14 17:49 /tmp/busybox.tar.gz\n"
 
 #define halt_trivial_usage \
 	""
 #define halt_full_usage \
 	"Halt the system."
 
 #define head_trivial_usage \
 	"[OPTION] [FILE]..."
 #define head_full_usage \
 	"Print first 10 lines of each FILE to standard output.\n" \
 	"With more than one FILE, precede each with a header giving the\n" \
 	"file name. With no FILE, or when FILE is -, read standard input.\n\n" \
 	"Options:\n" \
 	"\t-n NUM\t\tPrint first NUM lines instead of first 10"
 #define head_example_usage \
 	"$ head -n 2 /etc/passwd\n" \
 	"root:x:0:0:root:/root:/bin/bash\n" \
 	"daemon:x:1:1:daemon:/usr/sbin:/bin/sh\n"
 
 #define hostid_trivial_usage \
 	""
 #define hostid_full_usage \
 	"Print out a unique 32-bit identifier for the machine."
 
 #define hostname_trivial_usage \
 	"[OPTION] {hostname | -F FILE}"
 #define hostname_full_usage \
 	"Get or set the hostname or DNS domain name. If a hostname is given\n" \
 	"(or FILE with the -F parameter), the host name will be set.\n\n" \
 	"Options:\n" \
 	"\t-s\t\tShort\n" \
 	"\t-i\t\tAddresses for the hostname\n" \
 	"\t-d\t\tDNS domain name\n" \
 	"\t-F, --file FILE\tUse the contents of FILE to specify the hostname"
 #define hostname_example_usage \
 	"$ hostname\n" \
 	"sage \n"
 
 #define id_trivial_usage \
 	"[OPTIONS]... [USERNAME]"
 #define id_full_usage \
 	"Print information for USERNAME or the current user\n\n" \
 	"Options:\n" \
 	"\t-g\tprints only the group ID\n" \
 	"\t-u\tprints only the user ID\n" \
 	"\t-n\tprint a name instead of a number (with for -ug)\n" \
 	"\t-r\tprints the real user ID instead of the effective ID (with -ug)"
 #define id_example_usage \
 	"$ id\n" \
 	"uid=1000(andersen) gid=1000(andersen)\n"
 
 #ifdef BB_FEATURE_IFCONFIG_SLIP
   #define USAGE_SIOCSKEEPALIVE(a) a
 #else
   #define USAGE_SIOCSKEEPALIVE(a)
 #endif
 #ifdef BB_FEATURE_IFCONFIG_MEMSTART_IOADDR_IRQ
   #define USAGE_IFCONFIG_MII(a) a
 #else
   #define USAGE_IFCONFIG_MII(a)
 #endif
 #ifdef BB_FEATURE_IFCONFIG_HW
   #define USAGE_IFCONFIG_HW(a) a
 #else
   #define USAGE_IFCONFIG_HW(a)
 #endif
 #ifdef BB_FEATURE_IFCONFIG_STATUS
   #define USAGE_IFCONFIG_OPT_A(a) a
 #else
   #define USAGE_IFCONFIG_OPT_A(a)
 #endif
 
 #define ifconfig_trivial_usage \
 	USAGE_IFCONFIG_OPT_A("[-a]") " <interface> [<address>]"
 #define ifconfig_full_usage \
 	"configure a network interface\n\n" \
 	"Options:\n" \
 	"\t[[-]broadcast [<address>]]  [[-]pointopoint [<address>]]\n" \
 	"\t[netmask <address>]  [dstaddr <address>]\n" \
 	USAGE_SIOCSKEEPALIVE("\t[outfill <NN>] [keepalive <NN>]\n") \
 	"\t" USAGE_IFCONFIG_HW("[hw ether <address>]  ") \
     "[metric <NN>]  [mtu <NN>]\n" \
 	"\t[[-]trailers]  [[-]arp]  [[-]allmulti]\n" \
 	"\t[multicast]  [[-]promisc]  [txqueuelen <NN>]  [[-]dynamic]\n" \
 	USAGE_IFCONFIG_MII("\t[mem_start <NN>]  [io_addr <NN>]  [irq <NN>]\n") \
 	"\t[up|down] ..."
 
 #define init_trivial_usage \
 	""
 #define init_full_usage \
 	"Init is the parent of all processes."
 #define init_notes_usage \
 "This version of init is designed to be run only by the kernel.\n" \
 "\n" \
 "BusyBox init doesn't support multiple runlevels.  The runlevels field of\n" \
 "the /etc/inittab file is completely ignored by BusyBox init. If you want \n" \
 "runlevels, use sysvinit.\n" \
 "\n" \
 "BusyBox init works just fine without an inittab.  If no inittab is found, \n" \
 "it has the following default behavior:\n" \
 "\n" \
 "	::sysinit:/etc/init.d/rcS\n" \
 "	::askfirst:/bin/sh\n" \
 "	::ctrlaltdel:/sbin/reboot\n" \
 "	::shutdown:/sbin/swapoff -a\n" \
 "	::shutdown:/bin/umount -a -r\n" \
 "\n" \
 "if it detects that /dev/console is _not_ a serial console, it will also run:\n" \
 "\n" \
 "	tty2::askfirst:/bin/sh\n" \
 "	tty3::askfirst:/bin/sh\n" \
 "	tty4::askfirst:/bin/sh\n" \
 "\n" \
 "If you choose to use an /etc/inittab file, the inittab entry format is as follows:\n" \
 "\n" \
 "	<id>:<runlevels>:<action>:<process>\n" \
 "\n" \
 "	<id>: \n" \
 "\n" \
 "		WARNING: This field has a non-traditional meaning for BusyBox init!\n" \
 "		The id field is used by BusyBox init to specify the controlling tty for\n" \
 "		the specified process to run on.  The contents of this field are\n" \
 "		appended to "/dev/" and used as-is.  There is no need for this field to\n" \
 "		be unique, although if it isn't you may have strange results.  If this\n" \
 "		field is left blank, the controlling tty is set to the console.  Also\n" \
 "		note that if BusyBox detects that a serial console is in use, then only\n" \
 "		entries whose controlling tty is either the serial console or /dev/null\n" \
 "		will be run.  BusyBox init does nothing with utmp.  We don't need no\n" \
 "		stinkin' utmp.\n" \
 "\n" \
 "	<runlevels>: \n" \
 "\n" \
 "		The runlevels field is completely ignored.\n" \
 "\n" \
 "	<action>: \n" \
 "\n" \
 "		Valid actions include: sysinit, respawn, askfirst, wait, \n" \
 "		once, ctrlaltdel, and shutdown.\n" \
 "\n" \
 "		The available actions can be classified into two groups: actions\n" \
 "		that are run only once, and actions that are re-run when the specified\n" \
 "		process exits.\n" \
 "\n" \
 "		Run only-once actions:\n" \
 "\n" \
 "			'sysinit' is the first item run on boot.  init waits until all\n" \
 "			sysinit actions are completed before continuing.  Following the\n" \
 "			completion of all sysinit actions, all 'wait' actions are run.\n" \
 "			'wait' actions, like  'sysinit' actions, cause init to wait until\n" \
 "			the specified task completes.  'once' actions are asyncronous,\n" \
 "			therefore, init does not wait for them to complete.  'ctrlaltdel'\n" \
 "			actions are run when the system detects that someone on the system\n" \
 "                       console has pressed the CTRL-ALT-DEL key combination.  Typically one\n" \
 "                       wants to run 'reboot' at this point to cause the system to reboot.\n" \
 "			Finally the 'shutdown' action specifies the actions to taken when\n" \
 "                       init is told to reboot.  Unmounting filesystems and disabling swap\n" \
 "                       is a very good here\n" \
 "\n" \
 "		Run repeatedly actions:\n" \
 "\n" \
 "			'respawn' actions are run after the 'once' actions.  When a process\n" \
 "			started with a 'respawn' action exits, init automatically restarts\n" \
 "			it.  Unlike sysvinit, BusyBox init does not stop processes from\n" \
 "			respawning out of control.  The 'askfirst' actions acts just like\n" \
 "			respawn, except that before running the specified process it\n" \
 "			displays the line "Please press Enter to activate this console."\n" \
 "			and then waits for the user to press enter before starting the\n" \
 "			specified process.  \n" \
 "\n" \
 "		Unrecognized actions (like initdefault) will cause init to emit an\n" \
 "		error message, and then go along with its business.  All actions are\n" \
 "		run in the reverse order from how they appear in /etc/inittab.\n" \
 "\n" \
 "	<process>: \n" \
 "\n" \
 "		Specifies the process to be executed and it's command line.\n" \
 "\n" \
 "Example /etc/inittab file:\n" \
 "\n" \
 "	# This is run first except when booting in single-user mode.\n" \
 "	#\n" \
 "	::sysinit:/etc/init.d/rcS\n" \
 "	\n" \
 "	# /bin/sh invocations on selected ttys\n" \
 "	#\n" \
 "	# Start an "askfirst" shell on the console (whatever that may be)\n" \
 "	::askfirst:-/bin/sh\n" \
 "	# Start an "askfirst" shell on /dev/tty2-4\n" \
 "	tty2::askfirst:-/bin/sh\n" \
 "	tty3::askfirst:-/bin/sh\n" \
 "	tty4::askfirst:-/bin/sh\n" \
 "	\n" \
 "	# /sbin/getty invocations for selected ttys\n" \
 "	#\n" \
 "	tty4::respawn:/sbin/getty 38400 tty5\n" \
 "	tty5::respawn:/sbin/getty 38400 tty6\n" \
 "	\n" \
 "	\n" \
 "	# Example of how to put a getty on a serial line (for a terminal)\n" \
 "	#\n" \
 "	#::respawn:/sbin/getty -L ttyS0 9600 vt100\n" \
 "	#::respawn:/sbin/getty -L ttyS1 9600 vt100\n" \
 "	#\n" \
 "	# Example how to put a getty on a modem line.\n" \
 "	#::respawn:/sbin/getty 57600 ttyS2\n" \
 "	\n" \
 "	# Stuff to do before rebooting\n" \
 "	::ctrlaltdel:/sbin/reboot\n" \
 "	::shutdown:/bin/umount -a -r\n" \
 "	::shutdown:/sbin/swapoff -a\n"
 
 #define insmod_trivial_usage \
 	"[OPTION]... MODULE [symbol=value]..."
 #define insmod_full_usage \
 	"Loads the specified kernel modules into the kernel.\n\n" \
 	"Options:\n" \
 	"\t-f\tForce module to load into the wrong kernel version.\n" \
 	"\t-k\tMake module autoclean-able.\n" \
 	"\t-v\tverbose output\n"  \
 	"\t-L\tLock to prevent simultaneous loads of a module\n" \
 	"\t-x\tdo not export externs"
 
 #define kill_trivial_usage \
 	"[-signal] process-id [process-id ...]"
 #define kill_full_usage \
 	"Send a signal (default is SIGTERM) to the specified process(es).\n\n"\
 	"Options:\n" \
 	"\t-l\tList all signal names and numbers."
 #define kill_example_usage \
 	"$ ps | grep apache\n" \
 	"252 root     root     S [apache]\n" \
 	"263 www-data www-data S [apache]\n" \
 	"264 www-data www-data S [apache]\n" \
 	"265 www-data www-data S [apache]\n" \
 	"266 www-data www-data S [apache]\n" \
 	"267 www-data www-data S [apache]\n" \
 	"$ kill 252\n"
 
 #define killall_trivial_usage \
 	"[-signal] process-name [process-name ...]"
 #define killall_full_usage \
 	"Send a signal (default is SIGTERM) to the specified process(es).\n\n"\
 	"Options:\n" \
 	"\t-l\tList all signal names and numbers."
 #define killall_example_usage \
 	"$ killall apache\n" 
 
 #define klogd_trivial_usage \
 	"-n"
 #define klogd_full_usage \
 	"Kernel logger.\n"\
 	"Options:\n"\
 	"\t-n\tRun as a foreground process."
 
 #define length_trivial_usage \
 	"STRING"
 #define length_full_usage \
 	"Prints out the length of the specified STRING."
 #define length_example_usage \
 	"$ length Hello\n" \
 	"5\n"
 
 #define ln_trivial_usage \
 	"[OPTION] TARGET... LINK_NAME|DIRECTORY"
 #define ln_full_usage \
 	"Create a link named LINK_NAME or DIRECTORY to the specified TARGET\n"\
 	"\nYou may use '--' to indicate that all following arguments are non-options.\n\n" \
 	"Options:\n" \
 	"\t-s\tmake symbolic links instead of hard links\n" \
 	"\t-f\tremove existing destination files\n" \
 	"\t-n\tno dereference symlinks - treat like normal file"
 #define ln_example_usage \
 	"$ ln -s BusyBox /tmp/ls\n" \
 	"$ ls -l /tmp/ls\n" \
 	"lrwxrwxrwx    1 root     root            7 Apr 12 18:39 ls -> BusyBox*\n" 
 
 #define loadacm_trivial_usage \
 	"< mapfile"
 #define loadacm_full_usage \
 	"Loads an acm from standard input."
 #define loadacm_example_usage \
 	"$ loadacm < /etc/i18n/acmname\n" 
 
 #define loadfont_trivial_usage \
 	"< font"
 #define loadfont_full_usage \
 	"Loads a console font from standard input."
 #define loadfont_example_usage \
 	"$ loadfont < /etc/i18n/fontname\n" 
 
 #define loadkmap_trivial_usage \
 	"< keymap"
 #define loadkmap_full_usage \
 	"Loads a binary keyboard translation table from standard input."
 #define loadkmap_example_usage \
 	"$ loadkmap < /etc/i18n/lang-keymap\n" 
 
 #define logger_trivial_usage \
 	"[OPTION]... [MESSAGE]"
 #define logger_full_usage \
 	"Write MESSAGE to the system log.  If MESSAGE is omitted, log stdin.\n\n" \
 	"Options:\n" \
 	"\t-s\tLog to stderr as well as the system log.\n" \
 	"\t-t\tLog using the specified tag (defaults to user name).\n" \
 	"\t-p\tEnter the message with the specified priority.\n" \
 	"\t\tThis may be numerical or a ``facility.level'' pair."
 #define logger_example_usage \
 	"$ logger "hello"\n" 
 
 #define logname_trivial_usage \
 	""
 #define logname_full_usage \
 	"Print the name of the current user."
 #define logname_example_usage \
 	"$ logname\n" \
 	"root\n" 
 
 #define logread_trivial_usage \
         ""
 
 #define logread_full_usage \
         "Shows the messages from syslogd (using circular buffer)."
 
 #ifdef BB_FEATURE_LS_TIMESTAMPS
   #define USAGE_LS_TIMESTAMPS(a) a
 #else
   #define USAGE_LS_TIMESTAMPS(a)
 #endif
 #ifdef BB_FEATURE_LS_FILETYPES
   #define USAGE_LS_FILETYPES(a) a
 #else
   #define USAGE_LS_FILETYPES(a)
 #endif
 #ifdef BB_FEATURE_LS_FOLLOWLINKS
   #define USAGE_LS_FOLLOWLINKS(a) a
 #else
   #define USAGE_LS_FOLLOWLINKS(a)
 #endif
 #ifdef BB_FEATURE_LS_RECURSIVE
   #define USAGE_LS_RECURSIVE(a) a
 #else
   #define USAGE_LS_RECURSIVE(a)
 #endif
 #ifdef BB_FEATURE_LS_SORTFILES
   #define USAGE_LS_SORTFILES(a) a
 #else
   #define USAGE_LS_SORTFILES(a)
 #endif
 #ifdef BB_FEATURE_AUTOWIDTH
   #define USAGE_AUTOWIDTH(a) a
 #else
   #define USAGE_AUTOWIDTH(a)
 #endif
 #define ls_trivial_usage \
 	"[-1Aa" USAGE_LS_TIMESTAMPS("c") "Cd" USAGE_LS_TIMESTAMPS("e") USAGE_LS_FILETYPES("F") "iln" USAGE_LS_FILETYPES("p") USAGE_LS_FOLLOWLINKS("L") USAGE_LS_RECURSIVE("R") USAGE_LS_SORTFILES("rS") "s" USAGE_AUTOWIDTH("T") USAGE_LS_TIMESTAMPS("tu") USAGE_LS_SORTFILES("v") USAGE_AUTOWIDTH("w") "x" USAGE_LS_SORTFILES("X") USAGE_HUMAN_READABLE("h") USAGE_NOT_HUMAN_READABLE("") "k] [filenames...]"
 #define ls_full_usage \
 	"List directory contents\n\n" \
 	"Options:\n" \
 	"\t-1\tlist files in a single column\n" \
 	"\t-A\tdo not list implied . and ..\n" \
 	"\t-a\tdo not hide entries starting with .\n" \
 	"\t-C\tlist entries by columns\n" \
 	USAGE_LS_TIMESTAMPS("\t-c\twith -l: show ctime\n") \
 	"\t-d\tlist directory entries instead of contents\n" \
 	USAGE_LS_TIMESTAMPS("\t-e\tlist both full date and full time\n") \
 	USAGE_LS_FILETYPES("\t-F\tappend indicator (one of */=@|) to entries\n") \
 	"\t-i\tlist the i-node for each file\n" \
 	"\t-l\tuse a long listing format\n" \
 	"\t-n\tlist numeric UIDs and GIDs instead of names\n" \
 	USAGE_LS_FILETYPES("\t-p\tappend indicator (one of /=@|) to entries\n") \
 	USAGE_LS_FOLLOWLINKS("\t-L\tlist entries pointed to by symbolic links\n") \
 	USAGE_LS_RECURSIVE("\t-R\tlist subdirectories recursively\n") \
 	USAGE_LS_SORTFILES("\t-r\tsort the listing in reverse order\n") \
 	USAGE_LS_SORTFILES("\t-S\tsort the listing by file size\n") \
 	"\t-s\tlist the size of each file, in blocks\n" \
 	USAGE_AUTOWIDTH("\t-T NUM\tassume Tabstop every NUM columns\n") \
 	USAGE_LS_TIMESTAMPS("\t-t\twith -l: show modification time\n") \
 	USAGE_LS_TIMESTAMPS("\t-u\twith -l: show access time\n") \
 	USAGE_LS_SORTFILES("\t-v\tsort the listing by version\n") \
 	USAGE_AUTOWIDTH("\t-w NUM\tassume the terminal is NUM columns wide\n") \
 	"\t-x\tlist entries by lines instead of by columns\n" \
 	USAGE_LS_SORTFILES("\t-X\tsort the listing by extension\n") \
 	USAGE_HUMAN_READABLE( \
 	"\t-h\tprint sizes in human readable format (e.g., 1K 243M 2G )\n" \
 	"\t-k\tprint sizes in kilobytes(default)") USAGE_NOT_HUMAN_READABLE( \
 	"\t-k\tprint sizes in kilobytes(compatability)") 
 
 #define lsmod_trivial_usage \
 	""
 #define lsmod_full_usage \
 	"List the currently loaded kernel modules."
 
 #define makedevs_trivial_usage \
 	"NAME TYPE MAJOR MINOR FIRST LAST [s]"
 #define makedevs_full_usage \
 	"Creates a range of block or character special files\n\n" \
 	"TYPEs include:\n" \
 	"\tb:\tMake a block (buffered) device.\n" \
 	"\tc or u:\tMake a character (un-buffered) device.\n" \
 	"\tp:\tMake a named pipe. MAJOR and MINOR are ignored for named pipes.\n\n" \
 	"FIRST specifies the number appended to NAME to create the first device.\n" \
 	"LAST specifies the number of the last item that should be created.\n" \
 	"If 's' is the last argument, the base device is created as well.\n\n" \
 	"For example:\n" \
 	"\tmakedevs /dev/ttyS c 4 66 2 63   ->  ttyS2-ttyS63\n" \
 	"\tmakedevs /dev/hda b 3 0 0 8 s    ->  hda,hda1-hda8"
 #define makedevs_example_usage \
 	"$ makedevs /dev/ttyS c 4 66 2 63\n" \
 	"[creates ttyS2-ttyS63]\n" \
 	"$ makedevs /dev/hda b 3 0 0 8 s\n" \
 	"[creates hda,hda1-hda8]\n" 
 
 #define md5sum_trivial_usage \
 	"[OPTION] [FILE]...\n" \
 	"or: md5sum [OPTION] -c [FILE]"
 #define md5sum_full_usage \
 	"Print or check MD5 checksums.\n\n" \
 	"Options:\n" \
 	"With no FILE, or when FILE is -, read standard input.\n\n" \
 	"\t-b\tread files in binary mode\n" \
 	"\t-c\tcheck MD5 sums against given list\n" \
 	"\t-t\tread files in text mode (default)\n" \
 	"\t-g\tread a string\n" \
 	"\nThe following two options are useful only when verifying checksums:\n" \
 	"\t-s\tdon't output anything, status code shows success\n" \
 	"\t-w\twarn about improperly formated MD5 checksum lines"
 #define md5sum_example_usage \
 	"$ md5sum < busybox\n" \
 	"6fd11e98b98a58f64ff3398d7b324003\n" \
 	"$ md5sum busybox\n" \
 	"6fd11e98b98a58f64ff3398d7b324003  busybox\n" \
 	"$ md5sum -c -\n" \
 	"6fd11e98b98a58f64ff3398d7b324003  busybox\n" \
 	"busybox: OK\n" \
 	"^D\n"
 
 #define mkdir_trivial_usage \
 	"[OPTION] DIRECTORY..."
 #define mkdir_full_usage \
 	"Create the DIRECTORY(ies) if they do not already exist\n\n" \
 	"Options:\n" \
 	"\t-m\tset permission mode (as in chmod), not rwxrwxrwx - umask\n" \
 	"\t-p\tno error if existing, make parent directories as needed"
 #define mkdir_example_usage \
 	"$ mkdir /tmp/foo\n" \
 	"$ mkdir /tmp/foo\n" \
 	"/tmp/foo: File exists\n" \
 	"$ mkdir /tmp/foo/bar/baz\n" \
 	"/tmp/foo/bar/baz: No such file or directory\n" \
 	"$ mkdir -p /tmp/foo/bar/baz\n" 
 
 #define mkfifo_trivial_usage \
 	"[OPTIONS] name"
 #define mkfifo_full_usage \
 	"Creates a named pipe (identical to 'mknod name p')\n\n" \
 	"Options:\n" \
 	"\t-m\tcreate the pipe using the specified mode (default a=rw)"
 
 #define mkfs_minix_trivial_usage \
 	"[-c | -l filename] [-nXX] [-iXX] /dev/name [blocks]"
 #define mkfs_minix_full_usage \
 	"Make a MINIX filesystem.\n\n" \
 	"Options:\n" \
 	"\t-c\t\tCheck the device for bad blocks\n" \
 	"\t-n [14|30]\tSpecify the maximum length of filenames\n" \
 	"\t-i INODES\tSpecify the number of inodes for the filesystem\n" \
 	"\t-l FILENAME\tRead the bad blocks list from FILENAME\n" \
 	"\t-v\t\tMake a Minix version 2 filesystem"
 
 #define mknod_trivial_usage \
 	"[OPTIONS] NAME TYPE MAJOR MINOR"
 #define mknod_full_usage \
 	"Create a special file (block, character, or pipe).\n\n" \
 	"Options:\n" \
 	"\t-m\tcreate the special file using the specified mode (default a=rw)\n\n" \
 	"TYPEs include:\n" \
 	"\tb:\tMake a block (buffered) device.\n" \
 	"\tc or u:\tMake a character (un-buffered) device.\n" \
 	"\tp:\tMake a named pipe. MAJOR and MINOR are ignored for named pipes."
 #define mknod_example_usage \
 	"$ mknod /dev/fd0 b 2 0 \n" \
 	"$ mknod -m 644 /tmp/pipe p\n" 
 
 #define mkswap_trivial_usage \
 	"[-c] [-v0|-v1] device [block-count]"
 #define mkswap_full_usage \
 	"Prepare a disk partition to be used as a swap partition.\n\n" \
 	"Options:\n" \
 	"\t-c\t\tCheck for read-ability.\n" \
 	"\t-v0\t\tMake version 0 swap [max 128 Megs].\n" \
 	"\t-v1\t\tMake version 1 swap [big!] (default for kernels >\n\t\t\t2.1.117).\n" \
 	"\tblock-count\tNumber of block to use (default is entire partition)."
 
 #define mktemp_trivial_usage \
 	"[-q] TEMPLATE"
 #define mktemp_full_usage \
 	"Creates a temporary file with its name based on TEMPLATE.\n" \
 	"TEMPLATE is any name with six `Xs' (i.e. /tmp/temp.XXXXXX)."
 #define mktemp_example_usage \
 	"$ mktemp /tmp/temp.XXXXXX\n" \
 	"/tmp/temp.mWiLjM\n" \
 	"$ ls -la /tmp/temp.mWiLjM\n" \
 	"-rw-------    1 andersen andersen        0 Apr 25 17:10 /tmp/temp.mWiLjM\n" 
 
 #define more_trivial_usage \
 	"[FILE ...]"
 #define more_full_usage \
 	"More is a filter for viewing FILE one screenful at a time."
 #define more_example_usage \
 	"$ dmesg | more\n" 
 
 #ifdef BB_FEATURE_MOUNT_LOOP
   #define USAGE_MOUNT_LOOP(a) a
 #else
   #define USAGE_MOUNT_LOOP(a)
 #endif
 #ifdef BB_FEATURE_MTAB_SUPPORT
   #define USAGE_MTAB(a) a
 #else
   #define USAGE_MTAB(a)
 #endif
 #define mount_trivial_usage \
 	"[flags] DEVICE NODE [-o options,more-options]"
 #define mount_full_usage \
 	"Mount a filesystem\n\n" \
 	"Flags:\n"  \
 	"\t-a:\t\tMount all filesystems in fstab.\n" \
 	USAGE_MTAB( \
 	"\t-f:\t\t\"Fake\" Add entry to mount table but don't mount it.\n" \
 	"\t-n:\t\tDon't write a mount table entry.\n" \
 	) \
 	"\t-o option:\tOne of many filesystem options, listed below.\n" \
 	"\t-r:\t\tMount the filesystem read-only.\n" \
 	"\t-t fs-type:\tSpecify the filesystem type.\n" \
 	"\t-w:\t\tMount for reading and writing (default).\n" \
 	"\n" \
 	"Options for use with the \"-o\" flag:\n" \
 	"\tasync/sync:\tWrites are asynchronous / synchronous.\n" \
 	"\tatime/noatime:\tEnable / disable updates to inode access times.\n" \
 	"\tdev/nodev:\tAllow use of special device files / disallow them.\n" \
 	"\texec/noexec:\tAllow use of executable files / disallow them.\n" \
 	USAGE_MOUNT_LOOP( \
 	"\tloop:\t\tMounts a file via loop device.\n" \
 	) \
 	"\tsuid/nosuid:\tAllow set-user-id-root programs / disallow them.\n" \
 	"\tremount:\tRe-mount a mounted filesystem, changing its flags.\n" \
 	"\tro/rw:\t\tMount for read-only / read-write.\n" \
 	"\tbind:\t\tUse the linux 2.4.x \"bind\" feature.\n" \
 	"\nThere are EVEN MORE flags that are specific to each filesystem.\n" \
 	"You'll have to see the written documentation for those filesystems."
 #define mount_example_usage \
 	"$ mount\n" \
 	"/dev/hda3 on / type minix (rw)\n" \
 	"proc on /proc type proc (rw)\n" \
 	"devpts on /dev/pts type devpts (rw)\n" \
 	"$ mount /dev/fd0 /mnt -t msdos -o ro\n" \
 	"$ mount /tmp/diskimage /opt -t ext2 -o loop\n" 
 
 #define mt_trivial_usage \
 	"[-f device] opcode value"
 #define mt_full_usage \
 	"Control magnetic tape drive operation\n" \
 	"\nAvailable Opcodes:\n\n" \
 	"bsf bsfm bsr bss datacompression drvbuffer eof eom erase\n" \
 	"fsf fsfm fsr fss load lock mkpart nop offline ras1 ras2\n" \
 	"ras3 reset retension rew rewoffline seek setblk setdensity\n" \
 	"setpart tell unload unlock weof wset"
 
 #define mv_trivial_usage \
 	"SOURCE DEST\n" \
 	"or: mv SOURCE... DIRECTORY"
 #define mv_full_usage \
 	"Rename SOURCE to DEST, or move SOURCE(s) to DIRECTORY."
 #define mv_example_usage \
 	"$ mv /tmp/foo /bin/bar\n" 
 
 #define nc_trivial_usage \
 	"[IP] [port]" 
 #define nc_full_usage \
 	"Netcat opens a pipe to IP:port"
 #define nc_example_usage \
 	"$ nc foobar.somedomain.com 25\n" \
 	"220 foobar ESMTP Exim 3.12 #1 Sat, 15 Apr 2000 00:03:02 -0600\n" \
 	"help\n" \
 	"214-Commands supported:\n" \
 	"214-    HELO EHLO MAIL RCPT DATA AUTH\n" \
 	"214     NOOP QUIT RSET HELP\n" \
 	"quit\n" \
 	"221 foobar closing connection\n" 
 
 #define nslookup_trivial_usage \
 	"[HOST]"
 #define nslookup_full_usage \
 	"Queries the nameserver for the IP address of the given HOST"
 #define nslookup_example_usage \
 	"$ nslookup localhost\n" \
 	"Server:     default\n" \
 	"Address:    default\n" \
 	"\n" \
 	"Name:       debian\n" \
 	"Address:    127.0.0.1\n" 
 
-#ifdef BB_FEATURE_SIMPLE_PING
+#ifndef BB_FEATURE_FANCY_PING
 #define ping_trivial_usage "host"
 #define ping_full_usage    "Send ICMP ECHO_REQUEST packets to network hosts"
 #else
 #define ping_trivial_usage \
 	"[OPTION]... host"
 #define ping_full_usage \
 	"Send ICMP ECHO_REQUEST packets to network hosts.\n\n" \
 	"Options:\n" \
 	"\t-c COUNT\tSend only COUNT pings.\n" \
 	"\t-s SIZE\t\tSend SIZE data bytes in packets (default=56).\n" \
 	"\t-q\t\tQuiet mode, only displays output at start\n" \
 	"\t\t\tand when finished."
 #endif
 #define ping_example_usage \
 	"$ ping localhost\n" \
 	"PING slag (127.0.0.1): 56 data bytes\n" \
 	"64 bytes from 127.0.0.1: icmp_seq=0 ttl=255 time=20.1 ms\n" \
 	"\n" \
 	"--- debian ping statistics ---\n" \
 	"1 packets transmitted, 1 packets received, 0% packet loss\n" \
 	"round-trip min/avg/max = 20.1/20.1/20.1 ms\n" 
 
 #define pivot_root_trivial_usage \
 	"NEW_ROOT PUT_OLD"
 #define pivot_root_full_usage \
 	"Move the current root file system to PUT_OLD and make NEW_ROOT\n" \
 	"the new root file system."
 
 #define poweroff_trivial_usage \
 	""
 #define poweroff_full_usage \
 	"Halt the system and request that the kernel shut off the power."
 
 #define printf_trivial_usage \
 	"FORMAT [ARGUMENT...]"
 #define printf_full_usage \
 	"Formats and prints ARGUMENT(s) according to FORMAT,\n" \
 	"Where FORMAT controls the output exactly as in C printf."
 #define printf_example_usage \
 	"$ printf "Val=%d\\n" 5\n" \
 	"Val=5\n" 
 
 #define ps_trivial_usage \
 	""
 #define ps_full_usage \
 	"Report process status\n" \
 	"\nThis version of ps accepts no options."
 #define ps_example_usage \
 	"$ ps\n" \
 	"  PID  Uid      Gid State Command\n" \
 	"    1 root     root     S init\n" \
 	"    2 root     root     S [kflushd]\n" \
 	"    3 root     root     S [kupdate]\n" \
 	"    4 root     root     S [kpiod]\n" \
 	"    5 root     root     S [kswapd]\n" \
 	"  742 andersen andersen S [bash]\n" \
 	"  743 andersen andersen S -bash\n" \
 	"  745 root     root     S [getty]\n" \
 	" 2990 andersen andersen R ps\n"
 
 #define pwd_trivial_usage \
 	""
 #define pwd_full_usage \
 	"Print the full filename of the current working directory."
 #define pwd_example_usage \
 	"$ pwd\n" \
 	"/root\n"
 
 #define rdate_trivial_usage \
 	"[OPTION] HOST"
 #define rdate_full_usage \
 	"Get and possibly set the system date and time from a remote HOST.\n\n" \
 	"Options:\n" \
 	"\t-s\tSet the system date and time (default).\n" \
 	"\t-p\tPrint the date and time."
 
 #define readlink_trivial_usage \
 	""
 #define readlink_full_usage \
 	"Read a symbolic link."
 
 #define reboot_trivial_usage \
 	""
 #define reboot_full_usage \
 	"Reboot the system."
 
 #define renice_trivial_usage \
 	"priority pid [pid ...]"
 #define renice_full_usage \
 	"Changes priority of running processes. Allowed priorities range\n" \
 	"from 20 (the process runs only when nothing else is running) to 0\n" \
 	"(default priority) to -20 (almost nothing else ever gets to run)."
 
 #define reset_trivial_usage \
 	""
 #define reset_full_usage \
 	"Resets the screen."
 
 #define rm_trivial_usage \
 	"[OPTION]... FILE..."
 #define rm_full_usage \
 	"Remove (unlink) the FILE(s).  You may use '--' to\n" \
 	"indicate that all following arguments are non-options.\n\n" \
 	"Options:\n" \
 	"\t-i\t\talways prompt before removing each destination" \
 	"\t-f\t\tremove existing destinations, never prompt\n" \
 	"\t-r or -R\tremove the contents of directories recursively"
 #define rm_example_usage \
 	"$ rm -rf /tmp/foo\n"
 
 #define rmdir_trivial_usage \
 	"[OPTION]... DIRECTORY..."
 #define rmdir_full_usage \
 	"Remove the DIRECTORY(ies), if they are empty."
 #define rmdir_example_usage \
 	"# rmdir /tmp/foo\n"
 
 #define rmmod_trivial_usage \
 	"[OPTION]... [MODULE]..."
 #define rmmod_full_usage \
 	"Unloads the specified kernel modules from the kernel.\n\n" \
 	"Options:\n" \
 	"\t-a\tTry to remove all unused kernel modules."
 #define rmmod_example_usage \
 	"$ rmmod tulip\n"
 
 #define route_trivial_usage \
 	"[{add|del|flush}]"
 #define route_full_usage \
 	"Edit the kernel's routing tables"
 
 #define rpmunpack_trivial_usage \
 	"< package.rpm | gunzip | cpio -idmuv"
 #define rpmunpack_full_usage \
 	"Extracts an rpm archive."
 
 #define sed_trivial_usage \
 	"[-Vhnef] pattern [files...]"
 #define sed_full_usage \
 	"Options:\n" \
 	"\t-n\t\tsuppress automatic printing of pattern space\n" \
 	"\t-e script\tadd the script to the commands to be executed\n" \
 	"\t-f scriptfile\tadd the contents of script-file to the commands to be executed\n" \
 	"\t-h\t\tdisplay this help message\n" \
 	"\n" \
 	"If no -e or -f is given, the first non-option argument is taken as the\n" \
 	"sed script to interpret. All remaining arguments are names of input\n" \
 	"files; if no input files are specified, then the standard input is read."
 #define sed_example_usage \
 	"$ echo "foo" | sed -e 's/f[a-zA-Z]o/bar/g'\n" \
 	"bar\n"
 
 #define setkeycodes_trivial_usage \
 	"SCANCODE KEYCODE ..."
 #define setkeycodes_full_usage \
 	"Set entries into the kernel's scancode-to-keycode map,\n" \
 	"allowing unusual keyboards to generate usable keycodes.\n\n" \
 	"SCANCODE may be either xx or e0xx (hexadecimal),\n" \
 	"and KEYCODE is given in decimal"
 #define setkeycodes_example_usage \
 	"$ setkeycodes e030 127\n"
 
 #define sh_trivial_usage \
 	"[FILE]...\n" \
 	"or: sh -c command [args]..."
 #define sh_full_usage \
 	"lash: The BusyBox LAme SHell (command interpreter)"
 #define sh_notes_usage \
 "This command does not yet have proper documentation.\n" \
 "\n" \
 "Use lash just as you would use any other shell.  It properly handles pipes,\n" \
 "redirects, job control, can be used as the shell for scripts, and has a\n" \
 "sufficient set of builtins to do what is needed.  It does not (yet) support\n" \
 "Bourne Shell syntax.  If you need things like "if-then-else", "while", and such\n" \
 "use ash or bash.  If you just need a very simple and extremely small shell,\n" \
 "this will do the job."
 
 #define sleep_trivial_usage \
 	"N"
 #define sleep_full_usage \
 	"Pause for N seconds."
 #define sleep_example_usage \
 	"$ sleep 2\n" \
 	"[2 second delay results]\n"
 
 
 #ifdef BB_FEATURE_SORT_UNIQUE
   #define USAGE_SORT_UNIQUE(a) a
 #else
   #define USAGE_SORT_UNIQUE(a)
 #endif
 #ifdef BB_FEATURE_SORT_REVERSE
   #define USAGE_SORT_REVERSE(a) a
 #else
   #define USAGE_SORT_REVERSE(a)
 #endif
 #define sort_trivial_usage \
 	"[-n" USAGE_SORT_REVERSE("r") USAGE_SORT_UNIQUE("u") "] [FILE]..."
 #define sort_full_usage \
 	"Sorts lines of text in the specified files\n\n"\
 	"Options:\n" \
 	USAGE_SORT_UNIQUE("\t-u\tsuppress duplicate lines\n") \
 	USAGE_SORT_REVERSE("\t-r\tsort in reverse order\n") \
 	"\t-n\tsort numerics"
 #define sort_example_usage \
 	"$ echo -e \"e\\nf\\nb\\nd\\nc\\na\" | sort\n" \
 	"a\n" \
 	"b\n" \
 	"c\n" \
 	"d\n" \
 	"e\n" \
 	"f\n"
 
 #define stty_trivial_usage \
 	"[-a|g] [-F DEVICE] [SETTING]..."
 #define stty_full_usage \
 	"Without arguments, prints baud rate, line discipline," \
 	"\nand deviations from stty sane." \
 	"\n\nOptions:" \
 	"\n\t-F DEVICE\topen device instead of stdin" \
 	"\n\t-a\t\tprint all current settings in human-readable form" \
 	"\n\t-g\t\tprint in stty-readable form" \
 	"\n\t[SETTING]\tsee manpage"
 
 #define swapoff_trivial_usage \
 	"[OPTION] [DEVICE]"
 #define swapoff_full_usage \
 	"Stop swapping virtual memory pages on DEVICE.\n\n" \
 	"Options:\n" \
 	"\t-a\tStop swapping on all swap devices"
 
 #define swapon_trivial_usage \
 	"[OPTION] [DEVICE]"
 #define swapon_full_usage \
 	"Start swapping virtual memory pages on DEVICE.\n\n" \
 	"Options:\n" \
 	"\t-a\tStart swapping on all swap devices"
 
 #define sync_trivial_usage \
 	""
 #define sync_full_usage \
 	"Write all buffered filesystem blocks to disk."
 
 
 #ifdef BB_FEATURE_REMOTE_LOG
   #define USAGE_REMOTE_LOG(a) a
 #else
   #define USAGE_REMOTE_LOG(a)
 #endif
 #define syslogd_trivial_usage \
 	"[OPTION]..."
 #define syslogd_full_usage \
 	"Linux system and kernel logging utility.\n" \
 	"Note that this version of syslogd ignores /etc/syslog.conf.\n\n" \
 	"Options:\n" \
 	"\t-m NUM\t\tInterval between MARK lines (default=20min, 0=off)\n" \
 	"\t-n\t\tRun as a foreground process\n" \
 	"\t-O FILE\t\tUse an alternate log file (default=/var/log/messages)" \
 	USAGE_REMOTE_LOG( \
 	"\n\t-R HOST[:PORT]\tLog to IP or hostname on PORT (default PORT=514/UDP)\n" \
 	"\t-L\t\tLog locally and via network logging (default is network only)")
 #define syslogd_example_usage \
 	"$ syslogd -R masterlog:514\n" \
 	"$ syslogd -R 192.168.1.1:601\n"
 
 
-#ifdef BB_FEATURE_SIMPLE_TAIL
+#ifndef BB_FEATURE_FANCY_TAIL
   #define USAGE_UNSIMPLE_TAIL(a)
 #else
   #define USAGE_UNSIMPLE_TAIL(a) a
 #endif
 #define tail_trivial_usage \
 	"[OPTION]... [FILE]..."
 #define tail_full_usage \
 	"Print last 10 lines of each FILE to standard output.\n" \
 	"With more than one FILE, precede each with a header giving the\n" \
 	"file name. With no FILE, or when FILE is -, read standard input.\n\n" \
 	"Options:\n" \
 	USAGE_UNSIMPLE_TAIL("\t-c N[kbm]\toutput the last N bytes\n") \
 	"\t-n N[kbm]\tprint last N lines instead of last 10\n" \
 	"\t-f\t\toutput data as the file grows" \
 	USAGE_UNSIMPLE_TAIL( "\n\t-q\t\tnever output headers giving file names\n" \
 	"\t-s SEC\t\twait SEC seconds between reads with -f\n" \
 	"\t-v\t\talways output headers giving file names\n\n" \
 	"If the first character of N (bytes or lines) is a '+', output begins with \n" \
 	"the Nth item from the start of each file, otherwise, print the last N items\n" \
 	"in the file. N bytes may be suffixed by k (x1024), b (x512), or m (1024^2)." )
 #define tail_example_usage \
 	"$ tail -n 1 /etc/resolv.conf\n" \
 	"nameserver 10.0.0.1\n"
 
 #ifdef BB_FEATURE_TAR_CREATE
   #define USAGE_TAR_CREATE(a) a
 #else
   #define USAGE_TAR_CREATE(a)
 #endif
 #ifdef BB_FEATURE_TAR_EXCLUDE
   #define USAGE_TAR_EXCLUDE(a) a
 #else
   #define USAGE_TAR_EXCLUDE(a)
 #endif
 #define tar_trivial_usage \
 	"-[" USAGE_TAR_CREATE("c") "xtvO] " \
 	USAGE_TAR_EXCLUDE("[--exclude FILE] [-X FILE]") \
 	"[-f TARFILE] [FILE(s)] ..."
 #define tar_full_usage \
 	"Create, extract, or list files from a tar file.\n\n" \
 	"Main operation mode:\n" \
 	USAGE_TAR_CREATE("\tc\t\tcreate\n") \
 	"\tx\t\textract\n" \
 	"\tt\t\tlist\n" \
 	"\nFile selection:\n" \
 	"\tf\t\tname of TARFILE or \"-\" for stdin\n" \
 	"\tO\t\textract to stdout\n" \
 	USAGE_TAR_EXCLUDE( \
 	"\texclude\t\tfile to exclude\n" \
 	 "\tX\t\tfile with names to exclude\n" \
 	) \
 	"\nInformative output:\n" \
 	"\tv\t\tverbosely list files processed"
 #define tar_example_usage \
 	"$ zcat /tmp/tarball.tar.gz | tar -xf -\n" \
 	"$ tar -cf /tmp/tarball.tar /usr/local\n"
 
 #define tee_trivial_usage \
 	"[OPTION]... [FILE]..."
 #define tee_full_usage \
 	"Copy standard input to each FILE, and also to standard output.\n\n" \
 	"Options:\n" \
 	"\t-a\tappend to the given FILEs, do not overwrite"
 #define tee_example_usage \
 	"$ echo "Hello" | tee /tmp/foo\n" \
 	"$ cat /tmp/foo\n" \
 	"Hello\n"
 
 #define telnet_trivial_usage \
 	"HOST [PORT]"
 #define telnet_full_usage \
 	"Telnet is used to establish interactive communication with another\n"\
 	"computer over a network using the TELNET protocol."
 
 #define test_trivial_usage \
 	"EXPRESSION\n  or   [ EXPRESSION ]"
 #define test_full_usage \
 	"Checks file types and compares values returning an exit\n" \
 	"code determined by the value of EXPRESSION."
 #define test_example_usage \
 	"$ test 1 -eq 2\n" \
 	"$ echo $?\n" \
 	"1\n" \
 	"$ test 1 -eq 1\n" \
 	"$ echo $? \n" \
 	"0\n" \
 	"$ [ -d /etc ]\n" \
 	"$ echo $?\n" \
 	"0\n" \
 	"$ [ -d /junk ]\n" \
 	"$ echo $?\n" \
 	"1\n"
 
 #ifdef BB_FEATURE_TFTP_GET
   #define USAGE_TFTP_GET(a) a
 #else
   #define USAGE_TFTP_GET(a)
 #endif
 #ifdef BB_FEATURE_TFTP_PUT
   #define USAGE_TFTP_PUT(a) a
 #else
   #define USAGE_TFTP_PUT(a)
 #endif
 
 #define tftp_trivial_usage \
 	"command SOURCE DEST"
 #define tftp_full_usage \
 	"Transfers a file from/to a tftp server using \"octet\" mode.\n\n" \
 	"Commands:\n" \
         USAGE_TFTP_GET(	\
         "\tget\tGet file from server SOURCE and store to local DEST.\n" \
         ) \
         USAGE_TFTP_PUT(	\
 	"\tput\tPut local file SOURCE to server DEST.\n" \
 	) \
 	"\nWhen naming a server, use the syntax \"server:file\"."
 
 #define touch_trivial_usage \
 	"[-c] FILE [FILE ...]"
 #define touch_full_usage \
 	"Update the last-modified date on the given FILE[s].\n\n" \
 	"Options:\n" \
 	"\t-c\tDo not create any files"
 #define touch_example_usage \
 	"$ ls -l /tmp/foo\n" \
 	"/bin/ls: /tmp/foo: No such file or directory\n" \
 	"$ touch /tmp/foo\n" \
 	"$ ls -l /tmp/foo\n" \
 	"-rw-rw-r--    1 andersen andersen        0 Apr 15 01:11 /tmp/foo\n" 
 
 #define tr_trivial_usage \
 	"[-cds] STRING1 [STRING2]"
 #define tr_full_usage \
 	"Translate, squeeze, and/or delete characters from\n" \
 	"standard input, writing to standard output.\n\n" \
 	"Options:\n" \
 	"\t-c\ttake complement of STRING1\n" \
 	"\t-d\tdelete input characters coded STRING1\n" \
 	"\t-s\tsqueeze multiple output characters of STRING2 into one character"
 #define tr_example_usage \
 	"$ echo "gdkkn vnqkc" | tr [a-y] [b-z]\n" \
 	"hello world\n" 
 
 #define true_trivial_usage \
 	""
 #define true_full_usage \
 	"Return an exit code of TRUE (0)."
 #define true_example_usage \
 	"$ true\n" \
 	"$ echo $?\n" \
 	"0\n"
 
 #define tty_trivial_usage \
 	""
 #define tty_full_usage \
 	"Print the file name of the terminal connected to standard input.\n\n"\
 	"Options:\n" \
 	"\t-s\tprint nothing, only return an exit status"
 #define tty_example_usage \
 	"$ tty\n" \
 	"/dev/tty2\n"
 
 #ifdef BB_FEATURE_MOUNT_FORCE
   #define USAGE_MOUNT_FORCE(a) a
 #else
   #define USAGE_MOUNT_FORCE(a)
 #endif
 #define umount_trivial_usage \
 	"[flags] FILESYSTEM|DIRECTORY"
 #define umount_full_usage \
 	"Unmount file systems\n" \
 	"\nFlags:\n" "\t-a\tUnmount all file systems" \
 	USAGE_MTAB(" in /etc/mtab\n\t-n\tDon't erase /etc/mtab entries") \
 	"\n\t-r\tTry to remount devices as read-only if mount is busy" \
 	USAGE_MOUNT_FORCE("\n\t-f\tForce umount (i.e. unreachable NFS server)") \
 	USAGE_MOUNT_LOOP("\n\t-l\tDo not free loop device (if a loop device has been used)")
 #define umount_example_usage \
 	"$ umount /dev/hdc1 \n"
 
 #define uname_trivial_usage \
 	"[OPTION]..."
 #define uname_full_usage \
 	"Print certain system information.  With no OPTION, same as -s.\n\n" \
 	"Options:\n" \
 	"\t-a\tprint all information\n" \
 	"\t-m\tthe machine (hardware) type\n" \
 	"\t-n\tprint the machine's network node hostname\n" \
 	"\t-r\tprint the operating system release\n" \
 	"\t-s\tprint the operating system name\n" \
 	"\t-p\tprint the host processor type\n" \
 	"\t-v\tprint the operating system version"
 #define uname_example_usage \
 	"$ uname -a\n" \
 	"Linux debian 2.2.15pre13 #5 Tue Mar 14 16:03:50 MST 2000 i686 unknown\n" 
 
 #define uniq_trivial_usage \
 	"[OPTION]... [INPUT [OUTPUT]]"
 #define uniq_full_usage \
 	"Discard all but one of successive identical lines from INPUT\n" \
 	"(or standard input), writing to OUTPUT (or standard output).\n\n" \
 	"Options:\n" \
 	"\t-c\tprefix lines by the number of occurrences\n" \
 	"\t-d\tonly print duplicate lines\n" \
 	"\t-u\tonly print unique lines"
 #define uniq_example_usage \
 	"$ echo -e \"a\\na\\nb\\nc\\nc\\na\" | sort | uniq\n" \
 	"a\n" \
 	"b\n" \
 	"c\n"
 
 #define unix2dos_trivial_usage \
 	"[option] [FILE]"
 #define unix2dos_full_usage \
 	"Converts FILE from unix format to dos format.  When no option\n" \
 	"is given, the input is converted to the opposite output format.\n" \
 	"When no file is given, uses stdin for input and stdout for output." \
 	"Options:\n" \
 	"\t-u\toutput will be in UNIX format\n" \
 	"\t-d\toutput will be in DOS format\n\n" \
 
 #define update_trivial_usage \
 	"[options]"
 #define update_full_usage \
 	"Periodically flushes filesystem buffers.\n\n" \
 	"Options:\n" \
 	"\t-S\tforce use of sync(2) instead of flushing\n" \
 	"\t-s SECS\tcall sync this often (default 30)\n" \
 	"\t-f SECS\tflush some buffers this often (default 5)"
 
 #define uptime_trivial_usage \
 	""
 #define uptime_full_usage \
 	"Display the time since the last boot."
 #define uptime_example_usage \
 	"$ uptime\n" \
 	"  1:55pm  up  2:30, load average: 0.09, 0.04, 0.00\n" 
 
 #define usleep_trivial_usage \
 	"N" 
 #define usleep_full_usage \
 	"Pause for N microseconds."
 #define usleep_example_usage \
 	"$ usleep 1000000\n" \
 	"[pauses for 1 second]\n"
 
 #define uudecode_trivial_usage \
 	"[FILE]..."
 #define uudecode_full_usage \
 	"Uudecode a file that is uuencoded.\n\n" \
 	"Options:\n" \
 	"\t-o FILE\tdirect output to FILE" 
 #define uudecode_example_usage \
 	"$ uudecode -o busybox busybox.uu\n" \
 	"$ ls -l busybox\n" \
 	"-rwxr-xr-x   1 ams      ams        245264 Jun  7 21:35 busybox\n" 
 
 #define uuencode_trivial_usage \
 	"[OPTION] [INFILE] REMOTEFILE"
 #define uuencode_full_usage \
 	"Uuencode a file.\n\n" \
 	"Options:\n" \
 	"\t-m\tuse base64 encoding per RFC1521"
 #define uuencode_example_usage \
 	"$ uuencode busybox busybox\n" \
 	"begin 755 busybox\n" \
 	"<encoded file snipped>\n" \
 	"$ uudecode busybox busybox > busybox.uu\n" \
 	"$\n"
 
 #define vi_trivial_usage \
 	"[OPTION] [FILE]..."
 #define vi_full_usage \
 	"edit FILE.\n\n" \
 	"Options:\n" \
 	"\t-R\tRead-only- do not write to the file." 
 
 #define watchdog_trivial_usage \
 	"DEV"
 #define watchdog_full_usage \
 	"Periodically write to watchdog device DEV"
 
 #define wc_trivial_usage \
 	"[OPTION]... [FILE]..."
 #define wc_full_usage \
 	"Print line, word, and byte counts for each FILE, and a total line if\n" \
 	"more than one FILE is specified.  With no FILE, read standard input.\n\n" \
 	"Options:\n" \
 	"\t-c\tprint the byte counts\n" \
 	"\t-l\tprint the newline counts\n" \
 	"\t-L\tprint the length of the longest line\n" \
 	"\t-w\tprint the word counts"
 #define wc_example_usage \
 	"$ wc /etc/passwd\n" \
 	"     31      46    1365 /etc/passwd\n" 
 
 #define wget_trivial_usage \
 	"[-c|--continue] [-q|--quiet] [-O|--output-document file] [--header 'header: value'] url"
 #define wget_full_usage \
 	"wget retrieves files via HTTP or FTP\n\n" \
 	"Options:\n" \
 	"\t-c\tcontinue retrieval of aborted transfers\n" \
 	"\t-q\tquiet mode - do not print\n" \
 	"\t-O\tsave to filename ('-' for stdout)"
 
 #define which_trivial_usage \
 	"[COMMAND ...]"
 #define which_full_usage \
 	"Locates a COMMAND."
 #define which_example_usage \
 	"$ which login\n" \
 	"/bin/login\n"
 
 #define whoami_trivial_usage \
 	""
 #define whoami_full_usage \
 	"Prints the user name associated with the current effective user id."
 
 #define xargs_trivial_usage \
 	"[COMMAND] [ARGS...]"
 #define xargs_full_usage \
 	"Executes COMMAND on every item given by standard input."
 #define xargs_example_usage \
 	"$ ls | xargs gzip\n" \
 	"$ find . -name '*.c' -print | xargs rm\n" 
 
 #define yes_trivial_usage \
 	"[OPTION]... [STRING]..."
 #define yes_full_usage \
 	"Repeatedly outputs a line with all specified STRING(s), or 'y'."
 
 #define zcat_trivial_usage \
 	"FILE"
 #define zcat_full_usage \
 	"Uncompress to stdout."
diff --git a/cmdedit.c b/cmdedit.c
index cc39e56..a877231 100644
--- a/cmdedit.c
+++ b/cmdedit.c
@@ -1,1546 +1,1546 @@
 /* vi: set sw=4 ts=4: */
 /*
  * Termios command line History and Editting.
  *
  * Copyright (c) 1986-2001 may safely be consumed by a BSD or GPL license.
  * Written by:   Vladimir Oleynik <vodz@usa.net>
  *
  * Used ideas:
  *      Adam Rogoyski    <rogoyski@cs.utexas.edu>
  *      Dave Cinege      <dcinege@psychosis.com>
  *      Jakub Jelinek (c) 1995
  *      Erik Andersen    <andersee@debian.org> (Majorly adjusted for busybox)
  *
  * This code is 'as is' with no warranty.
  *
  *
  */
 
 /*
    Usage and Known bugs:
    Terminal key codes are not extensive, and more will probably
    need to be added. This version was created on Debian GNU/Linux 2.x.
    Delete, Backspace, Home, End, and the arrow keys were tested
    to work in an Xterm and console. Ctrl-A also works as Home.
    Ctrl-E also works as End.
 
    Small bugs (simple effect):
    - not true viewing if terminal size (x*y symbols) less
      size (prompt + editor`s line + 2 symbols)
    - not true viewing if length prompt less terminal width
  */
 
 
 #include <stdio.h>
 #include <errno.h>
 #include <unistd.h>
 #include <stdlib.h>
 #include <string.h>
 #include <sys/ioctl.h>
 #include <ctype.h>
 #include <signal.h>
 #include <limits.h>
 
 #include "busybox.h"
 
 #ifdef BB_LOCALE_SUPPORT
 #define Isprint(c) isprint((c))
 #else
 #define Isprint(c) ( (c) >= ' ' && (c) != ((unsigned char)'\233') )
 #endif
 
 #ifndef TEST
 
 #define D(x)
 
 #else
 
 #define BB_FEATURE_COMMAND_EDITING
 #define BB_FEATURE_COMMAND_TAB_COMPLETION
 #define BB_FEATURE_COMMAND_USERNAME_COMPLETION
 #define BB_FEATURE_NONPRINTABLE_INVERSE_PUT
 #define BB_FEATURE_CLEAN_UP
 
 #define D(x)  x
 
 #endif							/* TEST */
 
 #ifdef BB_FEATURE_COMMAND_TAB_COMPLETION
 #include <dirent.h>
 #include <sys/stat.h>
 #endif
 
 #ifdef BB_FEATURE_COMMAND_EDITING
 
 #ifndef BB_FEATURE_COMMAND_TAB_COMPLETION
 #undef  BB_FEATURE_COMMAND_USERNAME_COMPLETION
 #endif
 
-#if defined(BB_FEATURE_COMMAND_USERNAME_COMPLETION) || !defined(BB_FEATURE_SH_SIMPLE_PROMPT)
+#if defined(BB_FEATURE_COMMAND_USERNAME_COMPLETION) || defined(BB_FEATURE_SH_FANCY_PROMPT)
 #define BB_FEATURE_GETUSERNAME_AND_HOMEDIR
 #endif
 
 #ifdef BB_FEATURE_GETUSERNAME_AND_HOMEDIR
 #ifndef TEST
 #include "pwd_grp/pwd.h"
 #else
 #include <pwd.h>
 #endif							/* TEST */
 #endif							/* advanced FEATURES */
 
 
 
 struct history {
 	char *s;
 	struct history *p;
 	struct history *n;
 };
 
 /* Maximum length of the linked list for the command line history */
 static const int MAX_HISTORY = 15;
 
 /* First element in command line list */
 static struct history *his_front = NULL;
 
 /* Last element in command line list */
 static struct history *his_end = NULL;
 
 
 /* ED: sparc termios is broken: revert back to old termio handling. */
 
 #if #cpu(sparc)
 #      include <termio.h>
 #      define termios termio
 #      define setTermSettings(fd,argp) ioctl(fd,TCSETAF,argp)
 #      define getTermSettings(fd,argp) ioctl(fd,TCGETA,argp)
 #else
 #      include <termios.h>
 #      define setTermSettings(fd,argp) tcsetattr(fd,TCSANOW,argp)
 #      define getTermSettings(fd,argp) tcgetattr(fd, argp);
 #endif
 
 /* Current termio and the previous termio before starting sh */
 static struct termios initial_settings, new_settings;
 
 
 #ifndef _POSIX_VDISABLE
 #define _POSIX_VDISABLE '\0'
 #endif
 
 
 static
 volatile int cmdedit_termw = 80;	/* actual terminal width */
 static int history_counter = 0;	/* Number of commands in history list */
 static
 volatile int handlers_sets = 0;	/* Set next bites: */
 
 enum {
 	SET_ATEXIT = 1,		/* when atexit() has been called 
 				   and get euid,uid,gid to fast compare */
 	SET_TERM_HANDLERS = 2,	/* set many terminates signal handlers */
 	SET_WCHG_HANDLERS = 4,	/* winchg signal handler */
 	SET_RESET_TERM = 8,	/* if the terminal needs to be reset upon exit */
 };
 
 
 static int cmdedit_x;		/* real x terminal position */
 static int cmdedit_y;		/* pseudoreal y terminal position */
 static int cmdedit_prmt_len;	/* lenght prompt without colores string */
 
 static int cursor;		/* required global for signal handler */
 static int len;			/* --- "" - - "" - -"- --""-- --""--- */
 static char *command_ps;	/* --- "" - - "" - -"- --""-- --""--- */
 static
-#ifdef BB_FEATURE_SH_SIMPLE_PROMPT
+#ifndef BB_FEATURE_SH_FANCY_PROMPT
 	const
 #endif
 char *cmdedit_prompt;		/* --- "" - - "" - -"- --""-- --""--- */
 
 /* Link into lash to reset context to 0 on ^C and such */
 extern unsigned int shell_context;
 
 
 #ifdef BB_FEATURE_GETUSERNAME_AND_HOMEDIR
 static char *user_buf = "";
 static char *home_pwd_buf = "";
 static int my_euid;
 #endif
 
-#ifndef BB_FEATURE_SH_SIMPLE_PROMPT
+#ifdef BB_FEATURE_SH_FANCY_PROMPT
 static char *hostname_buf = "";
 static int num_ok_lines = 1;
 #endif
 
 
 #ifdef  BB_FEATURE_COMMAND_TAB_COMPLETION
 
 #ifndef BB_FEATURE_GETUSERNAME_AND_HOMEDIR
 static int my_euid;
 #endif
 
 static int my_uid;
 static int my_gid;
 
 #endif	/* BB_FEATURE_COMMAND_TAB_COMPLETION */
 
 
 static void cmdedit_setwidth(int w, int redraw_flg);
 
 static void win_changed(int nsig)
 {
 	struct winsize win = { 0, 0, 0, 0 };
 	static __sighandler_t previous_SIGWINCH_handler;	/* for reset */
 
 	/*   emulate      || signal call */
 	if (nsig == -SIGWINCH || nsig == SIGWINCH) {
 		ioctl(0, TIOCGWINSZ, &win);
 		if (win.ws_col > 0) {
 			cmdedit_setwidth(win.ws_col, nsig == SIGWINCH);
 		} 
 	}
 	/* Unix not all standart in recall signal */
 
 	if (nsig == -SIGWINCH)		/* save previous handler   */
 		previous_SIGWINCH_handler = signal(SIGWINCH, win_changed);
 	else if (nsig == SIGWINCH)	/* signaled called handler */
 		signal(SIGWINCH, win_changed);	/* set for next call       */
 	else						/* nsig == 0 */
 		/* set previous handler    */
 		signal(SIGWINCH, previous_SIGWINCH_handler);	/* reset    */
 }
 
 static void cmdedit_reset_term(void)
 {
 	if ((handlers_sets & SET_RESET_TERM) != 0) {
 /* sparc and other have broken termios support: use old termio handling. */
 		setTermSettings(fileno(stdin), (void *) &initial_settings);
 		handlers_sets &= ~SET_RESET_TERM;
 	}
 	if ((handlers_sets & SET_WCHG_HANDLERS) != 0) {
 		/* reset SIGWINCH handler to previous (default) */
 		win_changed(0);
 		handlers_sets &= ~SET_WCHG_HANDLERS;
 	}
 	fflush(stdout);
 #ifdef BB_FEATURE_CLEAN_UP
 	if (his_front) {
 		struct history *n;
 
 		while (his_front != his_end) {
 			n = his_front->n;
 			free(his_front->s);
 			free(his_front);
 			his_front = n;
 		}
 	}
 #endif
 }
 
 
 /* special for recount position for scroll and remove terminal margin effect */
 static void cmdedit_set_out_char(int next_char)
 {
 
 	int c = (int)((unsigned char) command_ps[cursor]);
 
 	if (c == 0)
 		c = ' ';	/* destroy end char? */
 #ifdef BB_FEATURE_NONPRINTABLE_INVERSE_PUT
 	if (!Isprint(c)) {	/* Inverse put non-printable characters */
 		if (c >= 128)
 			c -= 128;
 		if (c < ' ')
 			c += '@';
 		if (c == 127)
 			c = '?';
 		printf("\033[7m%c\033[0m", c);
 	} else
 #endif
 		putchar(c);
 	if (++cmdedit_x >= cmdedit_termw) {
 		/* terminal is scrolled down */
 		cmdedit_y++;
 		cmdedit_x = 0;
 
 		if (!next_char)
 			next_char = ' ';
 		/* destroy "(auto)margin" */
 		putchar(next_char);
 		putchar('\b');
 	}
 	cursor++;
 }
 
 /* Move to end line. Bonus: rewrite line from cursor */
 static void input_end(void)
 {
 	while (cursor < len)
 		cmdedit_set_out_char(0);
 }
 
 /* Go to the next line */
 static void goto_new_line(void)
 {
 	input_end();
 	if (cmdedit_x)
 		putchar('\n');
 }
 
 
 static inline void out1str(const char *s)
 {
 	fputs(s, stdout);
 }
 static inline void beep(void)
 {
 	putchar('\007');
 }
 
 /* Move back one charactor */
 /* special for slow terminal */
 static void input_backward(int num)
 {
 	if (num > cursor)
 		num = cursor;
 	cursor -= num;		/* new cursor (in command, not terminal) */
 
 	if (cmdedit_x >= num) {		/* no to up line */
 		cmdedit_x -= num;
 		if (num < 4)
 			while (num-- > 0)
 				putchar('\b');
 
 		else
 			printf("\033[%dD", num);
 	} else {
 		int count_y;
 
 		if (cmdedit_x) {
 			putchar('\r');		/* back to first terminal pos.  */
 			num -= cmdedit_x;	/* set previous backward        */
 		}
 		count_y = 1 + num / cmdedit_termw;
 		printf("\033[%dA", count_y);
 		cmdedit_y -= count_y;
 		/*  require  forward  after  uping   */
 		cmdedit_x = cmdedit_termw * count_y - num;
 		printf("\033[%dC", cmdedit_x);	/* set term cursor   */
 	}
 }
 
 static void put_prompt(void)
 {
 	out1str(cmdedit_prompt);
 	cmdedit_x = cmdedit_prmt_len;	/* count real x terminal position */
 	cursor = 0;
 }
 
-#ifdef BB_FEATURE_SH_SIMPLE_PROMPT
+#ifndef BB_FEATURE_SH_FANCY_PROMPT
 static void parse_prompt(const char *prmt_ptr)
 {
 	cmdedit_prompt = prmt_ptr;
 	cmdedit_prmt_len = strlen(prmt_ptr);
 	put_prompt();
 }
 #else
 static void parse_prompt(const char *prmt_ptr)
 {
 	int prmt_len = 0;
 	int sub_len = 0;
 	char  flg_not_length = '[';
 	char *prmt_mem_ptr = xcalloc(1, 1);
 	char *pwd_buf = xgetcwd(0);
 	char  buf2[PATH_MAX + 1];
 	char  buf[2];
 	char  c;
 	char *pbuf;
 
 	if (!pwd_buf) {
 		pwd_buf=unknown;
 	}
 
 	while (*prmt_ptr) {
 		pbuf    = buf;
 		pbuf[1] = 0;
 		c = *prmt_ptr++;
 		if (c == '\\') {
 			const char *cp = prmt_ptr;
 			int l;
 			
 			c = process_escape_sequence(&prmt_ptr);
 			if(prmt_ptr==cp) {
 			  if (*cp == 0)
 				break;
 			  c = *prmt_ptr++;
 			  switch (c) {
 #ifdef BB_FEATURE_GETUSERNAME_AND_HOMEDIR
 			  case 'u':
 				pbuf = user_buf;
 				break;
 #endif	
 			  case 'h':
 				pbuf = hostname_buf;
 				if (*pbuf == 0) {
 					pbuf = xcalloc(256, 1);
 					if (gethostname(pbuf, 255) < 0) {
 						strcpy(pbuf, "?");
 					} else {
 						char *s = strchr(pbuf, '.');
 
 						if (s)
 							*s = 0;
 					}
 					hostname_buf = pbuf;
 				}
 				break;
 			  case '$':
 				c = my_euid == 0 ? '#' : '$';
 				break;
 #ifdef BB_FEATURE_GETUSERNAME_AND_HOMEDIR
 			  case 'w':
 				pbuf = pwd_buf;
 				l = strlen(home_pwd_buf);
 				if (home_pwd_buf[0] != 0 &&
 				    strncmp(home_pwd_buf, pbuf, l) == 0 &&
 				    (pbuf[l]=='/' || pbuf[l]=='\0') &&
 				    strlen(pwd_buf+l)<PATH_MAX) {
 					pbuf = buf2;
 					*pbuf = '~';
 					strcpy(pbuf+1, pwd_buf+l);
 					}
 				break;
 #endif	
 			  case 'W':
 				pbuf = pwd_buf;
 				cp = strrchr(pbuf,'/');
 				if ( (cp != NULL) && (cp != pbuf) )
 					pbuf += (cp-pbuf)+1;
 				break;
 			  case '!':
 				snprintf(pbuf = buf2, sizeof(buf2), "%d", num_ok_lines);
 				break;
 			  case 'e': case 'E':     /* \e \E = \033 */
 				c = '\033';
 				break;
 			  case 'x': case 'X': 
 				for (l = 0; l < 3;) {
 					int h;
 					buf2[l++] = *prmt_ptr;
 					buf2[l] = 0;
 					h = strtol(buf2, &pbuf, 16);
 					if (h > UCHAR_MAX || (pbuf - buf2) < l) {
 						l--;
 						break;
 					}
 					prmt_ptr++;
 				}
 				buf2[l] = 0;
 				c = (char)strtol(buf2, 0, 16);
 				if(c==0)
 					c = '?';
 				pbuf = buf;
 				break;
 			  case '[': case ']':
 				if (c == flg_not_length) {
 					flg_not_length = flg_not_length == '[' ? ']' : '[';
 					continue;
 				}
 				break;
 			  }
 			} 
 		}
 		if(pbuf == buf)
 			*pbuf = c;
 		prmt_len += strlen(pbuf);
 		prmt_mem_ptr = strcat(xrealloc(prmt_mem_ptr, prmt_len+1), pbuf);
 		if (flg_not_length == ']')
 			sub_len++;
 	}
 	free(pwd_buf);
 	cmdedit_prompt = prmt_mem_ptr;
 	cmdedit_prmt_len = prmt_len - sub_len;
 	put_prompt();
 }
 #endif
 
 
 /* draw promt, editor line, and clear tail */
 static void redraw(int y, int back_cursor)
 {
 	if (y > 0)				/* up to start y */
 		printf("\033[%dA", y);
 	cmdedit_y = 0;				/* new quasireal y */
 	putchar('\r');
 	put_prompt();
 	input_end();				/* rewrite */
 	printf("\033[J");			/* destroy tail after cursor */
 	input_backward(back_cursor);
 }
 
 /* Delete the char in front of the cursor */
 static void input_delete(void)
 {
 	int j = cursor;
 
 	if (j == len)
 		return;
 
 	strcpy(command_ps + j, command_ps + j + 1);
 	len--;
 	input_end();			/* rewtite new line */
 	cmdedit_set_out_char(0);	/* destroy end char */
 	input_backward(cursor - j);	/* back to old pos cursor */
 }
 
 /* Delete the char in back of the cursor */
 static void input_backspace(void)
 {
 	if (cursor > 0) {
 		input_backward(1);
 		input_delete();
 	}
 }
 
 
 /* Move forward one charactor */
 static void input_forward(void)
 {
 	if (cursor < len)
 		cmdedit_set_out_char(command_ps[cursor + 1]);
 }
 
 
 static void clean_up_and_die(int sig)
 {
 	goto_new_line();
 	if (sig != SIGINT)
 		exit(EXIT_SUCCESS);	/* cmdedit_reset_term() called in atexit */
 	cmdedit_reset_term();
 }
 
 static void cmdedit_setwidth(int w, int redraw_flg)
 {
 	cmdedit_termw = cmdedit_prmt_len + 2;
 	if (w <= cmdedit_termw) {
 		cmdedit_termw = cmdedit_termw % w;
 	}
 	if (w > cmdedit_termw) {
 		cmdedit_termw = w;
 
 		if (redraw_flg) {
 			/* new y for current cursor */
 			int new_y = (cursor + cmdedit_prmt_len) / w;
 
 			/* redraw */
 			redraw((new_y >= cmdedit_y ? new_y : cmdedit_y), len - cursor);
 			fflush(stdout);
 		}
 	} 
 }
 
 extern void cmdedit_init(void)
 {
 	cmdedit_prmt_len = 0;
 	if ((handlers_sets & SET_WCHG_HANDLERS) == 0) {
 		/* emulate usage handler to set handler and call yours work */
 		win_changed(-SIGWINCH);
 		handlers_sets |= SET_WCHG_HANDLERS;
 	}
 
 	if ((handlers_sets & SET_ATEXIT) == 0) {
 #ifdef BB_FEATURE_GETUSERNAME_AND_HOMEDIR
 		struct passwd *entry;
 
 		my_euid = geteuid();
 		entry = getpwuid(my_euid);
 		if (entry) {
 			user_buf = xstrdup(entry->pw_name);
 			home_pwd_buf = xstrdup(entry->pw_dir);
 		}
 #endif
 
 #ifdef  BB_FEATURE_COMMAND_TAB_COMPLETION
 
 #ifndef BB_FEATURE_GETUSERNAME_AND_HOMEDIR
 		my_euid = geteuid();
 #endif
 		my_uid = getuid();
 		my_gid = getgid();
 #endif	/* BB_FEATURE_COMMAND_TAB_COMPLETION */
 		handlers_sets |= SET_ATEXIT;
 		atexit(cmdedit_reset_term);	/* be sure to do this only once */
 	}
 
 #if 0
 	if ((handlers_sets & SET_TERM_HANDLERS) == 0) {
 		signal(SIGKILL, clean_up_and_die);
 		signal(SIGINT, clean_up_and_die);
 		signal(SIGQUIT, clean_up_and_die);
 		signal(SIGTERM, clean_up_and_die);
 		handlers_sets |= SET_TERM_HANDLERS;
 	}
 #endif	
 
 }
 
 #ifdef BB_FEATURE_COMMAND_TAB_COMPLETION
 
 static int is_execute(const struct stat *st)
 {
 	if ((!my_euid && (st->st_mode & (S_IXUSR | S_IXGRP | S_IXOTH))) ||
 		(my_uid == st->st_uid && (st->st_mode & S_IXUSR)) ||
 		(my_gid == st->st_gid && (st->st_mode & S_IXGRP)) ||
 		(st->st_mode & S_IXOTH)) return TRUE;
 	return FALSE;
 }
 
 #ifdef BB_FEATURE_COMMAND_USERNAME_COMPLETION
 
 static char **username_tab_completion(char *ud, int *num_matches)
 {
 	struct passwd *entry;
 	int userlen;
 	char *temp;
 
 
 	ud++;				/* ~user/... to user/... */
 	userlen = strlen(ud);
 
 	if (num_matches == 0) {		/* "~/..." or "~user/..." */
 		char *sav_ud = ud - 1;
 		char *home = 0;
 
 		if (*ud == '/') {	/* "~/..."     */
 			home = home_pwd_buf;
 		} else {
 			/* "~user/..." */
 			temp = strchr(ud, '/');
 			*temp = 0;		/* ~user\0 */
 			entry = getpwnam(ud);
 			*temp = '/';		/* restore ~user/... */
 			ud = temp;
 			if (entry)
 				home = entry->pw_dir;
 		}
 		if (home) {
 			if ((userlen + strlen(home) + 1) < BUFSIZ) {
 				char temp2[BUFSIZ];	/* argument size */
 
 				/* /home/user/... */
 				sprintf(temp2, "%s%s", home, ud);
 				strcpy(sav_ud, temp2);
 			}
 		}
 		return 0;	/* void, result save to argument :-) */
 	} else {
 		/* "~[^/]*" */
 		char **matches = (char **) NULL;
 		int nm = 0;
 
 		setpwent();
 
 		while ((entry = getpwent()) != NULL) {
 			/* Null usernames should result in all users as possible completions. */
 			if ( /*!userlen || */ !strncmp(ud, entry->pw_name, userlen)) {
 
 				temp = xmalloc(3 + strlen(entry->pw_name));
 				sprintf(temp, "~%s/", entry->pw_name);
 				matches = xrealloc(matches, (nm + 1) * sizeof(char *));
 
 				matches[nm++] = temp;
 			}
 		}
 
 		endpwent();
 		(*num_matches) = nm;
 		return (matches);
 	}
 }
 #endif	/* BB_FEATURE_COMMAND_USERNAME_COMPLETION */
 
 enum {
 	FIND_EXE_ONLY = 0,
 	FIND_DIR_ONLY = 1,
 	FIND_FILE_ONLY = 2,
 };
 
 static int path_parse(char ***p, int flags)
 {
 	int npth;
 	char *tmp;
 	char *pth;
 
 	/* if not setenv PATH variable, to search cur dir "." */
 	if (flags != FIND_EXE_ONLY || (pth = getenv("PATH")) == 0 ||
 		/* PATH=<empty> or PATH=:<empty> */
 		*pth == 0 || (*pth == ':' && *(pth + 1) == 0)) {
 		return 1;
 	}
 
 	tmp = pth;
 	npth = 0;
 
 	for (;;) {
 		npth++;			/* count words is + 1 count ':' */
 		tmp = strchr(tmp, ':');
 		if (tmp) {
 			if (*++tmp == 0)
 				break;	/* :<empty> */
 		} else
 			break;
 	}
 
 	*p = xmalloc(npth * sizeof(char *));
 
 	tmp = pth;
 	(*p)[0] = xstrdup(tmp);
 	npth = 1;			/* count words is + 1 count ':' */
 
 	for (;;) {
 		tmp = strchr(tmp, ':');
 		if (tmp) {
 			(*p)[0][(tmp - pth)] = 0;	/* ':' -> '\0' */
 			if (*++tmp == 0)
 				break;			/* :<empty> */
 		} else
 			break;
 		(*p)[npth++] = &(*p)[0][(tmp - pth)];	/* p[next]=p[0][&'\0'+1] */
 	}
 
 	return npth;
 }
 
 static char *add_quote_for_spec_chars(char *found)
 {
 	int l = 0;
 	char *s = xmalloc((strlen(found) + 1) * 2);
 
 	while (*found) {
 		if (strchr(" `\"#$%^&*()=+{}[]:;\'|\\<>", *found))
 			s[l++] = '\\';
 		s[l++] = *found++;
 	}
 	s[l] = 0;
 	return s;
 }
 
 static char **exe_n_cwd_tab_completion(char *command, int *num_matches,
 					int type)
 {
 
 	char **matches = 0;
 	DIR *dir;
 	struct dirent *next;
 	char dirbuf[BUFSIZ];
 	int nm = *num_matches;
 	struct stat st;
 	char *path1[1];
 	char **paths = path1;
 	int npaths;
 	int i;
 	char *found;
 	char *pfind = strrchr(command, '/');
 
 	path1[0] = ".";
 
 	if (pfind == NULL) {
 		/* no dir, if flags==EXE_ONLY - get paths, else "." */
 		npaths = path_parse(&paths, type);
 		pfind = command;
 	} else {
 		/* with dir */
 		/* save for change */
 		strcpy(dirbuf, command);
 		/* set dir only */
 		dirbuf[(pfind - command) + 1] = 0;
 #ifdef BB_FEATURE_COMMAND_USERNAME_COMPLETION
 		if (dirbuf[0] == '~')	/* ~/... or ~user/... */
 			username_tab_completion(dirbuf, 0);
 #endif
 		/* "strip" dirname in command */
 		pfind++;
 
 		paths[0] = dirbuf;
 		npaths = 1;				/* only 1 dir */
 	}
 
 	for (i = 0; i < npaths; i++) {
 
 		dir = opendir(paths[i]);
 		if (!dir)			/* Don't print an error */
 			continue;
 
 		while ((next = readdir(dir)) != NULL) {
 			char *str_found = next->d_name;
 
 			/* matched ? */
 			if (strncmp(str_found, pfind, strlen(pfind)))
 				continue;
 			/* not see .name without .match */
 			if (*str_found == '.' && *pfind == 0) {
 				if (*paths[i] == '/' && paths[i][1] == 0
 					&& str_found[1] == 0) str_found = "";	/* only "/" */
 				else
 					continue;
 			}
 			found = concat_path_file(paths[i], str_found);
 			/* hmm, remover in progress? */
 			if (stat(found, &st) < 0) 
 				goto cont;
 			/* find with dirs ? */
 			if (paths[i] != dirbuf)
 				strcpy(found, next->d_name);	/* only name */
 			if (S_ISDIR(st.st_mode)) {
 				/* name is directory      */
 				str_found = found;
 				found = concat_path_file(found, "");
 				free(str_found);
 				str_found = add_quote_for_spec_chars(found);
 			} else {
 				/* not put found file if search only dirs for cd */
 				if (type == FIND_DIR_ONLY) 
 					goto cont;
 				str_found = add_quote_for_spec_chars(found);
 				if (type == FIND_FILE_ONLY ||
 					(type == FIND_EXE_ONLY && is_execute(&st) == TRUE))
 					strcat(str_found, " ");
 			}
 			/* Add it to the list */
 			matches = xrealloc(matches, (nm + 1) * sizeof(char *));
 
 			matches[nm++] = str_found;
 cont:
 			free(found);
 		}
 		closedir(dir);
 	}
 	if (paths != path1) {
 		free(paths[0]);			/* allocated memory only in first member */
 		free(paths);
 	}
 	*num_matches = nm;
 	return (matches);
 }
 
 static int match_compare(const void *a, const void *b)
 {
 	return strcmp(*(char **) a, *(char **) b);
 }
 
 
 
 #define QUOT    (UCHAR_MAX+1)
 
 #define collapse_pos(is, in) { \
 	memcpy(int_buf+is, int_buf+in, (BUFSIZ+1-is-in)*sizeof(int)); \
 	memcpy(pos_buf+is, pos_buf+in, (BUFSIZ+1-is-in)*sizeof(int)); }
 
 static int find_match(char *matchBuf, int *len_with_quotes)
 {
 	int i, j;
 	int command_mode;
 	int c, c2;
 	int int_buf[BUFSIZ + 1];
 	int pos_buf[BUFSIZ + 1];
 
 	/* set to integer dimension characters and own positions */
 	for (i = 0;; i++) {
 		int_buf[i] = (int) ((unsigned char) matchBuf[i]);
 		if (int_buf[i] == 0) {
 			pos_buf[i] = -1;	/* indicator end line */
 			break;
 		} else
 			pos_buf[i] = i;
 	}
 
 	/* mask \+symbol and convert '\t' to ' ' */
 	for (i = j = 0; matchBuf[i]; i++, j++)
 		if (matchBuf[i] == '\\') {
 			collapse_pos(j, j + 1);
 			int_buf[j] |= QUOT;
 			i++;
 #ifdef BB_FEATURE_NONPRINTABLE_INVERSE_PUT
 			if (matchBuf[i] == '\t')	/* algorithm equivalent */
 				int_buf[j] = ' ' | QUOT;
 #endif
 		}
 #ifdef BB_FEATURE_NONPRINTABLE_INVERSE_PUT
 		else if (matchBuf[i] == '\t')
 			int_buf[j] = ' ';
 #endif
 
 	/* mask "symbols" or 'symbols' */
 	c2 = 0;
 	for (i = 0; int_buf[i]; i++) {
 		c = int_buf[i];
 		if (c == '\'' || c == '"') {
 			if (c2 == 0)
 				c2 = c;
 			else {
 				if (c == c2)
 					c2 = 0;
 				else
 					int_buf[i] |= QUOT;
 			}
 		} else if (c2 != 0 && c != '$')
 			int_buf[i] |= QUOT;
 	}
 
 	/* skip commands with arguments if line have commands delimiters */
 	/* ';' ';;' '&' '|' '&&' '||' but `>&' `<&' `>|' */
 	for (i = 0; int_buf[i]; i++) {
 		c = int_buf[i];
 		c2 = int_buf[i + 1];
 		j = i ? int_buf[i - 1] : -1;
 		command_mode = 0;
 		if (c == ';' || c == '&' || c == '|') {
 			command_mode = 1 + (c == c2);
 			if (c == '&') {
 				if (j == '>' || j == '<')
 					command_mode = 0;
 			} else if (c == '|' && j == '>')
 				command_mode = 0;
 		}
 		if (command_mode) {
 			collapse_pos(0, i + command_mode);
 			i = -1;				/* hack incremet */
 		}
 	}
 	/* collapse `command...` */
 	for (i = 0; int_buf[i]; i++)
 		if (int_buf[i] == '`') {
 			for (j = i + 1; int_buf[j]; j++)
 				if (int_buf[j] == '`') {
 					collapse_pos(i, j + 1);
 					j = 0;
 					break;
 				}
 			if (j) {
 				/* not found close ` - command mode, collapse all previous */
 				collapse_pos(0, i + 1);
 				break;
 			} else
 				i--;			/* hack incremet */
 		}
 
 	/* collapse (command...(command...)...) or {command...{command...}...} */
 	c = 0;						/* "recursive" level */
 	c2 = 0;
 	for (i = 0; int_buf[i]; i++)
 		if (int_buf[i] == '(' || int_buf[i] == '{') {
 			if (int_buf[i] == '(')
 				c++;
 			else
 				c2++;
 			collapse_pos(0, i + 1);
 			i = -1;				/* hack incremet */
 		}
 	for (i = 0; pos_buf[i] >= 0 && (c > 0 || c2 > 0); i++)
 		if ((int_buf[i] == ')' && c > 0) || (int_buf[i] == '}' && c2 > 0)) {
 			if (int_buf[i] == ')')
 				c--;
 			else
 				c2--;
 			collapse_pos(0, i + 1);
 			i = -1;				/* hack incremet */
 		}
 
 	/* skip first not quote space */
 	for (i = 0; int_buf[i]; i++)
 		if (int_buf[i] != ' ')
 			break;
 	if (i)
 		collapse_pos(0, i);
 
 	/* set find mode for completion */
 	command_mode = FIND_EXE_ONLY;
 	for (i = 0; int_buf[i]; i++)
 		if (int_buf[i] == ' ' || int_buf[i] == '<' || int_buf[i] == '>') {
 			if (int_buf[i] == ' ' && command_mode == FIND_EXE_ONLY
 				&& matchBuf[pos_buf[0]]=='c'
 				&& matchBuf[pos_buf[1]]=='d' )
 				command_mode = FIND_DIR_ONLY;
 			else {
 				command_mode = FIND_FILE_ONLY;
 				break;
 			}
 		}
 	/* "strlen" */
 	for (i = 0; int_buf[i]; i++);
 	/* find last word */
 	for (--i; i >= 0; i--) {
 		c = int_buf[i];
 		if (c == ' ' || c == '<' || c == '>' || c == '|' || c == '&') {
 			collapse_pos(0, i + 1);
 			break;
 		}
 	}
 	/* skip first not quoted '\'' or '"' */
 	for (i = 0; int_buf[i] == '\'' || int_buf[i] == '"'; i++);
 	/* collapse quote or unquote // or /~ */
 	while ((int_buf[i] & ~QUOT) == '/' && 
 			((int_buf[i + 1] & ~QUOT) == '/'
 			 || (int_buf[i + 1] & ~QUOT) == '~')) {
 		i++;
 	}
 	if (i) {
 		collapse_pos(0, i);
 	}
 
 	/* set only match and destroy quotes */
 	j = 0;
 	for (i = 0; pos_buf[i] >= 0; i++) {
 		matchBuf[i] = matchBuf[pos_buf[i]];
 		j = pos_buf[i] + 1;
 	}
 	matchBuf[i] = 0;
 	/* old lenght matchBuf with quotes symbols */
 	*len_with_quotes = j ? j - pos_buf[0] : 0;
 
 	return command_mode;
 }
 
 
 static void input_tab(int *lastWasTab)
 {
 	/* Do TAB completion */
 	static int num_matches;
 	static char **matches;
 
 	if (lastWasTab == 0) {		/* free all memory */
 		if (matches) {
 			while (num_matches > 0)
 				free(matches[--num_matches]);
 			free(matches);
 			matches = (char **) NULL;
 		}
 		return;
 	}
 	if (*lastWasTab == FALSE) {
 
 		char *tmp;
 		int len_found;
 		char matchBuf[BUFSIZ];
 		int find_type;
 		int recalc_pos;
 
 		*lastWasTab = TRUE;		/* flop trigger */
 
 		/* Make a local copy of the string -- up
 		 * to the position of the cursor */
 		tmp = strncpy(matchBuf, command_ps, cursor);
 		tmp[cursor] = 0;
 
 		find_type = find_match(matchBuf, &recalc_pos);
 
 		/* Free up any memory already allocated */
 		input_tab(0);
 
 #ifdef BB_FEATURE_COMMAND_USERNAME_COMPLETION
 		/* If the word starts with `~' and there is no slash in the word,
 		 * then try completing this word as a username. */
 
 		if (matchBuf[0] == '~' && strchr(matchBuf, '/') == 0)
 			matches = username_tab_completion(matchBuf, &num_matches);
 #endif
 		/* Try to match any executable in our path and everything
 		 * in the current working directory that matches.  */
 		if (!matches)
 			matches =
 				exe_n_cwd_tab_completion(matchBuf, &num_matches,
 										 find_type);
 
 		/* Did we find exactly one match? */
 		if (!matches || num_matches > 1) {
 			char *tmp1;
 
 			beep();
 			if (!matches)
 				return;		/* not found */
 			/* sort */
 			qsort(matches, num_matches, sizeof(char *), match_compare);
 
 			/* find minimal match */
 			tmp = xstrdup(matches[0]);
 			for (tmp1 = tmp; *tmp1; tmp1++)
 				for (len_found = 1; len_found < num_matches; len_found++)
 					if (matches[len_found][(tmp1 - tmp)] != *tmp1) {
 						*tmp1 = 0;
 						break;
 					}
 			if (*tmp == 0) {	/* have unique */
 				free(tmp);
 				return;
 			}
 		} else {			/* one match */
 			tmp = matches[0];
 			/* for next completion current found */
 			*lastWasTab = FALSE;
 		}
 
 		len_found = strlen(tmp);
 		/* have space to placed match? */
 		if ((len_found - strlen(matchBuf) + len) < BUFSIZ) {
 
 			/* before word for match   */
 			command_ps[cursor - recalc_pos] = 0;
 			/* save   tail line        */
 			strcpy(matchBuf, command_ps + cursor);
 			/* add    match            */
 			strcat(command_ps, tmp);
 			/* add    tail             */
 			strcat(command_ps, matchBuf);
 			/* back to begin word for match    */
 			input_backward(recalc_pos);
 			/* new pos                         */
 			recalc_pos = cursor + len_found;
 			/* new len                         */
 			len = strlen(command_ps);
 			/* write out the matched command   */
 			input_end();
 			input_backward(cursor - recalc_pos);
 		}
 		if (tmp != matches[0])
 			free(tmp);
 	} else {
 		/* Ok -- the last char was a TAB.  Since they
 		 * just hit TAB again, print a list of all the
 		 * available choices... */
 		if (matches && num_matches > 0) {
 			int i, col, l;
 			int sav_cursor = cursor;	/* change goto_new_line() */
 
 			/* Go to the next line */
 			goto_new_line();
 			for (i = 0, col = 0; i < num_matches; i++) {
 				l = strlen(matches[i]);
 				if (l < 14)
 					l = 14;
 				printf("%-14s  ", matches[i]);
 				if ((l += 2) > 16)
 					while (l % 16) {
 						putchar(' ');
 						l++;
 					}
 				col += l;
 				col -= (col / cmdedit_termw) * cmdedit_termw;
 				if (col > 60 && matches[i + 1] != NULL) {
 					putchar('\n');
 					col = 0;
 				}
 			}
 			/* Go to the next line and rewrite */
 			putchar('\n');
 			redraw(0, len - sav_cursor);
 		}
 	}
 }
 #endif	/* BB_FEATURE_COMMAND_TAB_COMPLETION */
 
 static void get_previous_history(struct history **hp, struct history *p)
 {
 	if ((*hp)->s)
 		free((*hp)->s);
 	(*hp)->s = xstrdup(command_ps);
 	*hp = p;
 }
 
 static inline void get_next_history(struct history **hp)
 {
 	get_previous_history(hp, (*hp)->n);
 }
 
 enum {
 	ESC = 27,
 	DEL = 127,
 };
 
 
 /*
  * This function is used to grab a character buffer
  * from the input file descriptor and allows you to
  * a string with full command editing (sortof like
  * a mini readline).
  *
  * The following standard commands are not implemented:
  * ESC-b -- Move back one word
  * ESC-f -- Move forward one word
  * ESC-d -- Delete back one word
  * ESC-h -- Delete forward one word
  * CTL-t -- Transpose two characters
  *
  * Furthermore, the "vi" command editing keys are not implemented.
  *
  */
  
 extern void cmdedit_read_input(char *prompt, char command[BUFSIZ])
 {
 
 	int inputFd = fileno(stdin);
 
 	int break_out = 0;
 	int lastWasTab = FALSE;
 	unsigned char c = 0;
 	struct history *hp = his_end;
 
 	/* prepare before init handlers */
 	cmdedit_y = 0;	/* quasireal y, not true work if line > xt*yt */
 	len = 0;
 	command_ps = command;
 
 	if (new_settings.c_cc[VMIN] == 0) {	/* first call */
 
 		getTermSettings(inputFd, (void *) &initial_settings);
 		memcpy(&new_settings, &initial_settings, sizeof(struct termios));
 
 		new_settings.c_cc[VMIN] = 1;
 		new_settings.c_cc[VTIME] = 0;
 		/* Turn off CTRL-C, so we can trap it */
 		new_settings.c_cc[VINTR] = _POSIX_VDISABLE;	
 		new_settings.c_lflag &= ~ICANON;	/* unbuffered input */
 		/* Turn off echoing */
 		new_settings.c_lflag &= ~(ECHO | ECHOCTL | ECHONL);	
 	}
 
 	command[0] = 0;
 
 	setTermSettings(inputFd, (void *) &new_settings);
 	handlers_sets |= SET_RESET_TERM;
 
 	/* Now initialize things */
 	cmdedit_init();
 	/* Print out the command prompt */
 	parse_prompt(prompt);
 
 	while (1) {
 
 		fflush(stdout);			/* buffered out to fast */
 
 		if (read(inputFd, &c, 1) < 1)
 			/* if we can't read input then exit */
 			goto prepare_to_die;
 
 		switch (c) {
 		case '\n':
 		case '\r':
 			/* Enter */
 			goto_new_line();
 			break_out = 1;
 			break;
 		case 1:
 			/* Control-a -- Beginning of line */
 			input_backward(cursor);
 			break;
 		case 2:
 			/* Control-b -- Move back one character */
 			input_backward(1);
 			break;
 		case 3:
 			/* Control-c -- stop gathering input */
 
 			/* Link into lash to reset context to 0 on ^C and such */
 			shell_context = 0;
 
 			/* Go to the next line */
 			goto_new_line();
 			command[0] = 0;
 
 			return;
 		case 4:
 			/* Control-d -- Delete one character, or exit
 			 * if the len=0 and no chars to delete */
 			if (len == 0) {
 prepare_to_die:
 				printf("exit");
 				clean_up_and_die(0);
 			} else {
 				input_delete();
 			}
 			break;
 		case 5:
 			/* Control-e -- End of line */
 			input_end();
 			break;
 		case 6:
 			/* Control-f -- Move forward one character */
 			input_forward();
 			break;
 		case '\b':
 		case DEL:
 			/* Control-h and DEL */
 			input_backspace();
 			break;
 		case '\t':
 #ifdef BB_FEATURE_COMMAND_TAB_COMPLETION
 			input_tab(&lastWasTab);
 #endif
 			break;
 		case 14:
 			/* Control-n -- Get next command in history */
 			if (hp && hp->n && hp->n->s) {
 				get_next_history(&hp);
 				goto rewrite_line;
 			} else {
 				beep();
 			}
 			break;
 		case 16:
 			/* Control-p -- Get previous command from history */
 			if (hp && hp->p) {
 				get_previous_history(&hp, hp->p);
 				goto rewrite_line;
 			} else {
 				beep();
 			}
 			break;
 		case 21:
 			/* Control-U -- Clear line before cursor */
 			if (cursor) {
 				strcpy(command, command + cursor);
 				redraw(cmdedit_y, len -= cursor);
 			}
 			break;
 
 		case ESC:{
 			/* escape sequence follows */
 			if (read(inputFd, &c, 1) < 1)
 				return;
 			/* different vt100 emulations */
 			if (c == '[' || c == 'O') {
 				if (read(inputFd, &c, 1) < 1)
 					return;
 			}
 			switch (c) {
 #ifdef BB_FEATURE_COMMAND_TAB_COMPLETION
 			case '\t':			/* Alt-Tab */
 
 				input_tab(&lastWasTab);
 				break;
 #endif
 			case 'A':
 				/* Up Arrow -- Get previous command from history */
 				if (hp && hp->p) {
 					get_previous_history(&hp, hp->p);
 					goto rewrite_line;
 				} else {
 					beep();
 				}
 				break;
 			case 'B':
 				/* Down Arrow -- Get next command in history */
 				if (hp && hp->n && hp->n->s) {
 					get_next_history(&hp);
 					goto rewrite_line;
 				} else {
 					beep();
 				}
 				break;
 
 				/* Rewrite the line with the selected history item */
 			  rewrite_line:
 				/* change command */
 				len = strlen(strcpy(command, hp->s));
 				/* redraw and go to end line */
 				redraw(cmdedit_y, 0);
 				break;
 			case 'C':
 				/* Right Arrow -- Move forward one character */
 				input_forward();
 				break;
 			case 'D':
 				/* Left Arrow -- Move back one character */
 				input_backward(1);
 				break;
 			case '3':
 				/* Delete */
 				input_delete();
 				break;
 			case '1':
 			case 'H':
 				/* Home (Ctrl-A) */
 				input_backward(cursor);
 				break;
 			case '4':
 			case 'F':
 				/* End (Ctrl-E) */
 				input_end();
 				break;
 			default:
 				if (!(c >= '1' && c <= '9'))
 					c = 0;
 				beep();
 			}
 			if (c >= '1' && c <= '9')
 				do
 					if (read(inputFd, &c, 1) < 1)
 						return;
 				while (c != '~');
 			break;
 		}
 
 		default:	/* If it's regular input, do the normal thing */
 #ifdef BB_FEATURE_NONPRINTABLE_INVERSE_PUT
 			/* Control-V -- Add non-printable symbol */
 			if (c == 22) {
 				if (read(inputFd, &c, 1) < 1)
 					return;
 				if (c == 0) {
 					beep();
 					break;
 				}
 			} else
 #endif
 			if (!Isprint(c))	/* Skip non-printable characters */
 				break;
 
 			if (len >= (BUFSIZ - 2))	/* Need to leave space for enter */
 				break;
 
 			len++;
 
 			if (cursor == (len - 1)) {	/* Append if at the end of the line */
 				*(command + cursor) = c;
 				*(command + cursor + 1) = 0;
 				cmdedit_set_out_char(0);
 			} else {			/* Insert otherwise */
 				int sc = cursor;
 
 				memmove(command + sc + 1, command + sc, len - sc);
 				*(command + sc) = c;
 				sc++;
 				/* rewrite from cursor */
 				input_end();
 				/* to prev x pos + 1 */
 				input_backward(cursor - sc);
 			}
 
 			break;
 		}
 		if (break_out)			/* Enter is the command terminator, no more input. */
 			break;
 
 		if (c != '\t')
 			lastWasTab = FALSE;
 	}
 
 	setTermSettings(inputFd, (void *) &initial_settings);
 	handlers_sets &= ~SET_RESET_TERM;
 
 	/* Handle command history log */
 	if (len) {					/* no put empty line */
 
 		struct history *h = his_end;
 		char *ss;
 
 		ss = xstrdup(command);	/* duplicate */
 
 		if (h == 0) {
 			/* No previous history -- this memory is never freed */
 			h = his_front = xmalloc(sizeof(struct history));
 			h->n = xmalloc(sizeof(struct history));
 
 			h->p = NULL;
 			h->s = ss;
 			h->n->p = h;
 			h->n->n = NULL;
 			h->n->s = NULL;
 			his_end = h->n;
 			history_counter++;
 		} else {
 			/* Add a new history command -- this memory is never freed */
 			h->n = xmalloc(sizeof(struct history));
 
 			h->n->p = h;
 			h->n->n = NULL;
 			h->n->s = NULL;
 			h->s = ss;
 			his_end = h->n;
 
 			/* After max history, remove the oldest command */
 			if (history_counter >= MAX_HISTORY) {
 
 				struct history *p = his_front->n;
 
 				p->p = NULL;
 				free(his_front->s);
 				free(his_front);
 				his_front = p;
 			} else {
 				history_counter++;
 			}
 		}
-#if !defined(BB_FEATURE_SH_SIMPLE_PROMPT)
+#if defined(BB_FEATURE_SH_FANCY_PROMPT)
 		num_ok_lines++;
 #endif
 	}
 	command[len++] = '\n';		/* set '\n' */
 	command[len] = 0;
 #if defined(BB_FEATURE_CLEAN_UP) && defined(BB_FEATURE_COMMAND_TAB_COMPLETION)
 	input_tab(0);				/* strong free */
 #endif
-#if !defined(BB_FEATURE_SH_SIMPLE_PROMPT)
+#if defined(BB_FEATURE_SH_FANCY_PROMPT)
 	free(cmdedit_prompt);
 #endif
 	return;
 }
 
 
 /* Undo the effects of cmdedit_init(). */
 extern void cmdedit_terminate(void)
 {
 	cmdedit_reset_term();
 #if 0
 	if ((handlers_sets & SET_TERM_HANDLERS) != 0) {
 		signal(SIGKILL, SIG_DFL);
 		signal(SIGINT, SIG_DFL);
 		signal(SIGQUIT, SIG_DFL);
 		signal(SIGTERM, SIG_DFL);
 		signal(SIGWINCH, SIG_DFL);
 		handlers_sets &= ~SET_TERM_HANDLERS;
 	}
 #endif	
 }
 
 #endif	/* BB_FEATURE_COMMAND_EDITING */
 
 
 #ifdef TEST
 
 const char *applet_name = "debug stuff usage";
 const char *memory_exhausted = "Memory exhausted";
 
 #ifdef BB_FEATURE_NONPRINTABLE_INVERSE_PUT
 #include <locale.h>
 #endif
 
 unsigned int shell_context;
 
 int main(int argc, char **argv)
 {
 	char buff[BUFSIZ];
 	char *prompt =
-#if !defined(BB_FEATURE_SH_SIMPLE_PROMPT)
+#if defined(BB_FEATURE_SH_FANCY_PROMPT)
 		"\\[\\033[32;1m\\]\\u@\\[\\x1b[33;1m\\]\\h:\
 \\[\\033[34;1m\\]\\w\\[\\033[35;1m\\] \
 \\!\\[\\e[36;1m\\]\\$ \\[\\E[0m\\]";
 #else
 		"% ";
 #endif
 
 #ifdef BB_FEATURE_NONPRINTABLE_INVERSE_PUT
 	setlocale(LC_ALL, "");
 #endif
 	shell_context = 1;
 	do {
 		int l;
 		cmdedit_read_input(prompt, buff);
 		l = strlen(buff);
 		if(l > 0 && buff[l-1] == '\n')
 			buff[l-1] = 0;
 		printf("*** cmdedit_read_input() returned line =%s=\n", buff);
 	} while (shell_context);
 	printf("*** cmdedit_read_input() detect ^C\n");
 	return 0;
 }
 
 #endif	/* TEST */
diff --git a/coreutils/tail.c b/coreutils/tail.c
index ff77bde..4fe92ba 100644
--- a/coreutils/tail.c
+++ b/coreutils/tail.c
@@ -1,247 +1,247 @@
 /* vi: set sw=4 ts=4: */
 /*
  * Mini tail implementation for busybox
  *
  *
  * Copyright (C) 2001 by Matt Kraai <kraai@alumni.carnegiemellon.edu>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
  * General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
  *
  */
 
 
 #include <fcntl.h>
 #include <getopt.h>
 #include <string.h>
 #include <stdlib.h>
 #include <unistd.h>
 #include <sys/types.h>
 #include "busybox.h"
 
 static const struct suffix_mult tail_suffixes[] = {
 	{ "b", 512 },
 	{ "k", 1024 },
 	{ "m", 1048576 },
 	{ NULL, 0 }
 };
 
 static const int BYTES = 0;
 static const int LINES = 1;
 
 static char *tailbuf;
 static int taillen;
 static int newline;
 
 static void tailbuf_append(char *buf, int len)
 {
 	tailbuf = xrealloc(tailbuf, taillen + len);
 	memcpy(tailbuf + taillen, buf, len);
 	taillen += len;
 }
 
 static void tailbuf_trunc()
 {
 	char *s;
 	s = memchr(tailbuf, '\n', taillen);
 	memmove(tailbuf, s + 1, taillen - ((s + 1) - tailbuf));
 	taillen -= (s + 1) - tailbuf;
 	newline = 0;
 }
 
 int tail_main(int argc, char **argv)
 {
 	int from_top = 0, units = LINES, count = 10, sleep_period = 1;
 	int show_headers = 0, hide_headers = 0, follow = 0;
 	int *fds, nfiles = 0, status = EXIT_SUCCESS, nread, nwrite, seen = 0;
 	char *s, *start, *end, buf[BUFSIZ];
 	int i, opt;
 
 	while ((opt = getopt(argc, argv, "c:fhn:q:s:v")) > 0) {
 		switch (opt) {
 			case 'f':
 				follow = 1;
 				break;
-#ifndef BB_FEATURE_SIMPLE_TAIL
+#ifdef BB_FEATURE_FANCY_TAIL
 			case 'c':
 				units = BYTES;
 				/* FALLS THROUGH */
 #endif
 			case 'n':
 				count = parse_number(optarg, tail_suffixes);
 				if (count < 0)
 					count = -count;
 				if (optarg[0] == '+')
 					from_top = 1;
 				break;
-#ifndef BB_FEATURE_SIMPLE_TAIL
+#ifdef BB_FEATURE_FANCY_TAIL
 			case 'q':
 				hide_headers = 1;
 				break;
 			case 's':
 				sleep_period = parse_number(optarg, 0);
 				break;
 			case 'v':
 				show_headers = 1;
 				break;
 #endif
 			default:
 				show_usage();
 		}
 	}
 
 	/* open all the files */
 	fds = (int *)xmalloc(sizeof(int) * (argc - optind + 1));
 	if (argc == optind) {
 		fds[nfiles++] = STDIN_FILENO;
 		argv[optind] = "standard input";
 	} else {
 		for (i = optind; i < argc; i++) {
 			if (strcmp(argv[i], "-") == 0) {
 				fds[nfiles++] = STDIN_FILENO;
 				argv[i] = "standard input";
 			} else if ((fds[nfiles++] = open(argv[i], O_RDONLY)) < 0) {
 				perror_msg("%s", argv[i]);
 				status = EXIT_FAILURE;
 			}
 		}
 	}
 	
-#ifndef BB_FEATURE_SIMPLE_TAIL
+#ifdef BB_FEATURE_FANCY_TAIL
 	/* tail the files */
 	if (!from_top && units == BYTES)
 		tailbuf = xmalloc(count);
 #endif
 
 	for (i = 0; i < nfiles; i++) {
 		if (fds[i] == -1)
 			continue;
 		seen = 0;
 		if (show_headers || (!hide_headers && nfiles > 1))
 			printf("%s==> %s <==\n", i == 0 ? "" : "\n", argv[optind + i]);
 		while ((nread = safe_read(fds[i], buf, sizeof(buf))) > 0) {
 			if (from_top) {
-#ifndef BB_FEATURE_SIMPLE_TAIL
+#ifdef BB_FEATURE_FANCY_TAIL
 				if (units == BYTES) {
 					if (count - 1 <= seen)
 						nwrite = nread;
 					else if (count - 1 <= seen + nread)
 						nwrite = nread + seen - (count - 1);
 					else
 						nwrite = 0;
 					seen += nread;
 				} else {
 #else
 				{
 #endif
 					if (count - 1 <= seen)
 						nwrite = nread;
 					else {
 						nwrite = 0;
 						for (s = memchr(buf, '\n', nread); s != NULL;
 								s = memchr(s+1, '\n', nread - (s + 1 - buf))) {
 							if (count - 1 <= ++seen) {
 								nwrite = nread - (s + 1 - buf);
 								break;
 							}
 						}
 					}
 				}
 				if (full_write(STDOUT_FILENO, buf + nread - nwrite,
 							nwrite) < 0) {
 					perror_msg("write");
 					status = EXIT_FAILURE;
 					break;
 				}
 			} else {
-#ifndef BB_FEATURE_SIMPLE_TAIL
+#ifdef BB_FEATURE_FANCY_TAIL
 				if (units == BYTES) {
 					if (nread < count) {
 						memmove(tailbuf, tailbuf + nread, count - nread);
 						memcpy(tailbuf + count - nread, buf, nread);
 					} else {
 						memcpy(tailbuf, buf + nread - count, count);
 					}
 					seen += nread;
 				} else {
 #else
 				{
 #endif
 					for (start = buf, end = memchr(buf, '\n', nread);
 							end != NULL; start = end+1,
 							end = memchr(start, '\n', nread - (start - buf))) {
 						if (newline && count <= seen)
 							tailbuf_trunc();
 						tailbuf_append(start, end - start + 1);
 						seen++;
 						newline = 1;
 					}
 					if (newline && count <= seen && nread - (start - buf) > 0)
 						tailbuf_trunc();
 					tailbuf_append(start, nread - (start - buf));
 				}
 			}
 		}
 
 		if (nread < 0) {
 			perror_msg("read");
 			status = EXIT_FAILURE;
 		}
 
-#ifndef BB_FEATURE_SIMPLE_TAIL
+#ifdef BB_FEATURE_FANCY_TAIL
 		if (!from_top && units == BYTES) {
 			if (count < seen)
 				seen = count;
 			if (full_write(STDOUT_FILENO, tailbuf + count - seen, seen) < 0) {
 				perror_msg("write");
 				status = EXIT_FAILURE;
 			}
 		}
 #endif
 
 		if (!from_top && units == LINES) {
 			if (full_write(STDOUT_FILENO, tailbuf, taillen) < 0) {
 				perror_msg("write");
 				status = EXIT_FAILURE;
 			}
 		}
 
 		taillen = 0;
 	}
 
 	while (follow) {
 		sleep(sleep_period);
 
 		for (i = 0; i < nfiles; i++) {
 			if (fds[i] == -1)
 				continue;
 
 			if ((nread = safe_read(fds[i], buf, sizeof(buf))) > 0) {
 				if (show_headers || (!hide_headers && nfiles > 1))
 					printf("\n==> %s <==\n", argv[optind + i]);
 
 				do {
 					full_write(STDOUT_FILENO, buf, nread);
 				} while ((nread = safe_read(fds[i], buf, sizeof(buf))) > 0);
 			}
 
 			if (nread < 0) {
 				perror_msg("read");
 				status = EXIT_FAILURE;
 			}
 		}
 	}
 
 	return status;
 }
diff --git a/hush.c b/hush.c
index fc45bb2..722dcf7 100644
--- a/hush.c
+++ b/hush.c
@@ -1,2637 +1,2637 @@
 /* vi: set sw=4 ts=4: */
 /*
  * sh.c -- a prototype Bourne shell grammar parser
  *      Intended to follow the original Thompson and Ritchie
  *      "small and simple is beautiful" philosophy, which
  *      incidentally is a good match to today's BusyBox.
  *
  * Copyright (C) 2000,2001  Larry Doolittle  <larry@doolittle.boa.org>
  *
  * Credits:
  *      The parser routines proper are all original material, first
  *      written Dec 2000 and Jan 2001 by Larry Doolittle.
  *      The execution engine, the builtins, and much of the underlying
  *      support has been adapted from busybox-0.49pre's lash,
  *      which is Copyright (C) 2000 by Lineo, Inc., and
  *      written by Erik Andersen <andersen@lineo.com>, <andersee@debian.org>.
  *      That, in turn, is based in part on ladsh.c, by Michael K. Johnson and
  *      Erik W. Troan, which they placed in the public domain.  I don't know
  *      how much of the Johnson/Troan code has survived the repeated rewrites.
  * Other credits:
  *      simple_itoa() was lifted from boa-0.93.15
  *      b_addchr() derived from similar w_addchar function in glibc-2.2
  *      setup_redirect(), redirect_opt_num(), and big chunks of main()
  *        and many builtins derived from contributions by Erik Andersen
  *      miscellaneous bugfixes from Matt Kraai
  *
  * There are two big (and related) architecture differences between
  * this parser and the lash parser.  One is that this version is
  * actually designed from the ground up to understand nearly all
  * of the Bourne grammar.  The second, consequential change is that
  * the parser and input reader have been turned inside out.  Now,
  * the parser is in control, and asks for input as needed.  The old
  * way had the input reader in control, and it asked for parsing to
  * take place as needed.  The new way makes it much easier to properly
  * handle the recursion implicit in the various substitutions, especially
  * across continuation lines.
  *
  * Bash grammar not implemented: (how many of these were in original sh?)
  *      $@ (those sure look like weird quoting rules)
  *      $_
  *      ! negation operator for pipes
  *      &> and >& redirection of stdout+stderr
  *      Brace Expansion
  *      Tilde Expansion
  *      fancy forms of Parameter Expansion
  *      aliases
  *      Arithmetic Expansion
  *      <(list) and >(list) Process Substitution
  *      reserved words: case, esac, select, function
  *      Here Documents ( << word )
  *      Functions
  * Major bugs:
  *      job handling woefully incomplete and buggy
  *      reserved word execution woefully incomplete and buggy
  * to-do:
  *      port selected bugfixes from post-0.49 busybox lash - done?
  *      finish implementing reserved words: for, while, until, do, done
  *      change { and } from special chars to reserved words
  *      builtins: break, continue, eval, return, set, trap, ulimit
  *      test magic exec
  *      handle children going into background
  *      clean up recognition of null pipes
  *      check setting of global_argc and global_argv
  *      control-C handling, probably with longjmp
  *      follow IFS rules more precisely, including update semantics
  *      figure out what to do with backslash-newline
  *      explain why we use signal instead of sigaction
  *      propagate syntax errors, die on resource errors?
  *      continuation lines, both explicit and implicit - done?
  *      memory leak finding and plugging - done?
  *      more testing, especially quoting rules and redirection
  *      document how quoting rules not precisely followed for variable assignments
  *      maybe change map[] to use 2-bit entries
  *      (eventually) remove all the printf's
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
  * General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
  */
 #include <ctype.h>     /* isalpha, isdigit */
 #include <unistd.h>    /* getpid */
 #include <stdlib.h>    /* getenv, atoi */
 #include <string.h>    /* strchr */
 #include <stdio.h>     /* popen etc. */
 #include <glob.h>      /* glob, of course */
 #include <stdarg.h>    /* va_list */
 #include <errno.h>
 #include <fcntl.h>
 #include <getopt.h>    /* should be pretty obvious */
 
 #include <sys/stat.h>  /* ulimit */
 #include <sys/types.h>
 #include <sys/wait.h>
 #include <signal.h>
 
 /* #include <dmalloc.h> */
 /* #define DEBUG_SHELL */
 
 #ifdef BB_VER
 #include "busybox.h"
 #include "cmdedit.h"
 #else
 #define applet_name "hush"
 #include "standalone.h"
 #define shell_main main
-#define BB_FEATURE_SH_SIMPLE_PROMPT
+#undef BB_FEATURE_SH_FANCY_PROMPT
 #endif
 
 typedef enum {
 	REDIRECT_INPUT     = 1,
 	REDIRECT_OVERWRITE = 2,
 	REDIRECT_APPEND    = 3,
 	REDIRECT_HEREIS    = 4,
 	REDIRECT_IO        = 5
 } redir_type;
 
 /* The descrip member of this structure is only used to make debugging
  * output pretty */
 struct {int mode; int default_fd; char *descrip;} redir_table[] = {
 	{ 0,                         0, "()" },
 	{ O_RDONLY,                  0, "<"  },
 	{ O_CREAT|O_TRUNC|O_WRONLY,  1, ">"  },
 	{ O_CREAT|O_APPEND|O_WRONLY, 1, ">>" },
 	{ O_RDONLY,                 -1, "<<" },
 	{ O_RDWR,                    1, "<>" }
 };
 
 typedef enum {
 	PIPE_SEQ = 1,
 	PIPE_AND = 2,
 	PIPE_OR  = 3,
 	PIPE_BG  = 4,
 } pipe_style;
 
 /* might eventually control execution */
 typedef enum {
 	RES_NONE  = 0,
 	RES_IF    = 1,
 	RES_THEN  = 2,
 	RES_ELIF  = 3,
 	RES_ELSE  = 4,
 	RES_FI    = 5,
 	RES_FOR   = 6,
 	RES_WHILE = 7,
 	RES_UNTIL = 8,
 	RES_DO    = 9,
 	RES_DONE  = 10,
 	RES_XXXX  = 11,
 	RES_SNTX  = 12
 } reserved_style;
 #define FLAG_END   (1<<RES_NONE)
 #define FLAG_IF    (1<<RES_IF)
 #define FLAG_THEN  (1<<RES_THEN)
 #define FLAG_ELIF  (1<<RES_ELIF)
 #define FLAG_ELSE  (1<<RES_ELSE)
 #define FLAG_FI    (1<<RES_FI)
 #define FLAG_FOR   (1<<RES_FOR)
 #define FLAG_WHILE (1<<RES_WHILE)
 #define FLAG_UNTIL (1<<RES_UNTIL)
 #define FLAG_DO    (1<<RES_DO)
 #define FLAG_DONE  (1<<RES_DONE)
 #define FLAG_START (1<<RES_XXXX)
 
 /* This holds pointers to the various results of parsing */
 struct p_context {
 	struct child_prog *child;
 	struct pipe *list_head;
 	struct pipe *pipe;
 	struct redir_struct *pending_redirect;
 	reserved_style w;
 	int old_flag;				/* for figuring out valid reserved words */
 	struct p_context *stack;
 	/* How about quoting status? */
 };
 
 struct redir_struct {
 	redir_type type;			/* type of redirection */
 	int fd;						/* file descriptor being redirected */
 	int dup;					/* -1, or file descriptor being duplicated */
 	struct redir_struct *next;	/* pointer to the next redirect in the list */ 
 	glob_t word;				/* *word.gl_pathv is the filename */
 };
 
 struct child_prog {
 	pid_t pid;					/* 0 if exited */
 	char **argv;				/* program name and arguments */
 	struct pipe *group;			/* if non-NULL, first in group or subshell */
 	int subshell;				/* flag, non-zero if group must be forked */
 	struct redir_struct *redirects;	/* I/O redirections */
 	glob_t glob_result;			/* result of parameter globbing */
 	int is_stopped;				/* is the program currently running? */
 	struct pipe *family;		/* pointer back to the child's parent pipe */
 };
 
 struct pipe {
 	int jobid;					/* job number */
 	int num_progs;				/* total number of programs in job */
 	int running_progs;			/* number of programs running */
 	char *text;					/* name of job */
 	char *cmdbuf;				/* buffer various argv's point into */
 	pid_t pgrp;					/* process group ID for the job */
 	struct child_prog *progs;	/* array of commands in pipe */
 	struct pipe *next;			/* to track background commands */
 	int stopped_progs;			/* number of programs alive, but stopped */
 	int job_context;			/* bitmask defining current context */
 	pipe_style followup;		/* PIPE_BG, PIPE_SEQ, PIPE_OR, PIPE_AND */
 	reserved_style r_mode;		/* supports if, for, while, until */
 };
 
 struct jobset {
 	struct pipe *head;			/* head of list of running jobs */
 	struct pipe *fg;			/* current foreground job */
 };
 
 struct close_me {
 	int fd;
 	struct close_me *next;
 };
 
 struct variables {
 	char *name;
 	char *value;
 	int flg_export;
 	int flg_read_only;
 	struct variables *next;
 };
 
 /* globals, connect us to the outside world
  * the first three support $?, $#, and $1 */
 char **global_argv;
 unsigned int global_argc;
 unsigned int last_return_code;
 extern char **environ; /* This is in <unistd.h>, but protected with __USE_GNU */
  
 /* Variables we export */
 unsigned int shell_context;  /* Used in cmdedit.c to reset the
                               * context when someone hits ^C */
 
 /* "globals" within this file */
 static char *ifs;
 static char map[256];
 static int fake_mode;
 static int interactive;
 static struct close_me *close_me_head;
 static const char *cwd;
 static struct jobset *job_list;
 static unsigned int last_bg_pid;
 static char *PS1;
 static char PS2[] = "> ";
 
 struct variables shell_ver = { "HUSH_VERSION", "0.01", 1, 1, 0 };
 
 struct variables *top_vars = &shell_ver;
 
 #define B_CHUNK (100)
 #define B_NOSPAC 1
 
 typedef struct {
 	char *data;
 	int length;
 	int maxlen;
 	int quote;
 	int nonnull;
 } o_string;
 #define NULL_O_STRING {NULL,0,0,0,0}
 /* used for initialization:
 	o_string foo = NULL_O_STRING; */
 
 /* I can almost use ordinary FILE *.  Is open_memstream() universally
  * available?  Where is it documented? */
 struct in_str {
 	const char *p;
 	int __promptme;
 	int promptmode;
 	FILE *file;
 	int (*get) (struct in_str *);
 	int (*peek) (struct in_str *);
 };
 #define b_getch(input) ((input)->get(input))
 #define b_peek(input) ((input)->peek(input))
 
 #define JOB_STATUS_FORMAT "[%d] %-22s %.40s\n"
 
 struct built_in_command {
 	char *cmd;					/* name */
 	char *descr;				/* description */
 	int (*function) (struct child_prog *);	/* function ptr */
 };
 
 /* belongs in busybox.h */
 static inline int max(int a, int b) {
 	return (a>b)?a:b;
 }
 
 /* This should be in utility.c */
 #ifdef DEBUG_SHELL
 static void debug_printf(const char *format, ...)
 {
 	va_list args;
 	va_start(args, format);
 	vfprintf(stderr, format, args);
 	va_end(args);
 }
 #else
 static inline void debug_printf(const char *format, ...) { }
 #endif
 #define final_printf debug_printf
 
 static void __syntax(char *file, int line) {
 	error_msg("syntax error %s:%d", file, line);
 }
 #define syntax() __syntax(__FILE__, __LINE__)
 
 /* Index of subroutines: */
 /*   function prototypes for builtins */
 static int builtin_cd(struct child_prog *child);
 static int builtin_env(struct child_prog *child);
 static int builtin_exec(struct child_prog *child);
 static int builtin_exit(struct child_prog *child);
 static int builtin_export(struct child_prog *child);
 static int builtin_fg_bg(struct child_prog *child);
 static int builtin_help(struct child_prog *child);
 static int builtin_jobs(struct child_prog *child);
 static int builtin_pwd(struct child_prog *child);
 static int builtin_read(struct child_prog *child);
 static int builtin_set(struct child_prog *child);
 static int builtin_shift(struct child_prog *child);
 static int builtin_source(struct child_prog *child);
 static int builtin_umask(struct child_prog *child);
 static int builtin_unset(struct child_prog *child);
 static int builtin_not_written(struct child_prog *child);
 /*   o_string manipulation: */
 static int b_check_space(o_string *o, int len);
 static int b_addchr(o_string *o, int ch);
 static void b_reset(o_string *o);
 static int b_addqchr(o_string *o, int ch, int quote);
 static int b_adduint(o_string *o, unsigned int i);
 /*  in_str manipulations: */
 static int static_get(struct in_str *i);
 static int static_peek(struct in_str *i);
 static int file_get(struct in_str *i);
 static int file_peek(struct in_str *i);
 static void setup_file_in_str(struct in_str *i, FILE *f);
 static void setup_string_in_str(struct in_str *i, const char *s);
 /*  close_me manipulations: */
 static void mark_open(int fd);
 static void mark_closed(int fd);
 static void close_all();
 /*  "run" the final data structures: */
 static char *indenter(int i);
 static int run_list_test(struct pipe *head, int indent);
 static int run_pipe_test(struct pipe *pi, int indent);
 /*  really run the final data structures: */
 static int setup_redirects(struct child_prog *prog, int squirrel[]);
 static int pipe_wait(struct pipe *pi);
 static int run_list_real(struct pipe *pi);
 static void pseudo_exec(struct child_prog *child) __attribute__ ((noreturn));
 int controlling_tty(int check_pgrp);
 static int run_pipe_real(struct pipe *pi);
 /*   extended glob support: */
 static int globhack(const char *src, int flags, glob_t *pglob);
 static int glob_needed(const char *s);
 static int xglob(o_string *dest, int flags, glob_t *pglob);
 /*   variable assignment: */
 static int is_assignment(const char *s);
 /*   data structure manipulation: */
 static int setup_redirect(struct p_context *ctx, int fd, redir_type style, struct in_str *input);
 static void initialize_context(struct p_context *ctx);
 static int done_word(o_string *dest, struct p_context *ctx);
 static int done_command(struct p_context *ctx);
 static int done_pipe(struct p_context *ctx, pipe_style type);
 /*   primary string parsing: */
 static int redirect_dup_num(struct in_str *input);
 static int redirect_opt_num(o_string *o);
 static int process_command_subs(o_string *dest, struct p_context *ctx, struct in_str *input, int subst_end);
 static int parse_group(o_string *dest, struct p_context *ctx, struct in_str *input, int ch);
 static void lookup_param(o_string *dest, struct p_context *ctx, o_string *src);
 static int handle_dollar(o_string *dest, struct p_context *ctx, struct in_str *input);
 static int parse_string(o_string *dest, struct p_context *ctx, const char *src);
 static int parse_stream(o_string *dest, struct p_context *ctx, struct in_str *input0, int end_trigger);
 /*   setup: */
 static int parse_stream_outer(struct in_str *inp);
 static int parse_string_outer(const char *s);
 static int parse_file_outer(FILE *f);
 /*   job management: */
 static void checkjobs();
 static void insert_bg_job(struct pipe *pi);
 static void remove_bg_job(struct pipe *pi);
 static void free_pipe(struct pipe *pi);
 /*     local variable support */
 static char *get_local_var(const char *var);
 static void  unset_local_var(const char *name);
 static int set_local_var(const char *s, int flg_export);
 
 
 /* Table of built-in functions.  They can be forked or not, depending on
  * context: within pipes, they fork.  As simple commands, they do not.
  * When used in non-forking context, they can change global variables
  * in the parent shell process.  If forked, of course they can not.
  * For example, 'unset foo | whatever' will parse and run, but foo will
  * still be set at the end. */
 static struct built_in_command bltins[] = {
 	{"bg", "Resume a job in the background", builtin_fg_bg},
 	{"break", "Exit for, while or until loop", builtin_not_written},
 	{"cd", "Change working directory", builtin_cd},
 	{"continue", "Continue for, while or until loop", builtin_not_written},
 	{"env", "Print all environment variables", builtin_env},
 	{"eval", "Construct and run shell command", builtin_not_written},
 	{"exec", "Exec command, replacing this shell with the exec'd process", 
 		builtin_exec},
 	{"exit", "Exit from shell()", builtin_exit},
 	{"export", "Set environment variable", builtin_export},
 	{"fg", "Bring job into the foreground", builtin_fg_bg},
 	{"jobs", "Lists the active jobs", builtin_jobs},
 	{"pwd", "Print current directory", builtin_pwd},
 	{"read", "Input environment variable", builtin_read},
 	{"return", "Return from a function", builtin_not_written},
 	{"set", "Set/unset shell local variables", builtin_set},
 	{"shift", "Shift positional parameters", builtin_shift},
 	{"trap", "Trap signals", builtin_not_written},
 	{"ulimit","Controls resource limits", builtin_not_written},
 	{"umask","Sets file creation mask", builtin_umask},
 	{"unset", "Unset environment variable", builtin_unset},
 	{".", "Source-in and run commands in a file", builtin_source},
 	{"help", "List shell built-in commands", builtin_help},
 	{NULL, NULL, NULL}
 };
 
 static const char *set_cwd(void)
 {
 	if(cwd==unknown)
 		cwd = NULL;     /* xgetcwd(arg) called free(arg) */
 	cwd = xgetcwd((char *)cwd);
 	if (!cwd)
 		cwd = unknown;
 	return cwd;
 }
 
 
 /* built-in 'cd <path>' handler */
 static int builtin_cd(struct child_prog *child)
 {
 	char *newdir;
 	if (child->argv[1] == NULL)
 		newdir = getenv("HOME");
 	else
 		newdir = child->argv[1];
 	if (chdir(newdir)) {
 		printf("cd: %s: %s\n", newdir, strerror(errno));
 		return EXIT_FAILURE;
 	}
 	set_cwd();
 	return EXIT_SUCCESS;
 }
 
 /* built-in 'env' handler */
 static int builtin_env(struct child_prog *dummy)
 {
 	char **e = environ;
 	if (e == NULL) return EXIT_FAILURE;
 	for (; *e; e++) {
 		puts(*e);
 	}
 	return EXIT_SUCCESS;
 }
 
 /* built-in 'exec' handler */
 static int builtin_exec(struct child_prog *child)
 {
 	if (child->argv[1] == NULL)
 		return EXIT_SUCCESS;   /* Really? */
 	child->argv++;
 	pseudo_exec(child);
 	/* never returns */
 }
 
 /* built-in 'exit' handler */
 static int builtin_exit(struct child_prog *child)
 {
 	if (child->argv[1] == NULL)
 		exit(last_return_code);
 	exit (atoi(child->argv[1]));
 }
 
 /* built-in 'export VAR=value' handler */
 static int builtin_export(struct child_prog *child)
 {
 	int res = 0;
 	char *name = child->argv[1];
 
 	if (name == NULL) {
 		return (builtin_env(child));
 	}
 
 	name = strdup(name);
 
 	if(name) {
 	    char *value = strchr(name, '=');
 
 	if (!value) {
 		char *tmp;
 		/* They are exporting something without an =VALUE */
 
 		value = get_local_var(name);
 		if (value) {
 			size_t ln = strlen(name);
 
 			tmp = realloc(name, ln+strlen(value)+2);
 			if(tmp==NULL)
 				res = -1;
 			else {
 				sprintf(tmp+ln, "=%s", value);
 				name = tmp;
 			}
 		} else {
 			/* bash not put error and set error code
 			   if exporting not defined variable */
 			res = 1;
 		}
 	    }
 	}
 	if (res<0)
 		perror_msg("export");
 	else if(res==0)
 		res = set_local_var(name, 1);
 	else
 		res = 0;
 	free(name);
 	return res;
 }
 
 /* built-in 'fg' and 'bg' handler */
 static int builtin_fg_bg(struct child_prog *child)
 {
 	int i, jobnum;
 	struct pipe *pi=NULL;
 
 	/* If they gave us no args, assume they want the last backgrounded task */
 	if (!child->argv[1]) {
 		for (pi = job_list->head; pi; pi = pi->next) {
 			if (pi->progs && pi->progs->pid == last_bg_pid) {
 				break;
 			}
 		}
 		if (!pi) {
 			error_msg("%s: no current job", child->argv[0]);
 			return EXIT_FAILURE;
 		}
 	} else {
 		if (sscanf(child->argv[1], "%%%d", &jobnum) != 1) {
 			error_msg("%s: bad argument '%s'", child->argv[0], child->argv[1]);
 			return EXIT_FAILURE;
 		}
 
 		for (pi = job_list->head; pi; pi = pi->next) {
 			if (pi->jobid == jobnum) {
 				break;
 			}
 		}
 		if (!pi) {
 			error_msg("%s: %d: no such job", child->argv[0], jobnum);
 			return EXIT_FAILURE;
 		}
 	}
 	if (*child->argv[0] == 'f') {
 		/* Make this job the foreground job */
 		signal(SIGTTOU, SIG_IGN);
 		/* suppress messages when run from /linuxrc mag@sysgo.de */
 		if (tcsetpgrp(0, pi->pgrp) && errno != ENOTTY)
 			perror_msg("tcsetpgrp-1"); 
 		signal(SIGTTOU, SIG_DFL);
 		job_list->fg = pi;
 	}
 
 	/* Restart the processes in the job */
 	for (i = 0; i < pi->num_progs; i++)
 		pi->progs[i].is_stopped = 0;
 
 	kill(-pi->pgrp, SIGCONT);
 
 	pi->stopped_progs = 0;
 	return EXIT_SUCCESS;
 }
 
 /* built-in 'help' handler */
 static int builtin_help(struct child_prog *dummy)
 {
 	struct built_in_command *x;
 
 	printf("\nBuilt-in commands:\n");
 	printf("-------------------\n");
 	for (x = bltins; x->cmd; x++) {
 		if (x->descr==NULL)
 			continue;
 		printf("%s\t%s\n", x->cmd, x->descr);
 	}
 	printf("\n\n");
 	return EXIT_SUCCESS;
 }
 
 /* built-in 'jobs' handler */
 static int builtin_jobs(struct child_prog *child)
 {
 	struct pipe *job;
 	char *status_string;
 
 	for (job = job_list->head; job; job = job->next) {
 		if (job->running_progs == job->stopped_progs)
 			status_string = "Stopped";
 		else
 			status_string = "Running";
 		printf(JOB_STATUS_FORMAT, job->jobid, status_string, job->text);
 	}
 	return EXIT_SUCCESS;
 }
 
 
 /* built-in 'pwd' handler */
 static int builtin_pwd(struct child_prog *dummy)
 {
 	puts(set_cwd());
 	return EXIT_SUCCESS;
 }
 
 /* built-in 'read VAR' handler */
 static int builtin_read(struct child_prog *child)
 {
 	int res;
 
 	if (child->argv[1]) {
 		char string[BUFSIZ];
 		char *var = 0;
 
 		string[0] = 0;  /* for correct work if stdin have "only EOF" */
 		/* read string */
 		fgets(string, sizeof(string), stdin);
 		chomp(string);
 		var = malloc(strlen(child->argv[1])+strlen(string)+2);
 		if(var) {
 			sprintf(var, "%s=%s", child->argv[1], string);
 			res = set_local_var(var, 0);
 		} else
 		res = -1;
 		if (res)
 			fprintf(stderr, "read: %m\n");
 		free(var);      /* not move up - saved errno */
 		return res;
 	} else {
 		do res=getchar(); while(res!='\n' && res!=EOF);
 		return 0;
 	}
 }
 
 /* built-in 'set VAR=value' handler */
 static int builtin_set(struct child_prog *child)
 {
 	char *temp = child->argv[1];
 	struct variables *e;
 
 	if (temp == NULL)
 		for(e = top_vars; e; e=e->next)
 			printf("%s=%s\n", e->name, e->value);
 	else
 		set_local_var(temp, 0);
 
 		return EXIT_SUCCESS;
 }
 
 
 /* Built-in 'shift' handler */
 static int builtin_shift(struct child_prog *child)
 {
 	int n=1;
 	if (child->argv[1]) {
 		n=atoi(child->argv[1]);
 	}
 	if (n>=0 && n<global_argc) {
 		/* XXX This probably breaks $0 */
 		global_argc -= n;
 		global_argv += n;
 		return EXIT_SUCCESS;
 	} else {
 		return EXIT_FAILURE;
 	}
 }
 
 /* Built-in '.' handler (read-in and execute commands from file) */
 static int builtin_source(struct child_prog *child)
 {
 	FILE *input;
 	int status;
 
 	if (child->argv[1] == NULL)
 		return EXIT_FAILURE;
 
 	/* XXX search through $PATH is missing */
 	input = fopen(child->argv[1], "r");
 	if (!input) {
 		error_msg("Couldn't open file '%s'", child->argv[1]);
 		return EXIT_FAILURE;
 	}
 
 	/* Now run the file */
 	/* XXX argv and argc are broken; need to save old global_argv
 	 * (pointer only is OK!) on this stack frame,
 	 * set global_argv=child->argv+1, recurse, and restore. */
 	mark_open(fileno(input));
 	status = parse_file_outer(input);
 	mark_closed(fileno(input));
 	fclose(input);
 	return (status);
 }
 
 static int builtin_umask(struct child_prog *child)
 {
 	mode_t new_umask;
 	const char *arg = child->argv[1];
 	char *end;
 	if (arg) {
 		new_umask=strtoul(arg, &end, 8);
 		if (*end!='\0' || end == arg) {
 			return EXIT_FAILURE;
 		}
 	} else {
 		printf("%.3o\n", (unsigned int) (new_umask=umask(0)));
 	}
 	umask(new_umask);
 	return EXIT_SUCCESS;
 }
 
 /* built-in 'unset VAR' handler */
 static int builtin_unset(struct child_prog *child)
 {
 	/* bash returned already true */
 	unset_local_var(child->argv[1]);
 	return EXIT_SUCCESS;
 }
 
 static int builtin_not_written(struct child_prog *child)
 {
 	printf("builtin_%s not written\n",child->argv[0]);
 	return EXIT_FAILURE;
 }
 
 static int b_check_space(o_string *o, int len)
 {
 	/* It would be easy to drop a more restrictive policy
 	 * in here, such as setting a maximum string length */
 	if (o->length + len > o->maxlen) {
 		char *old_data = o->data;
 		/* assert (data == NULL || o->maxlen != 0); */
 		o->maxlen += max(2*len, B_CHUNK);
 		o->data = realloc(o->data, 1 + o->maxlen);
 		if (o->data == NULL) {
 			free(old_data);
 		}
 	}
 	return o->data == NULL;
 }
 
 static int b_addchr(o_string *o, int ch)
 {
 	debug_printf("b_addchr: %c %d %p\n", ch, o->length, o);
 	if (b_check_space(o, 1)) return B_NOSPAC;
 	o->data[o->length] = ch;
 	o->length++;
 	o->data[o->length] = '\0';
 	return 0;
 }
 
 static void b_reset(o_string *o)
 {
 	o->length = 0;
 	o->nonnull = 0;
 	if (o->data != NULL) *o->data = '\0';
 }
 
 static void b_free(o_string *o)
 {
 	b_reset(o);
 	if (o->data != NULL) free(o->data);
 	o->data = NULL;
 	o->maxlen = 0;
 }
 
 /* My analysis of quoting semantics tells me that state information
  * is associated with a destination, not a source.
  */
 static int b_addqchr(o_string *o, int ch, int quote)
 {
 	if (quote && strchr("*?[\\",ch)) {
 		int rc;
 		rc = b_addchr(o, '\\');
 		if (rc) return rc;
 	}
 	return b_addchr(o, ch);
 }
 
 /* belongs in utility.c */
 char *simple_itoa(unsigned int i)
 {
 	/* 21 digits plus null terminator, good for 64-bit or smaller ints */
 	static char local[22];
 	char *p = &local[21];
 	*p-- = '\0';
 	do {
 		*p-- = '0' + i % 10;
 		i /= 10;
 	} while (i > 0);
 	return p + 1;
 }
 
 static int b_adduint(o_string *o, unsigned int i)
 {
 	int r;
 	char *p = simple_itoa(i);
 	/* no escape checking necessary */
 	do r=b_addchr(o, *p++); while (r==0 && *p);
 	return r;
 }
 
 static int static_get(struct in_str *i)
 {
 	int ch=*i->p++;
 	if (ch=='\0') return EOF;
 	return ch;
 }
 
 static int static_peek(struct in_str *i)
 {
 	return *i->p;
 }
 
 static inline void cmdedit_set_initial_prompt(void)
 {
-#ifdef BB_FEATURE_SH_SIMPLE_PROMPT
+#ifndef BB_FEATURE_SH_FANCY_PROMPT
 	PS1 = NULL;
 #else
 	PS1 = getenv("PS1");
 	if(PS1==0)
 		PS1 = "\\w \\$ ";
 #endif	
 }
 
 static inline void setup_prompt_string(int promptmode, char **prompt_str)
 {
 	debug_printf("setup_prompt_string %d ",promptmode);
-#ifdef BB_FEATURE_SH_SIMPLE_PROMPT
+#ifndef BB_FEATURE_SH_FANCY_PROMPT
 	/* Set up the prompt */
 	if (promptmode == 1) {
 		if (PS1)
 			free(PS1);
 		PS1=xmalloc(strlen(cwd)+4);
 		sprintf(PS1, "%s %s", cwd, ( geteuid() != 0 ) ?  "$ ":"# ");
 		*prompt_str = PS1;
 	} else {
 		*prompt_str = PS2;
 	}
 #else
 	*prompt_str = (promptmode==0)? PS1 : PS2;
 #endif
 	debug_printf("result %s\n",*prompt_str);
 }
 
 static void get_user_input(struct in_str *i)
 {
 	char *prompt_str;
 	static char the_command[BUFSIZ];
 
 	setup_prompt_string(i->promptmode, &prompt_str);
 #ifdef BB_FEATURE_COMMAND_EDITING
 	/*
 	 ** enable command line editing only while a command line
 	 ** is actually being read; otherwise, we'll end up bequeathing
 	 ** atexit() handlers and other unwanted stuff to our
 	 ** child processes (rob@sysgo.de)
 	 */
 	cmdedit_read_input(prompt_str, the_command);
 	cmdedit_terminate();
 #else
 	fputs(prompt_str, stdout);
 	fflush(stdout);
 	the_command[0]=fgetc(i->file);
 	the_command[1]='\0';
 #endif
 	i->p = the_command;
 }
 
 /* This is the magic location that prints prompts 
  * and gets data back from the user */
 static int file_get(struct in_str *i)
 {
 	int ch;
 
 	ch = 0;
 	/* If there is data waiting, eat it up */
 	if (i->p && *i->p) {
 		ch=*i->p++;
 	} else {
 		/* need to double check i->file because we might be doing something
 		 * more complicated by now, like sourcing or substituting. */
 		if (i->__promptme && interactive && i->file == stdin) {
 			get_user_input(i);
 			i->promptmode=2;
 			i->__promptme = 0;
 			if (i->p && *i->p) {
 				ch=*i->p++;
 			}
 		} else {
 			ch = fgetc(i->file);
 		}
 
 		debug_printf("b_getch: got a %d\n", ch);
 	}
 	if (ch == '\n') i->__promptme=1;
 	return ch;
 }
 
 /* All the callers guarantee this routine will never be
  * used right after a newline, so prompting is not needed.
  */
 static int file_peek(struct in_str *i)
 {
 	if (i->p && *i->p) {
 		return *i->p;
 	} else {
 		static char buffer[2];
 		buffer[0] = fgetc(i->file);
 		buffer[1] = '\0';
 		i->p = buffer;
 		debug_printf("b_peek: got a %d\n", *i->p);
 		return *i->p; 
 	}
 }
 
 static void setup_file_in_str(struct in_str *i, FILE *f)
 {
 	i->peek = file_peek;
 	i->get = file_get;
 	i->__promptme=1;
 	i->promptmode=1;
 	i->file = f;
 	i->p = NULL;
 }
 
 static void setup_string_in_str(struct in_str *i, const char *s)
 {
 	i->peek = static_peek;
 	i->get = static_get;
 	i->__promptme=1;
 	i->promptmode=1;
 	i->p = s;
 }
 
 static void mark_open(int fd)
 {
 	struct close_me *new = xmalloc(sizeof(struct close_me));
 	new->fd = fd;
 	new->next = close_me_head;
 	close_me_head = new;
 }
 
 static void mark_closed(int fd)
 {
 	struct close_me *tmp;
 	if (close_me_head == NULL || close_me_head->fd != fd)
 		error_msg_and_die("corrupt close_me");
 	tmp = close_me_head;
 	close_me_head = close_me_head->next;
 	free(tmp);
 }
 
 static void close_all()
 {
 	struct close_me *c;
 	for (c=close_me_head; c; c=c->next) {
 		close(c->fd);
 	}
 	close_me_head = NULL;
 }
 
 /* squirrel != NULL means we squirrel away copies of stdin, stdout,
  * and stderr if they are redirected. */
 static int setup_redirects(struct child_prog *prog, int squirrel[])
 {
 	int openfd, mode;
 	struct redir_struct *redir;
 
 	for (redir=prog->redirects; redir; redir=redir->next) {
 		if (redir->dup == -1) {
 			mode=redir_table[redir->type].mode;
 			openfd = open(redir->word.gl_pathv[0], mode, 0666);
 			if (openfd < 0) {
 			/* this could get lost if stderr has been redirected, but
 			   bash and ash both lose it as well (though zsh doesn't!) */
 				perror_msg("error opening %s", redir->word.gl_pathv[0]);
 				return 1;
 			}
 		} else {
 			openfd = redir->dup;
 		}
 
 		if (openfd != redir->fd) {
 			if (squirrel && redir->fd < 3) {
 				squirrel[redir->fd] = dup(redir->fd);
 			}
 			if (openfd == -3) {
 				close(openfd);
 			} else {
 				dup2(openfd, redir->fd);
 				close(openfd);
 			}
 		}
 	}
 	return 0;
 }
 
 static void restore_redirects(int squirrel[])
 {
 	int i, fd;
 	for (i=0; i<3; i++) {
 		fd = squirrel[i];
 		if (fd != -1) {
 			/* No error checking.  I sure wouldn't know what
 			 * to do with an error if I found one! */
 			dup2(fd, i);
 			close(fd);
 		}
 	}
 }
 
 /* XXX this definitely needs some more thought, work, and
  * cribbing from other shells */
 static int pipe_wait(struct pipe *pi)
 {
 	int rcode=0, i, pid, running, status;
 	running = pi->num_progs;
 	while (running) {
 		pid=waitpid(-1, &status, 0);
 		if (pid < 0) perror_msg_and_die("waitpid");
 		for (i=0; i < pi->num_progs; i++) {
 			if (pi->progs[i].pid == pid) {
 				if (i==pi->num_progs-1) rcode=WEXITSTATUS(status);
 				pi->progs[i].pid = 0;
 				running--;
 				break;
 			}
 		}
 	}
 	return rcode;
 }
 
 /* never returns */
 static void pseudo_exec(struct child_prog *child)
 {
 	int i, rcode;
 	struct built_in_command *x;
 	if (child->argv) {
 		for (i=0; is_assignment(child->argv[i]); i++) {
 			debug_printf("pid %d environment modification: %s\n",getpid(),child->argv[i]);
 			putenv(strdup(child->argv[i]));
 		}
 		child->argv+=i;  /* XXX this hack isn't so horrible, since we are about
 		                        to exit, and therefore don't need to keep data
 		                        structures consistent for free() use. */
 		/* If a variable is assigned in a forest, and nobody listens,
 		 * was it ever really set?
 		 */
 		if (child->argv[0] == NULL) exit(EXIT_SUCCESS);
 
 		/*
 		 * Check if the command matches any of the builtins.
 		 * Depending on context, this might be redundant.  But it's
 		 * easier to waste a few CPU cycles than it is to figure out
 		 * if this is one of those cases.
 		 */
 		for (x = bltins; x->cmd; x++) {
 			if (strcmp(child->argv[0], x->cmd) == 0 ) {
 				debug_printf("builtin exec %s\n", child->argv[0]);
 				exit(x->function(child));
 			}
 		}
 
 		/* Check if the command matches any busybox internal commands
 		 * ("applets") here.  
 		 * FIXME: This feature is not 100% safe, since
 		 * BusyBox is not fully reentrant, so we have no guarantee the things
 		 * from the .bss are still zeroed, or that things from .data are still
 		 * at their defaults.  We could exec ourself from /proc/self/exe, but I
 		 * really dislike relying on /proc for things.  We could exec ourself
 		 * from global_argv[0], but if we are in a chroot, we may not be able
 		 * to find ourself... */ 
 #ifdef BB_FEATURE_SH_STANDALONE_SHELL
 		{
 			int argc_l;
 			char** argv_l=child->argv;
 			char *name = child->argv[0];
 
 #ifdef BB_FEATURE_SH_APPLETS_ALWAYS_WIN
 			/* Following discussions from November 2000 on the busybox mailing
 			 * list, the default configuration, (without
 			 * get_last_path_component()) lets the user force use of an
 			 * external command by specifying the full (with slashes) filename.
 			 * If you enable BB_FEATURE_SH_APPLETS_ALWAYS_WIN, then applets
 			 * _aways_ override external commands, so if you want to run
 			 * /bin/cat, it will use BusyBox cat even if /bin/cat exists on the
 			 * filesystem and is _not_ busybox.  Some systems may want this,
 			 * most do not.  */
 			name = get_last_path_component(name);
 #endif
 			/* Count argc for use in a second... */
 			for(argc_l=0;*argv_l!=NULL; argv_l++, argc_l++);
 			optind = 1;
 			debug_printf("running applet %s\n", name);
 			run_applet_by_name(name, argc_l, child->argv);
 		}
 #endif
 		debug_printf("exec of %s\n",child->argv[0]);
 		execvp(child->argv[0],child->argv);
 		perror_msg("couldn't exec: %s",child->argv[0]);
 		exit(1);
 	} else if (child->group) {
 		debug_printf("runtime nesting to group\n");
 		interactive=0;    /* crucial!!!! */
 		rcode = run_list_real(child->group);
 		/* OK to leak memory by not calling run_list_test,
 		 * since this process is about to exit */
 		exit(rcode);
 	} else {
 		/* Can happen.  See what bash does with ">foo" by itself. */
 		debug_printf("trying to pseudo_exec null command\n");
 		exit(EXIT_SUCCESS);
 	}
 }
 
 static void insert_bg_job(struct pipe *pi)
 {
 	struct pipe *thejob;
 
 	/* Linear search for the ID of the job to use */
 	pi->jobid = 1;
 	for (thejob = job_list->head; thejob; thejob = thejob->next)
 		if (thejob->jobid >= pi->jobid)
 			pi->jobid = thejob->jobid + 1;
 
 	/* add thejob to the list of running jobs */
 	if (!job_list->head) {
 		thejob = job_list->head = xmalloc(sizeof(*thejob));
 	} else {
 		for (thejob = job_list->head; thejob->next; thejob = thejob->next) /* nothing */;
 		thejob->next = xmalloc(sizeof(*thejob));
 		thejob = thejob->next;
 	}
 
 	/* physically copy the struct job */
 	memcpy(thejob, pi, sizeof(struct pipe));
 	thejob->next = NULL;
 	thejob->running_progs = thejob->num_progs;
 	thejob->stopped_progs = 0;
 	thejob->text = xmalloc(BUFSIZ); /* cmdedit buffer size */
 
 	//if (pi->progs[0] && pi->progs[0].argv && pi->progs[0].argv[0])
 	{
 		char *bar=thejob->text;
 		char **foo=pi->progs[0].argv;
 		while(foo && *foo) {
 			bar += sprintf(bar, "%s ", *foo++);
 		}
 	}
 
 	/* we don't wait for background thejobs to return -- append it 
 	   to the list of backgrounded thejobs and leave it alone */
 	printf("[%d] %d\n", thejob->jobid, thejob->progs[0].pid);
 	last_bg_pid = thejob->progs[0].pid;
 }
 
 /* remove a backgrounded job from a jobset */
 static void remove_bg_job(struct pipe *pi)
 {
 	struct pipe *prev_pipe;
 
 	if (pi == job_list->head) {
 		job_list->head = pi->next;
 	} else {
 		prev_pipe = job_list->head;
 		while (prev_pipe->next != pi)
 			prev_pipe = prev_pipe->next;
 		prev_pipe->next = pi->next;
 	}
 
 	free_pipe(pi);
 	free(pi);
 }
 
 /* free up all memory from a pipe */
 static void free_pipe(struct pipe *pi)
 {
 	int i;
 
 	for (i = 0; i < pi->num_progs; i++) {
 		free(pi->progs[i].argv);
 		if (pi->progs[i].redirects)
 			free(pi->progs[i].redirects);
 	}
 	if (pi->progs)
 		free(pi->progs);
 	if (pi->text)
 		free(pi->text);
 	if (pi->cmdbuf)
 		free(pi->cmdbuf);
 	memset(pi, 0, sizeof(struct pipe));
 }
 
 
 /* Checks to see if any background processes have exited -- if they 
    have, figure out why and see if a job has completed */
 static void checkjobs()
 {
 	int status, ctty;
 	int prognum = 0;
 	struct pipe *pi;
 	pid_t childpid;
 
 	while ((childpid = waitpid(-1, &status, WNOHANG | WUNTRACED)) > 0) {
 		for (pi = job_list->head; pi; pi = pi->next) {
 			prognum = 0;
 			while (prognum < pi->num_progs &&
 				   pi->progs[prognum].pid != childpid) prognum++;
 			if (prognum < pi->num_progs)
 				break;
 		}
 
 		if (WIFEXITED(status) || WIFSIGNALED(status)) {
 			/* child exited */
 			pi->running_progs--;
 			pi->progs[prognum].pid = 0;
 
 			if (!pi->running_progs) {
 				printf(JOB_STATUS_FORMAT, pi->jobid, "Done", pi->text);
 				remove_bg_job(pi);
 			}
 		} else {
 			if(pi==NULL)
 				break;
 			/* child stopped */
 			pi->stopped_progs++;
 			pi->progs[prognum].is_stopped = 1;
 
 			if (pi->stopped_progs == pi->num_progs) {
 				printf(JOB_STATUS_FORMAT, pi->jobid, "Stopped", pi->text);
 			}
 		}
 	}
 
 	if (childpid == -1 && errno != ECHILD)
 		perror_msg("waitpid");
 
 	/* move the shell to the foreground */
 	if (interactive && (ctty=controlling_tty(0))!=-1) {
 		if (tcsetpgrp(ctty, getpgrp()))
 			perror_msg("tcsetpgrp-2");
 	}
 }
 
 /* Figure out our controlling tty, checking in order stderr,
  * stdin, and stdout.  If check_pgrp is set, also check that
  * we belong to the foreground process group associated with
  * that tty.  The value of ctty is needed in order to call
  * tcsetpgrp(ctty, ...); */
 int controlling_tty(int check_pgrp)
 {
 	pid_t curpgrp;
 	int ctty;
 
 	if ((curpgrp = tcgetpgrp(ctty = 2)) < 0
 		&& (curpgrp = tcgetpgrp(ctty = 0)) < 0
 		&& (curpgrp = tcgetpgrp(ctty = 1)) < 0)
 		return errno = ENOTTY, -1;
 
 	if (check_pgrp && curpgrp != getpgrp())
 		return errno = EPERM, -1;
 
 	return ctty;
 }
 
 /* run_pipe_real() starts all the jobs, but doesn't wait for anything
  * to finish.  See pipe_wait().
  *
  * return code is normally -1, when the caller has to wait for children
  * to finish to determine the exit status of the pipe.  If the pipe
  * is a simple builtin command, however, the action is done by the
  * time run_pipe_real returns, and the exit code is provided as the
  * return value.
  *
  * The input of the pipe is always stdin, the output is always
  * stdout.  The outpipe[] mechanism in BusyBox-0.48 lash is bogus,
  * because it tries to avoid running the command substitution in
  * subshell, when that is in fact necessary.  The subshell process
  * now has its stdout directed to the input of the appropriate pipe,
  * so this routine is noticeably simpler.
  */
 static int run_pipe_real(struct pipe *pi)
 {
 	int i;
 	int ctty;
 	int nextin, nextout;
 	int pipefds[2];				/* pipefds[0] is for reading */
 	struct child_prog *child;
 	struct built_in_command *x;
 
 	ctty = -1;
 	nextin = 0;
 	pi->pgrp = -1;
 
 	/* Check if we are supposed to run in the foreground */
 	if (interactive && pi->followup!=PIPE_BG) {
 		if ((ctty = controlling_tty(pi->pgrp<0)) < 0) return -1;
 	}
 
 	/* Check if this is a simple builtin (not part of a pipe).
 	 * Builtins within pipes have to fork anyway, and are handled in
 	 * pseudo_exec.  "echo foo | read bar" doesn't work on bash, either.
 	 */
 	if (pi->num_progs == 1 && pi->progs[0].argv != NULL) {
 		child = & (pi->progs[0]);
 		if (child->group && ! child->subshell) {
 			int squirrel[] = {-1, -1, -1};
 			int rcode;
 			debug_printf("non-subshell grouping\n");
 			setup_redirects(child, squirrel);
 			/* XXX could we merge code with following builtin case,
 			 * by creating a pseudo builtin that calls run_list_real? */
 			rcode = run_list_real(child->group);
 			restore_redirects(squirrel);
 			return rcode;
 		}
 		for (i=0; is_assignment(child->argv[i]); i++) { /* nothing */ }
 		if (i!=0 && child->argv[i]==NULL) {
 			/* assignments, but no command: set the local environment */
 			for (i=0; child->argv[i]!=NULL; i++) {
 				set_local_var(child->argv[i], 0);
 			}
 			return EXIT_SUCCESS;   /* don't worry about errors in set_local_var() yet */
 		}
 		for (x = bltins; x->cmd; x++) {
 			if (strcmp(child->argv[i], x->cmd) == 0 ) {
 				int squirrel[] = {-1, -1, -1};
 				int rcode;
 				if (x->function == builtin_exec && child->argv[i+1]==NULL) {
 					debug_printf("magic exec\n");
 					setup_redirects(child,NULL);
 					return EXIT_SUCCESS;
 				}
 				debug_printf("builtin inline %s\n", child->argv[0]);
 				/* XXX setup_redirects acts on file descriptors, not FILEs.
 				 * This is perfect for work that comes after exec().
 				 * Is it really safe for inline use?  Experimentally,
 				 * things seem to work with glibc. */
 				setup_redirects(child, squirrel);
 				for (i=0; is_assignment(child->argv[i]); i++) {
 					putenv(strdup(child->argv[i]));
 				}
 				child->argv+=i;  /* XXX horrible hack */
 				rcode = x->function(child);
 				child->argv-=i;  /* XXX restore hack so free() can work right */
 				restore_redirects(squirrel);
 				return rcode;
 			}
 		}
 	}
 
 	for (i = 0; i < pi->num_progs; i++) {
 		child = & (pi->progs[i]);
 
 		/* pipes are inserted between pairs of commands */
 		if ((i + 1) < pi->num_progs) {
 			if (pipe(pipefds)<0) perror_msg_and_die("pipe");
 			nextout = pipefds[1];
 		} else {
 			nextout=1;
 			pipefds[0] = -1;
 		}
 
 		/* XXX test for failed fork()? */
 		if (!(child->pid = fork())) {
 
 			signal(SIGTTOU, SIG_DFL);
 			
 			close_all();
 
 			if (nextin != 0) {
 				dup2(nextin, 0);
 				close(nextin);
 			}
 			if (nextout != 1) {
 				dup2(nextout, 1);
 				close(nextout);
 			}
 			if (pipefds[0]!=-1) {
 				close(pipefds[0]);  /* opposite end of our output pipe */
 			}
 
 			/* Like bash, explicit redirects override pipes,
 			 * and the pipe fd is available for dup'ing. */
 			setup_redirects(child,NULL);
 			
 			if (interactive && pi->followup!=PIPE_BG) {
 				/* If we (the child) win the race, put ourselves in the process
 				 * group whose leader is the first process in this pipe. */
 				if (pi->pgrp < 0) {
 					pi->pgrp = getpid();
 				}
 				if (setpgid(0, pi->pgrp) == 0) {
 					signal(SIGTTOU, SIG_IGN);
 					tcsetpgrp(ctty, pi->pgrp);
 					signal(SIGTTOU, SIG_DFL);
 				}
 			}
 
 			pseudo_exec(child);
 		}
 		/* Put our child in the process group whose leader is the
 		 * first process in this pipe. */
 		if (pi->pgrp < 0) {
 			pi->pgrp = child->pid;
 		}
 		/* Don't check for errors.  The child may be dead already,
 		 * in which case setpgid returns error code EACCES. */
 		setpgid(child->pid, pi->pgrp);
 
 		if (nextin != 0)
 			close(nextin);
 		if (nextout != 1)
 			close(nextout);
 
 		/* If there isn't another process, nextin is garbage 
 		   but it doesn't matter */
 		nextin = pipefds[0];
 	}
 	return -1;
 }
 
 static int run_list_real(struct pipe *pi)
 {
 	int rcode=0;
 	int if_code=0, next_if_code=0;  /* need double-buffer to handle elif */
 	reserved_style rmode, skip_more_in_this_rmode=RES_XXXX;
 	for (;pi;pi=pi->next) {
 		rmode = pi->r_mode;
 		debug_printf("rmode=%d  if_code=%d  next_if_code=%d skip_more=%d\n", rmode, if_code, next_if_code, skip_more_in_this_rmode);
 		if (rmode == skip_more_in_this_rmode) continue;
 		skip_more_in_this_rmode = RES_XXXX;
 		if (rmode == RES_THEN || rmode == RES_ELSE) if_code = next_if_code;
 		if (rmode == RES_THEN &&  if_code) continue;
 		if (rmode == RES_ELSE && !if_code) continue;
 		if (rmode == RES_ELIF && !if_code) continue;
 		if (pi->num_progs == 0) continue;
 		rcode = run_pipe_real(pi);
 		if (rcode!=-1) {
 			/* We only ran a builtin: rcode was set by the return value
 			 * of run_pipe_real(), and we don't need to wait for anything. */
 		} else if (pi->followup==PIPE_BG) {
 			/* XXX check bash's behavior with nontrivial pipes */
 			/* XXX compute jobid */
 			/* XXX what does bash do with attempts to background builtins? */
 			insert_bg_job(pi);
 			rcode = EXIT_SUCCESS;
 		} else {
 
 			if (interactive) {
 				/* move the new process group into the foreground */
 				/* suppress messages when run from /linuxrc mag@sysgo.de */
 				/* XXX probably this "0" should come from controlling_tty() */
 				if (tcsetpgrp(0, pi->pgrp) && errno != ENOTTY)
 					perror_msg("tcsetpgrp-3");
 				rcode = pipe_wait(pi);
 				if (tcsetpgrp(0, getpgrp()) && errno != ENOTTY)
 					perror_msg("tcsetpgrp-4");
 			} else {
 				rcode = pipe_wait(pi);
 				debug_printf("pipe_wait returned %d\n",rcode);
 			}
 		}
 		last_return_code=rcode;
 		if ( rmode == RES_IF || rmode == RES_ELIF )
 			next_if_code=rcode;  /* can be overwritten a number of times */
 		if ( (rcode==EXIT_SUCCESS && pi->followup==PIPE_OR) ||
 		     (rcode!=EXIT_SUCCESS && pi->followup==PIPE_AND) )
 			skip_more_in_this_rmode=rmode;
 	}
 	checkjobs();
 	return rcode;
 }
 
 /* broken, of course, but OK for testing */
 static char *indenter(int i)
 {
 	static char blanks[]="                                    ";
 	return &blanks[sizeof(blanks)-i-1];
 }
 
 /* return code is the exit status of the pipe */
 static int run_pipe_test(struct pipe *pi, int indent)
 {
 	char **p;
 	struct child_prog *child;
 	struct redir_struct *r, *rnext;
 	int a, i, ret_code=0;
 	char *ind = indenter(indent);
 	final_printf("%s run pipe: (pid %d)\n",ind,getpid());
 	for (i=0; i<pi->num_progs; i++) {
 		child = &pi->progs[i];
 		final_printf("%s  command %d:\n",ind,i);
 		if (child->argv) {
 			for (a=0,p=child->argv; *p; a++,p++) {
 				final_printf("%s   argv[%d] = %s\n",ind,a,*p);
 			}
 			globfree(&child->glob_result);
 			child->argv=NULL;
 		} else if (child->group) {
 			final_printf("%s   begin group (subshell:%d)\n",ind, child->subshell);
 			ret_code = run_list_test(child->group,indent+3);
 			final_printf("%s   end group\n",ind);
 		} else {
 			final_printf("%s   (nil)\n",ind);
 		}
 		for (r=child->redirects; r; r=rnext) {
 			final_printf("%s   redirect %d%s", ind, r->fd, redir_table[r->type].descrip);
 			if (r->dup == -1) {
 				final_printf(" %s\n", *r->word.gl_pathv);
 				globfree(&r->word);
 			} else {
 				final_printf("&%d\n", r->dup);
 			}
 			rnext=r->next;
 			free(r);
 		}
 		child->redirects=NULL;
 	}
 	free(pi->progs);   /* children are an array, they get freed all at once */
 	pi->progs=NULL;
 	return ret_code;
 }
 
 static int run_list_test(struct pipe *head, int indent)
 {
 	int rcode=0;   /* if list has no members */
 	struct pipe *pi, *next;
 	char *ind = indenter(indent);
 	for (pi=head; pi; pi=next) {
 		if (pi->num_progs == 0) break;
 		final_printf("%s pipe reserved mode %d\n", ind, pi->r_mode);
 		rcode = run_pipe_test(pi, indent);
 		final_printf("%s pipe followup code %d\n", ind, pi->followup);
 		next=pi->next;
 		pi->next=NULL;
 		free(pi);
 	}
 	return rcode;	
 }
 
 /* Select which version we will use */
 static int run_list(struct pipe *pi)
 {
 	int rcode=0;
 	if (fake_mode==0) {
 		rcode = run_list_real(pi);
 	} 
 	/* run_list_test has the side effect of clearing memory
 	 * In the long run that function can be merged with run_list_real,
 	 * but doing that now would hobble the debugging effort. */
 	run_list_test(pi,0);
 	return rcode;
 }
 
 /* The API for glob is arguably broken.  This routine pushes a non-matching
  * string into the output structure, removing non-backslashed backslashes.
  * If someone can prove me wrong, by performing this function within the
  * original glob(3) api, feel free to rewrite this routine into oblivion.
  * Return code (0 vs. GLOB_NOSPACE) matches glob(3).
  * XXX broken if the last character is '\\', check that before calling.
  */
 static int globhack(const char *src, int flags, glob_t *pglob)
 {
 	int cnt, pathc;
 	const char *s;
 	char *dest;
 	for (cnt=1, s=src; *s; s++) {
 		if (*s == '\\') s++;
 		cnt++;
 	}
 	dest = malloc(cnt);
 	if (!dest) return GLOB_NOSPACE;
 	if (!(flags & GLOB_APPEND)) {
 		pglob->gl_pathv=NULL;
 		pglob->gl_pathc=0;
 		pglob->gl_offs=0;
 		pglob->gl_offs=0;
 	}
 	pathc = ++pglob->gl_pathc;
 	pglob->gl_pathv = realloc(pglob->gl_pathv, (pathc+1)*sizeof(*pglob->gl_pathv));
 	if (pglob->gl_pathv == NULL) return GLOB_NOSPACE;
 	pglob->gl_pathv[pathc-1]=dest;
 	pglob->gl_pathv[pathc]=NULL;
 	for (s=src; *s; s++, dest++) {
 		if (*s == '\\') s++;
 		*dest = *s;
 	}
 	*dest='\0';
 	return 0;
 }
 
 /* XXX broken if the last character is '\\', check that before calling */
 static int glob_needed(const char *s)
 {
 	for (; *s; s++) {
 		if (*s == '\\') s++;
 		if (strchr("*[?",*s)) return 1;
 	}
 	return 0;
 }
 
 #if 0
 static void globprint(glob_t *pglob)
 {
 	int i;
 	debug_printf("glob_t at %p:\n", pglob);
 	debug_printf("  gl_pathc=%d  gl_pathv=%p  gl_offs=%d  gl_flags=%d\n",
 		pglob->gl_pathc, pglob->gl_pathv, pglob->gl_offs, pglob->gl_flags);
 	for (i=0; i<pglob->gl_pathc; i++)
 		debug_printf("pglob->gl_pathv[%d] = %p = %s\n", i,
 			pglob->gl_pathv[i], pglob->gl_pathv[i]);
 }
 #endif
 
 static int xglob(o_string *dest, int flags, glob_t *pglob)
 {
 	int gr;
 
  	/* short-circuit for null word */
 	/* we can code this better when the debug_printf's are gone */
  	if (dest->length == 0) {
  		if (dest->nonnull) {
  			/* bash man page calls this an "explicit" null */
  			gr = globhack(dest->data, flags, pglob);
  			debug_printf("globhack returned %d\n",gr);
  		} else {
 			return 0;
 		}
  	} else if (glob_needed(dest->data)) {
 		gr = glob(dest->data, flags, NULL, pglob);
 		debug_printf("glob returned %d\n",gr);
 		if (gr == GLOB_NOMATCH) {
 			/* quote removal, or more accurately, backslash removal */
 			gr = globhack(dest->data, flags, pglob);
 			debug_printf("globhack returned %d\n",gr);
 		}
 	} else {
 		gr = globhack(dest->data, flags, pglob);
 		debug_printf("globhack returned %d\n",gr);
 	}
 	if (gr == GLOB_NOSPACE)
 		error_msg_and_die("out of memory during glob");
 	if (gr != 0) { /* GLOB_ABORTED ? */
 		error_msg("glob(3) error %d",gr);
 	}
 	/* globprint(glob_target); */
 	return gr;
 }
 
 /* This is used to get/check local shell variables */
 static char *get_local_var(const char *s)
 {
 	struct variables *cur;
 
 	if (!s)
 		return NULL;
 	for (cur = top_vars; cur; cur=cur->next)
 		if(strcmp(cur->name, s)==0)
 			return cur->value;
 	return NULL;
 }
 
 /* This is used to set local shell variables
    flg_export==0 if only local (not exporting) variable
    flg_export==1 if "new" exporting environ
    flg_export>1  if current startup environ (not call putenv()) */
 static int set_local_var(const char *s, int flg_export)
 {
 	char *name, *value;
 	int result=0;
 	struct variables *cur;
 	char *newval = 0;
 
 	name=strdup(s);
 
 	/* Assume when we enter this function that we are already in
 	 * NAME=VALUE format.  So the first order of business is to
 	 * split 's' on the '=' into 'name' and 'value' */ 
 	value = strchr(name, '=');
 	if (value==0 || (newval = strdup(value+1))==0) {
 		result = -1;
 	} else {
 		*value++ = 0;
 
 		for(cur = top_vars; cur; cur = cur->next)
 			if(strcmp(cur->name, name)==0)
 			break;
 
 		if(cur) {
 			if(strcmp(cur->value, value)==0) {
 				result = cur->flg_export == flg_export;
 			} else {
 				if(cur->flg_read_only) {
 			result = -1;
 					error_msg("%s: readonly variable", name);
 				} else {
 					free(cur->value);
 					cur->value = newval;
 					newval = 0; /* protect free */
 		}
 	}
 		} else {
 			cur = malloc(sizeof(struct variables));
 			if(cur==0) {
 				result = -1;
 			} else {
 				cur->name = strdup(name);
 				if(cur->name == 0) {
 					free(cur);
 				result = -1;
 				} else {
 					struct variables *bottom = top_vars;
 
 					cur->value = newval;
 					newval = 0;     /* protect free */
 					cur->next = 0;
 					cur->flg_export = flg_export;
 					cur->flg_read_only = 0;
 					while(bottom->next) bottom=bottom->next;
 					bottom->next = cur;
 			}
 		}
 	}
 	}
 
 	if((result==0 && flg_export==1) || (result>0 && cur->flg_export>0)) {
 		*(value-1) = '=';
 		result = putenv(name);
 	} else {
 	free(name);
 		if(result>0)            /* equivalent to previous set */
 			result = 0;
 	}
 	free(newval);
 	return result;
 }
 
 static void unset_local_var(const char *name)
 {
 	struct variables *cur;
 
 	if (name) {
 		for (cur = top_vars; cur; cur=cur->next)
 			if(strcmp(cur->name, name)==0)
 				break;
 		if(cur!=0) {
 			struct variables *next = top_vars;
 			if(cur==next)
 		return;
 			else {
 				if(cur->flg_export)
 					unsetenv(cur->name);
 				free(cur->name);
 				free(cur->value);
 				while (next->next != cur)
 					next = next->next;
 				next->next = cur->next;
 			}
 			free(cur);
 		}
 	}
 }
 
 static int is_assignment(const char *s)
 {
 	if (s==NULL || !isalpha(*s)) return 0;
 	++s;
 	while(isalnum(*s) || *s=='_') ++s;
 	return *s=='=';
 }
 
 /* the src parameter allows us to peek forward to a possible &n syntax
  * for file descriptor duplication, e.g., "2>&1".
  * Return code is 0 normally, 1 if a syntax error is detected in src.
  * Resource errors (in xmalloc) cause the process to exit */
 static int setup_redirect(struct p_context *ctx, int fd, redir_type style,
 	struct in_str *input)
 {
 	struct child_prog *child=ctx->child;
 	struct redir_struct *redir = child->redirects;
 	struct redir_struct *last_redir=NULL;
 
 	/* Create a new redir_struct and drop it onto the end of the linked list */
 	while(redir) {
 		last_redir=redir;
 		redir=redir->next;
 	}
 	redir = xmalloc(sizeof(struct redir_struct));
 	redir->next=NULL;
 	if (last_redir) {
 		last_redir->next=redir;
 	} else {
 		child->redirects=redir;
 	}
 
 	redir->type=style;
 	redir->fd= (fd==-1) ? redir_table[style].default_fd : fd ;
 
 	debug_printf("Redirect type %d%s\n", redir->fd, redir_table[style].descrip);
 
 	/* Check for a '2>&1' type redirect */ 
 	redir->dup = redirect_dup_num(input);
 	if (redir->dup == -2) return 1;  /* syntax error */
 	if (redir->dup != -1) {
 		/* Erik had a check here that the file descriptor in question
 		 * is legit; I postpone that to "run time"
 		 * A "-" representation of "close me" shows up as a -3 here */
 		debug_printf("Duplicating redirect '%d>&%d'\n", redir->fd, redir->dup);
 	} else {
 		/* We do _not_ try to open the file that src points to,
 		 * since we need to return and let src be expanded first.
 		 * Set ctx->pending_redirect, so we know what to do at the
 		 * end of the next parsed word.
 		 */
 		ctx->pending_redirect = redir;
 	}
 	return 0;
 }
 
 struct pipe *new_pipe(void) {
 	struct pipe *pi;
 	pi = xmalloc(sizeof(struct pipe));
 	pi->num_progs = 0;
 	pi->progs = NULL;
 	pi->next = NULL;
 	pi->followup = 0;  /* invalid */
 	return pi;
 }
 
 static void initialize_context(struct p_context *ctx)
 {
 	ctx->pipe=NULL;
 	ctx->pending_redirect=NULL;
 	ctx->child=NULL;
 	ctx->list_head=new_pipe();
 	ctx->pipe=ctx->list_head;
 	ctx->w=RES_NONE;
 	ctx->stack=NULL;
 	done_command(ctx);   /* creates the memory for working child */
 }
 
 /* normal return is 0
  * if a reserved word is found, and processed, return 1
  * should handle if, then, elif, else, fi, for, while, until, do, done.
  * case, function, and select are obnoxious, save those for later.
  */
 int reserved_word(o_string *dest, struct p_context *ctx)
 {
 	struct reserved_combo {
 		char *literal;
 		int code;
 		long flag;
 	};
 	/* Mostly a list of accepted follow-up reserved words.
 	 * FLAG_END means we are done with the sequence, and are ready
 	 * to turn the compound list into a command.
 	 * FLAG_START means the word must start a new compound list.
 	 */
 	static struct reserved_combo reserved_list[] = {
 		{ "if",    RES_IF,    FLAG_THEN | FLAG_START },
 		{ "then",  RES_THEN,  FLAG_ELIF | FLAG_ELSE | FLAG_FI },
 		{ "elif",  RES_ELIF,  FLAG_THEN },
 		{ "else",  RES_ELSE,  FLAG_FI   },
 		{ "fi",    RES_FI,    FLAG_END  },
 		{ "for",   RES_FOR,   FLAG_DO   | FLAG_START },
 		{ "while", RES_WHILE, FLAG_DO   | FLAG_START },
 		{ "until", RES_UNTIL, FLAG_DO   | FLAG_START },
 		{ "do",    RES_DO,    FLAG_DONE },
 		{ "done",  RES_DONE,  FLAG_END  }
 	};
 	struct reserved_combo *r;
 	for (r=reserved_list;
 #define NRES sizeof(reserved_list)/sizeof(struct reserved_combo)
 		r<reserved_list+NRES; r++) {
 		if (strcmp(dest->data, r->literal) == 0) {
 			debug_printf("found reserved word %s, code %d\n",r->literal,r->code);
 			if (r->flag & FLAG_START) {
 				struct p_context *new = xmalloc(sizeof(struct p_context));
 				debug_printf("push stack\n");
 				*new = *ctx;   /* physical copy */
 				initialize_context(ctx);
 				ctx->stack=new;
 			} else if ( ctx->w == RES_NONE || ! (ctx->old_flag & (1<<r->code))) {
 				syntax();
 				ctx->w = RES_SNTX;
 				b_reset (dest);
 				return 1;
 			}
 			ctx->w=r->code;
 			ctx->old_flag = r->flag;
 			if (ctx->old_flag & FLAG_END) {
 				struct p_context *old;
 				debug_printf("pop stack\n");
 				old = ctx->stack;
 				old->child->group = ctx->list_head;
 				*ctx = *old;   /* physical copy */
 				free(old);
 			}
 			b_reset (dest);
 			return 1;
 		}
 	}
 	return 0;
 }
 
 /* normal return is 0.
  * Syntax or xglob errors return 1. */
 static int done_word(o_string *dest, struct p_context *ctx)
 {
 	struct child_prog *child=ctx->child;
 	glob_t *glob_target;
 	int gr, flags = 0;
 
 	debug_printf("done_word: %s %p\n", dest->data, child);
 	if (dest->length == 0 && !dest->nonnull) {
 		debug_printf("  true null, ignored\n");
 		return 0;
 	}
 	if (ctx->pending_redirect) {
 		glob_target = &ctx->pending_redirect->word;
 	} else {
 		if (child->group) {
 			syntax();
 			return 1;  /* syntax error, groups and arglists don't mix */
 		}
 		if (!child->argv) {
 			debug_printf("checking %s for reserved-ness\n",dest->data);
 			if (reserved_word(dest,ctx)) return ctx->w==RES_SNTX;
 		}
 		glob_target = &child->glob_result;
  		if (child->argv) flags |= GLOB_APPEND;
 	}
 	gr = xglob(dest, flags, glob_target);
 	if (gr != 0) return 1;
 
 	b_reset(dest);
 	if (ctx->pending_redirect) {
 		ctx->pending_redirect=NULL;
 		if (glob_target->gl_pathc != 1) {
 			error_msg("ambiguous redirect");
 			return 1;
 		}
 	} else {
 		child->argv = glob_target->gl_pathv;
 	}
 	return 0;
 }
 
 /* The only possible error here is out of memory, in which case
  * xmalloc exits. */
 static int done_command(struct p_context *ctx)
 {
 	/* The child is really already in the pipe structure, so
 	 * advance the pipe counter and make a new, null child.
 	 * Only real trickiness here is that the uncommitted
 	 * child structure, to which ctx->child points, is not
 	 * counted in pi->num_progs. */
 	struct pipe *pi=ctx->pipe;
 	struct child_prog *prog=ctx->child;
 
 	if (prog && prog->group == NULL
 	         && prog->argv == NULL
 	         && prog->redirects == NULL) {
 		debug_printf("done_command: skipping null command\n");
 		return 0;
 	} else if (prog) {
 		pi->num_progs++;
 		debug_printf("done_command: num_progs incremented to %d\n",pi->num_progs);
 	} else {
 		debug_printf("done_command: initializing\n");
 	}
 	pi->progs = xrealloc(pi->progs, sizeof(*pi->progs) * (pi->num_progs+1));
 
 	prog = pi->progs + pi->num_progs;
 	prog->redirects = NULL;
 	prog->argv = NULL;
 	prog->is_stopped = 0;
 	prog->group = NULL;
 	prog->glob_result.gl_pathv = NULL;
 	prog->family = pi;
 
 	ctx->child=prog;
 	/* but ctx->pipe and ctx->list_head remain unchanged */
 	return 0;
 }
 
 static int done_pipe(struct p_context *ctx, pipe_style type)
 {
 	struct pipe *new_p;
 	done_command(ctx);  /* implicit closure of previous command */
 	debug_printf("done_pipe, type %d\n", type);
 	ctx->pipe->followup = type;
 	ctx->pipe->r_mode = ctx->w;
 	new_p=new_pipe();
 	ctx->pipe->next = new_p;
 	ctx->pipe = new_p;
 	ctx->child = NULL;
 	done_command(ctx);  /* set up new pipe to accept commands */
 	return 0;
 }
 
 /* peek ahead in the in_str to find out if we have a "&n" construct,
  * as in "2>&1", that represents duplicating a file descriptor.
  * returns either -2 (syntax error), -1 (no &), or the number found.
  */
 static int redirect_dup_num(struct in_str *input)
 {
 	int ch, d=0, ok=0;
 	ch = b_peek(input);
 	if (ch != '&') return -1;
 
 	b_getch(input);  /* get the & */
 	ch=b_peek(input);
 	if (ch == '-') {
 		b_getch(input);
 		return -3;  /* "-" represents "close me" */
 	}
 	while (isdigit(ch)) {
 		d = d*10+(ch-'0');
 		ok=1;
 		b_getch(input);
 		ch = b_peek(input);
 	}
 	if (ok) return d;
 
 	error_msg("ambiguous redirect");
 	return -2;
 }
 
 /* If a redirect is immediately preceded by a number, that number is
  * supposed to tell which file descriptor to redirect.  This routine
  * looks for such preceding numbers.  In an ideal world this routine
  * needs to handle all the following classes of redirects...
  *     echo 2>foo     # redirects fd  2 to file "foo", nothing passed to echo
  *     echo 49>foo    # redirects fd 49 to file "foo", nothing passed to echo
  *     echo -2>foo    # redirects fd  1 to file "foo",    "-2" passed to echo
  *     echo 49x>foo   # redirects fd  1 to file "foo",   "49x" passed to echo
  * A -1 output from this program means no valid number was found, so the
  * caller should use the appropriate default for this redirection.
  */
 static int redirect_opt_num(o_string *o)
 {
 	int num;
 
 	if (o->length==0) return -1;
 	for(num=0; num<o->length; num++) {
 		if (!isdigit(*(o->data+num))) {
 			return -1;
 		}
 	}
 	/* reuse num (and save an int) */
 	num=atoi(o->data);
 	b_reset(o);
 	return num;
 }
 
 FILE *generate_stream_from_list(struct pipe *head)
 {
 	FILE *pf;
 #if 1
 	int pid, channel[2];
 	if (pipe(channel)<0) perror_msg_and_die("pipe");
 	pid=fork();
 	if (pid<0) {
 		perror_msg_and_die("fork");
 	} else if (pid==0) {
 		close(channel[0]);
 		if (channel[1] != 1) {
 			dup2(channel[1],1);
 			close(channel[1]);
 		}
 #if 0
 #define SURROGATE "surrogate response"
 		write(1,SURROGATE,sizeof(SURROGATE));
 		exit(run_list(head));
 #else
 		exit(run_list_real(head));   /* leaks memory */
 #endif
 	}
 	debug_printf("forked child %d\n",pid);
 	close(channel[1]);
 	pf = fdopen(channel[0],"r");
 	debug_printf("pipe on FILE *%p\n",pf);
 #else
 	run_list_test(head,0);
 	pf=popen("echo surrogate response","r");
 	debug_printf("started fake pipe on FILE *%p\n",pf);
 #endif
 	return pf;
 }
 
 /* this version hacked for testing purposes */
 /* return code is exit status of the process that is run. */
 static int process_command_subs(o_string *dest, struct p_context *ctx, struct in_str *input, int subst_end)
 {
 	int retcode;
 	o_string result=NULL_O_STRING;
 	struct p_context inner;
 	FILE *p;
 	struct in_str pipe_str;
 	initialize_context(&inner);
 
 	/* recursion to generate command */
 	retcode = parse_stream(&result, &inner, input, subst_end);
 	if (retcode != 0) return retcode;  /* syntax error or EOF */
 	done_word(&result, &inner);
 	done_pipe(&inner, PIPE_SEQ);
 	b_free(&result);
 
 	p=generate_stream_from_list(inner.list_head);
 	if (p==NULL) return 1;
 	mark_open(fileno(p));
 	setup_file_in_str(&pipe_str, p);
 
 	/* now send results of command back into original context */
 	retcode = parse_stream(dest, ctx, &pipe_str, '\0');
 	/* XXX In case of a syntax error, should we try to kill the child?
 	 * That would be tough to do right, so just read until EOF. */
 	if (retcode == 1) {
 		while (b_getch(&pipe_str)!=EOF) { /* discard */ };
 	}
 
 	debug_printf("done reading from pipe, pclose()ing\n");
 	/* This is the step that wait()s for the child.  Should be pretty
 	 * safe, since we just read an EOF from its stdout.  We could try
 	 * to better, by using wait(), and keeping track of background jobs
 	 * at the same time.  That would be a lot of work, and contrary
 	 * to the KISS philosophy of this program. */
 	mark_closed(fileno(p));
 	retcode=pclose(p);
 	debug_printf("pclosed, retcode=%d\n",retcode);
 	/* XXX this process fails to trim a single trailing newline */
 	return retcode;
 }
 
 static int parse_group(o_string *dest, struct p_context *ctx,
 	struct in_str *input, int ch)
 {
 	int rcode, endch=0;
 	struct p_context sub;
 	struct child_prog *child = ctx->child;
 	if (child->argv) {
 		syntax();
 		return 1;  /* syntax error, groups and arglists don't mix */
 	}
 	initialize_context(&sub);
 	switch(ch) {
 		case '(': endch=')'; child->subshell=1; break;
 		case '{': endch='}'; break;
 		default: syntax();   /* really logic error */
 	}
 	rcode=parse_stream(dest,&sub,input,endch);
 	done_word(dest,&sub); /* finish off the final word in the subcontext */
 	done_pipe(&sub, PIPE_SEQ);  /* and the final command there, too */
 	child->group = sub.list_head;
 	return rcode;
 	/* child remains "open", available for possible redirects */
 }
 
 /* basically useful version until someone wants to get fancier,
  * see the bash man page under "Parameter Expansion" */
 static void lookup_param(o_string *dest, struct p_context *ctx, o_string *src)
 {
 	const char *p=NULL;
 	if (src->data) { 
 		p = getenv(src->data);
 		if (!p) 
 			p = get_local_var(src->data);
 	}
 	if (p) parse_string(dest, ctx, p);   /* recursion */
 	b_free(src);
 }
 
 /* return code: 0 for OK, 1 for syntax error */
 static int handle_dollar(o_string *dest, struct p_context *ctx, struct in_str *input)
 {
 	int i, advance=0;
 	o_string alt=NULL_O_STRING;
 	char sep[]=" ";
 	int ch = input->peek(input);  /* first character after the $ */
 	debug_printf("handle_dollar: ch=%c\n",ch);
 	if (isalpha(ch)) {
 		while(ch=b_peek(input),isalnum(ch) || ch=='_') {
 			b_getch(input);
 			b_addchr(&alt,ch);
 		}
 		lookup_param(dest, ctx, &alt);
 	} else if (isdigit(ch)) {
 		i = ch-'0';  /* XXX is $0 special? */
 		if (i<global_argc) {
 			parse_string(dest, ctx, global_argv[i]); /* recursion */
 		}
 		advance = 1;
 	} else switch (ch) {
 		case '$':
 			b_adduint(dest,getpid());
 			advance = 1;
 			break;
 		case '!':
 			if (last_bg_pid > 0) b_adduint(dest, last_bg_pid);
 			advance = 1;
 			break;
 		case '?':
 			b_adduint(dest,last_return_code);
 			advance = 1;
 			break;
 		case '#':
 			b_adduint(dest,global_argc ? global_argc-1 : 0);
 			advance = 1;
 			break;
 		case '{':
 			b_getch(input);
 			/* XXX maybe someone will try to escape the '}' */
 			while(ch=b_getch(input),ch!=EOF && ch!='}') {
 				b_addchr(&alt,ch);
 			}
 			if (ch != '}') {
 				syntax();
 				return 1;
 			}
 			lookup_param(dest, ctx, &alt);
 			break;
 		case '(':
 			b_getch(input);
 			process_command_subs(dest, ctx, input, ')');
 			break;
 		case '*':
 			sep[0]=ifs[0];
 			for (i=1; i<global_argc; i++) {
 				parse_string(dest, ctx, global_argv[i]);
 				if (i+1 < global_argc) parse_string(dest, ctx, sep);
 			}
 			break;
 		case '@':
 		case '-':
 		case '_':
 			/* still unhandled, but should be eventually */
 			error_msg("unhandled syntax: $%c",ch);
 			return 1;
 			break;
 		default:
 			b_addqchr(dest,'$',dest->quote);
 	}
 	/* Eat the character if the flag was set.  If the compiler
 	 * is smart enough, we could substitute "b_getch(input);"
 	 * for all the "advance = 1;" above, and also end up with
 	 * a nice size-optimized program.  Hah!  That'll be the day.
 	 */
 	if (advance) b_getch(input);
 	return 0;
 }
 
 int parse_string(o_string *dest, struct p_context *ctx, const char *src)
 {
 	struct in_str foo;
 	setup_string_in_str(&foo, src);
 	return parse_stream(dest, ctx, &foo, '\0');
 }
 
 /* return code is 0 for normal exit, 1 for syntax error */
 int parse_stream(o_string *dest, struct p_context *ctx,
 	struct in_str *input, int end_trigger)
 {
 	unsigned int ch, m;
 	int redir_fd;
 	redir_type redir_style;
 	int next;
 
 	/* Only double-quote state is handled in the state variable dest->quote.
 	 * A single-quote triggers a bypass of the main loop until its mate is
 	 * found.  When recursing, quote state is passed in via dest->quote. */
 
 	debug_printf("parse_stream, end_trigger=%d\n",end_trigger);
 	while ((ch=b_getch(input))!=EOF) {
 		m = map[ch];
 		next = (ch == '\n') ? 0 : b_peek(input);
 		debug_printf("parse_stream: ch=%c (%d) m=%d quote=%d\n",
 			ch,ch,m,dest->quote);
 		if (m==0 || ((m==1 || m==2) && dest->quote)) {
 			b_addqchr(dest, ch, dest->quote);
 		} else {
 			if (m==2) {  /* unquoted IFS */
 				done_word(dest, ctx);
 				/* If we aren't performing a substitution, treat a newline as a
 				 * command separator.  */
 				if (end_trigger != '\0' && ch=='\n')
 					done_pipe(ctx,PIPE_SEQ);
 			}
 			if (ch == end_trigger && !dest->quote && ctx->w==RES_NONE) {
 				debug_printf("leaving parse_stream\n");
 				return 0;
 			}
 #if 0
 			if (ch=='\n') {
 				/* Yahoo!  Time to run with it! */
 				done_pipe(ctx,PIPE_SEQ);
 				run_list(ctx->list_head);
 				initialize_context(ctx);
 			}
 #endif
 			if (m!=2) switch (ch) {
 		case '#':
 			if (dest->length == 0 && !dest->quote) {
 				while(ch=b_peek(input),ch!=EOF && ch!='\n') { b_getch(input); }
 			} else {
 				b_addqchr(dest, ch, dest->quote);
 			}
 			break;
 		case '\\':
 			if (next == EOF) {
 				syntax();
 				return 1;
 			}
 			b_addqchr(dest, '\\', dest->quote);
 			b_addqchr(dest, b_getch(input), dest->quote);
 			break;
 		case '$':
 			if (handle_dollar(dest, ctx, input)!=0) return 1;
 			break;
 		case '\'':
 			dest->nonnull = 1;
 			while(ch=b_getch(input),ch!=EOF && ch!='\'') {
 				b_addchr(dest,ch);
 			}
 			if (ch==EOF) {
 				syntax();
 				return 1;
 			}
 			break;
 		case '"':
 			dest->nonnull = 1;
 			dest->quote = !dest->quote;
 			break;
 		case '`':
 			process_command_subs(dest, ctx, input, '`');
 			break;
 		case '>':
 			redir_fd = redirect_opt_num(dest);
 			done_word(dest, ctx);
 			redir_style=REDIRECT_OVERWRITE;
 			if (next == '>') {
 				redir_style=REDIRECT_APPEND;
 				b_getch(input);
 			} else if (next == '(') {
 				syntax();   /* until we support >(list) Process Substitution */
 				return 1;
 			}
 			setup_redirect(ctx, redir_fd, redir_style, input);
 			break;
 		case '<':
 			redir_fd = redirect_opt_num(dest);
 			done_word(dest, ctx);
 			redir_style=REDIRECT_INPUT;
 			if (next == '<') {
 				redir_style=REDIRECT_HEREIS;
 				b_getch(input);
 			} else if (next == '>') {
 				redir_style=REDIRECT_IO;
 				b_getch(input);
 			} else if (next == '(') {
 				syntax();   /* until we support <(list) Process Substitution */
 				return 1;
 			}
 			setup_redirect(ctx, redir_fd, redir_style, input);
 			break;
 		case ';':
 			done_word(dest, ctx);
 			done_pipe(ctx,PIPE_SEQ);
 			break;
 		case '&':
 			done_word(dest, ctx);
 			if (next=='&') {
 				b_getch(input);
 				done_pipe(ctx,PIPE_AND);
 			} else {
 				done_pipe(ctx,PIPE_BG);
 			}
 			break;
 		case '|':
 			done_word(dest, ctx);
 			if (next=='|') {
 				b_getch(input);
 				done_pipe(ctx,PIPE_OR);
 			} else {
 				/* we could pick up a file descriptor choice here
 				 * with redirect_opt_num(), but bash doesn't do it.
 				 * "echo foo 2| cat" yields "foo 2". */
 				done_command(ctx);
 			}
 			break;
 		case '(':
 		case '{':
 			if (parse_group(dest, ctx, input, ch)!=0) return 1;
 			break;
 		case ')':
 		case '}':
 			syntax();   /* Proper use of this character caught by end_trigger */
 			return 1;
 			break;
 		default:
 			syntax();   /* this is really an internal logic error */
 			return 1;
 			}
 		}
 	}
 	/* complain if quote?  No, maybe we just finished a command substitution
 	 * that was quoted.  Example:
 	 * $ echo "`cat foo` plus more" 
 	 * and we just got the EOF generated by the subshell that ran "cat foo"
 	 * The only real complaint is if we got an EOF when end_trigger != '\0',
 	 * that is, we were really supposed to get end_trigger, and never got
 	 * one before the EOF.  Can't use the standard "syntax error" return code,
 	 * so that parse_stream_outer can distinguish the EOF and exit smoothly. */
 	if (end_trigger != '\0') return -1;
 	return 0;
 }
 
 void mapset(const unsigned char *set, int code)
 {
 	const unsigned char *s;
 	for (s=set; *s; s++) map[*s] = code;
 }
 
 void update_ifs_map(void)
 {
 	/* char *ifs and char map[256] are both globals. */
 	ifs = getenv("IFS");
 	if (ifs == NULL) ifs=" \t\n";
 	/* Precompute a list of 'flow through' behavior so it can be treated
 	 * quickly up front.  Computation is necessary because of IFS.
 	 * Special case handling of IFS == " \t\n" is not implemented.
 	 * The map[] array only really needs two bits each, and on most machines
 	 * that would be faster because of the reduced L1 cache footprint.
 	 */
 	memset(map,0,256);        /* most characters flow through always */
 	mapset("\\$'\"`", 3);     /* never flow through */
 	mapset("<>;&|(){}#", 1);  /* flow through if quoted */
 	mapset(ifs, 2);           /* also flow through if quoted */
 }
 
 /* most recursion does not come through here, the exeception is
  * from builtin_source() */
 int parse_stream_outer(struct in_str *inp)
 {
 
 	struct p_context ctx;
 	o_string temp=NULL_O_STRING;
 	int rcode;
 	do {
 		initialize_context(&ctx);
 		update_ifs_map();
 		inp->promptmode=1;
 		rcode = parse_stream(&temp, &ctx, inp, '\n');
 		done_word(&temp, &ctx);
 		done_pipe(&ctx,PIPE_SEQ);
 		run_list(ctx.list_head);
 	} while (rcode != -1);   /* loop on syntax errors, return on EOF */
 	return 0;
 }
 
 static int parse_string_outer(const char *s)
 {
 	struct in_str input;
 	setup_string_in_str(&input, s);
 	return parse_stream_outer(&input);
 }
 
 static int parse_file_outer(FILE *f)
 {
 	int rcode;
 	struct in_str input;
 	setup_file_in_str(&input, f);
 	rcode = parse_stream_outer(&input);
 	return rcode;
 }
 
 
 /* I think Erik wrote this.  It looks imperfect at best */
 void grab_tty_control(void)
 {
 	pid_t initialpgrp;
 	do {
 		initialpgrp = tcgetpgrp(fileno(stderr));
 		if (initialpgrp < 0) {
 			error_msg("sh: can't access tty; job control disabled\n");
 		}
 		if (initialpgrp == -1)
 			initialpgrp = getpgrp();
 		else if (initialpgrp != getpgrp()) {
 			killpg(initialpgrp, SIGTTIN);
 			continue;
 		}
 	} while (0);
 }
 
 int shell_main(int argc, char **argv)
 {
 	int opt;
 	FILE *input;
 	struct jobset joblist_end = { NULL, NULL };
 	char **e = environ;
 
 	/* initialize globals */
 	if (e) {
 		for (; *e; e++)
 			set_local_var(*e, 2);   /* without call putenv() */
 	}
 	job_list = &joblist_end;
 
 	last_return_code=EXIT_SUCCESS;
 
 	/* XXX what should these be while sourcing /etc/profile? */
 	global_argc = argc;
 	global_argv = argv;
 
 	/* If we get started under a job aware app (like bash 
 	 * for example), make sure we are now in charge so we 
 	 * don't fight over who gets the foreground */
 	/* don't pay any attention to this signal; it just confuses 
 	   things and isn't really meant for shells anyway */
 	signal(SIGTTOU, SIG_IGN);
 	setpgid(0, getpid());
 	tcsetpgrp(fileno(stderr), getpid());
 
 	if (argv[0] && argv[0][0] == '-') {
 		debug_printf("\nsourcing /etc/profile\n");
 		input = xfopen("/etc/profile", "r");
 		mark_open(fileno(input));
 		parse_file_outer(input);
 		mark_closed(fileno(input));
 		fclose(input);
 	}
 	input=stdin;
 	
 	/* initialize the cwd -- this is never freed...*/
 	cwd = xgetcwd(0);
 	if (!cwd)
 		cwd = unknown;
 #ifdef BB_FEATURE_COMMAND_EDITING
 	cmdedit_set_initial_prompt();
 #else
 	PS1 = NULL;
 #endif
 	
 	while ((opt = getopt(argc, argv, "c:xif")) > 0) {
 		switch (opt) {
 			case 'c':
 				{
 					global_argv = argv+optind;
 					global_argc = argc-optind;
 					opt = parse_string_outer(optarg);
 					goto final_return;
 				}
 				break;
 			case 'i':
 				interactive++;
 				break;
 			case 'f':
 				fake_mode++;
 				break;
 			default:
 #ifndef BB_VER
 				fprintf(stderr, "Usage: sh [FILE]...\n"
 						"   or: sh -c command [args]...\n\n");
 				exit(EXIT_FAILURE);
 #else
 				show_usage();
 #endif
 		}
 	}
 	/* A shell is interactive if the `-i' flag was given, or if all of
 	 * the following conditions are met:
 	 *	  no -c command
 	 *    no arguments remaining or the -s flag given
 	 *    standard input is a terminal
 	 *    standard output is a terminal
 	 *    Refer to Posix.2, the description of the `sh' utility. */
 	if (argv[optind]==NULL && input==stdin &&
 			isatty(fileno(stdin)) && isatty(fileno(stdout))) {
 		interactive++;
 	}
 
 	debug_printf("\ninteractive=%d\n", interactive);
 	if (interactive) {
 		/* Looks like they want an interactive shell */
 		fprintf(stdout, "\nhush -- the humble shell v0.01 (testing)\n\n");
 		grab_tty_control();
 	}
 	if (argv[optind]==NULL) {
 		opt=parse_file_outer(stdin);
 		goto final_return;
 	}
 
 	debug_printf("\nrunning script '%s'\n", argv[optind]);
 	global_argv = argv+optind;
 	global_argc = argc-optind;
 	input = xfopen(argv[optind], "r");
 	opt = parse_file_outer(input);
 
 #ifdef BB_FEATURE_CLEAN_UP
 	fclose(input.file);
 #endif
 
 final_return:
 	return(opt?opt:last_return_code);
 }
diff --git a/include/usage.h b/include/usage.h
index b442e8b..63c00c6 100644
--- a/include/usage.h
+++ b/include/usage.h
@@ -1,1770 +1,1770 @@
 #define adjtimex_trivial_usage \
 	"[-q] [-o offset] [-f frequency] [-p timeconstant] [-t tick]"
 #define adjtimex_full_usage \
 	"Reads and optionally sets system timebase parameters.\n" \
 	"See adjtimex(2).\n\n" \
 	"Options:\n" \
 	"\t-q\t\tquiet mode - do not print\n" \
 	"\t-o offset\ttime offset, microseconds\n" \
 	"\t-f frequency\tfrequency adjust, integer kernel units (65536 is 1ppm)\n" \
 	"\t\t\t(positive values make the system clock run fast)\n" \
 	"\t-t tick\t\tmicroseconds per tick, usually 10000\n" \
 	"\t-p timeconstant\n"
 
 #define ar_trivial_usage \
 	"-[ovR]{ptx} ARCHIVE FILES"
 #define ar_full_usage \
 	"Extract or list FILES from an ar archive.\n\n" \
 	"Options:\n" \
 	"\t-o\t\tpreserve original dates\n" \
 	"\t-p\t\textract to stdout\n" \
 	"\t-t\t\tlist\n" \
 	"\t-x\t\textract\n" \
 	"\t-v\t\tverbosely list files processed\n" \
 	"\t-R\t\trecursive action"
 
 #define basename_trivial_usage \
 	"FILE [SUFFIX]"
 #define basename_full_usage \
 	"Strips directory path and suffixes from FILE.\n" \
 	"If specified, also removes any trailing SUFFIX."
 #define basename_example_usage \
 	"$ basename /usr/local/bin/foo\n" \
 	"foo\n" \
 	"$ basename /usr/local/bin/\n" \
 	"bin\n" \
 	"$ basename /foo/bar.txt .txt\n" \
 	"bar"
 
 #define cat_trivial_usage \
 	"[FILE]..."
 #define cat_full_usage \
 	"Concatenates FILE(s) and prints them to stdout."
 #define cat_example_usage \
 	"$ cat /proc/uptime\n" \
 	"110716.72 17.67"
 
 #define chgrp_trivial_usage \
 	"[OPTION]... GROUP FILE..."
 #define chgrp_full_usage \
 	"Change the group membership of each FILE to GROUP.\n" \
 	"\nOptions:\n" \
 	"\t-R\tChanges files and directories recursively."
 #define chgrp_example_usage \
 	"$ ls -l /tmp/foo\n" \
 	"-r--r--r--    1 andersen andersen        0 Apr 12 18:25 /tmp/foo\n" \
 	"$ chgrp root /tmp/foo\n" \
 	"$ ls -l /tmp/foo\n" \
 	"-r--r--r--    1 andersen root            0 Apr 12 18:25 /tmp/foo\n"
 
 #define chmod_trivial_usage \
 	"[-R] MODE[,MODE]... FILE..."
 #define chmod_full_usage \
 	"Each MODE is one or more of the letters ugoa, one of the\n" \
 	"symbols +-= and one or more of the letters rwxst.\n\n" \
 	"Options:\n" \
 	"\t-R\tChanges files and directories recursively."
 #define chmod_example_usage \
 	"$ ls -l /tmp/foo\n" \
 	"-rw-rw-r--    1 root     root            0 Apr 12 18:25 /tmp/foo\n" \
 	"$ chmod u+x /tmp/foo\n" \
 	"$ ls -l /tmp/foo\n" \
 	"-rwxrw-r--    1 root     root            0 Apr 12 18:25 /tmp/foo*\n" \
 	"$ chmod 444 /tmp/foo\n" \
 	"$ ls -l /tmp/foo\n" \
 	"-r--r--r--    1 root     root            0 Apr 12 18:25 /tmp/foo\n"
 
 #define chown_trivial_usage \
 	"[ -Rh ]...  OWNER[<.|:>[GROUP]] FILE..."
 #define chown_full_usage \
 	"Change the owner and/or group of each FILE to OWNER and/or GROUP.\n" \
 	"\nOptions:\n" \
 	"\t-R\tChanges files and directories recursively.\n" \
 	"\t-h\tDo not dereference symbolic links."
 #define chown_example_usage \
 	"$ ls -l /tmp/foo\n" \
 	"-r--r--r--    1 andersen andersen        0 Apr 12 18:25 /tmp/foo\n" \
 	"$ chown root /tmp/foo\n" \
 	"$ ls -l /tmp/foo\n" \
 	"-r--r--r--    1 root     andersen        0 Apr 12 18:25 /tmp/foo\n" \
 	"$ chown root.root /tmp/foo\n" \
 	"ls -l /tmp/foo\n" \
 	"-r--r--r--    1 root     root            0 Apr 12 18:25 /tmp/foo\n"
 
 #define chroot_trivial_usage \
 	"NEWROOT [COMMAND...]"
 #define chroot_full_usage \
 	"Run COMMAND with root directory set to NEWROOT."
 #define chroot_example_usage \
 	"$ ls -l /bin/ls\n" \
 	"lrwxrwxrwx    1 root     root          12 Apr 13 00:46 /bin/ls -> /BusyBox\n" \
 	"$ mount /dev/hdc1 /mnt -t minix\n" \
 	"$ chroot /mnt\n" \
 	"$ ls -l /bin/ls\n" \
 	"-rwxr-xr-x    1 root     root        40816 Feb  5 07:45 /bin/ls*\n"
 
 #define chvt_trivial_usage \
 	"N"
 #define chvt_full_usage \
 	"Changes the foreground virtual terminal to /dev/ttyN"
 
 #define clear_trivial_usage \
 	""
 #define clear_full_usage \
 	"Clear screen."
 
 #define cmp_trivial_usage \
 	"FILE1 [FILE2]"
 #define cmp_full_usage \
 	"\t-s\tquiet mode - do not print\n" \
 	"Compare files."
 
 #define cp_trivial_usage \
 	"[OPTION]... SOURCE DEST"
 #define cp_full_usage \
 	"Copies SOURCE to DEST, or multiple SOURCE(s) to DIRECTORY.\n" \
 	"\n" \
 	"\t-a\tSame as -dpR\n" \
 	"\t-d\tPreserves links\n" \
 	"\t-p\tPreserves file attributes if possible\n" \
 	"\t-f\tforce (implied; ignored) - always set\n" \
 	"\t-R\tCopies directories recursively"
 
 #define cut_trivial_usage \
 	"[OPTION]... [FILE]..."
 #define cut_full_usage \
 	"Prints selected fields from each input FILE to standard output.\n\n" \
 	"Options:\n" \
 	"\t-b LIST\t\tOutput only bytes from LIST\n" \
 	"\t-c LIST\t\tOutput only characters from LIST\n" \
 	"\t-d CHAR\t\tUse CHAR instead of tab as the field delimiter\n" \
 	"\t-s\t\tOutput only the lines containing delimiter\n" \
 	"\t-f N\t\tPrint only these fields\n" \
 	"\t-n\t\tIgnored"
 #define cut_example_usage \
 	"$ echo "Hello world" | cut -f 1 -d ' '\n" \
 	"Hello\n" \
 	"$ echo "Hello world" | cut -f 2 -d ' '\n" \
 	"world\n"
 
 #define date_trivial_usage \
 	"[OPTION]... [+FORMAT]"
 #define date_full_usage \
 	"Displays the current time in the given FORMAT, or sets the system date.\n" \
 	"\nOptions:\n" \
 	"\t-R\t\tOutputs RFC-822 compliant date string\n" \
 	"\t-d STRING\tdisplay time described by STRING, not `now'\n" \
 	"\t-s\t\tSets time described by STRING\n" \
 	"\t-u\t\tPrints or sets Coordinated Universal Time"
 #define date_example_usage \
 	"$ date\n" \
 	"Wed Apr 12 18:52:41 MDT 2000\n"
 
 #define dc_trivial_usage \
 	"expression ..."
 #define dc_full_usage \
 	"This is a Tiny RPN calculator that understands the\n" \
 	"following operations: +, -, /, *, and, or, not, eor.\n" \
 	"i.e. 'dc 2 2 add' -> 4, and 'dc 8 8 \\* 2 2 + /' -> 16"
 #define dc_example_usage \
 	"$ dc 2 2 +\n" \
 	"4\n" \
 	"$ dc 8 8 \* 2 2 + /\n" \
 	"16\n" \
 	"$ dc 0 1 and\n" \
 	"0\n" \
 	"$ dc 0 1 or\n" \
 	"1\n" \
 	"$ echo 72 9 div 8 mul | dc\n" \
 	"64\n"
 
 #define dd_trivial_usage \
 	"[if=FILE] [of=FILE] [bs=N] [count=N] [skip=N]\n" \
 	"\t  [seek=N] [conv=notrunc|sync]"
 #define dd_full_usage \
 	"Copy a file, converting and formatting according to options\n\n" \
 	"\tif=FILE\t\tread from FILE instead of stdin\n" \
 	"\tof=FILE\t\twrite to FILE instead of stdout\n" \
 	"\tbs=N\t\tread and write N bytes at a time\n" \
 	"\tcount=N\t\tcopy only N input blocks\n" \
 	"\tskip=N\t\tskip N input blocks\n" \
 	"\tseek=N\t\tskip N output blocks\n" \
 	"\tconv=notrunc\tdon't truncate output file\n" \
 	"\tconv=sync\tpad blocks with zeros\n" \
 	"\n" \
 	"Numbers may be suffixed by c (x1), w (x2), b (x512), kD (x1000), k (x1024),\n" \
 	"MD (x1000000), M (x1048576), GD (x1000000000) or G (x1073741824)."
 #define dd_example_usage \
 	"$ dd if=/dev/zero of=/dev/ram1 bs=1M count=4\n" \
 	"4+0 records in\n" \
 	"4+0 records out\n"
 
 #define deallocvt_trivial_usage \
 	"N"
 #define deallocvt_full_usage \
 	 "Deallocate unused virtual terminal /dev/ttyN"
 
 
 #ifdef BB_FEATURE_HUMAN_READABLE
   #define USAGE_HUMAN_READABLE(a) a
   #define USAGE_NOT_HUMAN_READABLE(a)
 #else
   #define USAGE_HUMAN_READABLE(a) 
   #define USAGE_NOT_HUMAN_READABLE(a) a
 #endif
 #define df_trivial_usage \
 	"[-" USAGE_HUMAN_READABLE("hm") USAGE_NOT_HUMAN_READABLE("") "k] [FILESYSTEM ...]"
 #define df_full_usage \
 	"Print the filesystem space used and space available.\n\n" \
 	"Options:\n" \
 	USAGE_HUMAN_READABLE( \
 	"\n\t-h\tprint sizes in human readable format (e.g., 1K 243M 2G )\n" \
 	"\t-m\tprint sizes in megabytes\n" \
 	"\t-k\tprint sizes in kilobytes(default)") USAGE_NOT_HUMAN_READABLE( \
 	"\n\t-k\tprint sizes in kilobytes(compatability)")
 #define df_example_usage \
 	"$ df\n" \
 	"Filesystem           1k-blocks      Used Available Use% Mounted on\n" \
 	"/dev/sda3              8690864   8553540    137324  98% /\n" \
 	"/dev/sda1                64216     36364     27852  57% /boot\n" \
 	"$ df /dev/sda3\n" \
 	"Filesystem           1k-blocks      Used Available Use% Mounted on\n" \
 	"/dev/sda3              8690864   8553540    137324  98% /\n"
 
 #define dirname_trivial_usage \
 	"[FILENAME ...]"
 #define dirname_full_usage \
 	"Strips non-directory suffix from FILENAME"
 #define dirname_example_usage \
 	"$ dirname /tmp/foo\n" \
 	"/tmp\n" \
 	"$ dirname /tmp/foo/\n" \
 	"/tmp\n"
 
 #define dmesg_trivial_usage \
 	"[-c] [-n LEVEL] [-s SIZE]"
 #define dmesg_full_usage \
 	"Prints or controls the kernel ring buffer\n\n" \
 	"Options:\n" \
 	"\t-c\t\tClears the ring buffer's contents after printing\n" \
 	"\t-n LEVEL\tSets console logging level\n" \
 	"\t-s SIZE\t\tUse a buffer of size SIZE"
 
 #define dos2unix_trivial_usage \
 	"[option] [FILE]"
 #define dos2unix_full_usage \
 	"Converts FILE from dos format to unix format.  When no option\n" \
 	"is given, the input is converted to the opposite output format.\n" \
 	"When no file is given, uses stdin for input and stdout for output." \
 	"Options:\n" \
 	"\t-u\toutput will be in UNIX format\n" \
 	"\t-d\toutput will be in DOS format\n\n" \
 
 #define dpkg_trivial_usage \
 	"[-i|-r|--unpack|--configure] my.deb"
 #define dpkg_full_usage \
 	"WORK IN PROGRESS, only useful for debian-installer"
 
 #define dpkg_deb_trivial_usage \
 	"[-cefItxX] FILE [argument]"
 #define dpkg_deb_full_usage \
 	"Perform actions on debian packages (.debs)\n\n" \
 	"Options:\n" \
 	"\t-c\tList contents of filesystem tree\n" \
 	"\t-e\tExtract control files to [argument] directory\n" \
 	"\t-f\tDisplay control field name starting with [argument]\n" \
 	"\t-I\tDisplay the control filenamed [argument]\n" \
 	"\t-t\tExtract filesystem tree to stdout in tar format\n" \
 	"\t-x\tExctract packages filesystem tree to directory\n" \
 	"\t-X\tVerbose extract"
 #define dpkg_deb_example_usage \
 	"$ dpkg-deb -X ./busybox_0.48-1_i386.deb /tmp\n"
 
 #define du_trivial_usage \
 	"[-ls" USAGE_HUMAN_READABLE("hm") USAGE_NOT_HUMAN_READABLE("") "k] [FILE]..."
 #define du_full_usage \
 	"Summarizes disk space used for each FILE and/or directory.\n" \
 	"Disk space is printed in units of 1024 bytes.\n\n" \
 	"Options:\n" \
 	"\t-l\tcount sizes many times if hard linked\n" \
 	"\t-s\tdisplay only a total for each argument" \
 	USAGE_HUMAN_READABLE( \
 	"\n\t-h\tprint sizes in human readable format (e.g., 1K 243M 2G )\n" \
 	"\t-m\tprint sizes in megabytes\n" \
 	"\t-k\tprint sizes in kilobytes(default)") USAGE_NOT_HUMAN_READABLE( \
 	"\n\t-k\tprint sizes in kilobytes(compatability)")
 #define du_example_usage \
 	"$ du\n" \
 	"16      ./CVS\n" \
 	"12      ./kernel-patches/CVS\n" \
 	"80      ./kernel-patches\n" \
 	"12      ./tests/CVS\n" \
 	"36      ./tests\n" \
 	"12      ./scripts/CVS\n" \
 	"16      ./scripts\n" \
 	"12      ./docs/CVS\n" \
 	"104     ./docs\n" \
 	"2417    .\n"
 
 #define dumpkmap_trivial_usage \
 	"> keymap"
 #define dumpkmap_full_usage \
 	"Prints out a binary keyboard translation table to standard output."
 #define dumpkmap_example_usage \
 	"$ dumpkmap > keymap\n"
 
 #define dutmp_trivial_usage \
 	"[FILE]"
 #define dutmp_full_usage \
 	"Dump utmp file format (pipe delimited) from FILE\n" \
 	"or stdin to stdout.  (i.e. 'dutmp /var/run/utmp')"
 #define dutmp_example_usage \
 	"$ dutmp /var/run/utmp\n" \
 	"8|7||si|||0|0|0|955637625|760097|0\n" \
 	"2|0|~|~~|reboot||0|0|0|955637625|782235|0\n" \
 	"1|20020|~|~~|runlevel||0|0|0|955637625|800089|0\n" \
 	"8|125||l4|||0|0|0|955637629|998367|0\n" \
 	"6|245|tty1|1|LOGIN||0|0|0|955637630|998974|0\n" \
 	"6|246|tty2|2|LOGIN||0|0|0|955637630|999498|0\n" \
 	"7|336|pts/0|vt00andersen|andersen|:0.0|0|0|0|955637763|0|0\n"
 
 #define echo_trivial_usage \
 	"[-neE] [ARG ...]"
 #define echo_full_usage \
 	"Prints the specified ARGs to stdout\n\n" \
 	"Options:\n" \
 	"\t-n\tsuppress trailing newline\n" \
 	"\t-e\tinterpret backslash-escaped characters (i.e. \\t=tab etc)\n" \
 	"\t-E\tdisable interpretation of backslash-escaped characters"
 #define echo_example_usage \
 	"$ echo "Erik is cool"\n" \
 	"Erik is cool\n" \
 	"$  echo -e "Erik\\nis\\ncool"\n" \
 	"Erik\n" \
 	"is\n" \
 	"cool\n" \
 	"$ echo "Erik\\nis\\ncool"\n" \
 	"Erik\\nis\\ncool\n"
 
 #define env_trivial_usage \
 	"[-iu] [-] [name=value]... [command]"
 #define env_full_usage \
 	"Prints the current environment or runs a program after setting\n" \
 	"up the specified environment.\n\n" \
 	"Options:\n" \
 	"\t-, -i\tstart with an empty environment\n" \
 	"\t-u\tremove variable from the environment\n"
 
 #define expr_trivial_usage \
 	"EXPRESSION"
 #define expr_full_usage \
 	"Prints the value of EXPRESSION to standard output.\n\n" \
 	"EXPRESSION may be:\n" \
 	"\tARG1 |  ARG2	ARG1 if it is neither null nor 0, otherwise ARG2\n" \
 	"\tARG1 &  ARG2	ARG1 if neither argument is null or 0, otherwise 0\n" \
 	"\tARG1 <  ARG2	ARG1 is less than ARG2\n" \
 	"\tARG1 <= ARG2	ARG1 is less than or equal to ARG2\n" \
 	"\tARG1 =  ARG2	ARG1 is equal to ARG2\n" \
 	"\tARG1 != ARG2	ARG1 is unequal to ARG2\n" \
 	"\tARG1 >= ARG2	ARG1 is greater than or equal to ARG2\n" \
 	"\tARG1 >  ARG2	ARG1 is greater than ARG2\n" \
 	"\tARG1 +  ARG2	arithmetic sum of ARG1 and ARG2\n" \
 	"\tARG1 -  ARG2	arithmetic difference of ARG1 and ARG2\n" \
 	"\tARG1 *  ARG2	arithmetic product of ARG1 and ARG2\n" \
 	"\tARG1 /  ARG2	arithmetic quotient of ARG1 divided by ARG2\n" \
 	"\tARG1 %  ARG2	arithmetic remainder of ARG1 divided by ARG2\n" \
 	"\tSTRING : REGEXP             anchored pattern match of REGEXP in STRING\n" \
 	"\tmatch STRING REGEXP         same as STRING : REGEXP\n" \
 	"\tsubstr STRING POS LENGTH    substring of STRING, POS counted from 1\n" \
 	"\tindex STRING CHARS          index in STRING where any CHARS is found,\n" \
 	"\t                            or 0\n" \
 	"\tlength STRING               length of STRING\n" \
 	"\tquote TOKEN                 interpret TOKEN as a string, even if\n" \
 	"\t                            it is a keyword like `match' or an\n" \
 	"\t                            operator like `/'\n" \
 	"\t( EXPRESSION )              value of EXPRESSION\n\n" \
 	"Beware that many operators need to be escaped or quoted for shells.\n" \
 	"Comparisons are arithmetic if both ARGs are numbers, else\n" \
 	"lexicographical.  Pattern matches return the string matched between \n" \
 	"\\( and \\) or null; if \\( and \\) are not used, they return the number \n" \
 	"of characters matched or 0."
 
 #define false_trivial_usage \
 	""
 #define false_full_usage \
 	"Return an exit code of FALSE (1)."
 #define false_example_usage \
 	"$ false\n" \
 	"$ echo $?\n" \
 	"1\n"
 
 #define fbset_trivial_usage \
 	"[options] [mode]"
 #define fbset_full_usage \
 	"Show and modify frame buffer settings"
 #define fbset_example_usage \
 	"$ fbset\n" \
 	"mode "1024x768-76"\n" \
 	"\t# D: 78.653 MHz, H: 59.949 kHz, V: 75.694 Hz\n" \
 	"\tgeometry 1024 768 1024 768 16\n" \
 	"\ttimings 12714 128 32 16 4 128 4\n" \
 	"\taccel false\n" \
 	"\trgba 5/11,6/5,5/0,0/0\n" \
 	"endmode\n"
 
 #define fdflush_trivial_usage \
 	"DEVICE"
 #define fdflush_full_usage \
 	"Forces floppy disk drive to detect disk change"
 
 #ifdef BB_FEATURE_FIND_TYPE
   #define USAGE_FIND_TYPE(a) a
 #else
   #define USAGE_FIND_TYPE(a)
 #endif
 #ifdef BB_FEATURE_FIND_PERM
   #define USAGE_FIND_PERM(a) a
 #else
   #define USAGE_FIND_PERM(a)
 #endif
 #ifdef BB_FEATURE_FIND_MTIME
   #define USAGE_FIND_MTIME(a) a
 #else
   #define USAGE_FIND_MTIME(a)
 #endif
 
 #define find_trivial_usage \
 	"[PATH...] [EXPRESSION]"
 #define find_full_usage \
 	"Search for files in a directory hierarchy.  The default PATH is\n" \
 	"the current directory; default EXPRESSION is '-print'\n" \
 	"\nEXPRESSION may consist of:\n" \
 	"\t-follow\t\tDereference symbolic links.\n" \
 	"\t-name PATTERN\tFile name (leading directories removed) matches PATTERN.\n" \
 	"\t-print\t\tPrint (default and assumed).\n" \
 	USAGE_FIND_TYPE( \
 	"\n\t-type X\t\tFiletype matches X (where X is one of: f,d,l,b,c,...)" \
 ) USAGE_FIND_PERM( \
 	"\n\t-perm PERMS\tPermissions match any of (+NNN); all of (-NNN);\n\t\t\tor exactly (NNN)" \
 ) USAGE_FIND_MTIME( \
 	"\n\t-mtime TIME\tModified time is greater than (+N); less than (-N);\n\t\t\tor exactly (N) days")
 #define find_example_usage \
 	"$ find / -name /etc/passwd\n" \
 	"/etc/passwd\n"
 
 #define free_trivial_usage \
 	""
 #define free_full_usage \
 	"Displays the amount of free and used system memory"
 #define free_example_usage \
 	"$ free\n" \
 	"              total         used         free       shared      buffers\n" \
 	"  Mem:       257628       248724         8904        59644        93124\n" \
 	" Swap:       128516         8404       120112\n" \
 	"Total:       386144       257128       129016\n" \
 
 #define freeramdisk_trivial_usage \
 	"DEVICE"
 #define freeramdisk_full_usage \
 	"Frees all memory used by the specified ramdisk."
 #define freeramdisk_example_usage \
 	"$ freeramdisk /dev/ram2\n"
 
 #define fsck_minix_trivial_usage \
 	"[-larvsmf] /dev/name"
 #define fsck_minix_full_usage \
 	"Performs a consistency check for MINIX filesystems.\n\n" \
 	"Options:\n" \
 	"\t-l\tLists all filenames\n" \
 	"\t-r\tPerform interactive repairs\n" \
 	"\t-a\tPerform automatic repairs\n" \
 	"\t-v\tverbose\n" \
 	"\t-s\tOutputs super-block information\n" \
 	"\t-m\tActivates MINIX-like \"mode not cleared\" warnings\n" \
 	"\t-f\tForce file system check."
 
 #define getopt_trivial_usage \
 	"[OPTIONS]..."
 #define getopt_full_usage \
 	"Parse command options\n" \
 	"\t-a, --alternative		Allow long options starting with single -\n" \
 	"\t-l, --longoptions=longopts	Long options to be recognized\n" \
 	"\t-n, --name=progname		The name under which errors are reported\n" \
 	"\t-o, --options=optstring	Short options to be recognized\n" \
 	"\t-q, --quiet			Disable error reporting by getopt(3)\n" \
 	"\t-Q, --quiet-output		No normal output\n" \
 	"\t-s, --shell=shell		Set shell quoting conventions\n" \
 	"\t-T, --test			Test for getopt(1) version\n" \
 	"\t-u, --unqote			Do not quote the output"
 #define getopt_example_usage \
         "$ cat getopt.test\n" \
         "#!/bin/sh\n" \
         "GETOPT=`getopt -o ab:c:: --long a-long,b-long:,c-long:: \\\n" \
         "       -n 'example.busybox' -- "$@"`\n" \
         "if [ $? != 0 ] ; then  exit 1 ; fi\n" \
         "eval set -- "$GETOPT"\n" \
         "while true ; do\n" \
         " case $1 in\n" \
         "   -a|--a-long) echo \"Option a\" ; shift ;;\n" \
         "   -b|--b-long) echo \"Option b, argument \`$2'\" ; shift 2 ;;\n" \
         "   -c|--c-long)\n" \
         "     case "$2" in\n" \
         "       \"\") echo \"Option c, no argument\"; shift 2 ;;\n" \
         "       *)  echo \"Option c, argument \`$2'\" ; shift 2 ;;\n" \
         "     esac ;;\n" \
         "   --) shift ; break ;;\n" \
         "   *) echo \"Internal error!\" ; exit 1 ;;\n" \
         " esac\n" \
         "done\n"
 
 #define grep_trivial_usage \
 	"[-ihHnqvs] PATTERN [FILEs...]"
 #define grep_full_usage \
 	"Search for PATTERN in each FILE or standard input.\n\n" \
 	"Options:\n" \
 	"\t-H\tprefix output lines with filename where match was found\n" \
 	"\t-h\tsuppress the prefixing filename on output\n" \
 	"\t-i\tignore case distinctions\n" \
 	"\t-l\tlist names of files that match\n" \
 	"\t-n\tprint line number with output lines\n" \
 	"\t-q\tbe quiet. Returns 0 if result was found, 1 otherwise\n" \
 	"\t-v\tselect non-matching lines\n" \
 	"\t-s\tsuppress file open/read error messages"
 #define grep_example_usage \
 	"$ grep root /etc/passwd\n" \
 	"root:x:0:0:root:/root:/bin/bash\n" \
 	"$ grep ^[rR]oo. /etc/passwd\n" \
 	"root:x:0:0:root:/root:/bin/bash\n"
 
 #define gunzip_trivial_usage \
 	"[OPTION]... FILE"
 #define gunzip_full_usage \
 	"Uncompress FILE (or standard input if FILE is '-').\n\n" \
 	"Options:\n" \
 	"\t-c\tWrite output to standard output\n" \
 	"\t-t\tTest compressed file integrity"
 #define gunzip_example_usage \
 	"$ ls -la /tmp/BusyBox*\n" \
 	"-rw-rw-r--    1 andersen andersen   557009 Apr 11 10:55 /tmp/BusyBox-0.43.tar.gz\n" \
 	"$ gunzip /tmp/BusyBox-0.43.tar.gz\n" \
 	"$ ls -la /tmp/BusyBox*\n" \
 	"-rw-rw-r--    1 andersen andersen  1761280 Apr 14 17:47 /tmp/BusyBox-0.43.tar\n"
 
 #define gzip_trivial_usage \
 	"[OPTION]... FILE"
 #define gzip_full_usage \
 	"Compress FILE with maximum compression.\n" \
 	"When FILE is '-', reads standard input.  Implies -c.\n\n" \
 	"Options:\n" \
 	"\t-c\tWrite output to standard output instead of FILE.gz\n" \
 	"\t-d\tdecompress"
 #define gzip_example_usage \
 	"$ ls -la /tmp/busybox*\n" \
 	"-rw-rw-r--    1 andersen andersen  1761280 Apr 14 17:47 /tmp/busybox.tar\n" \
 	"$ gzip /tmp/busybox.tar\n" \
 	"$ ls -la /tmp/busybox*\n" \
 	"-rw-rw-r--    1 andersen andersen   554058 Apr 14 17:49 /tmp/busybox.tar.gz\n"
 
 #define halt_trivial_usage \
 	""
 #define halt_full_usage \
 	"Halt the system."
 
 #define head_trivial_usage \
 	"[OPTION] [FILE]..."
 #define head_full_usage \
 	"Print first 10 lines of each FILE to standard output.\n" \
 	"With more than one FILE, precede each with a header giving the\n" \
 	"file name. With no FILE, or when FILE is -, read standard input.\n\n" \
 	"Options:\n" \
 	"\t-n NUM\t\tPrint first NUM lines instead of first 10"
 #define head_example_usage \
 	"$ head -n 2 /etc/passwd\n" \
 	"root:x:0:0:root:/root:/bin/bash\n" \
 	"daemon:x:1:1:daemon:/usr/sbin:/bin/sh\n"
 
 #define hostid_trivial_usage \
 	""
 #define hostid_full_usage \
 	"Print out a unique 32-bit identifier for the machine."
 
 #define hostname_trivial_usage \
 	"[OPTION] {hostname | -F FILE}"
 #define hostname_full_usage \
 	"Get or set the hostname or DNS domain name. If a hostname is given\n" \
 	"(or FILE with the -F parameter), the host name will be set.\n\n" \
 	"Options:\n" \
 	"\t-s\t\tShort\n" \
 	"\t-i\t\tAddresses for the hostname\n" \
 	"\t-d\t\tDNS domain name\n" \
 	"\t-F, --file FILE\tUse the contents of FILE to specify the hostname"
 #define hostname_example_usage \
 	"$ hostname\n" \
 	"sage \n"
 
 #define id_trivial_usage \
 	"[OPTIONS]... [USERNAME]"
 #define id_full_usage \
 	"Print information for USERNAME or the current user\n\n" \
 	"Options:\n" \
 	"\t-g\tprints only the group ID\n" \
 	"\t-u\tprints only the user ID\n" \
 	"\t-n\tprint a name instead of a number (with for -ug)\n" \
 	"\t-r\tprints the real user ID instead of the effective ID (with -ug)"
 #define id_example_usage \
 	"$ id\n" \
 	"uid=1000(andersen) gid=1000(andersen)\n"
 
 #ifdef BB_FEATURE_IFCONFIG_SLIP
   #define USAGE_SIOCSKEEPALIVE(a) a
 #else
   #define USAGE_SIOCSKEEPALIVE(a)
 #endif
 #ifdef BB_FEATURE_IFCONFIG_MEMSTART_IOADDR_IRQ
   #define USAGE_IFCONFIG_MII(a) a
 #else
   #define USAGE_IFCONFIG_MII(a)
 #endif
 #ifdef BB_FEATURE_IFCONFIG_HW
   #define USAGE_IFCONFIG_HW(a) a
 #else
   #define USAGE_IFCONFIG_HW(a)
 #endif
 #ifdef BB_FEATURE_IFCONFIG_STATUS
   #define USAGE_IFCONFIG_OPT_A(a) a
 #else
   #define USAGE_IFCONFIG_OPT_A(a)
 #endif
 
 #define ifconfig_trivial_usage \
 	USAGE_IFCONFIG_OPT_A("[-a]") " <interface> [<address>]"
 #define ifconfig_full_usage \
 	"configure a network interface\n\n" \
 	"Options:\n" \
 	"\t[[-]broadcast [<address>]]  [[-]pointopoint [<address>]]\n" \
 	"\t[netmask <address>]  [dstaddr <address>]\n" \
 	USAGE_SIOCSKEEPALIVE("\t[outfill <NN>] [keepalive <NN>]\n") \
 	"\t" USAGE_IFCONFIG_HW("[hw ether <address>]  ") \
     "[metric <NN>]  [mtu <NN>]\n" \
 	"\t[[-]trailers]  [[-]arp]  [[-]allmulti]\n" \
 	"\t[multicast]  [[-]promisc]  [txqueuelen <NN>]  [[-]dynamic]\n" \
 	USAGE_IFCONFIG_MII("\t[mem_start <NN>]  [io_addr <NN>]  [irq <NN>]\n") \
 	"\t[up|down] ..."
 
 #define init_trivial_usage \
 	""
 #define init_full_usage \
 	"Init is the parent of all processes."
 #define init_notes_usage \
 "This version of init is designed to be run only by the kernel.\n" \
 "\n" \
 "BusyBox init doesn't support multiple runlevels.  The runlevels field of\n" \
 "the /etc/inittab file is completely ignored by BusyBox init. If you want \n" \
 "runlevels, use sysvinit.\n" \
 "\n" \
 "BusyBox init works just fine without an inittab.  If no inittab is found, \n" \
 "it has the following default behavior:\n" \
 "\n" \
 "	::sysinit:/etc/init.d/rcS\n" \
 "	::askfirst:/bin/sh\n" \
 "	::ctrlaltdel:/sbin/reboot\n" \
 "	::shutdown:/sbin/swapoff -a\n" \
 "	::shutdown:/bin/umount -a -r\n" \
 "\n" \
 "if it detects that /dev/console is _not_ a serial console, it will also run:\n" \
 "\n" \
 "	tty2::askfirst:/bin/sh\n" \
 "	tty3::askfirst:/bin/sh\n" \
 "	tty4::askfirst:/bin/sh\n" \
 "\n" \
 "If you choose to use an /etc/inittab file, the inittab entry format is as follows:\n" \
 "\n" \
 "	<id>:<runlevels>:<action>:<process>\n" \
 "\n" \
 "	<id>: \n" \
 "\n" \
 "		WARNING: This field has a non-traditional meaning for BusyBox init!\n" \
 "		The id field is used by BusyBox init to specify the controlling tty for\n" \
 "		the specified process to run on.  The contents of this field are\n" \
 "		appended to "/dev/" and used as-is.  There is no need for this field to\n" \
 "		be unique, although if it isn't you may have strange results.  If this\n" \
 "		field is left blank, the controlling tty is set to the console.  Also\n" \
 "		note that if BusyBox detects that a serial console is in use, then only\n" \
 "		entries whose controlling tty is either the serial console or /dev/null\n" \
 "		will be run.  BusyBox init does nothing with utmp.  We don't need no\n" \
 "		stinkin' utmp.\n" \
 "\n" \
 "	<runlevels>: \n" \
 "\n" \
 "		The runlevels field is completely ignored.\n" \
 "\n" \
 "	<action>: \n" \
 "\n" \
 "		Valid actions include: sysinit, respawn, askfirst, wait, \n" \
 "		once, ctrlaltdel, and shutdown.\n" \
 "\n" \
 "		The available actions can be classified into two groups: actions\n" \
 "		that are run only once, and actions that are re-run when the specified\n" \
 "		process exits.\n" \
 "\n" \
 "		Run only-once actions:\n" \
 "\n" \
 "			'sysinit' is the first item run on boot.  init waits until all\n" \
 "			sysinit actions are completed before continuing.  Following the\n" \
 "			completion of all sysinit actions, all 'wait' actions are run.\n" \
 "			'wait' actions, like  'sysinit' actions, cause init to wait until\n" \
 "			the specified task completes.  'once' actions are asyncronous,\n" \
 "			therefore, init does not wait for them to complete.  'ctrlaltdel'\n" \
 "			actions are run when the system detects that someone on the system\n" \
 "                       console has pressed the CTRL-ALT-DEL key combination.  Typically one\n" \
 "                       wants to run 'reboot' at this point to cause the system to reboot.\n" \
 "			Finally the 'shutdown' action specifies the actions to taken when\n" \
 "                       init is told to reboot.  Unmounting filesystems and disabling swap\n" \
 "                       is a very good here\n" \
 "\n" \
 "		Run repeatedly actions:\n" \
 "\n" \
 "			'respawn' actions are run after the 'once' actions.  When a process\n" \
 "			started with a 'respawn' action exits, init automatically restarts\n" \
 "			it.  Unlike sysvinit, BusyBox init does not stop processes from\n" \
 "			respawning out of control.  The 'askfirst' actions acts just like\n" \
 "			respawn, except that before running the specified process it\n" \
 "			displays the line "Please press Enter to activate this console."\n" \
 "			and then waits for the user to press enter before starting the\n" \
 "			specified process.  \n" \
 "\n" \
 "		Unrecognized actions (like initdefault) will cause init to emit an\n" \
 "		error message, and then go along with its business.  All actions are\n" \
 "		run in the reverse order from how they appear in /etc/inittab.\n" \
 "\n" \
 "	<process>: \n" \
 "\n" \
 "		Specifies the process to be executed and it's command line.\n" \
 "\n" \
 "Example /etc/inittab file:\n" \
 "\n" \
 "	# This is run first except when booting in single-user mode.\n" \
 "	#\n" \
 "	::sysinit:/etc/init.d/rcS\n" \
 "	\n" \
 "	# /bin/sh invocations on selected ttys\n" \
 "	#\n" \
 "	# Start an "askfirst" shell on the console (whatever that may be)\n" \
 "	::askfirst:-/bin/sh\n" \
 "	# Start an "askfirst" shell on /dev/tty2-4\n" \
 "	tty2::askfirst:-/bin/sh\n" \
 "	tty3::askfirst:-/bin/sh\n" \
 "	tty4::askfirst:-/bin/sh\n" \
 "	\n" \
 "	# /sbin/getty invocations for selected ttys\n" \
 "	#\n" \
 "	tty4::respawn:/sbin/getty 38400 tty5\n" \
 "	tty5::respawn:/sbin/getty 38400 tty6\n" \
 "	\n" \
 "	\n" \
 "	# Example of how to put a getty on a serial line (for a terminal)\n" \
 "	#\n" \
 "	#::respawn:/sbin/getty -L ttyS0 9600 vt100\n" \
 "	#::respawn:/sbin/getty -L ttyS1 9600 vt100\n" \
 "	#\n" \
 "	# Example how to put a getty on a modem line.\n" \
 "	#::respawn:/sbin/getty 57600 ttyS2\n" \
 "	\n" \
 "	# Stuff to do before rebooting\n" \
 "	::ctrlaltdel:/sbin/reboot\n" \
 "	::shutdown:/bin/umount -a -r\n" \
 "	::shutdown:/sbin/swapoff -a\n"
 
 #define insmod_trivial_usage \
 	"[OPTION]... MODULE [symbol=value]..."
 #define insmod_full_usage \
 	"Loads the specified kernel modules into the kernel.\n\n" \
 	"Options:\n" \
 	"\t-f\tForce module to load into the wrong kernel version.\n" \
 	"\t-k\tMake module autoclean-able.\n" \
 	"\t-v\tverbose output\n"  \
 	"\t-L\tLock to prevent simultaneous loads of a module\n" \
 	"\t-x\tdo not export externs"
 
 #define kill_trivial_usage \
 	"[-signal] process-id [process-id ...]"
 #define kill_full_usage \
 	"Send a signal (default is SIGTERM) to the specified process(es).\n\n"\
 	"Options:\n" \
 	"\t-l\tList all signal names and numbers."
 #define kill_example_usage \
 	"$ ps | grep apache\n" \
 	"252 root     root     S [apache]\n" \
 	"263 www-data www-data S [apache]\n" \
 	"264 www-data www-data S [apache]\n" \
 	"265 www-data www-data S [apache]\n" \
 	"266 www-data www-data S [apache]\n" \
 	"267 www-data www-data S [apache]\n" \
 	"$ kill 252\n"
 
 #define killall_trivial_usage \
 	"[-signal] process-name [process-name ...]"
 #define killall_full_usage \
 	"Send a signal (default is SIGTERM) to the specified process(es).\n\n"\
 	"Options:\n" \
 	"\t-l\tList all signal names and numbers."
 #define killall_example_usage \
 	"$ killall apache\n" 
 
 #define klogd_trivial_usage \
 	"-n"
 #define klogd_full_usage \
 	"Kernel logger.\n"\
 	"Options:\n"\
 	"\t-n\tRun as a foreground process."
 
 #define length_trivial_usage \
 	"STRING"
 #define length_full_usage \
 	"Prints out the length of the specified STRING."
 #define length_example_usage \
 	"$ length Hello\n" \
 	"5\n"
 
 #define ln_trivial_usage \
 	"[OPTION] TARGET... LINK_NAME|DIRECTORY"
 #define ln_full_usage \
 	"Create a link named LINK_NAME or DIRECTORY to the specified TARGET\n"\
 	"\nYou may use '--' to indicate that all following arguments are non-options.\n\n" \
 	"Options:\n" \
 	"\t-s\tmake symbolic links instead of hard links\n" \
 	"\t-f\tremove existing destination files\n" \
 	"\t-n\tno dereference symlinks - treat like normal file"
 #define ln_example_usage \
 	"$ ln -s BusyBox /tmp/ls\n" \
 	"$ ls -l /tmp/ls\n" \
 	"lrwxrwxrwx    1 root     root            7 Apr 12 18:39 ls -> BusyBox*\n" 
 
 #define loadacm_trivial_usage \
 	"< mapfile"
 #define loadacm_full_usage \
 	"Loads an acm from standard input."
 #define loadacm_example_usage \
 	"$ loadacm < /etc/i18n/acmname\n" 
 
 #define loadfont_trivial_usage \
 	"< font"
 #define loadfont_full_usage \
 	"Loads a console font from standard input."
 #define loadfont_example_usage \
 	"$ loadfont < /etc/i18n/fontname\n" 
 
 #define loadkmap_trivial_usage \
 	"< keymap"
 #define loadkmap_full_usage \
 	"Loads a binary keyboard translation table from standard input."
 #define loadkmap_example_usage \
 	"$ loadkmap < /etc/i18n/lang-keymap\n" 
 
 #define logger_trivial_usage \
 	"[OPTION]... [MESSAGE]"
 #define logger_full_usage \
 	"Write MESSAGE to the system log.  If MESSAGE is omitted, log stdin.\n\n" \
 	"Options:\n" \
 	"\t-s\tLog to stderr as well as the system log.\n" \
 	"\t-t\tLog using the specified tag (defaults to user name).\n" \
 	"\t-p\tEnter the message with the specified priority.\n" \
 	"\t\tThis may be numerical or a ``facility.level'' pair."
 #define logger_example_usage \
 	"$ logger "hello"\n" 
 
 #define logname_trivial_usage \
 	""
 #define logname_full_usage \
 	"Print the name of the current user."
 #define logname_example_usage \
 	"$ logname\n" \
 	"root\n" 
 
 #define logread_trivial_usage \
         ""
 
 #define logread_full_usage \
         "Shows the messages from syslogd (using circular buffer)."
 
 #ifdef BB_FEATURE_LS_TIMESTAMPS
   #define USAGE_LS_TIMESTAMPS(a) a
 #else
   #define USAGE_LS_TIMESTAMPS(a)
 #endif
 #ifdef BB_FEATURE_LS_FILETYPES
   #define USAGE_LS_FILETYPES(a) a
 #else
   #define USAGE_LS_FILETYPES(a)
 #endif
 #ifdef BB_FEATURE_LS_FOLLOWLINKS
   #define USAGE_LS_FOLLOWLINKS(a) a
 #else
   #define USAGE_LS_FOLLOWLINKS(a)
 #endif
 #ifdef BB_FEATURE_LS_RECURSIVE
   #define USAGE_LS_RECURSIVE(a) a
 #else
   #define USAGE_LS_RECURSIVE(a)
 #endif
 #ifdef BB_FEATURE_LS_SORTFILES
   #define USAGE_LS_SORTFILES(a) a
 #else
   #define USAGE_LS_SORTFILES(a)
 #endif
 #ifdef BB_FEATURE_AUTOWIDTH
   #define USAGE_AUTOWIDTH(a) a
 #else
   #define USAGE_AUTOWIDTH(a)
 #endif
 #define ls_trivial_usage \
 	"[-1Aa" USAGE_LS_TIMESTAMPS("c") "Cd" USAGE_LS_TIMESTAMPS("e") USAGE_LS_FILETYPES("F") "iln" USAGE_LS_FILETYPES("p") USAGE_LS_FOLLOWLINKS("L") USAGE_LS_RECURSIVE("R") USAGE_LS_SORTFILES("rS") "s" USAGE_AUTOWIDTH("T") USAGE_LS_TIMESTAMPS("tu") USAGE_LS_SORTFILES("v") USAGE_AUTOWIDTH("w") "x" USAGE_LS_SORTFILES("X") USAGE_HUMAN_READABLE("h") USAGE_NOT_HUMAN_READABLE("") "k] [filenames...]"
 #define ls_full_usage \
 	"List directory contents\n\n" \
 	"Options:\n" \
 	"\t-1\tlist files in a single column\n" \
 	"\t-A\tdo not list implied . and ..\n" \
 	"\t-a\tdo not hide entries starting with .\n" \
 	"\t-C\tlist entries by columns\n" \
 	USAGE_LS_TIMESTAMPS("\t-c\twith -l: show ctime\n") \
 	"\t-d\tlist directory entries instead of contents\n" \
 	USAGE_LS_TIMESTAMPS("\t-e\tlist both full date and full time\n") \
 	USAGE_LS_FILETYPES("\t-F\tappend indicator (one of */=@|) to entries\n") \
 	"\t-i\tlist the i-node for each file\n" \
 	"\t-l\tuse a long listing format\n" \
 	"\t-n\tlist numeric UIDs and GIDs instead of names\n" \
 	USAGE_LS_FILETYPES("\t-p\tappend indicator (one of /=@|) to entries\n") \
 	USAGE_LS_FOLLOWLINKS("\t-L\tlist entries pointed to by symbolic links\n") \
 	USAGE_LS_RECURSIVE("\t-R\tlist subdirectories recursively\n") \
 	USAGE_LS_SORTFILES("\t-r\tsort the listing in reverse order\n") \
 	USAGE_LS_SORTFILES("\t-S\tsort the listing by file size\n") \
 	"\t-s\tlist the size of each file, in blocks\n" \
 	USAGE_AUTOWIDTH("\t-T NUM\tassume Tabstop every NUM columns\n") \
 	USAGE_LS_TIMESTAMPS("\t-t\twith -l: show modification time\n") \
 	USAGE_LS_TIMESTAMPS("\t-u\twith -l: show access time\n") \
 	USAGE_LS_SORTFILES("\t-v\tsort the listing by version\n") \
 	USAGE_AUTOWIDTH("\t-w NUM\tassume the terminal is NUM columns wide\n") \
 	"\t-x\tlist entries by lines instead of by columns\n" \
 	USAGE_LS_SORTFILES("\t-X\tsort the listing by extension\n") \
 	USAGE_HUMAN_READABLE( \
 	"\t-h\tprint sizes in human readable format (e.g., 1K 243M 2G )\n" \
 	"\t-k\tprint sizes in kilobytes(default)") USAGE_NOT_HUMAN_READABLE( \
 	"\t-k\tprint sizes in kilobytes(compatability)") 
 
 #define lsmod_trivial_usage \
 	""
 #define lsmod_full_usage \
 	"List the currently loaded kernel modules."
 
 #define makedevs_trivial_usage \
 	"NAME TYPE MAJOR MINOR FIRST LAST [s]"
 #define makedevs_full_usage \
 	"Creates a range of block or character special files\n\n" \
 	"TYPEs include:\n" \
 	"\tb:\tMake a block (buffered) device.\n" \
 	"\tc or u:\tMake a character (un-buffered) device.\n" \
 	"\tp:\tMake a named pipe. MAJOR and MINOR are ignored for named pipes.\n\n" \
 	"FIRST specifies the number appended to NAME to create the first device.\n" \
 	"LAST specifies the number of the last item that should be created.\n" \
 	"If 's' is the last argument, the base device is created as well.\n\n" \
 	"For example:\n" \
 	"\tmakedevs /dev/ttyS c 4 66 2 63   ->  ttyS2-ttyS63\n" \
 	"\tmakedevs /dev/hda b 3 0 0 8 s    ->  hda,hda1-hda8"
 #define makedevs_example_usage \
 	"$ makedevs /dev/ttyS c 4 66 2 63\n" \
 	"[creates ttyS2-ttyS63]\n" \
 	"$ makedevs /dev/hda b 3 0 0 8 s\n" \
 	"[creates hda,hda1-hda8]\n" 
 
 #define md5sum_trivial_usage \
 	"[OPTION] [FILE]...\n" \
 	"or: md5sum [OPTION] -c [FILE]"
 #define md5sum_full_usage \
 	"Print or check MD5 checksums.\n\n" \
 	"Options:\n" \
 	"With no FILE, or when FILE is -, read standard input.\n\n" \
 	"\t-b\tread files in binary mode\n" \
 	"\t-c\tcheck MD5 sums against given list\n" \
 	"\t-t\tread files in text mode (default)\n" \
 	"\t-g\tread a string\n" \
 	"\nThe following two options are useful only when verifying checksums:\n" \
 	"\t-s\tdon't output anything, status code shows success\n" \
 	"\t-w\twarn about improperly formated MD5 checksum lines"
 #define md5sum_example_usage \
 	"$ md5sum < busybox\n" \
 	"6fd11e98b98a58f64ff3398d7b324003\n" \
 	"$ md5sum busybox\n" \
 	"6fd11e98b98a58f64ff3398d7b324003  busybox\n" \
 	"$ md5sum -c -\n" \
 	"6fd11e98b98a58f64ff3398d7b324003  busybox\n" \
 	"busybox: OK\n" \
 	"^D\n"
 
 #define mkdir_trivial_usage \
 	"[OPTION] DIRECTORY..."
 #define mkdir_full_usage \
 	"Create the DIRECTORY(ies) if they do not already exist\n\n" \
 	"Options:\n" \
 	"\t-m\tset permission mode (as in chmod), not rwxrwxrwx - umask\n" \
 	"\t-p\tno error if existing, make parent directories as needed"
 #define mkdir_example_usage \
 	"$ mkdir /tmp/foo\n" \
 	"$ mkdir /tmp/foo\n" \
 	"/tmp/foo: File exists\n" \
 	"$ mkdir /tmp/foo/bar/baz\n" \
 	"/tmp/foo/bar/baz: No such file or directory\n" \
 	"$ mkdir -p /tmp/foo/bar/baz\n" 
 
 #define mkfifo_trivial_usage \
 	"[OPTIONS] name"
 #define mkfifo_full_usage \
 	"Creates a named pipe (identical to 'mknod name p')\n\n" \
 	"Options:\n" \
 	"\t-m\tcreate the pipe using the specified mode (default a=rw)"
 
 #define mkfs_minix_trivial_usage \
 	"[-c | -l filename] [-nXX] [-iXX] /dev/name [blocks]"
 #define mkfs_minix_full_usage \
 	"Make a MINIX filesystem.\n\n" \
 	"Options:\n" \
 	"\t-c\t\tCheck the device for bad blocks\n" \
 	"\t-n [14|30]\tSpecify the maximum length of filenames\n" \
 	"\t-i INODES\tSpecify the number of inodes for the filesystem\n" \
 	"\t-l FILENAME\tRead the bad blocks list from FILENAME\n" \
 	"\t-v\t\tMake a Minix version 2 filesystem"
 
 #define mknod_trivial_usage \
 	"[OPTIONS] NAME TYPE MAJOR MINOR"
 #define mknod_full_usage \
 	"Create a special file (block, character, or pipe).\n\n" \
 	"Options:\n" \
 	"\t-m\tcreate the special file using the specified mode (default a=rw)\n\n" \
 	"TYPEs include:\n" \
 	"\tb:\tMake a block (buffered) device.\n" \
 	"\tc or u:\tMake a character (un-buffered) device.\n" \
 	"\tp:\tMake a named pipe. MAJOR and MINOR are ignored for named pipes."
 #define mknod_example_usage \
 	"$ mknod /dev/fd0 b 2 0 \n" \
 	"$ mknod -m 644 /tmp/pipe p\n" 
 
 #define mkswap_trivial_usage \
 	"[-c] [-v0|-v1] device [block-count]"
 #define mkswap_full_usage \
 	"Prepare a disk partition to be used as a swap partition.\n\n" \
 	"Options:\n" \
 	"\t-c\t\tCheck for read-ability.\n" \
 	"\t-v0\t\tMake version 0 swap [max 128 Megs].\n" \
 	"\t-v1\t\tMake version 1 swap [big!] (default for kernels >\n\t\t\t2.1.117).\n" \
 	"\tblock-count\tNumber of block to use (default is entire partition)."
 
 #define mktemp_trivial_usage \
 	"[-q] TEMPLATE"
 #define mktemp_full_usage \
 	"Creates a temporary file with its name based on TEMPLATE.\n" \
 	"TEMPLATE is any name with six `Xs' (i.e. /tmp/temp.XXXXXX)."
 #define mktemp_example_usage \
 	"$ mktemp /tmp/temp.XXXXXX\n" \
 	"/tmp/temp.mWiLjM\n" \
 	"$ ls -la /tmp/temp.mWiLjM\n" \
 	"-rw-------    1 andersen andersen        0 Apr 25 17:10 /tmp/temp.mWiLjM\n" 
 
 #define more_trivial_usage \
 	"[FILE ...]"
 #define more_full_usage \
 	"More is a filter for viewing FILE one screenful at a time."
 #define more_example_usage \
 	"$ dmesg | more\n" 
 
 #ifdef BB_FEATURE_MOUNT_LOOP
   #define USAGE_MOUNT_LOOP(a) a
 #else
   #define USAGE_MOUNT_LOOP(a)
 #endif
 #ifdef BB_FEATURE_MTAB_SUPPORT
   #define USAGE_MTAB(a) a
 #else
   #define USAGE_MTAB(a)
 #endif
 #define mount_trivial_usage \
 	"[flags] DEVICE NODE [-o options,more-options]"
 #define mount_full_usage \
 	"Mount a filesystem\n\n" \
 	"Flags:\n"  \
 	"\t-a:\t\tMount all filesystems in fstab.\n" \
 	USAGE_MTAB( \
 	"\t-f:\t\t\"Fake\" Add entry to mount table but don't mount it.\n" \
 	"\t-n:\t\tDon't write a mount table entry.\n" \
 	) \
 	"\t-o option:\tOne of many filesystem options, listed below.\n" \
 	"\t-r:\t\tMount the filesystem read-only.\n" \
 	"\t-t fs-type:\tSpecify the filesystem type.\n" \
 	"\t-w:\t\tMount for reading and writing (default).\n" \
 	"\n" \
 	"Options for use with the \"-o\" flag:\n" \
 	"\tasync/sync:\tWrites are asynchronous / synchronous.\n" \
 	"\tatime/noatime:\tEnable / disable updates to inode access times.\n" \
 	"\tdev/nodev:\tAllow use of special device files / disallow them.\n" \
 	"\texec/noexec:\tAllow use of executable files / disallow them.\n" \
 	USAGE_MOUNT_LOOP( \
 	"\tloop:\t\tMounts a file via loop device.\n" \
 	) \
 	"\tsuid/nosuid:\tAllow set-user-id-root programs / disallow them.\n" \
 	"\tremount:\tRe-mount a mounted filesystem, changing its flags.\n" \
 	"\tro/rw:\t\tMount for read-only / read-write.\n" \
 	"\tbind:\t\tUse the linux 2.4.x \"bind\" feature.\n" \
 	"\nThere are EVEN MORE flags that are specific to each filesystem.\n" \
 	"You'll have to see the written documentation for those filesystems."
 #define mount_example_usage \
 	"$ mount\n" \
 	"/dev/hda3 on / type minix (rw)\n" \
 	"proc on /proc type proc (rw)\n" \
 	"devpts on /dev/pts type devpts (rw)\n" \
 	"$ mount /dev/fd0 /mnt -t msdos -o ro\n" \
 	"$ mount /tmp/diskimage /opt -t ext2 -o loop\n" 
 
 #define mt_trivial_usage \
 	"[-f device] opcode value"
 #define mt_full_usage \
 	"Control magnetic tape drive operation\n" \
 	"\nAvailable Opcodes:\n\n" \
 	"bsf bsfm bsr bss datacompression drvbuffer eof eom erase\n" \
 	"fsf fsfm fsr fss load lock mkpart nop offline ras1 ras2\n" \
 	"ras3 reset retension rew rewoffline seek setblk setdensity\n" \
 	"setpart tell unload unlock weof wset"
 
 #define mv_trivial_usage \
 	"SOURCE DEST\n" \
 	"or: mv SOURCE... DIRECTORY"
 #define mv_full_usage \
 	"Rename SOURCE to DEST, or move SOURCE(s) to DIRECTORY."
 #define mv_example_usage \
 	"$ mv /tmp/foo /bin/bar\n" 
 
 #define nc_trivial_usage \
 	"[IP] [port]" 
 #define nc_full_usage \
 	"Netcat opens a pipe to IP:port"
 #define nc_example_usage \
 	"$ nc foobar.somedomain.com 25\n" \
 	"220 foobar ESMTP Exim 3.12 #1 Sat, 15 Apr 2000 00:03:02 -0600\n" \
 	"help\n" \
 	"214-Commands supported:\n" \
 	"214-    HELO EHLO MAIL RCPT DATA AUTH\n" \
 	"214     NOOP QUIT RSET HELP\n" \
 	"quit\n" \
 	"221 foobar closing connection\n" 
 
 #define nslookup_trivial_usage \
 	"[HOST]"
 #define nslookup_full_usage \
 	"Queries the nameserver for the IP address of the given HOST"
 #define nslookup_example_usage \
 	"$ nslookup localhost\n" \
 	"Server:     default\n" \
 	"Address:    default\n" \
 	"\n" \
 	"Name:       debian\n" \
 	"Address:    127.0.0.1\n" 
 
-#ifdef BB_FEATURE_SIMPLE_PING
+#ifndef BB_FEATURE_FANCY_PING
 #define ping_trivial_usage "host"
 #define ping_full_usage    "Send ICMP ECHO_REQUEST packets to network hosts"
 #else
 #define ping_trivial_usage \
 	"[OPTION]... host"
 #define ping_full_usage \
 	"Send ICMP ECHO_REQUEST packets to network hosts.\n\n" \
 	"Options:\n" \
 	"\t-c COUNT\tSend only COUNT pings.\n" \
 	"\t-s SIZE\t\tSend SIZE data bytes in packets (default=56).\n" \
 	"\t-q\t\tQuiet mode, only displays output at start\n" \
 	"\t\t\tand when finished."
 #endif
 #define ping_example_usage \
 	"$ ping localhost\n" \
 	"PING slag (127.0.0.1): 56 data bytes\n" \
 	"64 bytes from 127.0.0.1: icmp_seq=0 ttl=255 time=20.1 ms\n" \
 	"\n" \
 	"--- debian ping statistics ---\n" \
 	"1 packets transmitted, 1 packets received, 0% packet loss\n" \
 	"round-trip min/avg/max = 20.1/20.1/20.1 ms\n" 
 
 #define pivot_root_trivial_usage \
 	"NEW_ROOT PUT_OLD"
 #define pivot_root_full_usage \
 	"Move the current root file system to PUT_OLD and make NEW_ROOT\n" \
 	"the new root file system."
 
 #define poweroff_trivial_usage \
 	""
 #define poweroff_full_usage \
 	"Halt the system and request that the kernel shut off the power."
 
 #define printf_trivial_usage \
 	"FORMAT [ARGUMENT...]"
 #define printf_full_usage \
 	"Formats and prints ARGUMENT(s) according to FORMAT,\n" \
 	"Where FORMAT controls the output exactly as in C printf."
 #define printf_example_usage \
 	"$ printf "Val=%d\\n" 5\n" \
 	"Val=5\n" 
 
 #define ps_trivial_usage \
 	""
 #define ps_full_usage \
 	"Report process status\n" \
 	"\nThis version of ps accepts no options."
 #define ps_example_usage \
 	"$ ps\n" \
 	"  PID  Uid      Gid State Command\n" \
 	"    1 root     root     S init\n" \
 	"    2 root     root     S [kflushd]\n" \
 	"    3 root     root     S [kupdate]\n" \
 	"    4 root     root     S [kpiod]\n" \
 	"    5 root     root     S [kswapd]\n" \
 	"  742 andersen andersen S [bash]\n" \
 	"  743 andersen andersen S -bash\n" \
 	"  745 root     root     S [getty]\n" \
 	" 2990 andersen andersen R ps\n"
 
 #define pwd_trivial_usage \
 	""
 #define pwd_full_usage \
 	"Print the full filename of the current working directory."
 #define pwd_example_usage \
 	"$ pwd\n" \
 	"/root\n"
 
 #define rdate_trivial_usage \
 	"[OPTION] HOST"
 #define rdate_full_usage \
 	"Get and possibly set the system date and time from a remote HOST.\n\n" \
 	"Options:\n" \
 	"\t-s\tSet the system date and time (default).\n" \
 	"\t-p\tPrint the date and time."
 
 #define readlink_trivial_usage \
 	""
 #define readlink_full_usage \
 	"Read a symbolic link."
 
 #define reboot_trivial_usage \
 	""
 #define reboot_full_usage \
 	"Reboot the system."
 
 #define renice_trivial_usage \
 	"priority pid [pid ...]"
 #define renice_full_usage \
 	"Changes priority of running processes. Allowed priorities range\n" \
 	"from 20 (the process runs only when nothing else is running) to 0\n" \
 	"(default priority) to -20 (almost nothing else ever gets to run)."
 
 #define reset_trivial_usage \
 	""
 #define reset_full_usage \
 	"Resets the screen."
 
 #define rm_trivial_usage \
 	"[OPTION]... FILE..."
 #define rm_full_usage \
 	"Remove (unlink) the FILE(s).  You may use '--' to\n" \
 	"indicate that all following arguments are non-options.\n\n" \
 	"Options:\n" \
 	"\t-i\t\talways prompt before removing each destination" \
 	"\t-f\t\tremove existing destinations, never prompt\n" \
 	"\t-r or -R\tremove the contents of directories recursively"
 #define rm_example_usage \
 	"$ rm -rf /tmp/foo\n"
 
 #define rmdir_trivial_usage \
 	"[OPTION]... DIRECTORY..."
 #define rmdir_full_usage \
 	"Remove the DIRECTORY(ies), if they are empty."
 #define rmdir_example_usage \
 	"# rmdir /tmp/foo\n"
 
 #define rmmod_trivial_usage \
 	"[OPTION]... [MODULE]..."
 #define rmmod_full_usage \
 	"Unloads the specified kernel modules from the kernel.\n\n" \
 	"Options:\n" \
 	"\t-a\tTry to remove all unused kernel modules."
 #define rmmod_example_usage \
 	"$ rmmod tulip\n"
 
 #define route_trivial_usage \
 	"[{add|del|flush}]"
 #define route_full_usage \
 	"Edit the kernel's routing tables"
 
 #define rpmunpack_trivial_usage \
 	"< package.rpm | gunzip | cpio -idmuv"
 #define rpmunpack_full_usage \
 	"Extracts an rpm archive."
 
 #define sed_trivial_usage \
 	"[-Vhnef] pattern [files...]"
 #define sed_full_usage \
 	"Options:\n" \
 	"\t-n\t\tsuppress automatic printing of pattern space\n" \
 	"\t-e script\tadd the script to the commands to be executed\n" \
 	"\t-f scriptfile\tadd the contents of script-file to the commands to be executed\n" \
 	"\t-h\t\tdisplay this help message\n" \
 	"\n" \
 	"If no -e or -f is given, the first non-option argument is taken as the\n" \
 	"sed script to interpret. All remaining arguments are names of input\n" \
 	"files; if no input files are specified, then the standard input is read."
 #define sed_example_usage \
 	"$ echo "foo" | sed -e 's/f[a-zA-Z]o/bar/g'\n" \
 	"bar\n"
 
 #define setkeycodes_trivial_usage \
 	"SCANCODE KEYCODE ..."
 #define setkeycodes_full_usage \
 	"Set entries into the kernel's scancode-to-keycode map,\n" \
 	"allowing unusual keyboards to generate usable keycodes.\n\n" \
 	"SCANCODE may be either xx or e0xx (hexadecimal),\n" \
 	"and KEYCODE is given in decimal"
 #define setkeycodes_example_usage \
 	"$ setkeycodes e030 127\n"
 
 #define sh_trivial_usage \
 	"[FILE]...\n" \
 	"or: sh -c command [args]..."
 #define sh_full_usage \
 	"lash: The BusyBox LAme SHell (command interpreter)"
 #define sh_notes_usage \
 "This command does not yet have proper documentation.\n" \
 "\n" \
 "Use lash just as you would use any other shell.  It properly handles pipes,\n" \
 "redirects, job control, can be used as the shell for scripts, and has a\n" \
 "sufficient set of builtins to do what is needed.  It does not (yet) support\n" \
 "Bourne Shell syntax.  If you need things like "if-then-else", "while", and such\n" \
 "use ash or bash.  If you just need a very simple and extremely small shell,\n" \
 "this will do the job."
 
 #define sleep_trivial_usage \
 	"N"
 #define sleep_full_usage \
 	"Pause for N seconds."
 #define sleep_example_usage \
 	"$ sleep 2\n" \
 	"[2 second delay results]\n"
 
 
 #ifdef BB_FEATURE_SORT_UNIQUE
   #define USAGE_SORT_UNIQUE(a) a
 #else
   #define USAGE_SORT_UNIQUE(a)
 #endif
 #ifdef BB_FEATURE_SORT_REVERSE
   #define USAGE_SORT_REVERSE(a) a
 #else
   #define USAGE_SORT_REVERSE(a)
 #endif
 #define sort_trivial_usage \
 	"[-n" USAGE_SORT_REVERSE("r") USAGE_SORT_UNIQUE("u") "] [FILE]..."
 #define sort_full_usage \
 	"Sorts lines of text in the specified files\n\n"\
 	"Options:\n" \
 	USAGE_SORT_UNIQUE("\t-u\tsuppress duplicate lines\n") \
 	USAGE_SORT_REVERSE("\t-r\tsort in reverse order\n") \
 	"\t-n\tsort numerics"
 #define sort_example_usage \
 	"$ echo -e \"e\\nf\\nb\\nd\\nc\\na\" | sort\n" \
 	"a\n" \
 	"b\n" \
 	"c\n" \
 	"d\n" \
 	"e\n" \
 	"f\n"
 
 #define stty_trivial_usage \
 	"[-a|g] [-F DEVICE] [SETTING]..."
 #define stty_full_usage \
 	"Without arguments, prints baud rate, line discipline," \
 	"\nand deviations from stty sane." \
 	"\n\nOptions:" \
 	"\n\t-F DEVICE\topen device instead of stdin" \
 	"\n\t-a\t\tprint all current settings in human-readable form" \
 	"\n\t-g\t\tprint in stty-readable form" \
 	"\n\t[SETTING]\tsee manpage"
 
 #define swapoff_trivial_usage \
 	"[OPTION] [DEVICE]"
 #define swapoff_full_usage \
 	"Stop swapping virtual memory pages on DEVICE.\n\n" \
 	"Options:\n" \
 	"\t-a\tStop swapping on all swap devices"
 
 #define swapon_trivial_usage \
 	"[OPTION] [DEVICE]"
 #define swapon_full_usage \
 	"Start swapping virtual memory pages on DEVICE.\n\n" \
 	"Options:\n" \
 	"\t-a\tStart swapping on all swap devices"
 
 #define sync_trivial_usage \
 	""
 #define sync_full_usage \
 	"Write all buffered filesystem blocks to disk."
 
 
 #ifdef BB_FEATURE_REMOTE_LOG
   #define USAGE_REMOTE_LOG(a) a
 #else
   #define USAGE_REMOTE_LOG(a)
 #endif
 #define syslogd_trivial_usage \
 	"[OPTION]..."
 #define syslogd_full_usage \
 	"Linux system and kernel logging utility.\n" \
 	"Note that this version of syslogd ignores /etc/syslog.conf.\n\n" \
 	"Options:\n" \
 	"\t-m NUM\t\tInterval between MARK lines (default=20min, 0=off)\n" \
 	"\t-n\t\tRun as a foreground process\n" \
 	"\t-O FILE\t\tUse an alternate log file (default=/var/log/messages)" \
 	USAGE_REMOTE_LOG( \
 	"\n\t-R HOST[:PORT]\tLog to IP or hostname on PORT (default PORT=514/UDP)\n" \
 	"\t-L\t\tLog locally and via network logging (default is network only)")
 #define syslogd_example_usage \
 	"$ syslogd -R masterlog:514\n" \
 	"$ syslogd -R 192.168.1.1:601\n"
 
 
-#ifdef BB_FEATURE_SIMPLE_TAIL
+#ifndef BB_FEATURE_FANCY_TAIL
   #define USAGE_UNSIMPLE_TAIL(a)
 #else
   #define USAGE_UNSIMPLE_TAIL(a) a
 #endif
 #define tail_trivial_usage \
 	"[OPTION]... [FILE]..."
 #define tail_full_usage \
 	"Print last 10 lines of each FILE to standard output.\n" \
 	"With more than one FILE, precede each with a header giving the\n" \
 	"file name. With no FILE, or when FILE is -, read standard input.\n\n" \
 	"Options:\n" \
 	USAGE_UNSIMPLE_TAIL("\t-c N[kbm]\toutput the last N bytes\n") \
 	"\t-n N[kbm]\tprint last N lines instead of last 10\n" \
 	"\t-f\t\toutput data as the file grows" \
 	USAGE_UNSIMPLE_TAIL( "\n\t-q\t\tnever output headers giving file names\n" \
 	"\t-s SEC\t\twait SEC seconds between reads with -f\n" \
 	"\t-v\t\talways output headers giving file names\n\n" \
 	"If the first character of N (bytes or lines) is a '+', output begins with \n" \
 	"the Nth item from the start of each file, otherwise, print the last N items\n" \
 	"in the file. N bytes may be suffixed by k (x1024), b (x512), or m (1024^2)." )
 #define tail_example_usage \
 	"$ tail -n 1 /etc/resolv.conf\n" \
 	"nameserver 10.0.0.1\n"
 
 #ifdef BB_FEATURE_TAR_CREATE
   #define USAGE_TAR_CREATE(a) a
 #else
   #define USAGE_TAR_CREATE(a)
 #endif
 #ifdef BB_FEATURE_TAR_EXCLUDE
   #define USAGE_TAR_EXCLUDE(a) a
 #else
   #define USAGE_TAR_EXCLUDE(a)
 #endif
 #define tar_trivial_usage \
 	"-[" USAGE_TAR_CREATE("c") "xtvO] " \
 	USAGE_TAR_EXCLUDE("[--exclude FILE] [-X FILE]") \
 	"[-f TARFILE] [FILE(s)] ..."
 #define tar_full_usage \
 	"Create, extract, or list files from a tar file.\n\n" \
 	"Main operation mode:\n" \
 	USAGE_TAR_CREATE("\tc\t\tcreate\n") \
 	"\tx\t\textract\n" \
 	"\tt\t\tlist\n" \
 	"\nFile selection:\n" \
 	"\tf\t\tname of TARFILE or \"-\" for stdin\n" \
 	"\tO\t\textract to stdout\n" \
 	USAGE_TAR_EXCLUDE( \
 	"\texclude\t\tfile to exclude\n" \
 	 "\tX\t\tfile with names to exclude\n" \
 	) \
 	"\nInformative output:\n" \
 	"\tv\t\tverbosely list files processed"
 #define tar_example_usage \
 	"$ zcat /tmp/tarball.tar.gz | tar -xf -\n" \
 	"$ tar -cf /tmp/tarball.tar /usr/local\n"
 
 #define tee_trivial_usage \
 	"[OPTION]... [FILE]..."
 #define tee_full_usage \
 	"Copy standard input to each FILE, and also to standard output.\n\n" \
 	"Options:\n" \
 	"\t-a\tappend to the given FILEs, do not overwrite"
 #define tee_example_usage \
 	"$ echo "Hello" | tee /tmp/foo\n" \
 	"$ cat /tmp/foo\n" \
 	"Hello\n"
 
 #define telnet_trivial_usage \
 	"HOST [PORT]"
 #define telnet_full_usage \
 	"Telnet is used to establish interactive communication with another\n"\
 	"computer over a network using the TELNET protocol."
 
 #define test_trivial_usage \
 	"EXPRESSION\n  or   [ EXPRESSION ]"
 #define test_full_usage \
 	"Checks file types and compares values returning an exit\n" \
 	"code determined by the value of EXPRESSION."
 #define test_example_usage \
 	"$ test 1 -eq 2\n" \
 	"$ echo $?\n" \
 	"1\n" \
 	"$ test 1 -eq 1\n" \
 	"$ echo $? \n" \
 	"0\n" \
 	"$ [ -d /etc ]\n" \
 	"$ echo $?\n" \
 	"0\n" \
 	"$ [ -d /junk ]\n" \
 	"$ echo $?\n" \
 	"1\n"
 
 #ifdef BB_FEATURE_TFTP_GET
   #define USAGE_TFTP_GET(a) a
 #else
   #define USAGE_TFTP_GET(a)
 #endif
 #ifdef BB_FEATURE_TFTP_PUT
   #define USAGE_TFTP_PUT(a) a
 #else
   #define USAGE_TFTP_PUT(a)
 #endif
 
 #define tftp_trivial_usage \
 	"command SOURCE DEST"
 #define tftp_full_usage \
 	"Transfers a file from/to a tftp server using \"octet\" mode.\n\n" \
 	"Commands:\n" \
         USAGE_TFTP_GET(	\
         "\tget\tGet file from server SOURCE and store to local DEST.\n" \
         ) \
         USAGE_TFTP_PUT(	\
 	"\tput\tPut local file SOURCE to server DEST.\n" \
 	) \
 	"\nWhen naming a server, use the syntax \"server:file\"."
 
 #define touch_trivial_usage \
 	"[-c] FILE [FILE ...]"
 #define touch_full_usage \
 	"Update the last-modified date on the given FILE[s].\n\n" \
 	"Options:\n" \
 	"\t-c\tDo not create any files"
 #define touch_example_usage \
 	"$ ls -l /tmp/foo\n" \
 	"/bin/ls: /tmp/foo: No such file or directory\n" \
 	"$ touch /tmp/foo\n" \
 	"$ ls -l /tmp/foo\n" \
 	"-rw-rw-r--    1 andersen andersen        0 Apr 15 01:11 /tmp/foo\n" 
 
 #define tr_trivial_usage \
 	"[-cds] STRING1 [STRING2]"
 #define tr_full_usage \
 	"Translate, squeeze, and/or delete characters from\n" \
 	"standard input, writing to standard output.\n\n" \
 	"Options:\n" \
 	"\t-c\ttake complement of STRING1\n" \
 	"\t-d\tdelete input characters coded STRING1\n" \
 	"\t-s\tsqueeze multiple output characters of STRING2 into one character"
 #define tr_example_usage \
 	"$ echo "gdkkn vnqkc" | tr [a-y] [b-z]\n" \
 	"hello world\n" 
 
 #define true_trivial_usage \
 	""
 #define true_full_usage \
 	"Return an exit code of TRUE (0)."
 #define true_example_usage \
 	"$ true\n" \
 	"$ echo $?\n" \
 	"0\n"
 
 #define tty_trivial_usage \
 	""
 #define tty_full_usage \
 	"Print the file name of the terminal connected to standard input.\n\n"\
 	"Options:\n" \
 	"\t-s\tprint nothing, only return an exit status"
 #define tty_example_usage \
 	"$ tty\n" \
 	"/dev/tty2\n"
 
 #ifdef BB_FEATURE_MOUNT_FORCE
   #define USAGE_MOUNT_FORCE(a) a
 #else
   #define USAGE_MOUNT_FORCE(a)
 #endif
 #define umount_trivial_usage \
 	"[flags] FILESYSTEM|DIRECTORY"
 #define umount_full_usage \
 	"Unmount file systems\n" \
 	"\nFlags:\n" "\t-a\tUnmount all file systems" \
 	USAGE_MTAB(" in /etc/mtab\n\t-n\tDon't erase /etc/mtab entries") \
 	"\n\t-r\tTry to remount devices as read-only if mount is busy" \
 	USAGE_MOUNT_FORCE("\n\t-f\tForce umount (i.e. unreachable NFS server)") \
 	USAGE_MOUNT_LOOP("\n\t-l\tDo not free loop device (if a loop device has been used)")
 #define umount_example_usage \
 	"$ umount /dev/hdc1 \n"
 
 #define uname_trivial_usage \
 	"[OPTION]..."
 #define uname_full_usage \
 	"Print certain system information.  With no OPTION, same as -s.\n\n" \
 	"Options:\n" \
 	"\t-a\tprint all information\n" \
 	"\t-m\tthe machine (hardware) type\n" \
 	"\t-n\tprint the machine's network node hostname\n" \
 	"\t-r\tprint the operating system release\n" \
 	"\t-s\tprint the operating system name\n" \
 	"\t-p\tprint the host processor type\n" \
 	"\t-v\tprint the operating system version"
 #define uname_example_usage \
 	"$ uname -a\n" \
 	"Linux debian 2.2.15pre13 #5 Tue Mar 14 16:03:50 MST 2000 i686 unknown\n" 
 
 #define uniq_trivial_usage \
 	"[OPTION]... [INPUT [OUTPUT]]"
 #define uniq_full_usage \
 	"Discard all but one of successive identical lines from INPUT\n" \
 	"(or standard input), writing to OUTPUT (or standard output).\n\n" \
 	"Options:\n" \
 	"\t-c\tprefix lines by the number of occurrences\n" \
 	"\t-d\tonly print duplicate lines\n" \
 	"\t-u\tonly print unique lines"
 #define uniq_example_usage \
 	"$ echo -e \"a\\na\\nb\\nc\\nc\\na\" | sort | uniq\n" \
 	"a\n" \
 	"b\n" \
 	"c\n"
 
 #define unix2dos_trivial_usage \
 	"[option] [FILE]"
 #define unix2dos_full_usage \
 	"Converts FILE from unix format to dos format.  When no option\n" \
 	"is given, the input is converted to the opposite output format.\n" \
 	"When no file is given, uses stdin for input and stdout for output." \
 	"Options:\n" \
 	"\t-u\toutput will be in UNIX format\n" \
 	"\t-d\toutput will be in DOS format\n\n" \
 
 #define update_trivial_usage \
 	"[options]"
 #define update_full_usage \
 	"Periodically flushes filesystem buffers.\n\n" \
 	"Options:\n" \
 	"\t-S\tforce use of sync(2) instead of flushing\n" \
 	"\t-s SECS\tcall sync this often (default 30)\n" \
 	"\t-f SECS\tflush some buffers this often (default 5)"
 
 #define uptime_trivial_usage \
 	""
 #define uptime_full_usage \
 	"Display the time since the last boot."
 #define uptime_example_usage \
 	"$ uptime\n" \
 	"  1:55pm  up  2:30, load average: 0.09, 0.04, 0.00\n" 
 
 #define usleep_trivial_usage \
 	"N" 
 #define usleep_full_usage \
 	"Pause for N microseconds."
 #define usleep_example_usage \
 	"$ usleep 1000000\n" \
 	"[pauses for 1 second]\n"
 
 #define uudecode_trivial_usage \
 	"[FILE]..."
 #define uudecode_full_usage \
 	"Uudecode a file that is uuencoded.\n\n" \
 	"Options:\n" \
 	"\t-o FILE\tdirect output to FILE" 
 #define uudecode_example_usage \
 	"$ uudecode -o busybox busybox.uu\n" \
 	"$ ls -l busybox\n" \
 	"-rwxr-xr-x   1 ams      ams        245264 Jun  7 21:35 busybox\n" 
 
 #define uuencode_trivial_usage \
 	"[OPTION] [INFILE] REMOTEFILE"
 #define uuencode_full_usage \
 	"Uuencode a file.\n\n" \
 	"Options:\n" \
 	"\t-m\tuse base64 encoding per RFC1521"
 #define uuencode_example_usage \
 	"$ uuencode busybox busybox\n" \
 	"begin 755 busybox\n" \
 	"<encoded file snipped>\n" \
 	"$ uudecode busybox busybox > busybox.uu\n" \
 	"$\n"
 
 #define vi_trivial_usage \
 	"[OPTION] [FILE]..."
 #define vi_full_usage \
 	"edit FILE.\n\n" \
 	"Options:\n" \
 	"\t-R\tRead-only- do not write to the file." 
 
 #define watchdog_trivial_usage \
 	"DEV"
 #define watchdog_full_usage \
 	"Periodically write to watchdog device DEV"
 
 #define wc_trivial_usage \
 	"[OPTION]... [FILE]..."
 #define wc_full_usage \
 	"Print line, word, and byte counts for each FILE, and a total line if\n" \
 	"more than one FILE is specified.  With no FILE, read standard input.\n\n" \
 	"Options:\n" \
 	"\t-c\tprint the byte counts\n" \
 	"\t-l\tprint the newline counts\n" \
 	"\t-L\tprint the length of the longest line\n" \
 	"\t-w\tprint the word counts"
 #define wc_example_usage \
 	"$ wc /etc/passwd\n" \
 	"     31      46    1365 /etc/passwd\n" 
 
 #define wget_trivial_usage \
 	"[-c|--continue] [-q|--quiet] [-O|--output-document file] [--header 'header: value'] url"
 #define wget_full_usage \
 	"wget retrieves files via HTTP or FTP\n\n" \
 	"Options:\n" \
 	"\t-c\tcontinue retrieval of aborted transfers\n" \
 	"\t-q\tquiet mode - do not print\n" \
 	"\t-O\tsave to filename ('-' for stdout)"
 
 #define which_trivial_usage \
 	"[COMMAND ...]"
 #define which_full_usage \
 	"Locates a COMMAND."
 #define which_example_usage \
 	"$ which login\n" \
 	"/bin/login\n"
 
 #define whoami_trivial_usage \
 	""
 #define whoami_full_usage \
 	"Prints the user name associated with the current effective user id."
 
 #define xargs_trivial_usage \
 	"[COMMAND] [ARGS...]"
 #define xargs_full_usage \
 	"Executes COMMAND on every item given by standard input."
 #define xargs_example_usage \
 	"$ ls | xargs gzip\n" \
 	"$ find . -name '*.c' -print | xargs rm\n" 
 
 #define yes_trivial_usage \
 	"[OPTION]... [STRING]..."
 #define yes_full_usage \
 	"Repeatedly outputs a line with all specified STRING(s), or 'y'."
 
 #define zcat_trivial_usage \
 	"FILE"
 #define zcat_full_usage \
 	"Uncompress to stdout."
diff --git a/lash.c b/lash.c
index cb17e2d..f1200ba 100644
--- a/lash.c
+++ b/lash.c
@@ -1,1940 +1,1940 @@
 /* vi: set sw=4 ts=4: */
 /*
  * lash -- the BusyBox Lame-Ass SHell
  *
  * Copyright (C) 1999,2000,2001 by Lineo, inc.
  * Written by Erik Andersen <andersen@lineo.com>, <andersee@debian.org>
  *
  * Based in part on ladsh.c by Michael K. Johnson and Erik W. Troan, which is
  * under the following liberal license: "We have placed this source code in the
  * public domain. Use it in any project, free or commercial."
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
  * General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
  *
  */
 
 /* The parsing engine of this program is officially at a dead-end.
  * Future work in that direction should move to the work posted
  * at http://doolittle.faludi.com/~larry/parser.html .
  * A start on the integration of that work with the rest of sh.c
  * is at http://codepoet.org/sh.c .
  */
 //
 //This works pretty well now, and is now on by default.
 #define BB_FEATURE_SH_ENVIRONMENT
 //
 //Backtick support has some problems, use at your own risk!
 //#define BB_FEATURE_SH_BACKTICKS
 //
 //If, then, else, etc. support..  This should now behave basically
 //like any other Bourne shell -- sortof...
 #define BB_FEATURE_SH_IF_EXPRESSIONS
 //
 /* This is currently sortof broken, only for the brave... */
 #undef HANDLE_CONTINUATION_CHARS
 //
 /* This would be great -- if wordexp wouldn't strip all quoting
  * out from the target strings...  As is, a parser needs  */
 #undef BB_FEATURE_SH_WORDEXP
 //
 //For debugging/development on the shell only...
 //#define DEBUG_SHELL
 
 
 #include <stdio.h>
 #include <stdlib.h>
 #include <ctype.h>
 #include <errno.h>
 #include <fcntl.h>
 #include <signal.h>
 #include <string.h>
 #include <sys/ioctl.h>
 #include <sys/wait.h>
 #include <unistd.h>
 #include <getopt.h>
 #include "busybox.h"
 #include "cmdedit.h"
 
 #ifdef BB_LOCALE_SUPPORT
 #include <locale.h>
 #endif
 
 //#define BB_FEATURE_SH_WORDEXP
 
 #ifdef BB_FEATURE_SH_WORDEXP
 #include <wordexp.h>
 #define expand_t	wordexp_t
 #undef BB_FEATURE_SH_BACKTICKS
 #else
 #include <glob.h>
 #define expand_t	glob_t
 #endif	
 
 
 static const int MAX_READ = 128;	/* size of input buffer for `read' builtin */
 #define JOB_STATUS_FORMAT "[%d] %-22s %.40s\n"
 
 
 enum redir_type { REDIRECT_INPUT, REDIRECT_OVERWRITE,
 	REDIRECT_APPEND
 };
 
 static const unsigned int DEFAULT_CONTEXT=0x1;
 static const unsigned int IF_TRUE_CONTEXT=0x2;
 static const unsigned int IF_FALSE_CONTEXT=0x4;
 static const unsigned int THEN_EXP_CONTEXT=0x8;
 static const unsigned int ELSE_EXP_CONTEXT=0x10;
 
 
 struct jobset {
 	struct job *head;			/* head of list of running jobs */
 	struct job *fg;				/* current foreground job */
 };
 
 struct redir_struct {
 	enum redir_type type;	/* type of redirection */
 	int fd;						/* file descriptor being redirected */
 	char *filename;				/* file to redirect fd to */
 };
 
 struct child_prog {
 	pid_t pid;					/* 0 if exited */
 	char **argv;				/* program name and arguments */
 	int num_redirects;			/* elements in redirection array */
 	struct redir_struct *redirects;	/* I/O redirects */
 	int is_stopped;				/* is the program currently running? */
 	struct job *family;			/* pointer back to the child's parent job */
 };
 
 struct job {
 	int jobid;					/* job number */
 	int num_progs;				/* total number of programs in job */
 	int running_progs;			/* number of programs running */
 	char *text;					/* name of job */
 	char *cmdbuf;				/* buffer various argv's point into */
 	pid_t pgrp;					/* process group ID for the job */
 	struct child_prog *progs;	/* array of programs in job */
 	struct job *next;			/* to track background commands */
 	int stopped_progs;			/* number of programs alive, but stopped */
 	unsigned int job_context;	/* bitmask defining current context */
 	struct jobset *job_list;
 };
 
 struct built_in_command {
 	char *cmd;					/* name */
 	char *descr;				/* description */
 	int (*function) (struct child_prog *);	/* function ptr */
 };
 
 struct close_me {
 	int fd;
 	struct close_me *next;
 };
 
 /* function prototypes for builtins */
 static int builtin_cd(struct child_prog *cmd);
 static int builtin_exec(struct child_prog *cmd);
 static int builtin_exit(struct child_prog *cmd);
 static int builtin_fg_bg(struct child_prog *cmd);
 static int builtin_help(struct child_prog *cmd);
 static int builtin_jobs(struct child_prog *dummy);
 static int builtin_pwd(struct child_prog *dummy);
 static int builtin_export(struct child_prog *cmd);
 static int builtin_source(struct child_prog *cmd);
 static int builtin_unset(struct child_prog *cmd);
 static int builtin_read(struct child_prog *cmd);
 #ifdef BB_FEATURE_SH_IF_EXPRESSIONS
 static int builtin_if(struct child_prog *cmd);
 static int builtin_then(struct child_prog *cmd);
 static int builtin_else(struct child_prog *cmd);
 static int builtin_fi(struct child_prog *cmd);
 /* function prototypes for shell stuff */
 static int run_command_predicate(char *cmd);
 #endif
 
 
 /* function prototypes for shell stuff */
 static void mark_open(int fd);
 static void mark_closed(int fd);
 static void close_all(void);
 static void checkjobs(struct jobset *job_list);
 static int get_command(FILE * source, char *command);
 static int parse_command(char **command_ptr, struct job *job, int *inbg);
 static int run_command(struct job *newjob, int inbg, int outpipe[2]);
 static int pseudo_exec(struct child_prog *cmd) __attribute__ ((noreturn));
 static int busy_loop(FILE * input);
 
 
 /* Table of built-in functions (these are non-forking builtins, meaning they
  * can change global variables in the parent shell process but they will not
  * work with pipes and redirects; 'unset foo | whatever' will not work) */
 static struct built_in_command bltins[] = {
 	{"bg", "Resume a job in the background", builtin_fg_bg},
 	{"cd", "Change working directory", builtin_cd},
 	{"exec", "Exec command, replacing this shell with the exec'd process", builtin_exec},
 	{"exit", "Exit from shell()", builtin_exit},
 	{"fg", "Bring job into the foreground", builtin_fg_bg},
 	{"jobs", "Lists the active jobs", builtin_jobs},
 	{"export", "Set environment variable", builtin_export},
 	{"unset", "Unset environment variable", builtin_unset},
 	{"read", "Input environment variable", builtin_read},
 	{".", "Source-in and run commands in a file", builtin_source},
 	/* to do: add ulimit */
 #ifdef BB_FEATURE_SH_IF_EXPRESSIONS
 	{"if", NULL, builtin_if},
 	{"then", NULL, builtin_then},
 	{"else", NULL, builtin_else},
 	{"fi", NULL, builtin_fi},
 #endif
 	{NULL, NULL, NULL}
 };
 
 /* Table of forking built-in functions (things that fork cannot change global
  * variables in the parent process, such as the current working directory) */
 static struct built_in_command bltins_forking[] = {
 	{"pwd", "Print current directory", builtin_pwd},
 	{"help", "List shell built-in commands", builtin_help},
 	{NULL, NULL, NULL}
 };
 
 
 /* Variables we export */
 unsigned int shell_context;  /* Used in cmdedit.c to reset the
 								context when someone hits ^C */
 
 
 /* Globals that are static to this file */
 static const char *cwd;
 static char *local_pending_command = NULL;
 static struct jobset job_list = { NULL, NULL };
 static int argc;
 static char **argv;
 static struct close_me *close_me_head;
 #ifdef BB_FEATURE_SH_ENVIRONMENT
 static int last_bg_pid;
 static int last_return_code;
 static int show_x_trace;
 #endif
 #ifdef BB_FEATURE_SH_IF_EXPRESSIONS
 static char syntax_err[]="syntax error near unexpected token";
 #endif
 
 static char *PS1;
 static char *PS2 = "> ";
 
 
 #ifdef DEBUG_SHELL
 static inline void debug_printf(const char *format, ...)
 {
 	va_list args;
 	va_start(args, format);
 	vfprintf(stderr, format, args);
 	va_end(args);
 }
 #else
 static inline void debug_printf(const char *format, ...) { }
 #endif
 
 /*
 	Most builtins need access to the struct child_prog that has
 	their arguments, previously coded as cmd->progs[0].  That coding
 	can exhibit a bug, if the builtin is not the first command in
 	a pipeline: "echo foo | exec sort" will attempt to exec foo.
 
 builtin   previous use      notes
 ------ -----------------  ---------
 cd      cmd->progs[0]
 exec    cmd->progs[0]  squashed bug: didn't look for applets or forking builtins
 exit    cmd->progs[0]
 fg_bg   cmd->progs[0], job_list->head, job_list->fg
 help    0
 jobs    job_list->head
 pwd     0
 export  cmd->progs[0]
 source  cmd->progs[0]
 unset   cmd->progs[0]
 read    cmd->progs[0]
 if      cmd->job_context,  cmd->text
 then    cmd->job_context,  cmd->text
 else    cmd->job_context,  cmd->text
 fi      cmd->job_context
 
 The use of cmd->text by if/then/else/fi is hopelessly hacky.
 Would it work to increment cmd->progs[0]->argv and recurse,
 somewhat like builtin_exec does?
 
 I added "struct job *family;" to struct child_prog,
 and switched API to builtin_foo(struct child_prog *child);
 So   cmd->text        becomes  child->family->text
      cmd->job_context  becomes  child->family->job_context
      cmd->progs[0]    becomes  *child
      job_list          becomes  child->family->job_list
  */
 
 /* built-in 'cd <path>' handler */
 static int builtin_cd(struct child_prog *child)
 {
 	char *newdir;
 
 	if (child->argv[1] == NULL)
 		newdir = getenv("HOME");
 	else
 		newdir = child->argv[1];
 	if (chdir(newdir)) {
 		printf("cd: %s: %m\n", newdir);
 		return EXIT_FAILURE;
 	}
 	cwd = xgetcwd((char *)cwd);
 	if (!cwd)
 		cwd = unknown;
 	return EXIT_SUCCESS;
 }
 
 /* built-in 'exec' handler */
 static int builtin_exec(struct child_prog *child)
 {
 	if (child->argv[1] == NULL)
 		return EXIT_SUCCESS;   /* Really? */
 	child->argv++;
 	close_all();
 	pseudo_exec(child);
 	/* never returns */
 }
 
 /* built-in 'exit' handler */
 static int builtin_exit(struct child_prog *child)
 {
 	if (child->argv[1] == NULL)
 		exit(EXIT_SUCCESS);
 
 	exit (atoi(child->argv[1]));
 }
 
 /* built-in 'fg' and 'bg' handler */
 static int builtin_fg_bg(struct child_prog *child)
 {
 	int i, jobNum;
 	struct job *job=NULL;
 	
 	if (!child->argv[1] || child->argv[2]) {
 		error_msg("%s: exactly one argument is expected",
 				child->argv[0]);
 		return EXIT_FAILURE;
 	}
 
 	if (sscanf(child->argv[1], "%%%d", &jobNum) != 1) {
 		error_msg("%s: bad argument '%s'",
 				child->argv[0], child->argv[1]);
 		return EXIT_FAILURE;
 	}
 
 	for (job = child->family->job_list->head; job; job = job->next) {
 		if (job->jobid == jobNum) {
 			break;
 		}
 	}
 
 	if (!job) {
 		error_msg("%s: unknown job %d",
 				child->argv[0], jobNum);
 		return EXIT_FAILURE;
 	}
 
 	if (*child->argv[0] == 'f') {
 		/* Make this job the foreground job */
 		/* suppress messages when run from /linuxrc mag@sysgo.de */
 		if (tcsetpgrp(0, job->pgrp) && errno != ENOTTY)
 			perror_msg("tcsetpgrp"); 
 		child->family->job_list->fg = job;
 	}
 
 	/* Restart the processes in the job */
 	for (i = 0; i < job->num_progs; i++)
 		job->progs[i].is_stopped = 0;
 
 	kill(-job->pgrp, SIGCONT);
 
 	job->stopped_progs = 0;
 
 	return EXIT_SUCCESS;
 }
 
 /* built-in 'help' handler */
 static int builtin_help(struct child_prog *dummy)
 {
 	struct built_in_command *x;
 
 	printf("\nBuilt-in commands:\n");
 	printf("-------------------\n");
 	for (x = bltins; x->cmd; x++) {
 		if (x->descr==NULL)
 			continue;
 		printf("%s\t%s\n", x->cmd, x->descr);
 	}
 	for (x = bltins_forking; x->cmd; x++) {
 		if (x->descr==NULL)
 			continue;
 		printf("%s\t%s\n", x->cmd, x->descr);
 	}
 	printf("\n\n");
 	return EXIT_SUCCESS;
 }
 
 /* built-in 'jobs' handler */
 static int builtin_jobs(struct child_prog *child)
 {
 	struct job *job;
 	char *status_string;
 
 	for (job = child->family->job_list->head; job; job = job->next) {
 		if (job->running_progs == job->stopped_progs)
 			status_string = "Stopped";
 		else
 			status_string = "Running";
 
 		printf(JOB_STATUS_FORMAT, job->jobid, status_string, job->text);
 	}
 	return EXIT_SUCCESS;
 }
 
 
 /* built-in 'pwd' handler */
 static int builtin_pwd(struct child_prog *dummy)
 {
 	cwd = xgetcwd((char *)cwd);
 	if (!cwd)
 		cwd = unknown;
 	puts(cwd);
 	return EXIT_SUCCESS;
 }
 
 /* built-in 'export VAR=value' handler */
 static int builtin_export(struct child_prog *child)
 {
 	int res;
 	char *v = child->argv[1];
 
 	if (v == NULL) {
 		char **e;
 		for (e = environ; *e; e++) {
 			puts(*e);
 		}
 		return 0;
 	}
 	res = putenv(v);
 	if (res)
 		fprintf(stderr, "export: %m\n");
-#ifndef BB_FEATURE_SH_SIMPLE_PROMPT
+#ifdef BB_FEATURE_SH_FANCY_PROMPT
 	if (strncmp(v, "PS1=", 4)==0)
 		PS1 = getenv("PS1");
 #endif
 
 #ifdef BB_LOCALE_SUPPORT
 	if(strncmp(v, "LC_ALL=", 7)==0)
 		setlocale(LC_ALL, getenv("LC_ALL"));
 	if(strncmp(v, "LC_CTYPE=", 9)==0)
 		setlocale(LC_CTYPE, getenv("LC_CTYPE"));
 #endif
 
 	return (res);
 }
 
 /* built-in 'read VAR' handler */
 static int builtin_read(struct child_prog *child)
 {
 	int res = 0, len, newlen;
 	char *s;
 	char string[MAX_READ];
 
 	if (child->argv[1]) {
 		/* argument (VAR) given: put "VAR=" into buffer */
 		strcpy(string, child->argv[1]);
 		len = strlen(string);
 		string[len++] = '=';
 		string[len]   = '\0';
 		fgets(&string[len], sizeof(string) - len, stdin);	/* read string */
 		newlen = strlen(string);
 		if(newlen > len)
 			string[--newlen] = '\0';	/* chomp trailing newline */
 		/*
 		** string should now contain "VAR=<value>"
 		** copy it (putenv() won't do that, so we must make sure
 		** the string resides in a static buffer!)
 		*/
 		res = -1;
 		if((s = strdup(string)))
 			res = putenv(s);
 		if (res)
 			fprintf(stderr, "read: %m\n");
 	}
 	else
 		fgets(string, sizeof(string), stdin);
 
 	return (res);
 }
 
 #ifdef BB_FEATURE_SH_IF_EXPRESSIONS
 /* Built-in handler for 'if' commands */
 static int builtin_if(struct child_prog *child)
 {
 	struct job *cmd = child->family;
 	int status;
 	char* charptr1=cmd->text+3; /* skip over the leading 'if ' */
 
 	/* Now run the 'if' command */
 	debug_printf( "job=%p entering builtin_if ('%s')-- context=%d\n", cmd, charptr1, cmd->job_context);
 	status = run_command_predicate(charptr1);
 	debug_printf( "if test returned ");
 	if (status == 0) {
 		debug_printf( "TRUE\n");
 		cmd->job_context |= IF_TRUE_CONTEXT;
 	} else {
 		debug_printf( "FALSE\n");
 		cmd->job_context |= IF_FALSE_CONTEXT;
 	}
 	debug_printf("job=%p builtin_if set job context to %x\n", cmd, cmd->job_context);
 	shell_context++;
 
 	return status;
 }
 
 /* Built-in handler for 'then' (part of the 'if' command) */
 static int builtin_then(struct child_prog *child)
 {
 	struct job *cmd = child->family;
 	char* charptr1=cmd->text+5; /* skip over the leading 'then ' */
 
 	debug_printf( "job=%p entering builtin_then ('%s')-- context=%d\n", cmd, charptr1, cmd->job_context);
 	if (! (cmd->job_context & (IF_TRUE_CONTEXT|IF_FALSE_CONTEXT))) {
 		shell_context = 0; /* Reset the shell's context on an error */
 		error_msg("%s `then'", syntax_err);
 		return EXIT_FAILURE;
 	}
 
 	cmd->job_context |= THEN_EXP_CONTEXT;
 	debug_printf("job=%p builtin_then set job context to %x\n", cmd, cmd->job_context);
 
 	/* If the if result was FALSE, skip the 'then' stuff */
 	if (cmd->job_context & IF_FALSE_CONTEXT) {
 		return EXIT_SUCCESS;
 	}
 
 	/* Seems the if result was TRUE, so run the 'then' command */
 	debug_printf( "'then' now running '%s'\n", charptr1);
 
 	return(run_command_predicate(charptr1));
 }
 
 /* Built-in handler for 'else' (part of the 'if' command) */
 static int builtin_else(struct child_prog *child)
 {
 	struct job *cmd = child->family;
 	char* charptr1=cmd->text+5; /* skip over the leading 'else ' */
 
 	debug_printf( "job=%p entering builtin_else ('%s')-- context=%d\n", cmd, charptr1, cmd->job_context);
 
 	if (! (cmd->job_context & THEN_EXP_CONTEXT)) {
 		shell_context = 0; /* Reset the shell's context on an error */
 		error_msg("%s `else'", syntax_err);
 		return EXIT_FAILURE;
 	}
 	/* If the if result was TRUE, skip the 'else' stuff */
 	if (cmd->job_context & IF_TRUE_CONTEXT) {
 		return EXIT_SUCCESS;
 	}
 
 	cmd->job_context |= ELSE_EXP_CONTEXT;
 	debug_printf("job=%p builtin_else set job context to %x\n", cmd, cmd->job_context);
 
 	/* Now run the 'else' command */
 	debug_printf( "'else' now running '%s'\n", charptr1);
 	return(run_command_predicate(charptr1));
 }
 
 /* Built-in handler for 'fi' (part of the 'if' command) */
 static int builtin_fi(struct child_prog *child)
 {
 	struct job *cmd = child->family;
 	debug_printf( "job=%p entering builtin_fi ('%s')-- context=%d\n", cmd, "", cmd->job_context);
 	if (! (cmd->job_context & (IF_TRUE_CONTEXT|IF_FALSE_CONTEXT))) {
 		shell_context = 0; /* Reset the shell's context on an error */
 		error_msg("%s `fi'", syntax_err);
 		return EXIT_FAILURE;
 	}
 	/* Clear out the if and then context bits */
 	cmd->job_context &= ~(IF_TRUE_CONTEXT|IF_FALSE_CONTEXT|THEN_EXP_CONTEXT|ELSE_EXP_CONTEXT);
 	debug_printf("job=%p builtin_fi set job context to %x\n", cmd, cmd->job_context);
 	shell_context--;
 	return EXIT_SUCCESS;
 }
 #endif
 
 /* Built-in '.' handler (read-in and execute commands from file) */
 static int builtin_source(struct child_prog *child)
 {
 	FILE *input;
 	int status;
 	int fd;
 
 	if (child->argv[1] == NULL)
 		return EXIT_FAILURE;
 
 	input = fopen(child->argv[1], "r");
 	if (!input) {
 		printf( "Couldn't open file '%s'\n", child->argv[1]);
 		return EXIT_FAILURE;
 	}
 
 	fd=fileno(input);
 	mark_open(fd);
 	/* Now run the file */
 	status = busy_loop(input);
 	fclose(input);
 	mark_closed(fd);
 	return (status);
 }
 
 /* built-in 'unset VAR' handler */
 static int builtin_unset(struct child_prog *child)
 {
 	if (child->argv[1] == NULL) {
 		printf( "unset: parameter required.\n");
 		return EXIT_FAILURE;
 	}
 	unsetenv(child->argv[1]);
 	return EXIT_SUCCESS;
 }
 
 #ifdef BB_FEATURE_SH_IF_EXPRESSIONS
 /* currently used by if/then/else.
  *
  * Reparsing the command line for this purpose is gross,
  * incorrect, and fundamentally unfixable; in particular,
  * think about what happens with command substitution.
  * We really need to pull out the run, wait, return status
  * functionality out of busy_loop so we can child->argv++
  * and use that, without going back through parse_command.
  */
 static int run_command_predicate(char *cmd)
 {
 	local_pending_command = xstrdup(cmd);
 	return( busy_loop(NULL));
 }
 #endif
 
 static void mark_open(int fd)
 {
 	struct close_me *new = xmalloc(sizeof(struct close_me));
 	new->fd = fd;
 	new->next = close_me_head;
 	close_me_head = new;
 }
 
 static void mark_closed(int fd)
 {
 	struct close_me *tmp;
 	if (close_me_head == NULL || close_me_head->fd != fd)
 		error_msg_and_die("corrupt close_me");
 	tmp = close_me_head;
 	close_me_head = close_me_head->next;
 	free(tmp);
 }
 
 static void close_all()
 {
 	struct close_me *c, *tmp;
 	for (c=close_me_head; c; c=tmp) {
 		close(c->fd);
 		tmp=c->next;
 		free(c);
 	}
 	close_me_head = NULL;
 }
 
 
 /* free up all memory from a job */
 static void free_job(struct job *cmd)
 {
 	int i;
 	struct jobset *keep;
 
 	for (i = 0; i < cmd->num_progs; i++) {
 		free(cmd->progs[i].argv);
 		if (cmd->progs[i].redirects)
 			free(cmd->progs[i].redirects);
 	}
 	if (cmd->progs)
 		free(cmd->progs);
 	if (cmd->text)
 		free(cmd->text);
 	if (cmd->cmdbuf)
 		free(cmd->cmdbuf);
 	keep = cmd->job_list;
 	memset(cmd, 0, sizeof(struct job));
 	cmd->job_list = keep;
 }
 
 /* remove a job from a jobset */
 static void remove_job(struct jobset *j_list, struct job *job)
 {
 	struct job *prevjob;
 
 	free_job(job);
 	if (job == j_list->head) {
 		j_list->head = job->next;
 	} else {
 		prevjob = j_list->head;
 		while (prevjob->next != job)
 			prevjob = prevjob->next;
 		prevjob->next = job->next;
 	}
 
 	free(job);
 }
 
 /* Checks to see if any background processes have exited -- if they 
    have, figure out why and see if a job has completed */
 static void checkjobs(struct jobset *j_list)
 {
 	struct job *job;
 	pid_t childpid;
 	int status;
 	int prognum = 0;
 
 	while ((childpid = waitpid(-1, &status, WNOHANG | WUNTRACED)) > 0) {
 		for (job = j_list->head; job; job = job->next) {
 			prognum = 0;
 			while (prognum < job->num_progs &&
 				   job->progs[prognum].pid != childpid) prognum++;
 			if (prognum < job->num_progs)
 				break;
 		}
 
 		/* This happens on backticked commands */
 		if(job==NULL)
 			return;
 
 		if (WIFEXITED(status) || WIFSIGNALED(status)) {
 			/* child exited */
 			job->running_progs--;
 			job->progs[prognum].pid = 0;
 
 			if (!job->running_progs) {
 				printf(JOB_STATUS_FORMAT, job->jobid, "Done", job->text);
 				remove_job(j_list, job);
 			}
 		} else {
 			/* child stopped */
 			job->stopped_progs++;
 			job->progs[prognum].is_stopped = 1;
 
 			if (job->stopped_progs == job->num_progs) {
 				printf(JOB_STATUS_FORMAT, job->jobid, "Stopped",
 					   job->text);
 			}
 		}
 	}
 
 	if (childpid == -1 && errno != ECHILD)
 		perror_msg("waitpid");
 }
 
 /* squirrel != NULL means we squirrel away copies of stdin, stdout,
  * and stderr if they are redirected. */
 static int setup_redirects(struct child_prog *prog, int squirrel[])
 {
 	int i;
 	int openfd;
 	int mode = O_RDONLY;
 	struct redir_struct *redir = prog->redirects;
 
 	for (i = 0; i < prog->num_redirects; i++, redir++) {
 		switch (redir->type) {
 		case REDIRECT_INPUT:
 			mode = O_RDONLY;
 			break;
 		case REDIRECT_OVERWRITE:
 			mode = O_WRONLY | O_CREAT | O_TRUNC;
 			break;
 		case REDIRECT_APPEND:
 			mode = O_WRONLY | O_CREAT | O_APPEND;
 			break;
 		}
 
 		openfd = open(redir->filename, mode, 0666);
 		if (openfd < 0) {
 			/* this could get lost if stderr has been redirected, but
 			   bash and ash both lose it as well (though zsh doesn't!) */
 			perror_msg("error opening %s", redir->filename);
 			return 1;
 		}
 
 		if (openfd != redir->fd) {
 			if (squirrel && redir->fd < 3) {
 				squirrel[redir->fd] = dup(redir->fd);
 			}
 			dup2(openfd, redir->fd);
 			close(openfd);
 		}
 	}
 
 	return 0;
 }
 
 static void restore_redirects(int squirrel[])
 {
 	int i, fd;
 	for (i=0; i<3; i++) {
 		fd = squirrel[i];
 		if (fd != -1) {
 			/* No error checking.  I sure wouldn't know what
 			 * to do with an error if I found one! */
 			dup2(fd, i);
 			close(fd);
 		}
 	}
 }
 
 static inline void cmdedit_set_initial_prompt(void)
 {
-#ifdef BB_FEATURE_SH_SIMPLE_PROMPT
+#ifndef BB_FEATURE_SH_FANCY_PROMPT
 	PS1 = NULL;
 #else
 	PS1 = getenv("PS1");
 	if(PS1==0)
 		PS1 = "\\w \\$ ";
 #endif	
 }
 
 static inline void setup_prompt_string(char **prompt_str)
 {
-#ifdef BB_FEATURE_SH_SIMPLE_PROMPT
+#ifndef BB_FEATURE_SH_FANCY_PROMPT
 	/* Set up the prompt */
 	if (shell_context == 0) {
 		if (PS1)
 			free(PS1);
 		PS1=xmalloc(strlen(cwd)+4);
 		sprintf(PS1, "%s %s", cwd, ( geteuid() != 0 ) ?  "$ ":"# ");
 		*prompt_str = PS1;
 	} else {
 		*prompt_str = PS2;
 	}
 #else
 	*prompt_str = (shell_context==0)? PS1 : PS2;
 #endif	
 }
 
 static int get_command(FILE * source, char *command)
 {
 	char *prompt_str;
 
 	if (source == NULL) {
 		if (local_pending_command) {
 			/* a command specified (-c option): return it & mark it done */
 			strcpy(command, local_pending_command);
 			free(local_pending_command);
 			local_pending_command = NULL;
 			return 0;
 		}
 		return 1;
 	}
 
 	if (source == stdin) {
 		setup_prompt_string(&prompt_str);
 
 #ifdef BB_FEATURE_COMMAND_EDITING
 		/*
 		** enable command line editing only while a command line
 		** is actually being read; otherwise, we'll end up bequeathing
 		** atexit() handlers and other unwanted stuff to our
 		** child processes (rob@sysgo.de)
 		*/
 		cmdedit_read_input(prompt_str, command);
 		cmdedit_terminate();
 		return 0;
 #else
 		fputs(prompt_str, stdout);
 #endif
 	}
 
 	if (!fgets(command, BUFSIZ - 2, source)) {
 		if (source == stdin)
 			printf("\n");
 		return 1;
 	}
 
 	return 0;
 }
 
 #ifdef BB_FEATURE_SH_ENVIRONMENT
 static char* itoa(register int i)
 {
 	static char a[7]; /* Max 7 ints */
 	register char *b = a + sizeof(a) - 1;
 	int   sign = (i < 0);
 
 	if (sign)
 		i = -i;
 	*b = 0;
 	do
 	{
 		*--b = '0' + (i % 10);
 		i /= 10;
 	}
 	while (i);
 	if (sign)
 		*--b = '-';
 	return b;
 }
 #endif	
 
 #if defined BB_FEATURE_SH_ENVIRONMENT && ! defined BB_FEATURE_SH_WORDEXP
 char * strsep_space( char *string, int * ix)
 {
 	char *token, *begin;
 
 	begin = string;
 
 	/* Short circuit the trivial case */
 	if ( !string || ! string[*ix])
 		return NULL;
 
 	/* Find the end of the token. */
 	while( string && string[*ix] && !isspace(string[*ix]) ) {
 		(*ix)++;
 	}
 
 	/* Find the end of any whitespace trailing behind 
 	 * the token and let that be part of the token */
 	while( string && string[*ix] && isspace(string[*ix]) ) {
 		(*ix)++;
 	}
 
 	if (! string && *ix==0) {
 		/* Nothing useful was found */
 		return NULL;
 	}
 
 	token = xmalloc(*ix+1);
 	token[*ix] = '\0';
 	strncpy(token, string,  *ix); 
 
 	return token;
 }
 #endif	
 
 
 static int expand_arguments(char *command)
 {
 #ifdef BB_FEATURE_SH_ENVIRONMENT
 	expand_t expand_result;
 	char *src, *dst, *var;
 	int ix = 0;
 	int i=0, length, total_length=0, retval;
 	const char *out_of_space = "out of space during expansion"; 
 #endif
 
 	/* get rid of the terminating \n */
 	chomp(command);
 	
 	/* Fix up escape sequences to be the Real Thing(tm) */
 	while( command && command[ix]) {
 		if (command[ix] == '\\') {
 			const char *tmp = command+ix+1;
 			command[ix] = process_escape_sequence(  &tmp );
 			memmove(command+ix + 1, tmp, strlen(tmp)+1);
 		}
 		ix++;
 	}
 
 #ifdef BB_FEATURE_SH_ENVIRONMENT
 
 
 #ifdef BB_FEATURE_SH_WORDEXP
 	/* This first part uses wordexp() which is a wonderful C lib 
 	 * function which expands nearly everything.  */ 
 	retval = wordexp (command, &expand_result, WRDE_SHOWERR);
 	if (retval == WRDE_NOSPACE) {
 		/* Mem may have been allocated... */
 		wordfree (&expand_result);
 		error_msg(out_of_space);
 		return FALSE;
 	}
 	if (retval < 0) {
 		/* Some other error.  */
 		error_msg("syntax error");
 		return FALSE;
 	}
 	
 	if (expand_result.we_wordc > 0) {
 		/* Convert from char** (one word per string) to a simple char*,
 		 * but don't overflow command which is BUFSIZ in length */
 		*command = '\0';
 		while (i < expand_result.we_wordc && total_length < BUFSIZ) {
 			length=strlen(expand_result.we_wordv[i])+1;
 			if (BUFSIZ-total_length-length <= 0) {
 				error_msg(out_of_space);
 				return FALSE;
 			}
 			strcat(command+total_length, expand_result.we_wordv[i++]);
 			strcat(command+total_length, " ");
 			total_length+=length;
 		}
 		wordfree (&expand_result);
 	}
 #else
 
 	/* Ok.  They don't have a recent glibc and they don't have uClibc.  Chances
 	 * are about 100% they don't have wordexp(). So instead the best we can do
 	 * is use glob and then fixup environment variables and such ourselves.
 	 * This is better then nothing, but certainly not perfect */
 
 	/* It turns out that glob is very stupid.  We have to feed it one word at a
 	 * time since it can't cope with a full string.  Here we convert command
 	 * (char*) into cmd (char**, one word per string) */
 	{
         
 		int flags = GLOB_NOCHECK
 #ifdef GLOB_BRACE
 				| GLOB_BRACE
 #endif	
 #ifdef GLOB_TILDE
 				| GLOB_TILDE
 #endif	
 			;
 		char *tmpcmd, *cmd, *cmd_copy;
 		/* We need a clean copy, so strsep can mess up the copy while
 		 * we write stuff into the original (in a minute) */
 		cmd = cmd_copy = strdup(command);
 		*command = '\0';
 		for (ix = 0, tmpcmd = cmd; 
 				(tmpcmd = strsep_space(cmd, &ix)) != NULL; cmd += ix, ix=0) {
 			if (*tmpcmd == '\0')
 				break;
 			/* we need to trim() the result for glob! */
 			trim(tmpcmd);
 			retval = glob(tmpcmd, flags, NULL, &expand_result);
 			free(tmpcmd); /* Free mem allocated by strsep_space */
 			if (retval == GLOB_NOSPACE) {
 				/* Mem may have been allocated... */
 				globfree (&expand_result);
 				error_msg(out_of_space);
 				return FALSE;
 			} else if (retval != 0) {
 				/* Some other error.  GLOB_NOMATCH shouldn't
 				 * happen because of the GLOB_NOCHECK flag in 
 				 * the glob call. */
 				error_msg("syntax error");
 				return FALSE;
 			} else {
 			/* Convert from char** (one word per string) to a simple char*,
 			 * but don't overflow command which is BUFSIZ in length */
 				for (i=0; i < expand_result.gl_pathc; i++) {
 					length=strlen(expand_result.gl_pathv[i]);
 					if (total_length+length+1 >= BUFSIZ) {
 						error_msg(out_of_space);
 						return FALSE;
 					}
 					strcat(command+total_length, " ");
 					total_length+=1;
 					strcat(command+total_length, expand_result.gl_pathv[i]);
 					total_length+=length;
 				}
 				globfree (&expand_result);
 			}
 		}
 		free(cmd_copy);
 		trim(command);
 	}
 	
 #endif	
 
 	/* Now do the shell variable substitutions which 
 	 * wordexp can't do for us, namely $? and $! */
 	src = command;
 	while((dst = strchr(src,'$')) != NULL){
 		var = NULL;
 		switch(*(dst+1)) {
 			case '?':
 				var = itoa(last_return_code);
 				break;
 			case '!':
 				if (last_bg_pid==-1)
 					*(var)='\0';
 				else
 					var = itoa(last_bg_pid);
 				break;
 				/* Everything else like $$, $#, $[0-9], etc should all be
 				 * expanded by wordexp(), so we can in theory skip that stuff
 				 * here, but just to be on the safe side (i.e. since uClibc
 				 * wordexp doesn't do this stuff yet), lets leave it in for
 				 * now. */
 			case '$':
 				var = itoa(getpid());
 				break;
 			case '#':
 				var = itoa(argc-1);
 				break;
 			case '0':case '1':case '2':case '3':case '4':
 			case '5':case '6':case '7':case '8':case '9':
 				{
 					int ixx=*(dst + 1)-48;
 					if (ixx >= argc) {
 						var='\0';
 					} else {
 						var = argv[ixx];
 					}
 				}
 				break;
 
 		}
 		if (var) {
 			/* a single character construction was found, and 
 			 * already handled in the case statement */
 			src=dst+2;
 		} else {
 			/* Looks like an environment variable */
 			char delim_hold;
 			int num_skip_chars=0;
 			int dstlen = strlen(dst);
 			/* Is this a ${foo} type variable? */
 			if (dstlen >=2 && *(dst+1) == '{') {
 				src=strchr(dst+1, '}');
 				num_skip_chars=1;
 			} else {
 				src=dst+1;
 				while(isalnum(*src) || *src=='_') src++;
 			}
 			if (src == NULL) {
 				src = dst+dstlen;
 			}
 			delim_hold=*src;
 			*src='\0';  /* temporary */
 			var = getenv(dst + 1 + num_skip_chars);
 			*src=delim_hold;
 			src += num_skip_chars;
 		}
 		if (var == NULL) {
 			/* Seems we got an un-expandable variable.  So delete it. */
 			var = "";
 		}
 		{
 			int subst_len = strlen(var);
 			int trail_len = strlen(src);
 			if (dst+subst_len+trail_len >= command+BUFSIZ) {
 				error_msg(out_of_space);
 				return FALSE;
 			}
 			/* Move stuff to the end of the string to accommodate
 			 * filling the created gap with the new stuff */
 			memmove(dst+subst_len, src, trail_len+1);
 			/* Now copy in the new stuff */
 			memcpy(dst, var, subst_len);
 			src = dst+subst_len;
 		}
 	}
 
 #endif	
 	return TRUE;
 }
 
 /* Return cmd->num_progs as 0 if no command is present (e.g. an empty
    line). If a valid command is found, command_ptr is set to point to
    the beginning of the next command (if the original command had more 
    then one job associated with it) or NULL if no more commands are 
    present. */
 static int parse_command(char **command_ptr, struct job *job, int *inbg)
 {
 	char *command;
 	char *return_command = NULL;
 	char *src, *buf, *chptr;
 	int argc_l = 0;
 	int done = 0;
 	int argv_alloced;
 	int i, saw_quote = 0;
 	char quote = '\0';
 	int count;
 	struct child_prog *prog;
 
 	/* skip leading white space */
 	while (**command_ptr && isspace(**command_ptr))
 		(*command_ptr)++;
 
 	/* this handles empty lines or leading '#' characters */
 	if (!**command_ptr || (**command_ptr == '#')) {
 		job->num_progs=0;
 		return 0;
 	}
 
 	*inbg = 0;
 	job->num_progs = 1;
 	job->progs = xmalloc(sizeof(*job->progs));
 
 	/* We set the argv elements to point inside of this string. The 
 	   memory is freed by free_job(). Allocate twice the original
 	   length in case we need to quote every single character.
 
 	   Getting clean memory relieves us of the task of NULL 
 	   terminating things and makes the rest of this look a bit 
 	   cleaner (though it is, admittedly, a tad less efficient) */
 	job->cmdbuf = command = xcalloc(2*strlen(*command_ptr) + 1, sizeof(char));
 	job->text = NULL;
 
 	prog = job->progs;
 	prog->num_redirects = 0;
 	prog->redirects = NULL;
 	prog->is_stopped = 0;
 	prog->family = job;
 
 	argv_alloced = 5;
 	prog->argv = xmalloc(sizeof(*prog->argv) * argv_alloced);
 	prog->argv[0] = job->cmdbuf;
 
 	buf = command;
 	src = *command_ptr;
 	while (*src && !done) {
 		if (quote == *src) {
 			quote = '\0';
 		} else if (quote) {
 			if (*src == '\\') {
 				src++;
 				if (!*src) {
 					error_msg("character expected after \\");
 					free_job(job);
 					return 1;
 				}
 
 				/* in shell, "\'" should yield \' */
 				if (*src != quote) {
 					*buf++ = '\\';
 					*buf++ = '\\';
 				}
 			} else if (*src == '*' || *src == '?' || *src == '[' ||
 					   *src == ']') *buf++ = '\\';
 			*buf++ = *src;
 		} else if (isspace(*src)) {
 			if (*prog->argv[argc_l] || saw_quote) {
 				buf++, argc_l++;
 				/* +1 here leaves room for the NULL which ends argv */
 				if ((argc_l + 1) == argv_alloced) {
 					argv_alloced += 5;
 					prog->argv = xrealloc(prog->argv,
 										  sizeof(*prog->argv) *
 										  argv_alloced);
 				}
 				prog->argv[argc_l] = buf;
 				saw_quote = 0;
 			}
 		} else
 			switch (*src) {
 			case '"':
 			case '\'':
 				quote = *src;
 				saw_quote = 1;
 				break;
 
 			case '#':			/* comment */
 				if (*(src-1)== '$')
 					*buf++ = *src;
 				else
 					done = 1;
 				break;
 
 			case '>':			/* redirects */
 			case '<':
 				i = prog->num_redirects++;
 				prog->redirects = xrealloc(prog->redirects,
 											  sizeof(*prog->redirects) *
 											  (i + 1));
 
 				prog->redirects[i].fd = -1;
 				if (buf != prog->argv[argc_l]) {
 					/* the stuff before this character may be the file number 
 					   being redirected */
 					prog->redirects[i].fd =
 						strtol(prog->argv[argc_l], &chptr, 10);
 
 					if (*chptr && *prog->argv[argc_l]) {
 						buf++, argc_l++;
 						prog->argv[argc_l] = buf;
 					}
 				}
 
 				if (prog->redirects[i].fd == -1) {
 					if (*src == '>')
 						prog->redirects[i].fd = 1;
 					else
 						prog->redirects[i].fd = 0;
 				}
 
 				if (*src++ == '>') {
 					if (*src == '>')
 						prog->redirects[i].type =
 							REDIRECT_APPEND, src++;
 					else
 						prog->redirects[i].type = REDIRECT_OVERWRITE;
 				} else {
 					prog->redirects[i].type = REDIRECT_INPUT;
 				}
 
 				/* This isn't POSIX sh compliant. Oh well. */
 				chptr = src;
 				while (isspace(*chptr))
 					chptr++;
 
 				if (!*chptr) {
 					error_msg("file name expected after %c", *(src-1));
 					free_job(job);
 					job->num_progs=0;
 					return 1;
 				}
 
 				prog->redirects[i].filename = buf;
 				while (*chptr && !isspace(*chptr))
 					*buf++ = *chptr++;
 
 				src = chptr - 1;	/* we src++ later */
 				prog->argv[argc_l] = ++buf;
 				break;
 
 			case '|':			/* pipe */
 				/* finish this command */
 				if (*prog->argv[argc_l] || saw_quote)
 					argc_l++;
 				if (!argc_l) {
 					error_msg("empty command in pipe");
 					free_job(job);
 					job->num_progs=0;
 					return 1;
 				}
 				prog->argv[argc_l] = NULL;
 
 				/* and start the next */
 				job->num_progs++;
 				job->progs = xrealloc(job->progs,
 									  sizeof(*job->progs) * job->num_progs);
 				prog = job->progs + (job->num_progs - 1);
 				prog->num_redirects = 0;
 				prog->redirects = NULL;
 				prog->is_stopped = 0;
 				prog->family = job;
 				argc_l = 0;
 
 				argv_alloced = 5;
 				prog->argv = xmalloc(sizeof(*prog->argv) * argv_alloced);
 				prog->argv[0] = ++buf;
 
 				src++;
 				while (*src && isspace(*src))
 					src++;
 
 				if (!*src) {
 					error_msg("empty command in pipe");
 					free_job(job);
 					job->num_progs=0;
 					return 1;
 				}
 				src--;			/* we'll ++ it at the end of the loop */
 
 				break;
 
 			case '&':			/* background */
 				*inbg = 1;
 			case ';':			/* multiple commands */
 				done = 1;
 				return_command = *command_ptr + (src - *command_ptr) + 1;
 				break;
 
 #ifdef BB_FEATURE_SH_BACKTICKS
 			case '`':
 				/* Exec a backtick-ed command */
 				/* Besides any previous brokenness, I have not
 				 * updated backtick handling for close_me support.
 				 * I don't know if it needs it or not.  -- LRD */
 				{
 					char* charptr1=NULL, *charptr2;
 					char* ptr=NULL;
 					struct job *newjob;
 					struct jobset njob_list = { NULL, NULL };
 					int pipefd[2];
 					int size;
 
 					ptr=strchr(++src, '`');
 					if (ptr==NULL) {
 						fprintf(stderr, "Unmatched '`' in command\n");
 						free_job(job);
 						return 1;
 					}
 
 					/* Make some space to hold just the backticked command */
 					charptr1 = charptr2 = xmalloc(1+ptr-src);
 					memcpy(charptr1, src, ptr-src);
 					charptr1[ptr-src] = '\0';
 					newjob = xmalloc(sizeof(struct job));
 					newjob->job_list = &njob_list;
 					/* Now parse and run the backticked command */
 					if (!parse_command(&charptr1, newjob, inbg) 
 							&& newjob->num_progs) {
 						pipe(pipefd);
 						run_command(newjob, 0, pipefd);
 					}
 					checkjobs(job->job_list);
 					free_job(newjob);  /* doesn't actually free newjob,
 					                     looks like a memory leak */
 					free(charptr2);
 					
 					/* Make a copy of any stuff left over in the command 
 					 * line after the second backtick */
 					charptr2 = xmalloc(strlen(ptr)+1);
 					memcpy(charptr2, ptr+1, strlen(ptr));
 
 
 					/* Copy the output from the backtick-ed command into the
 					 * command line, making extra room as needed  */
 					--src;
 					charptr1 = xmalloc(BUFSIZ);
 					while ( (size=full_read(pipefd[0], charptr1, BUFSIZ-1)) >0) {
 						int newsize=src - *command_ptr + size + 1 + strlen(charptr2);
 						if (newsize > BUFSIZ) {
 							*command_ptr=xrealloc(*command_ptr, newsize);
 						}
 						memcpy(src, charptr1, size); 
 						src+=size;
 					}
 					free(charptr1);
 					close(pipefd[0]);
 					if (*(src-1)=='\n')
 						--src;
 
 					/* Now paste into the *command_ptr all the stuff 
 					 * leftover after the second backtick */
 					memcpy(src, charptr2, strlen(charptr2)+1);
 					free(charptr2);
 
 					/* Now recursively call parse_command to deal with the new
 					 * and improved version of the command line with the backtick
 					 * results expanded in place... */
 					{
 						struct jobset *jl=job->job_list;
 						free_job(job);
 						job->job_list = jl;
 					}
 					return(parse_command(command_ptr, job, inbg));
 				}
 				break;
 #endif // BB_FEATURE_SH_BACKTICKS
 
 			case '\\':
 				src++;
 				if (!*src) {
 /* This is currently a little broken... */
 #ifdef HANDLE_CONTINUATION_CHARS
 					/* They fed us a continuation char, so continue reading stuff
 					 * on the next line, then tack that onto the end of the current
 					 * command */
 					char *command;
 					int newsize;
 					printf("erik: found a continue char at EOL...\n");
 					command = (char *) xcalloc(BUFSIZ, sizeof(char));
 					if (get_command(input, command)) {
 						error_msg("character expected after \\");
 						free(command);
 						free_job(job);
 						return 1;
 					}
 					newsize = strlen(*command_ptr) + strlen(command) + 2;
 					if (newsize > BUFSIZ) {
 						printf("erik: doing realloc\n");
 						*command_ptr=xrealloc(*command_ptr, newsize);
 					}
 					printf("erik: A: *command_ptr='%s'\n", *command_ptr);
 					memcpy(--src, command, strlen(command)); 
 					printf("erik: B: *command_ptr='%s'\n", *command_ptr);
 					free(command);
 					break;
 #else
 					error_msg("character expected after \\");
 					free_job(job);
 					return 1;
 #endif
 				}
 				if (*src == '*' || *src == '[' || *src == ']'
 					|| *src == '?') *buf++ = '\\';
 				/* fallthrough */
 			default:
 				*buf++ = *src;
 			}
 
 		src++;
 	}
 
 	if (*prog->argv[argc_l] || saw_quote) {
 		argc_l++;
 	}
 	if (!argc_l) {
 		free_job(job);
 		return 0;
 	}
 	prog->argv[argc_l] = NULL;
 
 	if (!return_command) {
 		job->text = xmalloc(strlen(*command_ptr) + 1);
 		strcpy(job->text, *command_ptr);
 	} else {
 		/* This leaves any trailing spaces, which is a bit sloppy */
 		count = return_command - *command_ptr;
 		job->text = xmalloc(count + 1);
 		strncpy(job->text, *command_ptr, count);
 		job->text[count] = '\0';
 	}
 
 	*command_ptr = return_command;
 	
 	return 0;
 }
 
 /* Run the child_prog, no matter what kind of command it uses.
  */
 static int pseudo_exec(struct child_prog *child)
 {
 	struct built_in_command *x;
 #ifdef BB_FEATURE_SH_STANDALONE_SHELL
 	char *name;
 #endif
 
 	/* Check if the command matches any of the non-forking builtins.
 	 * Depending on context, this might be redundant.  But it's
 	 * easier to waste a few CPU cycles than it is to figure out
 	 * if this is one of those cases.
 	 */
 	for (x = bltins; x->cmd; x++) {
 		if (strcmp(child->argv[0], x->cmd) == 0 ) {
 			exit(x->function(child));
 		}
 	}
 
 	/* Check if the command matches any of the forking builtins. */
 	for (x = bltins_forking; x->cmd; x++) {
 		if (strcmp(child->argv[0], x->cmd) == 0) {
 			applet_name=x->cmd;
 			exit (x->function(child));
 		}
 	}
 #ifdef BB_FEATURE_SH_STANDALONE_SHELL
 	/* Check if the command matches any busybox internal
 	 * commands ("applets") here.  Following discussions from
 	 * November 2000 on busybox@opensource.lineo.com, don't use
 	 * get_last_path_component().  This way explicit (with
 	 * slashes) filenames will never be interpreted as an
 	 * applet, just like with builtins.  This way the user can
 	 * override an applet with an explicit filename reference.
 	 * The only downside to this change is that an explicit
 	 * /bin/foo invocation will fork and exec /bin/foo, even if
 	 * /bin/foo is a symlink to busybox.
 	 */
 	name = child->argv[0];
 
 #ifdef BB_FEATURE_SH_APPLETS_ALWAYS_WIN
 	/* If you enable BB_FEATURE_SH_APPLETS_ALWAYS_WIN, then
 	 * if you run /bin/cat, it will use BusyBox cat even if 
 	 * /bin/cat exists on the filesystem and is _not_ busybox.
 	 * Some systems want this, others do not.  Choose wisely.  :-)
 	 */
 	name = get_last_path_component(name);
 #endif
 
 	{
 	    char** argv_l=child->argv;
 	    int argc_l;
 	    for(argc_l=0;*argv_l!=NULL; argv_l++, argc_l++);
 	    optind = 1;
 	    run_applet_by_name(name, argc_l, child->argv);
 	}
 #endif
 
 	execvp(child->argv[0], child->argv);
 	perror_msg_and_die("%s", child->argv[0]);
 }
 
 static void insert_job(struct job *newjob, int inbg)
 {
 	struct job *thejob;
 	struct jobset *j_list=newjob->job_list;
 
 	/* find the ID for thejob to use */
 	newjob->jobid = 1;
 	for (thejob = j_list->head; thejob; thejob = thejob->next)
 		if (thejob->jobid >= newjob->jobid)
 			newjob->jobid = thejob->jobid + 1;
 
 	/* add thejob to the list of running jobs */
 	if (!j_list->head) {
 		thejob = j_list->head = xmalloc(sizeof(*thejob));
 	} else {
 		for (thejob = j_list->head; thejob->next; thejob = thejob->next) /* nothing */;
 		thejob->next = xmalloc(sizeof(*thejob));
 		thejob = thejob->next;
 	}
 
 	*thejob = *newjob;   /* physically copy the struct job */
 	thejob->next = NULL;
 	thejob->running_progs = thejob->num_progs;
 	thejob->stopped_progs = 0;
 
 	if (inbg) {
 		/* we don't wait for background thejobs to return -- append it 
 		   to the list of backgrounded thejobs and leave it alone */
 		printf("[%d] %d\n", thejob->jobid,
 			   newjob->progs[newjob->num_progs - 1].pid);
 #ifdef BB_FEATURE_SH_ENVIRONMENT
 		last_bg_pid=newjob->progs[newjob->num_progs - 1].pid;
 #endif
 	} else {
 		newjob->job_list->fg = thejob;
 
 		/* move the new process group into the foreground */
 		/* suppress messages when run from /linuxrc mag@sysgo.de */
 		if (tcsetpgrp(0, newjob->pgrp) && errno != ENOTTY)
 			perror_msg("tcsetpgrp");
 	}
 }
 
 static int run_command(struct job *newjob, int inbg, int outpipe[2])
 {
 	/* struct job *thejob; */
 	int i;
 	int nextin, nextout;
 	int pipefds[2];				/* pipefd[0] is for reading */
 	struct built_in_command *x;
 	struct child_prog *child;
 
 	nextin = 0, nextout = 1;
 	for (i = 0; i < newjob->num_progs; i++) {
 		child = & (newjob->progs[i]);
 
 		if ((i + 1) < newjob->num_progs) {
 			if (pipe(pipefds)<0) perror_msg_and_die("pipe");
 			nextout = pipefds[1];
 		} else {
 			if (outpipe[1]!=-1) {
 				nextout = outpipe[1];
 			} else {
 				nextout = 1;
 			}
 		}
 
 #ifdef BB_FEATURE_SH_ENVIRONMENT
 		if (show_x_trace==TRUE) {
 			int j;
 			fputc('+', stderr);
 			for (j = 0; child->argv[j]; j++) {
 				fputc(' ', stderr);
 				fputs(child->argv[j], stderr);
 			}
 			fputc('\n', stderr);
 		}
 #endif
 
 		/* Check if the command matches any non-forking builtins,
 		 * but only if this is a simple command.
 		 * Non-forking builtins within pipes have to fork anyway,
 		 * and are handled in pseudo_exec.  "echo foo | read bar"
 		 * is doomed to failure, and doesn't work on bash, either.
 		 */
 		if (newjob->num_progs == 1) {
 			for (x = bltins; x->cmd; x++) {
 				if (strcmp(child->argv[0], x->cmd) == 0 ) {
 					int squirrel[] = {-1, -1, -1};
 					int rcode;
 					setup_redirects(child, squirrel);
 					rcode = x->function(child);
 					restore_redirects(squirrel);
 					return rcode;
 				}
 			}
 		}
 
 		if (!(child->pid = fork())) {
 			signal(SIGTTOU, SIG_DFL);
 
 			close_all();
 
 			if (outpipe[1]!=-1) {
 				close(outpipe[0]);
 			}
 			if (nextin != 0) {
 				dup2(nextin, 0);
 				close(nextin);
 			}
 
 			if (nextout != 1) {
 				dup2(nextout, 1);
 				dup2(nextout, 2);  /* Really? */
 				close(nextout);
 				close(pipefds[0]);
 			}
 
 			/* explicit redirects override pipes */
 			setup_redirects(child,NULL);
 
 			pseudo_exec(child);
 		}
 		if (outpipe[1]!=-1) {
 			close(outpipe[1]);
 		}
 
 		/* put our child in the process group whose leader is the
 		   first process in this pipe */
 		setpgid(child->pid, newjob->progs[0].pid);
 		if (nextin != 0)
 			close(nextin);
 		if (nextout != 1)
 			close(nextout);
 
 		/* If there isn't another process, nextin is garbage 
 		   but it doesn't matter */
 		nextin = pipefds[0];
 	}
 
 	newjob->pgrp = newjob->progs[0].pid;
 
 	insert_job(newjob, inbg);
 
 	return 0;
 }
 
 static int busy_loop(FILE * input)
 {
 	char *command;
 	char *next_command = NULL;
 	struct job newjob;
 	pid_t  parent_pgrp;
 	int i;
 	int inbg;
 	int status;
 	newjob.job_list = &job_list;
 	newjob.job_context = DEFAULT_CONTEXT;
 
 	/* save current owner of TTY so we can restore it on exit */
 	parent_pgrp = tcgetpgrp(0);
 
 	command = (char *) xcalloc(BUFSIZ, sizeof(char));
 
 	/* don't pay any attention to this signal; it just confuses 
 	   things and isn't really meant for shells anyway */
 	signal(SIGTTOU, SIG_IGN);
 
 	while (1) {
 		if (!job_list.fg) {
 			/* no job is in the foreground */
 
 			/* see if any background processes have exited */
 			checkjobs(&job_list);
 
 			if (!next_command) {
 				if (get_command(input, command))
 					break;
 				next_command = command;
 			}
 
 			if (expand_arguments(next_command) == FALSE) {
 				free(command);
 				command = (char *) xcalloc(BUFSIZ, sizeof(char));
 				next_command = NULL;
 				continue;
 			}
 
 			if (!parse_command(&next_command, &newjob, &inbg) &&
 				newjob.num_progs) {
 				int pipefds[2] = {-1,-1};
 				debug_printf( "job=%p fed to run_command by busy_loop()'\n", 
 						&newjob);
 				run_command(&newjob, inbg, pipefds);
 			}
 			else {
 				free(command);
 				command = (char *) xcalloc(BUFSIZ, sizeof(char));
 				next_command = NULL;
 			}
 		} else {
 			/* a job is running in the foreground; wait for it */
 			i = 0;
 			while (!job_list.fg->progs[i].pid ||
 				   job_list.fg->progs[i].is_stopped == 1) i++;
 
 			if (waitpid(job_list.fg->progs[i].pid, &status, WUNTRACED)<0)
 				perror_msg_and_die("waitpid(%d)",job_list.fg->progs[i].pid);
 
 			if (WIFEXITED(status) || WIFSIGNALED(status)) {
 				/* the child exited */
 				job_list.fg->running_progs--;
 				job_list.fg->progs[i].pid = 0;
 
 #ifdef BB_FEATURE_SH_ENVIRONMENT
 				last_return_code=WEXITSTATUS(status);
 				debug_printf("'%s' exited -- return code %d\n",
 						job_list.fg->text, last_return_code);
 #endif
 				if (!job_list.fg->running_progs) {
 					/* child exited */
 					remove_job(&job_list, job_list.fg);
 					job_list.fg = NULL;
 				}
 			} else {
 				/* the child was stopped */
 				job_list.fg->stopped_progs++;
 				job_list.fg->progs[i].is_stopped = 1;
 
 				if (job_list.fg->stopped_progs == job_list.fg->running_progs) {
 					printf("\n" JOB_STATUS_FORMAT, job_list.fg->jobid,
 						   "Stopped", job_list.fg->text);
 					job_list.fg = NULL;
 				}
 			}
 
 			if (!job_list.fg) {
 				/* move the shell to the foreground */
 				/* suppress messages when run from /linuxrc mag@sysgo.de */
 				if (tcsetpgrp(0, getpgrp()) && errno != ENOTTY)
 					perror_msg("tcsetpgrp"); 
 			}
 		}
 	}
 	free(command);
 
 	/* return controlling TTY back to parent process group before exiting */
 	if (tcsetpgrp(0, parent_pgrp))
 		perror_msg("tcsetpgrp");
 
 	/* return exit status if called with "-c" */
 	if (input == NULL && WIFEXITED(status))
 		return WEXITSTATUS(status);
 	
 	return 0;
 }
 
 
 #ifdef BB_FEATURE_CLEAN_UP
 void free_memory(void)
 {
 	if (cwd) {
 		free(cwd);
 	}
 	if (local_pending_command)
 		free(local_pending_command);
 
 	if (job_list.fg && !job_list.fg->running_progs) {
 		remove_job(&job_list, job_list.fg);
 	}
 }
 #endif
 
 
 int shell_main(int argc_l, char **argv_l)
 {
 	int opt, interactive=FALSE;
 	FILE *input = stdin;
 	argc = argc_l;
 	argv = argv_l;
 
 	/* These variables need re-initializing when recursing */
 	shell_context = 0;
 	local_pending_command = NULL;
 	close_me_head = NULL;
 	job_list.head = NULL;
 	job_list.fg = NULL;
 #ifdef BB_FEATURE_SH_ENVIRONMENT
 	last_bg_pid=1;
 	last_return_code=1;
 	show_x_trace=FALSE;
 #endif
 
 	if (argv[0] && argv[0][0] == '-') {
 		FILE *prof_input;
 		prof_input = fopen("/etc/profile", "r");
 		if (!prof_input) {
 			printf( "Couldn't open file '/etc/profile'\n");
 		} else {
 			int tmp_fd = fileno(prof_input);
 			mark_open(tmp_fd);	
 			/* Now run the file */
 			busy_loop(prof_input);
 			fclose(prof_input);
 			mark_closed(tmp_fd);
 		}
 	}
 
 	while ((opt = getopt(argc_l, argv_l, "cxi")) > 0) {
 		switch (opt) {
 			case 'c':
 				input = NULL;
 				if (local_pending_command != 0)
 					error_msg_and_die("multiple -c arguments");
 				local_pending_command = xstrdup(argv[optind]);
 				optind++;
 				argv = argv+optind;
 				break;
 #ifdef BB_FEATURE_SH_ENVIRONMENT
 			case 'x':
 				show_x_trace = TRUE;
 				break;
 #endif
 			case 'i':
 				interactive = TRUE;
 				break;
 			default:
 				show_usage();
 		}
 	}
 	/* A shell is interactive if the `-i' flag was given, or if all of
 	 * the following conditions are met:
 	 *	  no -c command
 	 *    no arguments remaining or the -s flag given
 	 *    standard input is a terminal
 	 *    standard output is a terminal
 	 *    Refer to Posix.2, the description of the `sh' utility. */
 	if (argv[optind]==NULL && input==stdin &&
 			isatty(fileno(stdin)) && isatty(fileno(stdout))) {
 		interactive=TRUE;
 	}
 	if (interactive==TRUE) {
 		//printf( "optind=%d  argv[optind]='%s'\n", optind, argv[optind]);
 		/* Looks like they want an interactive shell */
 		printf( "\n\n" BB_BANNER " Built-in shell (lash)\n");
 		printf( "Enter 'help' for a list of built-in commands.\n\n");
 	} else if (local_pending_command==NULL) {
 		//printf( "optind=%d  argv[optind]='%s'\n", optind, argv[optind]);
 		input = xfopen(argv[optind], "r");
 		mark_open(fileno(input));  /* be lazy, never mark this closed */
 	}
 
 	/* initialize the cwd -- this is never freed...*/
 	cwd = xgetcwd(0);
 	if (!cwd)
 		cwd = unknown;
 
 #ifdef BB_FEATURE_CLEAN_UP
 	atexit(free_memory);
 #endif
 
 #ifdef BB_FEATURE_COMMAND_EDITING
 	cmdedit_set_initial_prompt();
 #else
 	PS1 = NULL;
 #endif
 	
 	return (busy_loop(input));
 }
 
diff --git a/networking/ping.c b/networking/ping.c
index 1afcb28..e4307d2 100644
--- a/networking/ping.c
+++ b/networking/ping.c
@@ -1,573 +1,573 @@
 /* vi: set sw=4 ts=4: */
 /*
- * $Id: ping.c,v 1.42 2001/05/16 15:52:23 kraai Exp $
+ * $Id: ping.c,v 1.43 2001/05/21 20:30:51 andersen Exp $
  * Mini ping implementation for busybox
  *
  * Copyright (C) 1999 by Randolph Chung <tausq@debian.org>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
  * General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
  *
  * This version of ping is adapted from the ping in netkit-base 0.10,
  * which is:
  *
  * Copyright (c) 1989 The Regents of the University of California.
  * All rights reserved.
  *
  * This code is derived from software contributed to Berkeley by
  * Mike Muuss.
  * 
  * Original copyright notice is retained at the end of this file.
  */
 
 #include <sys/param.h>
 #include <sys/socket.h>
 #include <sys/file.h>
 #include <sys/time.h>
 #include <sys/times.h>
 #include <sys/signal.h>
 
 #include <netinet/in.h>
 #include <netinet/ip.h>
 #include <netinet/ip_icmp.h>
 #include <arpa/inet.h>
 #include <netdb.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <errno.h>
 #include <unistd.h>
 #include <string.h>
 #include <stdlib.h>
 #include "busybox.h"
 
 
 /* It turns out that libc5 doesn't have proper icmp support
  * built into it header files, so we have to supplement it */
 #if __GNU_LIBRARY__ < 5
 static const int ICMP_MINLEN = 8;				/* abs minimum */
 
 struct icmp_ra_addr
 {
   u_int32_t ira_addr;
   u_int32_t ira_preference;
 };
 
 
 struct icmp
 {
   u_int8_t  icmp_type;	/* type of message, see below */
   u_int8_t  icmp_code;	/* type sub code */
   u_int16_t icmp_cksum;	/* ones complement checksum of struct */
   union
   {
     u_char ih_pptr;		/* ICMP_PARAMPROB */
     struct in_addr ih_gwaddr;	/* gateway address */
     struct ih_idseq		/* echo datagram */
     {
       u_int16_t icd_id;
       u_int16_t icd_seq;
     } ih_idseq;
     u_int32_t ih_void;
 
     /* ICMP_UNREACH_NEEDFRAG -- Path MTU Discovery (RFC1191) */
     struct ih_pmtu
     {
       u_int16_t ipm_void;
       u_int16_t ipm_nextmtu;
     } ih_pmtu;
 
     struct ih_rtradv
     {
       u_int8_t irt_num_addrs;
       u_int8_t irt_wpa;
       u_int16_t irt_lifetime;
     } ih_rtradv;
   } icmp_hun;
 #define	icmp_pptr	icmp_hun.ih_pptr
 #define	icmp_gwaddr	icmp_hun.ih_gwaddr
 #define	icmp_id		icmp_hun.ih_idseq.icd_id
 #define	icmp_seq	icmp_hun.ih_idseq.icd_seq
 #define	icmp_void	icmp_hun.ih_void
 #define	icmp_pmvoid	icmp_hun.ih_pmtu.ipm_void
 #define	icmp_nextmtu	icmp_hun.ih_pmtu.ipm_nextmtu
 #define	icmp_num_addrs	icmp_hun.ih_rtradv.irt_num_addrs
 #define	icmp_wpa	icmp_hun.ih_rtradv.irt_wpa
 #define	icmp_lifetime	icmp_hun.ih_rtradv.irt_lifetime
   union
   {
     struct
     {
       u_int32_t its_otime;
       u_int32_t its_rtime;
       u_int32_t its_ttime;
     } id_ts;
     struct
     {
       struct ip idi_ip;
       /* options and then 64 bits of data */
     } id_ip;
     struct icmp_ra_addr id_radv;
     u_int32_t   id_mask;
     u_int8_t    id_data[1];
   } icmp_dun;
 #define	icmp_otime	icmp_dun.id_ts.its_otime
 #define	icmp_rtime	icmp_dun.id_ts.its_rtime
 #define	icmp_ttime	icmp_dun.id_ts.its_ttime
 #define	icmp_ip		icmp_dun.id_ip.idi_ip
 #define	icmp_radv	icmp_dun.id_radv
 #define	icmp_mask	icmp_dun.id_mask
 #define	icmp_data	icmp_dun.id_data
 };
 #endif
 
 static const int DEFDATALEN = 56;
 static const int MAXIPLEN = 60;
 static const int MAXICMPLEN = 76;
 static const int MAXPACKET = 65468;
 #define	MAX_DUP_CHK	(8 * 128)
 static const int MAXWAIT = 10;
 static const int PINGINTERVAL = 1;		/* second */
 
 #define O_QUIET         (1 << 0)
 
 #define	A(bit)		rcvd_tbl[(bit)>>3]	/* identify byte in array */
 #define	B(bit)		(1 << ((bit) & 0x07))	/* identify bit in byte */
 #define	SET(bit)	(A(bit) |= B(bit))
 #define	CLR(bit)	(A(bit) &= (~B(bit)))
 #define	TST(bit)	(A(bit) & B(bit))
 
 static void ping(const char *host);
 
 /* common routines */
 static int in_cksum(unsigned short *buf, int sz)
 {
 	int nleft = sz;
 	int sum = 0;
 	unsigned short *w = buf;
 	unsigned short ans = 0;
 
 	while (nleft > 1) {
 		sum += *w++;
 		nleft -= 2;
 	}
 
 	if (nleft == 1) {
 		*(unsigned char *) (&ans) = *(unsigned char *) w;
 		sum += ans;
 	}
 
 	sum = (sum >> 16) + (sum & 0xFFFF);
 	sum += (sum >> 16);
 	ans = ~sum;
 	return (ans);
 }
 
 /* simple version */
-#ifdef BB_FEATURE_SIMPLE_PING
+#ifndef BB_FEATURE_FANCY_PING
 static char *hostname = NULL;
 
 static void noresp(int ign)
 {
 	printf("No response from %s\n", hostname);
 	exit(0);
 }
 
 static void ping(const char *host)
 {
 	struct hostent *h;
 	struct sockaddr_in pingaddr;
 	struct icmp *pkt;
 	int pingsock, c;
 	char packet[DEFDATALEN + MAXIPLEN + MAXICMPLEN];
 
 	if ((pingsock = socket(AF_INET, SOCK_RAW, 1)) < 0)	/* 1 == ICMP */
 		perror_msg_and_die("creating a raw socket");
 
 	/* drop root privs if running setuid */
 	setuid(getuid());
 
 	memset(&pingaddr, 0, sizeof(struct sockaddr_in));
 
 	pingaddr.sin_family = AF_INET;
 	h = xgethostbyname(host);
 	memcpy(&pingaddr.sin_addr, h->h_addr, sizeof(pingaddr.sin_addr));
 	hostname = h->h_name;
 
 	pkt = (struct icmp *) packet;
 	memset(pkt, 0, sizeof(packet));
 	pkt->icmp_type = ICMP_ECHO;
 	pkt->icmp_cksum = in_cksum((unsigned short *) pkt, sizeof(packet));
 
 	c = sendto(pingsock, packet, sizeof(packet), 0,
 			   (struct sockaddr *) &pingaddr, sizeof(struct sockaddr_in));
 
 	if (c < 0 || c != sizeof(packet))
 		perror_msg_and_die("sendto");
 
 	signal(SIGALRM, noresp);
 	alarm(5);					/* give the host 5000ms to respond */
 	/* listen for replies */
 	while (1) {
 		struct sockaddr_in from;
 		size_t fromlen = sizeof(from);
 
 		if ((c = recvfrom(pingsock, packet, sizeof(packet), 0,
 						  (struct sockaddr *) &from, &fromlen)) < 0) {
 			if (errno == EINTR)
 				continue;
 			perror_msg("recvfrom");
 			continue;
 		}
 		if (c >= 76) {			/* ip + icmp */
 			struct iphdr *iphdr = (struct iphdr *) packet;
 
 			pkt = (struct icmp *) (packet + (iphdr->ihl << 2));	/* skip ip hdr */
 			if (pkt->icmp_type == ICMP_ECHOREPLY)
 				break;
 		}
 	}
 	printf("%s is alive!\n", hostname);
 	return;
 }
 
 extern int ping_main(int argc, char **argv)
 {
 	argc--;
 	argv++;
 	if (argc < 1)
 		show_usage();
 	ping(*argv);
 	return EXIT_SUCCESS;
 }
 
-#else /* ! BB_FEATURE_SIMPLE_PING */
+#else /* ! BB_FEATURE_FANCY_PING */
 /* full(er) version */
 static char *hostname = NULL;
 static struct sockaddr_in pingaddr;
 static int pingsock = -1;
 static int datalen; /* intentionally uninitialized to work around gcc bug */
 
 static long ntransmitted = 0, nreceived = 0, nrepeats = 0, pingcount = 0;
 static int myid = 0, options = 0;
 static unsigned long tmin = ULONG_MAX, tmax = 0, tsum = 0;
 static char rcvd_tbl[MAX_DUP_CHK / 8];
 
 static void sendping(int);
 static void pingstats(int);
 static void unpack(char *, int, struct sockaddr_in *);
 
 /**************************************************************************/
 
 static void pingstats(int junk)
 {
 	int status;
 
 	signal(SIGINT, SIG_IGN);
 
 	printf("\n--- %s ping statistics ---\n", hostname);
 	printf("%ld packets transmitted, ", ntransmitted);
 	printf("%ld packets received, ", nreceived);
 	if (nrepeats)
 		printf("%ld duplicates, ", nrepeats);
 	if (ntransmitted)
 		printf("%ld%% packet loss\n",
 			   (ntransmitted - nreceived) * 100 / ntransmitted);
 	if (nreceived)
 		printf("round-trip min/avg/max = %lu.%lu/%lu.%lu/%lu.%lu ms\n",
 			   tmin / 10, tmin % 10,
 			   (tsum / (nreceived + nrepeats)) / 10,
 			   (tsum / (nreceived + nrepeats)) % 10, tmax / 10, tmax % 10);
 	if (nreceived != 0)
 		status = EXIT_SUCCESS;
 	else
 		status = EXIT_FAILURE;
 	exit(status);
 }
 
 static void sendping(int junk)
 {
 	struct icmp *pkt;
 	int i;
 	char packet[datalen + 8];
 
 	pkt = (struct icmp *) packet;
 
 	pkt->icmp_type = ICMP_ECHO;
 	pkt->icmp_code = 0;
 	pkt->icmp_cksum = 0;
 	pkt->icmp_seq = ntransmitted++;
 	pkt->icmp_id = myid;
 	CLR(pkt->icmp_seq % MAX_DUP_CHK);
 
 	gettimeofday((struct timeval *) &packet[8], NULL);
 	pkt->icmp_cksum = in_cksum((unsigned short *) pkt, sizeof(packet));
 
 	i = sendto(pingsock, packet, sizeof(packet), 0,
 			   (struct sockaddr *) &pingaddr, sizeof(struct sockaddr_in));
 
 	if (i < 0)
 		perror_msg_and_die("sendto");
 	else if ((size_t)i != sizeof(packet))
 		error_msg_and_die("ping wrote %d chars; %d expected", i,
 			   (int)sizeof(packet));
 
 	signal(SIGALRM, sendping);
 	if (pingcount == 0 || ntransmitted < pingcount) {	/* schedule next in 1s */
 		alarm(PINGINTERVAL);
 	} else {					/* done, wait for the last ping to come back */
 		/* todo, don't necessarily need to wait so long... */
 		signal(SIGALRM, pingstats);
 		alarm(MAXWAIT);
 	}
 }
 
 static char *icmp_type_name (int id)
 {
 	switch (id) {
 	case ICMP_ECHOREPLY: 		return "Echo Reply";
 	case ICMP_DEST_UNREACH: 	return "Destination Unreachable";
 	case ICMP_SOURCE_QUENCH: 	return "Source Quench";
 	case ICMP_REDIRECT: 		return "Redirect (change route)";
 	case ICMP_ECHO: 			return "Echo Request";
 	case ICMP_TIME_EXCEEDED: 	return "Time Exceeded";
 	case ICMP_PARAMETERPROB: 	return "Parameter Problem";
 	case ICMP_TIMESTAMP: 		return "Timestamp Request";
 	case ICMP_TIMESTAMPREPLY: 	return "Timestamp Reply";
 	case ICMP_INFO_REQUEST: 	return "Information Request";
 	case ICMP_INFO_REPLY: 		return "Information Reply";
 	case ICMP_ADDRESS: 			return "Address Mask Request";
 	case ICMP_ADDRESSREPLY: 	return "Address Mask Reply";
 	default: 					return "unknown ICMP type";
 	}
 }
 
 static void unpack(char *buf, int sz, struct sockaddr_in *from)
 {
 	struct icmp *icmppkt;
 	struct iphdr *iphdr;
 	struct timeval tv, *tp;
 	int hlen, dupflag;
 	unsigned long triptime;
 
 	gettimeofday(&tv, NULL);
 
 	/* check IP header */
 	iphdr = (struct iphdr *) buf;
 	hlen = iphdr->ihl << 2;
 	/* discard if too short */
 	if (sz < (datalen + ICMP_MINLEN))
 		return;
 
 	sz -= hlen;
 	icmppkt = (struct icmp *) (buf + hlen);
 
 	if (icmppkt->icmp_id != myid)
 	    return;				/* not our ping */
 
 	if (icmppkt->icmp_type == ICMP_ECHOREPLY) {
 	    ++nreceived;
 		tp = (struct timeval *) icmppkt->icmp_data;
 
 		if ((tv.tv_usec -= tp->tv_usec) < 0) {
 			--tv.tv_sec;
 			tv.tv_usec += 1000000;
 		}
 		tv.tv_sec -= tp->tv_sec;
 
 		triptime = tv.tv_sec * 10000 + (tv.tv_usec / 100);
 		tsum += triptime;
 		if (triptime < tmin)
 			tmin = triptime;
 		if (triptime > tmax)
 			tmax = triptime;
 
 		if (TST(icmppkt->icmp_seq % MAX_DUP_CHK)) {
 			++nrepeats;
 			--nreceived;
 			dupflag = 1;
 		} else {
 			SET(icmppkt->icmp_seq % MAX_DUP_CHK);
 			dupflag = 0;
 		}
 
 		if (options & O_QUIET)
 			return;
 
 		printf("%d bytes from %s: icmp_seq=%u", sz,
 			   inet_ntoa(*(struct in_addr *) &from->sin_addr.s_addr),
 			   icmppkt->icmp_seq);
 		printf(" ttl=%d", iphdr->ttl);
 		printf(" time=%lu.%lu ms", triptime / 10, triptime % 10);
 		if (dupflag)
 			printf(" (DUP!)");
 		printf("\n");
 	} else 
 		if (icmppkt->icmp_type != ICMP_ECHO)
 			error_msg("Warning: Got ICMP %d (%s)",
 					icmppkt->icmp_type, icmp_type_name (icmppkt->icmp_type));
 }
 
 static void ping(const char *host)
 {
 	struct protoent *proto;
 	struct hostent *h;
 	char buf[MAXHOSTNAMELEN];
 	char packet[datalen + MAXIPLEN + MAXICMPLEN];
 	int sockopt;
 
 	proto = getprotobyname("icmp");
 	/* if getprotobyname failed, just silently force 
 	 * proto->p_proto to have the correct value for "icmp" */
 	if ((pingsock = socket(AF_INET, SOCK_RAW,
 						   (proto ? proto->p_proto : 1))) < 0) {	/* 1 == ICMP */
 		if (errno == EPERM)
 			error_msg_and_die("permission denied. (are you root?)");
 		else
 			perror_msg_and_die("creating a raw socket");
 	}
 
 	/* drop root privs if running setuid */
 	setuid(getuid());
 
 	memset(&pingaddr, 0, sizeof(struct sockaddr_in));
 
 	pingaddr.sin_family = AF_INET;
 	h = xgethostbyname(host);
 	if (h->h_addrtype != AF_INET)
 		error_msg_and_die("unknown address type; only AF_INET is currently supported.");
 
 	pingaddr.sin_family = AF_INET;	/* h->h_addrtype */
 	memcpy(&pingaddr.sin_addr, h->h_addr, sizeof(pingaddr.sin_addr));
 	strncpy(buf, h->h_name, sizeof(buf) - 1);
 	hostname = buf;
 
 	/* enable broadcast pings */
 	sockopt = 1;
 	setsockopt(pingsock, SOL_SOCKET, SO_BROADCAST, (char *) &sockopt,
 			   sizeof(sockopt));
 
 	/* set recv buf for broadcast pings */
 	sockopt = 48 * 1024;
 	setsockopt(pingsock, SOL_SOCKET, SO_RCVBUF, (char *) &sockopt,
 			   sizeof(sockopt));
 
 	printf("PING %s (%s): %d data bytes\n",
 		   hostname,
 		   inet_ntoa(*(struct in_addr *) &pingaddr.sin_addr.s_addr),
 		   datalen);
 
 	signal(SIGINT, pingstats);
 
 	/* start the ping's going ... */
 	sendping(0);
 
 	/* listen for replies */
 	while (1) {
 		struct sockaddr_in from;
 		socklen_t fromlen = (socklen_t) sizeof(from);
 		int c;
 
 		if ((c = recvfrom(pingsock, packet, sizeof(packet), 0,
 						  (struct sockaddr *) &from, &fromlen)) < 0) {
 			if (errno == EINTR)
 				continue;
 			perror_msg("recvfrom");
 			continue;
 		}
 		unpack(packet, c, &from);
 		if (pingcount > 0 && nreceived >= pingcount)
 			break;
 	}
 	pingstats(0);
 }
 
 extern int ping_main(int argc, char **argv)
 {
 	char *thisarg;
 
 	datalen = DEFDATALEN; /* initialized here rather than in global scope to work around gcc bug */
 
 	argc--;
 	argv++;
 	options = 0;
 	/* Parse any options */
 	while (argc >= 1 && **argv == '-') {
 		thisarg = *argv;
 		thisarg++;
 		switch (*thisarg) {
 		case 'q':
 			options |= O_QUIET;
 			break;
 		case 'c':
 			if (--argc <= 0)
 			        show_usage();
 			argv++;
 			pingcount = atoi(*argv);
 			break;
 		case 's':
 			if (--argc <= 0)
 			        show_usage();
 			argv++;
 			datalen = atoi(*argv);
 			break;
 		default:
 			show_usage();
 		}
 		argc--;
 		argv++;
 	}
 	if (argc < 1)
 		show_usage();
 
 	myid = getpid() & 0xFFFF;
 	ping(*argv);
 	return EXIT_SUCCESS;
 }
-#endif /* ! BB_FEATURE_SIMPLE_PING */
+#endif /* ! BB_FEATURE_FANCY_PING */
 
 /*
  * Copyright (c) 1989 The Regents of the University of California.
  * All rights reserved.
  *
  * This code is derived from software contributed to Berkeley by
  * Mike Muuss.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  * 1. Redistributions of source code must retain the above copyright
  *    notice, this list of conditions and the following disclaimer.
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in the
  *    documentation and/or other materials provided with the distribution.
  *
  * 3. <BSD Advertising Clause omitted per the July 22, 1999 licensing change 
  *		ftp://ftp.cs.berkeley.edu/pub/4bsd/README.Impt.License.Change> 
  *
  * 4. Neither the name of the University nor the names of its contributors
  *    may be used to endorse or promote products derived from this software
  *    without specific prior written permission.
  *
  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  */
diff --git a/ping.c b/ping.c
index 1afcb28..e4307d2 100644
--- a/ping.c
+++ b/ping.c
@@ -1,573 +1,573 @@
 /* vi: set sw=4 ts=4: */
 /*
- * $Id: ping.c,v 1.42 2001/05/16 15:52:23 kraai Exp $
+ * $Id: ping.c,v 1.43 2001/05/21 20:30:51 andersen Exp $
  * Mini ping implementation for busybox
  *
  * Copyright (C) 1999 by Randolph Chung <tausq@debian.org>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
  * General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
  *
  * This version of ping is adapted from the ping in netkit-base 0.10,
  * which is:
  *
  * Copyright (c) 1989 The Regents of the University of California.
  * All rights reserved.
  *
  * This code is derived from software contributed to Berkeley by
  * Mike Muuss.
  * 
  * Original copyright notice is retained at the end of this file.
  */
 
 #include <sys/param.h>
 #include <sys/socket.h>
 #include <sys/file.h>
 #include <sys/time.h>
 #include <sys/times.h>
 #include <sys/signal.h>
 
 #include <netinet/in.h>
 #include <netinet/ip.h>
 #include <netinet/ip_icmp.h>
 #include <arpa/inet.h>
 #include <netdb.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <errno.h>
 #include <unistd.h>
 #include <string.h>
 #include <stdlib.h>
 #include "busybox.h"
 
 
 /* It turns out that libc5 doesn't have proper icmp support
  * built into it header files, so we have to supplement it */
 #if __GNU_LIBRARY__ < 5
 static const int ICMP_MINLEN = 8;				/* abs minimum */
 
 struct icmp_ra_addr
 {
   u_int32_t ira_addr;
   u_int32_t ira_preference;
 };
 
 
 struct icmp
 {
   u_int8_t  icmp_type;	/* type of message, see below */
   u_int8_t  icmp_code;	/* type sub code */
   u_int16_t icmp_cksum;	/* ones complement checksum of struct */
   union
   {
     u_char ih_pptr;		/* ICMP_PARAMPROB */
     struct in_addr ih_gwaddr;	/* gateway address */
     struct ih_idseq		/* echo datagram */
     {
       u_int16_t icd_id;
       u_int16_t icd_seq;
     } ih_idseq;
     u_int32_t ih_void;
 
     /* ICMP_UNREACH_NEEDFRAG -- Path MTU Discovery (RFC1191) */
     struct ih_pmtu
     {
       u_int16_t ipm_void;
       u_int16_t ipm_nextmtu;
     } ih_pmtu;
 
     struct ih_rtradv
     {
       u_int8_t irt_num_addrs;
       u_int8_t irt_wpa;
       u_int16_t irt_lifetime;
     } ih_rtradv;
   } icmp_hun;
 #define	icmp_pptr	icmp_hun.ih_pptr
 #define	icmp_gwaddr	icmp_hun.ih_gwaddr
 #define	icmp_id		icmp_hun.ih_idseq.icd_id
 #define	icmp_seq	icmp_hun.ih_idseq.icd_seq
 #define	icmp_void	icmp_hun.ih_void
 #define	icmp_pmvoid	icmp_hun.ih_pmtu.ipm_void
 #define	icmp_nextmtu	icmp_hun.ih_pmtu.ipm_nextmtu
 #define	icmp_num_addrs	icmp_hun.ih_rtradv.irt_num_addrs
 #define	icmp_wpa	icmp_hun.ih_rtradv.irt_wpa
 #define	icmp_lifetime	icmp_hun.ih_rtradv.irt_lifetime
   union
   {
     struct
     {
       u_int32_t its_otime;
       u_int32_t its_rtime;
       u_int32_t its_ttime;
     } id_ts;
     struct
     {
       struct ip idi_ip;
       /* options and then 64 bits of data */
     } id_ip;
     struct icmp_ra_addr id_radv;
     u_int32_t   id_mask;
     u_int8_t    id_data[1];
   } icmp_dun;
 #define	icmp_otime	icmp_dun.id_ts.its_otime
 #define	icmp_rtime	icmp_dun.id_ts.its_rtime
 #define	icmp_ttime	icmp_dun.id_ts.its_ttime
 #define	icmp_ip		icmp_dun.id_ip.idi_ip
 #define	icmp_radv	icmp_dun.id_radv
 #define	icmp_mask	icmp_dun.id_mask
 #define	icmp_data	icmp_dun.id_data
 };
 #endif
 
 static const int DEFDATALEN = 56;
 static const int MAXIPLEN = 60;
 static const int MAXICMPLEN = 76;
 static const int MAXPACKET = 65468;
 #define	MAX_DUP_CHK	(8 * 128)
 static const int MAXWAIT = 10;
 static const int PINGINTERVAL = 1;		/* second */
 
 #define O_QUIET         (1 << 0)
 
 #define	A(bit)		rcvd_tbl[(bit)>>3]	/* identify byte in array */
 #define	B(bit)		(1 << ((bit) & 0x07))	/* identify bit in byte */
 #define	SET(bit)	(A(bit) |= B(bit))
 #define	CLR(bit)	(A(bit) &= (~B(bit)))
 #define	TST(bit)	(A(bit) & B(bit))
 
 static void ping(const char *host);
 
 /* common routines */
 static int in_cksum(unsigned short *buf, int sz)
 {
 	int nleft = sz;
 	int sum = 0;
 	unsigned short *w = buf;
 	unsigned short ans = 0;
 
 	while (nleft > 1) {
 		sum += *w++;
 		nleft -= 2;
 	}
 
 	if (nleft == 1) {
 		*(unsigned char *) (&ans) = *(unsigned char *) w;
 		sum += ans;
 	}
 
 	sum = (sum >> 16) + (sum & 0xFFFF);
 	sum += (sum >> 16);
 	ans = ~sum;
 	return (ans);
 }
 
 /* simple version */
-#ifdef BB_FEATURE_SIMPLE_PING
+#ifndef BB_FEATURE_FANCY_PING
 static char *hostname = NULL;
 
 static void noresp(int ign)
 {
 	printf("No response from %s\n", hostname);
 	exit(0);
 }
 
 static void ping(const char *host)
 {
 	struct hostent *h;
 	struct sockaddr_in pingaddr;
 	struct icmp *pkt;
 	int pingsock, c;
 	char packet[DEFDATALEN + MAXIPLEN + MAXICMPLEN];
 
 	if ((pingsock = socket(AF_INET, SOCK_RAW, 1)) < 0)	/* 1 == ICMP */
 		perror_msg_and_die("creating a raw socket");
 
 	/* drop root privs if running setuid */
 	setuid(getuid());
 
 	memset(&pingaddr, 0, sizeof(struct sockaddr_in));
 
 	pingaddr.sin_family = AF_INET;
 	h = xgethostbyname(host);
 	memcpy(&pingaddr.sin_addr, h->h_addr, sizeof(pingaddr.sin_addr));
 	hostname = h->h_name;
 
 	pkt = (struct icmp *) packet;
 	memset(pkt, 0, sizeof(packet));
 	pkt->icmp_type = ICMP_ECHO;
 	pkt->icmp_cksum = in_cksum((unsigned short *) pkt, sizeof(packet));
 
 	c = sendto(pingsock, packet, sizeof(packet), 0,
 			   (struct sockaddr *) &pingaddr, sizeof(struct sockaddr_in));
 
 	if (c < 0 || c != sizeof(packet))
 		perror_msg_and_die("sendto");
 
 	signal(SIGALRM, noresp);
 	alarm(5);					/* give the host 5000ms to respond */
 	/* listen for replies */
 	while (1) {
 		struct sockaddr_in from;
 		size_t fromlen = sizeof(from);
 
 		if ((c = recvfrom(pingsock, packet, sizeof(packet), 0,
 						  (struct sockaddr *) &from, &fromlen)) < 0) {
 			if (errno == EINTR)
 				continue;
 			perror_msg("recvfrom");
 			continue;
 		}
 		if (c >= 76) {			/* ip + icmp */
 			struct iphdr *iphdr = (struct iphdr *) packet;
 
 			pkt = (struct icmp *) (packet + (iphdr->ihl << 2));	/* skip ip hdr */
 			if (pkt->icmp_type == ICMP_ECHOREPLY)
 				break;
 		}
 	}
 	printf("%s is alive!\n", hostname);
 	return;
 }
 
 extern int ping_main(int argc, char **argv)
 {
 	argc--;
 	argv++;
 	if (argc < 1)
 		show_usage();
 	ping(*argv);
 	return EXIT_SUCCESS;
 }
 
-#else /* ! BB_FEATURE_SIMPLE_PING */
+#else /* ! BB_FEATURE_FANCY_PING */
 /* full(er) version */
 static char *hostname = NULL;
 static struct sockaddr_in pingaddr;
 static int pingsock = -1;
 static int datalen; /* intentionally uninitialized to work around gcc bug */
 
 static long ntransmitted = 0, nreceived = 0, nrepeats = 0, pingcount = 0;
 static int myid = 0, options = 0;
 static unsigned long tmin = ULONG_MAX, tmax = 0, tsum = 0;
 static char rcvd_tbl[MAX_DUP_CHK / 8];
 
 static void sendping(int);
 static void pingstats(int);
 static void unpack(char *, int, struct sockaddr_in *);
 
 /**************************************************************************/
 
 static void pingstats(int junk)
 {
 	int status;
 
 	signal(SIGINT, SIG_IGN);
 
 	printf("\n--- %s ping statistics ---\n", hostname);
 	printf("%ld packets transmitted, ", ntransmitted);
 	printf("%ld packets received, ", nreceived);
 	if (nrepeats)
 		printf("%ld duplicates, ", nrepeats);
 	if (ntransmitted)
 		printf("%ld%% packet loss\n",
 			   (ntransmitted - nreceived) * 100 / ntransmitted);
 	if (nreceived)
 		printf("round-trip min/avg/max = %lu.%lu/%lu.%lu/%lu.%lu ms\n",
 			   tmin / 10, tmin % 10,
 			   (tsum / (nreceived + nrepeats)) / 10,
 			   (tsum / (nreceived + nrepeats)) % 10, tmax / 10, tmax % 10);
 	if (nreceived != 0)
 		status = EXIT_SUCCESS;
 	else
 		status = EXIT_FAILURE;
 	exit(status);
 }
 
 static void sendping(int junk)
 {
 	struct icmp *pkt;
 	int i;
 	char packet[datalen + 8];
 
 	pkt = (struct icmp *) packet;
 
 	pkt->icmp_type = ICMP_ECHO;
 	pkt->icmp_code = 0;
 	pkt->icmp_cksum = 0;
 	pkt->icmp_seq = ntransmitted++;
 	pkt->icmp_id = myid;
 	CLR(pkt->icmp_seq % MAX_DUP_CHK);
 
 	gettimeofday((struct timeval *) &packet[8], NULL);
 	pkt->icmp_cksum = in_cksum((unsigned short *) pkt, sizeof(packet));
 
 	i = sendto(pingsock, packet, sizeof(packet), 0,
 			   (struct sockaddr *) &pingaddr, sizeof(struct sockaddr_in));
 
 	if (i < 0)
 		perror_msg_and_die("sendto");
 	else if ((size_t)i != sizeof(packet))
 		error_msg_and_die("ping wrote %d chars; %d expected", i,
 			   (int)sizeof(packet));
 
 	signal(SIGALRM, sendping);
 	if (pingcount == 0 || ntransmitted < pingcount) {	/* schedule next in 1s */
 		alarm(PINGINTERVAL);
 	} else {					/* done, wait for the last ping to come back */
 		/* todo, don't necessarily need to wait so long... */
 		signal(SIGALRM, pingstats);
 		alarm(MAXWAIT);
 	}
 }
 
 static char *icmp_type_name (int id)
 {
 	switch (id) {
 	case ICMP_ECHOREPLY: 		return "Echo Reply";
 	case ICMP_DEST_UNREACH: 	return "Destination Unreachable";
 	case ICMP_SOURCE_QUENCH: 	return "Source Quench";
 	case ICMP_REDIRECT: 		return "Redirect (change route)";
 	case ICMP_ECHO: 			return "Echo Request";
 	case ICMP_TIME_EXCEEDED: 	return "Time Exceeded";
 	case ICMP_PARAMETERPROB: 	return "Parameter Problem";
 	case ICMP_TIMESTAMP: 		return "Timestamp Request";
 	case ICMP_TIMESTAMPREPLY: 	return "Timestamp Reply";
 	case ICMP_INFO_REQUEST: 	return "Information Request";
 	case ICMP_INFO_REPLY: 		return "Information Reply";
 	case ICMP_ADDRESS: 			return "Address Mask Request";
 	case ICMP_ADDRESSREPLY: 	return "Address Mask Reply";
 	default: 					return "unknown ICMP type";
 	}
 }
 
 static void unpack(char *buf, int sz, struct sockaddr_in *from)
 {
 	struct icmp *icmppkt;
 	struct iphdr *iphdr;
 	struct timeval tv, *tp;
 	int hlen, dupflag;
 	unsigned long triptime;
 
 	gettimeofday(&tv, NULL);
 
 	/* check IP header */
 	iphdr = (struct iphdr *) buf;
 	hlen = iphdr->ihl << 2;
 	/* discard if too short */
 	if (sz < (datalen + ICMP_MINLEN))
 		return;
 
 	sz -= hlen;
 	icmppkt = (struct icmp *) (buf + hlen);
 
 	if (icmppkt->icmp_id != myid)
 	    return;				/* not our ping */
 
 	if (icmppkt->icmp_type == ICMP_ECHOREPLY) {
 	    ++nreceived;
 		tp = (struct timeval *) icmppkt->icmp_data;
 
 		if ((tv.tv_usec -= tp->tv_usec) < 0) {
 			--tv.tv_sec;
 			tv.tv_usec += 1000000;
 		}
 		tv.tv_sec -= tp->tv_sec;
 
 		triptime = tv.tv_sec * 10000 + (tv.tv_usec / 100);
 		tsum += triptime;
 		if (triptime < tmin)
 			tmin = triptime;
 		if (triptime > tmax)
 			tmax = triptime;
 
 		if (TST(icmppkt->icmp_seq % MAX_DUP_CHK)) {
 			++nrepeats;
 			--nreceived;
 			dupflag = 1;
 		} else {
 			SET(icmppkt->icmp_seq % MAX_DUP_CHK);
 			dupflag = 0;
 		}
 
 		if (options & O_QUIET)
 			return;
 
 		printf("%d bytes from %s: icmp_seq=%u", sz,
 			   inet_ntoa(*(struct in_addr *) &from->sin_addr.s_addr),
 			   icmppkt->icmp_seq);
 		printf(" ttl=%d", iphdr->ttl);
 		printf(" time=%lu.%lu ms", triptime / 10, triptime % 10);
 		if (dupflag)
 			printf(" (DUP!)");
 		printf("\n");
 	} else 
 		if (icmppkt->icmp_type != ICMP_ECHO)
 			error_msg("Warning: Got ICMP %d (%s)",
 					icmppkt->icmp_type, icmp_type_name (icmppkt->icmp_type));
 }
 
 static void ping(const char *host)
 {
 	struct protoent *proto;
 	struct hostent *h;
 	char buf[MAXHOSTNAMELEN];
 	char packet[datalen + MAXIPLEN + MAXICMPLEN];
 	int sockopt;
 
 	proto = getprotobyname("icmp");
 	/* if getprotobyname failed, just silently force 
 	 * proto->p_proto to have the correct value for "icmp" */
 	if ((pingsock = socket(AF_INET, SOCK_RAW,
 						   (proto ? proto->p_proto : 1))) < 0) {	/* 1 == ICMP */
 		if (errno == EPERM)
 			error_msg_and_die("permission denied. (are you root?)");
 		else
 			perror_msg_and_die("creating a raw socket");
 	}
 
 	/* drop root privs if running setuid */
 	setuid(getuid());
 
 	memset(&pingaddr, 0, sizeof(struct sockaddr_in));
 
 	pingaddr.sin_family = AF_INET;
 	h = xgethostbyname(host);
 	if (h->h_addrtype != AF_INET)
 		error_msg_and_die("unknown address type; only AF_INET is currently supported.");
 
 	pingaddr.sin_family = AF_INET;	/* h->h_addrtype */
 	memcpy(&pingaddr.sin_addr, h->h_addr, sizeof(pingaddr.sin_addr));
 	strncpy(buf, h->h_name, sizeof(buf) - 1);
 	hostname = buf;
 
 	/* enable broadcast pings */
 	sockopt = 1;
 	setsockopt(pingsock, SOL_SOCKET, SO_BROADCAST, (char *) &sockopt,
 			   sizeof(sockopt));
 
 	/* set recv buf for broadcast pings */
 	sockopt = 48 * 1024;
 	setsockopt(pingsock, SOL_SOCKET, SO_RCVBUF, (char *) &sockopt,
 			   sizeof(sockopt));
 
 	printf("PING %s (%s): %d data bytes\n",
 		   hostname,
 		   inet_ntoa(*(struct in_addr *) &pingaddr.sin_addr.s_addr),
 		   datalen);
 
 	signal(SIGINT, pingstats);
 
 	/* start the ping's going ... */
 	sendping(0);
 
 	/* listen for replies */
 	while (1) {
 		struct sockaddr_in from;
 		socklen_t fromlen = (socklen_t) sizeof(from);
 		int c;
 
 		if ((c = recvfrom(pingsock, packet, sizeof(packet), 0,
 						  (struct sockaddr *) &from, &fromlen)) < 0) {
 			if (errno == EINTR)
 				continue;
 			perror_msg("recvfrom");
 			continue;
 		}
 		unpack(packet, c, &from);
 		if (pingcount > 0 && nreceived >= pingcount)
 			break;
 	}
 	pingstats(0);
 }
 
 extern int ping_main(int argc, char **argv)
 {
 	char *thisarg;
 
 	datalen = DEFDATALEN; /* initialized here rather than in global scope to work around gcc bug */
 
 	argc--;
 	argv++;
 	options = 0;
 	/* Parse any options */
 	while (argc >= 1 && **argv == '-') {
 		thisarg = *argv;
 		thisarg++;
 		switch (*thisarg) {
 		case 'q':
 			options |= O_QUIET;
 			break;
 		case 'c':
 			if (--argc <= 0)
 			        show_usage();
 			argv++;
 			pingcount = atoi(*argv);
 			break;
 		case 's':
 			if (--argc <= 0)
 			        show_usage();
 			argv++;
 			datalen = atoi(*argv);
 			break;
 		default:
 			show_usage();
 		}
 		argc--;
 		argv++;
 	}
 	if (argc < 1)
 		show_usage();
 
 	myid = getpid() & 0xFFFF;
 	ping(*argv);
 	return EXIT_SUCCESS;
 }
-#endif /* ! BB_FEATURE_SIMPLE_PING */
+#endif /* ! BB_FEATURE_FANCY_PING */
 
 /*
  * Copyright (c) 1989 The Regents of the University of California.
  * All rights reserved.
  *
  * This code is derived from software contributed to Berkeley by
  * Mike Muuss.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  * 1. Redistributions of source code must retain the above copyright
  *    notice, this list of conditions and the following disclaimer.
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in the
  *    documentation and/or other materials provided with the distribution.
  *
  * 3. <BSD Advertising Clause omitted per the July 22, 1999 licensing change 
  *		ftp://ftp.cs.berkeley.edu/pub/4bsd/README.Impt.License.Change> 
  *
  * 4. Neither the name of the University nor the names of its contributors
  *    may be used to endorse or promote products derived from this software
  *    without specific prior written permission.
  *
  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  */
diff --git a/shell/cmdedit.c b/shell/cmdedit.c
index cc39e56..a877231 100644
--- a/shell/cmdedit.c
+++ b/shell/cmdedit.c
@@ -1,1546 +1,1546 @@
 /* vi: set sw=4 ts=4: */
 /*
  * Termios command line History and Editting.
  *
  * Copyright (c) 1986-2001 may safely be consumed by a BSD or GPL license.
  * Written by:   Vladimir Oleynik <vodz@usa.net>
  *
  * Used ideas:
  *      Adam Rogoyski    <rogoyski@cs.utexas.edu>
  *      Dave Cinege      <dcinege@psychosis.com>
  *      Jakub Jelinek (c) 1995
  *      Erik Andersen    <andersee@debian.org> (Majorly adjusted for busybox)
  *
  * This code is 'as is' with no warranty.
  *
  *
  */
 
 /*
    Usage and Known bugs:
    Terminal key codes are not extensive, and more will probably
    need to be added. This version was created on Debian GNU/Linux 2.x.
    Delete, Backspace, Home, End, and the arrow keys were tested
    to work in an Xterm and console. Ctrl-A also works as Home.
    Ctrl-E also works as End.
 
    Small bugs (simple effect):
    - not true viewing if terminal size (x*y symbols) less
      size (prompt + editor`s line + 2 symbols)
    - not true viewing if length prompt less terminal width
  */
 
 
 #include <stdio.h>
 #include <errno.h>
 #include <unistd.h>
 #include <stdlib.h>
 #include <string.h>
 #include <sys/ioctl.h>
 #include <ctype.h>
 #include <signal.h>
 #include <limits.h>
 
 #include "busybox.h"
 
 #ifdef BB_LOCALE_SUPPORT
 #define Isprint(c) isprint((c))
 #else
 #define Isprint(c) ( (c) >= ' ' && (c) != ((unsigned char)'\233') )
 #endif
 
 #ifndef TEST
 
 #define D(x)
 
 #else
 
 #define BB_FEATURE_COMMAND_EDITING
 #define BB_FEATURE_COMMAND_TAB_COMPLETION
 #define BB_FEATURE_COMMAND_USERNAME_COMPLETION
 #define BB_FEATURE_NONPRINTABLE_INVERSE_PUT
 #define BB_FEATURE_CLEAN_UP
 
 #define D(x)  x
 
 #endif							/* TEST */
 
 #ifdef BB_FEATURE_COMMAND_TAB_COMPLETION
 #include <dirent.h>
 #include <sys/stat.h>
 #endif
 
 #ifdef BB_FEATURE_COMMAND_EDITING
 
 #ifndef BB_FEATURE_COMMAND_TAB_COMPLETION
 #undef  BB_FEATURE_COMMAND_USERNAME_COMPLETION
 #endif
 
-#if defined(BB_FEATURE_COMMAND_USERNAME_COMPLETION) || !defined(BB_FEATURE_SH_SIMPLE_PROMPT)
+#if defined(BB_FEATURE_COMMAND_USERNAME_COMPLETION) || defined(BB_FEATURE_SH_FANCY_PROMPT)
 #define BB_FEATURE_GETUSERNAME_AND_HOMEDIR
 #endif
 
 #ifdef BB_FEATURE_GETUSERNAME_AND_HOMEDIR
 #ifndef TEST
 #include "pwd_grp/pwd.h"
 #else
 #include <pwd.h>
 #endif							/* TEST */
 #endif							/* advanced FEATURES */
 
 
 
 struct history {
 	char *s;
 	struct history *p;
 	struct history *n;
 };
 
 /* Maximum length of the linked list for the command line history */
 static const int MAX_HISTORY = 15;
 
 /* First element in command line list */
 static struct history *his_front = NULL;
 
 /* Last element in command line list */
 static struct history *his_end = NULL;
 
 
 /* ED: sparc termios is broken: revert back to old termio handling. */
 
 #if #cpu(sparc)
 #      include <termio.h>
 #      define termios termio
 #      define setTermSettings(fd,argp) ioctl(fd,TCSETAF,argp)
 #      define getTermSettings(fd,argp) ioctl(fd,TCGETA,argp)
 #else
 #      include <termios.h>
 #      define setTermSettings(fd,argp) tcsetattr(fd,TCSANOW,argp)
 #      define getTermSettings(fd,argp) tcgetattr(fd, argp);
 #endif
 
 /* Current termio and the previous termio before starting sh */
 static struct termios initial_settings, new_settings;
 
 
 #ifndef _POSIX_VDISABLE
 #define _POSIX_VDISABLE '\0'
 #endif
 
 
 static
 volatile int cmdedit_termw = 80;	/* actual terminal width */
 static int history_counter = 0;	/* Number of commands in history list */
 static
 volatile int handlers_sets = 0;	/* Set next bites: */
 
 enum {
 	SET_ATEXIT = 1,		/* when atexit() has been called 
 				   and get euid,uid,gid to fast compare */
 	SET_TERM_HANDLERS = 2,	/* set many terminates signal handlers */
 	SET_WCHG_HANDLERS = 4,	/* winchg signal handler */
 	SET_RESET_TERM = 8,	/* if the terminal needs to be reset upon exit */
 };
 
 
 static int cmdedit_x;		/* real x terminal position */
 static int cmdedit_y;		/* pseudoreal y terminal position */
 static int cmdedit_prmt_len;	/* lenght prompt without colores string */
 
 static int cursor;		/* required global for signal handler */
 static int len;			/* --- "" - - "" - -"- --""-- --""--- */
 static char *command_ps;	/* --- "" - - "" - -"- --""-- --""--- */
 static
-#ifdef BB_FEATURE_SH_SIMPLE_PROMPT
+#ifndef BB_FEATURE_SH_FANCY_PROMPT
 	const
 #endif
 char *cmdedit_prompt;		/* --- "" - - "" - -"- --""-- --""--- */
 
 /* Link into lash to reset context to 0 on ^C and such */
 extern unsigned int shell_context;
 
 
 #ifdef BB_FEATURE_GETUSERNAME_AND_HOMEDIR
 static char *user_buf = "";
 static char *home_pwd_buf = "";
 static int my_euid;
 #endif
 
-#ifndef BB_FEATURE_SH_SIMPLE_PROMPT
+#ifdef BB_FEATURE_SH_FANCY_PROMPT
 static char *hostname_buf = "";
 static int num_ok_lines = 1;
 #endif
 
 
 #ifdef  BB_FEATURE_COMMAND_TAB_COMPLETION
 
 #ifndef BB_FEATURE_GETUSERNAME_AND_HOMEDIR
 static int my_euid;
 #endif
 
 static int my_uid;
 static int my_gid;
 
 #endif	/* BB_FEATURE_COMMAND_TAB_COMPLETION */
 
 
 static void cmdedit_setwidth(int w, int redraw_flg);
 
 static void win_changed(int nsig)
 {
 	struct winsize win = { 0, 0, 0, 0 };
 	static __sighandler_t previous_SIGWINCH_handler;	/* for reset */
 
 	/*   emulate      || signal call */
 	if (nsig == -SIGWINCH || nsig == SIGWINCH) {
 		ioctl(0, TIOCGWINSZ, &win);
 		if (win.ws_col > 0) {
 			cmdedit_setwidth(win.ws_col, nsig == SIGWINCH);
 		} 
 	}
 	/* Unix not all standart in recall signal */
 
 	if (nsig == -SIGWINCH)		/* save previous handler   */
 		previous_SIGWINCH_handler = signal(SIGWINCH, win_changed);
 	else if (nsig == SIGWINCH)	/* signaled called handler */
 		signal(SIGWINCH, win_changed);	/* set for next call       */
 	else						/* nsig == 0 */
 		/* set previous handler    */
 		signal(SIGWINCH, previous_SIGWINCH_handler);	/* reset    */
 }
 
 static void cmdedit_reset_term(void)
 {
 	if ((handlers_sets & SET_RESET_TERM) != 0) {
 /* sparc and other have broken termios support: use old termio handling. */
 		setTermSettings(fileno(stdin), (void *) &initial_settings);
 		handlers_sets &= ~SET_RESET_TERM;
 	}
 	if ((handlers_sets & SET_WCHG_HANDLERS) != 0) {
 		/* reset SIGWINCH handler to previous (default) */
 		win_changed(0);
 		handlers_sets &= ~SET_WCHG_HANDLERS;
 	}
 	fflush(stdout);
 #ifdef BB_FEATURE_CLEAN_UP
 	if (his_front) {
 		struct history *n;
 
 		while (his_front != his_end) {
 			n = his_front->n;
 			free(his_front->s);
 			free(his_front);
 			his_front = n;
 		}
 	}
 #endif
 }
 
 
 /* special for recount position for scroll and remove terminal margin effect */
 static void cmdedit_set_out_char(int next_char)
 {
 
 	int c = (int)((unsigned char) command_ps[cursor]);
 
 	if (c == 0)
 		c = ' ';	/* destroy end char? */
 #ifdef BB_FEATURE_NONPRINTABLE_INVERSE_PUT
 	if (!Isprint(c)) {	/* Inverse put non-printable characters */
 		if (c >= 128)
 			c -= 128;
 		if (c < ' ')
 			c += '@';
 		if (c == 127)
 			c = '?';
 		printf("\033[7m%c\033[0m", c);
 	} else
 #endif
 		putchar(c);
 	if (++cmdedit_x >= cmdedit_termw) {
 		/* terminal is scrolled down */
 		cmdedit_y++;
 		cmdedit_x = 0;
 
 		if (!next_char)
 			next_char = ' ';
 		/* destroy "(auto)margin" */
 		putchar(next_char);
 		putchar('\b');
 	}
 	cursor++;
 }
 
 /* Move to end line. Bonus: rewrite line from cursor */
 static void input_end(void)
 {
 	while (cursor < len)
 		cmdedit_set_out_char(0);
 }
 
 /* Go to the next line */
 static void goto_new_line(void)
 {
 	input_end();
 	if (cmdedit_x)
 		putchar('\n');
 }
 
 
 static inline void out1str(const char *s)
 {
 	fputs(s, stdout);
 }
 static inline void beep(void)
 {
 	putchar('\007');
 }
 
 /* Move back one charactor */
 /* special for slow terminal */
 static void input_backward(int num)
 {
 	if (num > cursor)
 		num = cursor;
 	cursor -= num;		/* new cursor (in command, not terminal) */
 
 	if (cmdedit_x >= num) {		/* no to up line */
 		cmdedit_x -= num;
 		if (num < 4)
 			while (num-- > 0)
 				putchar('\b');
 
 		else
 			printf("\033[%dD", num);
 	} else {
 		int count_y;
 
 		if (cmdedit_x) {
 			putchar('\r');		/* back to first terminal pos.  */
 			num -= cmdedit_x;	/* set previous backward        */
 		}
 		count_y = 1 + num / cmdedit_termw;
 		printf("\033[%dA", count_y);
 		cmdedit_y -= count_y;
 		/*  require  forward  after  uping   */
 		cmdedit_x = cmdedit_termw * count_y - num;
 		printf("\033[%dC", cmdedit_x);	/* set term cursor   */
 	}
 }
 
 static void put_prompt(void)
 {
 	out1str(cmdedit_prompt);
 	cmdedit_x = cmdedit_prmt_len;	/* count real x terminal position */
 	cursor = 0;
 }
 
-#ifdef BB_FEATURE_SH_SIMPLE_PROMPT
+#ifndef BB_FEATURE_SH_FANCY_PROMPT
 static void parse_prompt(const char *prmt_ptr)
 {
 	cmdedit_prompt = prmt_ptr;
 	cmdedit_prmt_len = strlen(prmt_ptr);
 	put_prompt();
 }
 #else
 static void parse_prompt(const char *prmt_ptr)
 {
 	int prmt_len = 0;
 	int sub_len = 0;
 	char  flg_not_length = '[';
 	char *prmt_mem_ptr = xcalloc(1, 1);
 	char *pwd_buf = xgetcwd(0);
 	char  buf2[PATH_MAX + 1];
 	char  buf[2];
 	char  c;
 	char *pbuf;
 
 	if (!pwd_buf) {
 		pwd_buf=unknown;
 	}
 
 	while (*prmt_ptr) {
 		pbuf    = buf;
 		pbuf[1] = 0;
 		c = *prmt_ptr++;
 		if (c == '\\') {
 			const char *cp = prmt_ptr;
 			int l;
 			
 			c = process_escape_sequence(&prmt_ptr);
 			if(prmt_ptr==cp) {
 			  if (*cp == 0)
 				break;
 			  c = *prmt_ptr++;
 			  switch (c) {
 #ifdef BB_FEATURE_GETUSERNAME_AND_HOMEDIR
 			  case 'u':
 				pbuf = user_buf;
 				break;
 #endif	
 			  case 'h':
 				pbuf = hostname_buf;
 				if (*pbuf == 0) {
 					pbuf = xcalloc(256, 1);
 					if (gethostname(pbuf, 255) < 0) {
 						strcpy(pbuf, "?");
 					} else {
 						char *s = strchr(pbuf, '.');
 
 						if (s)
 							*s = 0;
 					}
 					hostname_buf = pbuf;
 				}
 				break;
 			  case '$':
 				c = my_euid == 0 ? '#' : '$';
 				break;
 #ifdef BB_FEATURE_GETUSERNAME_AND_HOMEDIR
 			  case 'w':
 				pbuf = pwd_buf;
 				l = strlen(home_pwd_buf);
 				if (home_pwd_buf[0] != 0 &&
 				    strncmp(home_pwd_buf, pbuf, l) == 0 &&
 				    (pbuf[l]=='/' || pbuf[l]=='\0') &&
 				    strlen(pwd_buf+l)<PATH_MAX) {
 					pbuf = buf2;
 					*pbuf = '~';
 					strcpy(pbuf+1, pwd_buf+l);
 					}
 				break;
 #endif	
 			  case 'W':
 				pbuf = pwd_buf;
 				cp = strrchr(pbuf,'/');
 				if ( (cp != NULL) && (cp != pbuf) )
 					pbuf += (cp-pbuf)+1;
 				break;
 			  case '!':
 				snprintf(pbuf = buf2, sizeof(buf2), "%d", num_ok_lines);
 				break;
 			  case 'e': case 'E':     /* \e \E = \033 */
 				c = '\033';
 				break;
 			  case 'x': case 'X': 
 				for (l = 0; l < 3;) {
 					int h;
 					buf2[l++] = *prmt_ptr;
 					buf2[l] = 0;
 					h = strtol(buf2, &pbuf, 16);
 					if (h > UCHAR_MAX || (pbuf - buf2) < l) {
 						l--;
 						break;
 					}
 					prmt_ptr++;
 				}
 				buf2[l] = 0;
 				c = (char)strtol(buf2, 0, 16);
 				if(c==0)
 					c = '?';
 				pbuf = buf;
 				break;
 			  case '[': case ']':
 				if (c == flg_not_length) {
 					flg_not_length = flg_not_length == '[' ? ']' : '[';
 					continue;
 				}
 				break;
 			  }
 			} 
 		}
 		if(pbuf == buf)
 			*pbuf = c;
 		prmt_len += strlen(pbuf);
 		prmt_mem_ptr = strcat(xrealloc(prmt_mem_ptr, prmt_len+1), pbuf);
 		if (flg_not_length == ']')
 			sub_len++;
 	}
 	free(pwd_buf);
 	cmdedit_prompt = prmt_mem_ptr;
 	cmdedit_prmt_len = prmt_len - sub_len;
 	put_prompt();
 }
 #endif
 
 
 /* draw promt, editor line, and clear tail */
 static void redraw(int y, int back_cursor)
 {
 	if (y > 0)				/* up to start y */
 		printf("\033[%dA", y);
 	cmdedit_y = 0;				/* new quasireal y */
 	putchar('\r');
 	put_prompt();
 	input_end();				/* rewrite */
 	printf("\033[J");			/* destroy tail after cursor */
 	input_backward(back_cursor);
 }
 
 /* Delete the char in front of the cursor */
 static void input_delete(void)
 {
 	int j = cursor;
 
 	if (j == len)
 		return;
 
 	strcpy(command_ps + j, command_ps + j + 1);
 	len--;
 	input_end();			/* rewtite new line */
 	cmdedit_set_out_char(0);	/* destroy end char */
 	input_backward(cursor - j);	/* back to old pos cursor */
 }
 
 /* Delete the char in back of the cursor */
 static void input_backspace(void)
 {
 	if (cursor > 0) {
 		input_backward(1);
 		input_delete();
 	}
 }
 
 
 /* Move forward one charactor */
 static void input_forward(void)
 {
 	if (cursor < len)
 		cmdedit_set_out_char(command_ps[cursor + 1]);
 }
 
 
 static void clean_up_and_die(int sig)
 {
 	goto_new_line();
 	if (sig != SIGINT)
 		exit(EXIT_SUCCESS);	/* cmdedit_reset_term() called in atexit */
 	cmdedit_reset_term();
 }
 
 static void cmdedit_setwidth(int w, int redraw_flg)
 {
 	cmdedit_termw = cmdedit_prmt_len + 2;
 	if (w <= cmdedit_termw) {
 		cmdedit_termw = cmdedit_termw % w;
 	}
 	if (w > cmdedit_termw) {
 		cmdedit_termw = w;
 
 		if (redraw_flg) {
 			/* new y for current cursor */
 			int new_y = (cursor + cmdedit_prmt_len) / w;
 
 			/* redraw */
 			redraw((new_y >= cmdedit_y ? new_y : cmdedit_y), len - cursor);
 			fflush(stdout);
 		}
 	} 
 }
 
 extern void cmdedit_init(void)
 {
 	cmdedit_prmt_len = 0;
 	if ((handlers_sets & SET_WCHG_HANDLERS) == 0) {
 		/* emulate usage handler to set handler and call yours work */
 		win_changed(-SIGWINCH);
 		handlers_sets |= SET_WCHG_HANDLERS;
 	}
 
 	if ((handlers_sets & SET_ATEXIT) == 0) {
 #ifdef BB_FEATURE_GETUSERNAME_AND_HOMEDIR
 		struct passwd *entry;
 
 		my_euid = geteuid();
 		entry = getpwuid(my_euid);
 		if (entry) {
 			user_buf = xstrdup(entry->pw_name);
 			home_pwd_buf = xstrdup(entry->pw_dir);
 		}
 #endif
 
 #ifdef  BB_FEATURE_COMMAND_TAB_COMPLETION
 
 #ifndef BB_FEATURE_GETUSERNAME_AND_HOMEDIR
 		my_euid = geteuid();
 #endif
 		my_uid = getuid();
 		my_gid = getgid();
 #endif	/* BB_FEATURE_COMMAND_TAB_COMPLETION */
 		handlers_sets |= SET_ATEXIT;
 		atexit(cmdedit_reset_term);	/* be sure to do this only once */
 	}
 
 #if 0
 	if ((handlers_sets & SET_TERM_HANDLERS) == 0) {
 		signal(SIGKILL, clean_up_and_die);
 		signal(SIGINT, clean_up_and_die);
 		signal(SIGQUIT, clean_up_and_die);
 		signal(SIGTERM, clean_up_and_die);
 		handlers_sets |= SET_TERM_HANDLERS;
 	}
 #endif	
 
 }
 
 #ifdef BB_FEATURE_COMMAND_TAB_COMPLETION
 
 static int is_execute(const struct stat *st)
 {
 	if ((!my_euid && (st->st_mode & (S_IXUSR | S_IXGRP | S_IXOTH))) ||
 		(my_uid == st->st_uid && (st->st_mode & S_IXUSR)) ||
 		(my_gid == st->st_gid && (st->st_mode & S_IXGRP)) ||
 		(st->st_mode & S_IXOTH)) return TRUE;
 	return FALSE;
 }
 
 #ifdef BB_FEATURE_COMMAND_USERNAME_COMPLETION
 
 static char **username_tab_completion(char *ud, int *num_matches)
 {
 	struct passwd *entry;
 	int userlen;
 	char *temp;
 
 
 	ud++;				/* ~user/... to user/... */
 	userlen = strlen(ud);
 
 	if (num_matches == 0) {		/* "~/..." or "~user/..." */
 		char *sav_ud = ud - 1;
 		char *home = 0;
 
 		if (*ud == '/') {	/* "~/..."     */
 			home = home_pwd_buf;
 		} else {
 			/* "~user/..." */
 			temp = strchr(ud, '/');
 			*temp = 0;		/* ~user\0 */
 			entry = getpwnam(ud);
 			*temp = '/';		/* restore ~user/... */
 			ud = temp;
 			if (entry)
 				home = entry->pw_dir;
 		}
 		if (home) {
 			if ((userlen + strlen(home) + 1) < BUFSIZ) {
 				char temp2[BUFSIZ];	/* argument size */
 
 				/* /home/user/... */
 				sprintf(temp2, "%s%s", home, ud);
 				strcpy(sav_ud, temp2);
 			}
 		}
 		return 0;	/* void, result save to argument :-) */
 	} else {
 		/* "~[^/]*" */
 		char **matches = (char **) NULL;
 		int nm = 0;
 
 		setpwent();
 
 		while ((entry = getpwent()) != NULL) {
 			/* Null usernames should result in all users as possible completions. */
 			if ( /*!userlen || */ !strncmp(ud, entry->pw_name, userlen)) {
 
 				temp = xmalloc(3 + strlen(entry->pw_name));
 				sprintf(temp, "~%s/", entry->pw_name);
 				matches = xrealloc(matches, (nm + 1) * sizeof(char *));
 
 				matches[nm++] = temp;
 			}
 		}
 
 		endpwent();
 		(*num_matches) = nm;
 		return (matches);
 	}
 }
 #endif	/* BB_FEATURE_COMMAND_USERNAME_COMPLETION */
 
 enum {
 	FIND_EXE_ONLY = 0,
 	FIND_DIR_ONLY = 1,
 	FIND_FILE_ONLY = 2,
 };
 
 static int path_parse(char ***p, int flags)
 {
 	int npth;
 	char *tmp;
 	char *pth;
 
 	/* if not setenv PATH variable, to search cur dir "." */
 	if (flags != FIND_EXE_ONLY || (pth = getenv("PATH")) == 0 ||
 		/* PATH=<empty> or PATH=:<empty> */
 		*pth == 0 || (*pth == ':' && *(pth + 1) == 0)) {
 		return 1;
 	}
 
 	tmp = pth;
 	npth = 0;
 
 	for (;;) {
 		npth++;			/* count words is + 1 count ':' */
 		tmp = strchr(tmp, ':');
 		if (tmp) {
 			if (*++tmp == 0)
 				break;	/* :<empty> */
 		} else
 			break;
 	}
 
 	*p = xmalloc(npth * sizeof(char *));
 
 	tmp = pth;
 	(*p)[0] = xstrdup(tmp);
 	npth = 1;			/* count words is + 1 count ':' */
 
 	for (;;) {
 		tmp = strchr(tmp, ':');
 		if (tmp) {
 			(*p)[0][(tmp - pth)] = 0;	/* ':' -> '\0' */
 			if (*++tmp == 0)
 				break;			/* :<empty> */
 		} else
 			break;
 		(*p)[npth++] = &(*p)[0][(tmp - pth)];	/* p[next]=p[0][&'\0'+1] */
 	}
 
 	return npth;
 }
 
 static char *add_quote_for_spec_chars(char *found)
 {
 	int l = 0;
 	char *s = xmalloc((strlen(found) + 1) * 2);
 
 	while (*found) {
 		if (strchr(" `\"#$%^&*()=+{}[]:;\'|\\<>", *found))
 			s[l++] = '\\';
 		s[l++] = *found++;
 	}
 	s[l] = 0;
 	return s;
 }
 
 static char **exe_n_cwd_tab_completion(char *command, int *num_matches,
 					int type)
 {
 
 	char **matches = 0;
 	DIR *dir;
 	struct dirent *next;
 	char dirbuf[BUFSIZ];
 	int nm = *num_matches;
 	struct stat st;
 	char *path1[1];
 	char **paths = path1;
 	int npaths;
 	int i;
 	char *found;
 	char *pfind = strrchr(command, '/');
 
 	path1[0] = ".";
 
 	if (pfind == NULL) {
 		/* no dir, if flags==EXE_ONLY - get paths, else "." */
 		npaths = path_parse(&paths, type);
 		pfind = command;
 	} else {
 		/* with dir */
 		/* save for change */
 		strcpy(dirbuf, command);
 		/* set dir only */
 		dirbuf[(pfind - command) + 1] = 0;
 #ifdef BB_FEATURE_COMMAND_USERNAME_COMPLETION
 		if (dirbuf[0] == '~')	/* ~/... or ~user/... */
 			username_tab_completion(dirbuf, 0);
 #endif
 		/* "strip" dirname in command */
 		pfind++;
 
 		paths[0] = dirbuf;
 		npaths = 1;				/* only 1 dir */
 	}
 
 	for (i = 0; i < npaths; i++) {
 
 		dir = opendir(paths[i]);
 		if (!dir)			/* Don't print an error */
 			continue;
 
 		while ((next = readdir(dir)) != NULL) {
 			char *str_found = next->d_name;
 
 			/* matched ? */
 			if (strncmp(str_found, pfind, strlen(pfind)))
 				continue;
 			/* not see .name without .match */
 			if (*str_found == '.' && *pfind == 0) {
 				if (*paths[i] == '/' && paths[i][1] == 0
 					&& str_found[1] == 0) str_found = "";	/* only "/" */
 				else
 					continue;
 			}
 			found = concat_path_file(paths[i], str_found);
 			/* hmm, remover in progress? */
 			if (stat(found, &st) < 0) 
 				goto cont;
 			/* find with dirs ? */
 			if (paths[i] != dirbuf)
 				strcpy(found, next->d_name);	/* only name */
 			if (S_ISDIR(st.st_mode)) {
 				/* name is directory      */
 				str_found = found;
 				found = concat_path_file(found, "");
 				free(str_found);
 				str_found = add_quote_for_spec_chars(found);
 			} else {
 				/* not put found file if search only dirs for cd */
 				if (type == FIND_DIR_ONLY) 
 					goto cont;
 				str_found = add_quote_for_spec_chars(found);
 				if (type == FIND_FILE_ONLY ||
 					(type == FIND_EXE_ONLY && is_execute(&st) == TRUE))
 					strcat(str_found, " ");
 			}
 			/* Add it to the list */
 			matches = xrealloc(matches, (nm + 1) * sizeof(char *));
 
 			matches[nm++] = str_found;
 cont:
 			free(found);
 		}
 		closedir(dir);
 	}
 	if (paths != path1) {
 		free(paths[0]);			/* allocated memory only in first member */
 		free(paths);
 	}
 	*num_matches = nm;
 	return (matches);
 }
 
 static int match_compare(const void *a, const void *b)
 {
 	return strcmp(*(char **) a, *(char **) b);
 }
 
 
 
 #define QUOT    (UCHAR_MAX+1)
 
 #define collapse_pos(is, in) { \
 	memcpy(int_buf+is, int_buf+in, (BUFSIZ+1-is-in)*sizeof(int)); \
 	memcpy(pos_buf+is, pos_buf+in, (BUFSIZ+1-is-in)*sizeof(int)); }
 
 static int find_match(char *matchBuf, int *len_with_quotes)
 {
 	int i, j;
 	int command_mode;
 	int c, c2;
 	int int_buf[BUFSIZ + 1];
 	int pos_buf[BUFSIZ + 1];
 
 	/* set to integer dimension characters and own positions */
 	for (i = 0;; i++) {
 		int_buf[i] = (int) ((unsigned char) matchBuf[i]);
 		if (int_buf[i] == 0) {
 			pos_buf[i] = -1;	/* indicator end line */
 			break;
 		} else
 			pos_buf[i] = i;
 	}
 
 	/* mask \+symbol and convert '\t' to ' ' */
 	for (i = j = 0; matchBuf[i]; i++, j++)
 		if (matchBuf[i] == '\\') {
 			collapse_pos(j, j + 1);
 			int_buf[j] |= QUOT;
 			i++;
 #ifdef BB_FEATURE_NONPRINTABLE_INVERSE_PUT
 			if (matchBuf[i] == '\t')	/* algorithm equivalent */
 				int_buf[j] = ' ' | QUOT;
 #endif
 		}
 #ifdef BB_FEATURE_NONPRINTABLE_INVERSE_PUT
 		else if (matchBuf[i] == '\t')
 			int_buf[j] = ' ';
 #endif
 
 	/* mask "symbols" or 'symbols' */
 	c2 = 0;
 	for (i = 0; int_buf[i]; i++) {
 		c = int_buf[i];
 		if (c == '\'' || c == '"') {
 			if (c2 == 0)
 				c2 = c;
 			else {
 				if (c == c2)
 					c2 = 0;
 				else
 					int_buf[i] |= QUOT;
 			}
 		} else if (c2 != 0 && c != '$')
 			int_buf[i] |= QUOT;
 	}
 
 	/* skip commands with arguments if line have commands delimiters */
 	/* ';' ';;' '&' '|' '&&' '||' but `>&' `<&' `>|' */
 	for (i = 0; int_buf[i]; i++) {
 		c = int_buf[i];
 		c2 = int_buf[i + 1];
 		j = i ? int_buf[i - 1] : -1;
 		command_mode = 0;
 		if (c == ';' || c == '&' || c == '|') {
 			command_mode = 1 + (c == c2);
 			if (c == '&') {
 				if (j == '>' || j == '<')
 					command_mode = 0;
 			} else if (c == '|' && j == '>')
 				command_mode = 0;
 		}
 		if (command_mode) {
 			collapse_pos(0, i + command_mode);
 			i = -1;				/* hack incremet */
 		}
 	}
 	/* collapse `command...` */
 	for (i = 0; int_buf[i]; i++)
 		if (int_buf[i] == '`') {
 			for (j = i + 1; int_buf[j]; j++)
 				if (int_buf[j] == '`') {
 					collapse_pos(i, j + 1);
 					j = 0;
 					break;
 				}
 			if (j) {
 				/* not found close ` - command mode, collapse all previous */
 				collapse_pos(0, i + 1);
 				break;
 			} else
 				i--;			/* hack incremet */
 		}
 
 	/* collapse (command...(command...)...) or {command...{command...}...} */
 	c = 0;						/* "recursive" level */
 	c2 = 0;
 	for (i = 0; int_buf[i]; i++)
 		if (int_buf[i] == '(' || int_buf[i] == '{') {
 			if (int_buf[i] == '(')
 				c++;
 			else
 				c2++;
 			collapse_pos(0, i + 1);
 			i = -1;				/* hack incremet */
 		}
 	for (i = 0; pos_buf[i] >= 0 && (c > 0 || c2 > 0); i++)
 		if ((int_buf[i] == ')' && c > 0) || (int_buf[i] == '}' && c2 > 0)) {
 			if (int_buf[i] == ')')
 				c--;
 			else
 				c2--;
 			collapse_pos(0, i + 1);
 			i = -1;				/* hack incremet */
 		}
 
 	/* skip first not quote space */
 	for (i = 0; int_buf[i]; i++)
 		if (int_buf[i] != ' ')
 			break;
 	if (i)
 		collapse_pos(0, i);
 
 	/* set find mode for completion */
 	command_mode = FIND_EXE_ONLY;
 	for (i = 0; int_buf[i]; i++)
 		if (int_buf[i] == ' ' || int_buf[i] == '<' || int_buf[i] == '>') {
 			if (int_buf[i] == ' ' && command_mode == FIND_EXE_ONLY
 				&& matchBuf[pos_buf[0]]=='c'
 				&& matchBuf[pos_buf[1]]=='d' )
 				command_mode = FIND_DIR_ONLY;
 			else {
 				command_mode = FIND_FILE_ONLY;
 				break;
 			}
 		}
 	/* "strlen" */
 	for (i = 0; int_buf[i]; i++);
 	/* find last word */
 	for (--i; i >= 0; i--) {
 		c = int_buf[i];
 		if (c == ' ' || c == '<' || c == '>' || c == '|' || c == '&') {
 			collapse_pos(0, i + 1);
 			break;
 		}
 	}
 	/* skip first not quoted '\'' or '"' */
 	for (i = 0; int_buf[i] == '\'' || int_buf[i] == '"'; i++);
 	/* collapse quote or unquote // or /~ */
 	while ((int_buf[i] & ~QUOT) == '/' && 
 			((int_buf[i + 1] & ~QUOT) == '/'
 			 || (int_buf[i + 1] & ~QUOT) == '~')) {
 		i++;
 	}
 	if (i) {
 		collapse_pos(0, i);
 	}
 
 	/* set only match and destroy quotes */
 	j = 0;
 	for (i = 0; pos_buf[i] >= 0; i++) {
 		matchBuf[i] = matchBuf[pos_buf[i]];
 		j = pos_buf[i] + 1;
 	}
 	matchBuf[i] = 0;
 	/* old lenght matchBuf with quotes symbols */
 	*len_with_quotes = j ? j - pos_buf[0] : 0;
 
 	return command_mode;
 }
 
 
 static void input_tab(int *lastWasTab)
 {
 	/* Do TAB completion */
 	static int num_matches;
 	static char **matches;
 
 	if (lastWasTab == 0) {		/* free all memory */
 		if (matches) {
 			while (num_matches > 0)
 				free(matches[--num_matches]);
 			free(matches);
 			matches = (char **) NULL;
 		}
 		return;
 	}
 	if (*lastWasTab == FALSE) {
 
 		char *tmp;
 		int len_found;
 		char matchBuf[BUFSIZ];
 		int find_type;
 		int recalc_pos;
 
 		*lastWasTab = TRUE;		/* flop trigger */
 
 		/* Make a local copy of the string -- up
 		 * to the position of the cursor */
 		tmp = strncpy(matchBuf, command_ps, cursor);
 		tmp[cursor] = 0;
 
 		find_type = find_match(matchBuf, &recalc_pos);
 
 		/* Free up any memory already allocated */
 		input_tab(0);
 
 #ifdef BB_FEATURE_COMMAND_USERNAME_COMPLETION
 		/* If the word starts with `~' and there is no slash in the word,
 		 * then try completing this word as a username. */
 
 		if (matchBuf[0] == '~' && strchr(matchBuf, '/') == 0)
 			matches = username_tab_completion(matchBuf, &num_matches);
 #endif
 		/* Try to match any executable in our path and everything
 		 * in the current working directory that matches.  */
 		if (!matches)
 			matches =
 				exe_n_cwd_tab_completion(matchBuf, &num_matches,
 										 find_type);
 
 		/* Did we find exactly one match? */
 		if (!matches || num_matches > 1) {
 			char *tmp1;
 
 			beep();
 			if (!matches)
 				return;		/* not found */
 			/* sort */
 			qsort(matches, num_matches, sizeof(char *), match_compare);
 
 			/* find minimal match */
 			tmp = xstrdup(matches[0]);
 			for (tmp1 = tmp; *tmp1; tmp1++)
 				for (len_found = 1; len_found < num_matches; len_found++)
 					if (matches[len_found][(tmp1 - tmp)] != *tmp1) {
 						*tmp1 = 0;
 						break;
 					}
 			if (*tmp == 0) {	/* have unique */
 				free(tmp);
 				return;
 			}
 		} else {			/* one match */
 			tmp = matches[0];
 			/* for next completion current found */
 			*lastWasTab = FALSE;
 		}
 
 		len_found = strlen(tmp);
 		/* have space to placed match? */
 		if ((len_found - strlen(matchBuf) + len) < BUFSIZ) {
 
 			/* before word for match   */
 			command_ps[cursor - recalc_pos] = 0;
 			/* save   tail line        */
 			strcpy(matchBuf, command_ps + cursor);
 			/* add    match            */
 			strcat(command_ps, tmp);
 			/* add    tail             */
 			strcat(command_ps, matchBuf);
 			/* back to begin word for match    */
 			input_backward(recalc_pos);
 			/* new pos                         */
 			recalc_pos = cursor + len_found;
 			/* new len                         */
 			len = strlen(command_ps);
 			/* write out the matched command   */
 			input_end();
 			input_backward(cursor - recalc_pos);
 		}
 		if (tmp != matches[0])
 			free(tmp);
 	} else {
 		/* Ok -- the last char was a TAB.  Since they
 		 * just hit TAB again, print a list of all the
 		 * available choices... */
 		if (matches && num_matches > 0) {
 			int i, col, l;
 			int sav_cursor = cursor;	/* change goto_new_line() */
 
 			/* Go to the next line */
 			goto_new_line();
 			for (i = 0, col = 0; i < num_matches; i++) {
 				l = strlen(matches[i]);
 				if (l < 14)
 					l = 14;
 				printf("%-14s  ", matches[i]);
 				if ((l += 2) > 16)
 					while (l % 16) {
 						putchar(' ');
 						l++;
 					}
 				col += l;
 				col -= (col / cmdedit_termw) * cmdedit_termw;
 				if (col > 60 && matches[i + 1] != NULL) {
 					putchar('\n');
 					col = 0;
 				}
 			}
 			/* Go to the next line and rewrite */
 			putchar('\n');
 			redraw(0, len - sav_cursor);
 		}
 	}
 }
 #endif	/* BB_FEATURE_COMMAND_TAB_COMPLETION */
 
 static void get_previous_history(struct history **hp, struct history *p)
 {
 	if ((*hp)->s)
 		free((*hp)->s);
 	(*hp)->s = xstrdup(command_ps);
 	*hp = p;
 }
 
 static inline void get_next_history(struct history **hp)
 {
 	get_previous_history(hp, (*hp)->n);
 }
 
 enum {
 	ESC = 27,
 	DEL = 127,
 };
 
 
 /*
  * This function is used to grab a character buffer
  * from the input file descriptor and allows you to
  * a string with full command editing (sortof like
  * a mini readline).
  *
  * The following standard commands are not implemented:
  * ESC-b -- Move back one word
  * ESC-f -- Move forward one word
  * ESC-d -- Delete back one word
  * ESC-h -- Delete forward one word
  * CTL-t -- Transpose two characters
  *
  * Furthermore, the "vi" command editing keys are not implemented.
  *
  */
  
 extern void cmdedit_read_input(char *prompt, char command[BUFSIZ])
 {
 
 	int inputFd = fileno(stdin);
 
 	int break_out = 0;
 	int lastWasTab = FALSE;
 	unsigned char c = 0;
 	struct history *hp = his_end;
 
 	/* prepare before init handlers */
 	cmdedit_y = 0;	/* quasireal y, not true work if line > xt*yt */
 	len = 0;
 	command_ps = command;
 
 	if (new_settings.c_cc[VMIN] == 0) {	/* first call */
 
 		getTermSettings(inputFd, (void *) &initial_settings);
 		memcpy(&new_settings, &initial_settings, sizeof(struct termios));
 
 		new_settings.c_cc[VMIN] = 1;
 		new_settings.c_cc[VTIME] = 0;
 		/* Turn off CTRL-C, so we can trap it */
 		new_settings.c_cc[VINTR] = _POSIX_VDISABLE;	
 		new_settings.c_lflag &= ~ICANON;	/* unbuffered input */
 		/* Turn off echoing */
 		new_settings.c_lflag &= ~(ECHO | ECHOCTL | ECHONL);	
 	}
 
 	command[0] = 0;
 
 	setTermSettings(inputFd, (void *) &new_settings);
 	handlers_sets |= SET_RESET_TERM;
 
 	/* Now initialize things */
 	cmdedit_init();
 	/* Print out the command prompt */
 	parse_prompt(prompt);
 
 	while (1) {
 
 		fflush(stdout);			/* buffered out to fast */
 
 		if (read(inputFd, &c, 1) < 1)
 			/* if we can't read input then exit */
 			goto prepare_to_die;
 
 		switch (c) {
 		case '\n':
 		case '\r':
 			/* Enter */
 			goto_new_line();
 			break_out = 1;
 			break;
 		case 1:
 			/* Control-a -- Beginning of line */
 			input_backward(cursor);
 			break;
 		case 2:
 			/* Control-b -- Move back one character */
 			input_backward(1);
 			break;
 		case 3:
 			/* Control-c -- stop gathering input */
 
 			/* Link into lash to reset context to 0 on ^C and such */
 			shell_context = 0;
 
 			/* Go to the next line */
 			goto_new_line();
 			command[0] = 0;
 
 			return;
 		case 4:
 			/* Control-d -- Delete one character, or exit
 			 * if the len=0 and no chars to delete */
 			if (len == 0) {
 prepare_to_die:
 				printf("exit");
 				clean_up_and_die(0);
 			} else {
 				input_delete();
 			}
 			break;
 		case 5:
 			/* Control-e -- End of line */
 			input_end();
 			break;
 		case 6:
 			/* Control-f -- Move forward one character */
 			input_forward();
 			break;
 		case '\b':
 		case DEL:
 			/* Control-h and DEL */
 			input_backspace();
 			break;
 		case '\t':
 #ifdef BB_FEATURE_COMMAND_TAB_COMPLETION
 			input_tab(&lastWasTab);
 #endif
 			break;
 		case 14:
 			/* Control-n -- Get next command in history */
 			if (hp && hp->n && hp->n->s) {
 				get_next_history(&hp);
 				goto rewrite_line;
 			} else {
 				beep();
 			}
 			break;
 		case 16:
 			/* Control-p -- Get previous command from history */
 			if (hp && hp->p) {
 				get_previous_history(&hp, hp->p);
 				goto rewrite_line;
 			} else {
 				beep();
 			}
 			break;
 		case 21:
 			/* Control-U -- Clear line before cursor */
 			if (cursor) {
 				strcpy(command, command + cursor);
 				redraw(cmdedit_y, len -= cursor);
 			}
 			break;
 
 		case ESC:{
 			/* escape sequence follows */
 			if (read(inputFd, &c, 1) < 1)
 				return;
 			/* different vt100 emulations */
 			if (c == '[' || c == 'O') {
 				if (read(inputFd, &c, 1) < 1)
 					return;
 			}
 			switch (c) {
 #ifdef BB_FEATURE_COMMAND_TAB_COMPLETION
 			case '\t':			/* Alt-Tab */
 
 				input_tab(&lastWasTab);
 				break;
 #endif
 			case 'A':
 				/* Up Arrow -- Get previous command from history */
 				if (hp && hp->p) {
 					get_previous_history(&hp, hp->p);
 					goto rewrite_line;
 				} else {
 					beep();
 				}
 				break;
 			case 'B':
 				/* Down Arrow -- Get next command in history */
 				if (hp && hp->n && hp->n->s) {
 					get_next_history(&hp);
 					goto rewrite_line;
 				} else {
 					beep();
 				}
 				break;
 
 				/* Rewrite the line with the selected history item */
 			  rewrite_line:
 				/* change command */
 				len = strlen(strcpy(command, hp->s));
 				/* redraw and go to end line */
 				redraw(cmdedit_y, 0);
 				break;
 			case 'C':
 				/* Right Arrow -- Move forward one character */
 				input_forward();
 				break;
 			case 'D':
 				/* Left Arrow -- Move back one character */
 				input_backward(1);
 				break;
 			case '3':
 				/* Delete */
 				input_delete();
 				break;
 			case '1':
 			case 'H':
 				/* Home (Ctrl-A) */
 				input_backward(cursor);
 				break;
 			case '4':
 			case 'F':
 				/* End (Ctrl-E) */
 				input_end();
 				break;
 			default:
 				if (!(c >= '1' && c <= '9'))
 					c = 0;
 				beep();
 			}
 			if (c >= '1' && c <= '9')
 				do
 					if (read(inputFd, &c, 1) < 1)
 						return;
 				while (c != '~');
 			break;
 		}
 
 		default:	/* If it's regular input, do the normal thing */
 #ifdef BB_FEATURE_NONPRINTABLE_INVERSE_PUT
 			/* Control-V -- Add non-printable symbol */
 			if (c == 22) {
 				if (read(inputFd, &c, 1) < 1)
 					return;
 				if (c == 0) {
 					beep();
 					break;
 				}
 			} else
 #endif
 			if (!Isprint(c))	/* Skip non-printable characters */
 				break;
 
 			if (len >= (BUFSIZ - 2))	/* Need to leave space for enter */
 				break;
 
 			len++;
 
 			if (cursor == (len - 1)) {	/* Append if at the end of the line */
 				*(command + cursor) = c;
 				*(command + cursor + 1) = 0;
 				cmdedit_set_out_char(0);
 			} else {			/* Insert otherwise */
 				int sc = cursor;
 
 				memmove(command + sc + 1, command + sc, len - sc);
 				*(command + sc) = c;
 				sc++;
 				/* rewrite from cursor */
 				input_end();
 				/* to prev x pos + 1 */
 				input_backward(cursor - sc);
 			}
 
 			break;
 		}
 		if (break_out)			/* Enter is the command terminator, no more input. */
 			break;
 
 		if (c != '\t')
 			lastWasTab = FALSE;
 	}
 
 	setTermSettings(inputFd, (void *) &initial_settings);
 	handlers_sets &= ~SET_RESET_TERM;
 
 	/* Handle command history log */
 	if (len) {					/* no put empty line */
 
 		struct history *h = his_end;
 		char *ss;
 
 		ss = xstrdup(command);	/* duplicate */
 
 		if (h == 0) {
 			/* No previous history -- this memory is never freed */
 			h = his_front = xmalloc(sizeof(struct history));
 			h->n = xmalloc(sizeof(struct history));
 
 			h->p = NULL;
 			h->s = ss;
 			h->n->p = h;
 			h->n->n = NULL;
 			h->n->s = NULL;
 			his_end = h->n;
 			history_counter++;
 		} else {
 			/* Add a new history command -- this memory is never freed */
 			h->n = xmalloc(sizeof(struct history));
 
 			h->n->p = h;
 			h->n->n = NULL;
 			h->n->s = NULL;
 			h->s = ss;
 			his_end = h->n;
 
 			/* After max history, remove the oldest command */
 			if (history_counter >= MAX_HISTORY) {
 
 				struct history *p = his_front->n;
 
 				p->p = NULL;
 				free(his_front->s);
 				free(his_front);
 				his_front = p;
 			} else {
 				history_counter++;
 			}
 		}
-#if !defined(BB_FEATURE_SH_SIMPLE_PROMPT)
+#if defined(BB_FEATURE_SH_FANCY_PROMPT)
 		num_ok_lines++;
 #endif
 	}
 	command[len++] = '\n';		/* set '\n' */
 	command[len] = 0;
 #if defined(BB_FEATURE_CLEAN_UP) && defined(BB_FEATURE_COMMAND_TAB_COMPLETION)
 	input_tab(0);				/* strong free */
 #endif
-#if !defined(BB_FEATURE_SH_SIMPLE_PROMPT)
+#if defined(BB_FEATURE_SH_FANCY_PROMPT)
 	free(cmdedit_prompt);
 #endif
 	return;
 }
 
 
 /* Undo the effects of cmdedit_init(). */
 extern void cmdedit_terminate(void)
 {
 	cmdedit_reset_term();
 #if 0
 	if ((handlers_sets & SET_TERM_HANDLERS) != 0) {
 		signal(SIGKILL, SIG_DFL);
 		signal(SIGINT, SIG_DFL);
 		signal(SIGQUIT, SIG_DFL);
 		signal(SIGTERM, SIG_DFL);
 		signal(SIGWINCH, SIG_DFL);
 		handlers_sets &= ~SET_TERM_HANDLERS;
 	}
 #endif	
 }
 
 #endif	/* BB_FEATURE_COMMAND_EDITING */
 
 
 #ifdef TEST
 
 const char *applet_name = "debug stuff usage";
 const char *memory_exhausted = "Memory exhausted";
 
 #ifdef BB_FEATURE_NONPRINTABLE_INVERSE_PUT
 #include <locale.h>
 #endif
 
 unsigned int shell_context;
 
 int main(int argc, char **argv)
 {
 	char buff[BUFSIZ];
 	char *prompt =
-#if !defined(BB_FEATURE_SH_SIMPLE_PROMPT)
+#if defined(BB_FEATURE_SH_FANCY_PROMPT)
 		"\\[\\033[32;1m\\]\\u@\\[\\x1b[33;1m\\]\\h:\
 \\[\\033[34;1m\\]\\w\\[\\033[35;1m\\] \
 \\!\\[\\e[36;1m\\]\\$ \\[\\E[0m\\]";
 #else
 		"% ";
 #endif
 
 #ifdef BB_FEATURE_NONPRINTABLE_INVERSE_PUT
 	setlocale(LC_ALL, "");
 #endif
 	shell_context = 1;
 	do {
 		int l;
 		cmdedit_read_input(prompt, buff);
 		l = strlen(buff);
 		if(l > 0 && buff[l-1] == '\n')
 			buff[l-1] = 0;
 		printf("*** cmdedit_read_input() returned line =%s=\n", buff);
 	} while (shell_context);
 	printf("*** cmdedit_read_input() detect ^C\n");
 	return 0;
 }
 
 #endif	/* TEST */
diff --git a/shell/hush.c b/shell/hush.c
index fc45bb2..722dcf7 100644
--- a/shell/hush.c
+++ b/shell/hush.c
@@ -1,2637 +1,2637 @@
 /* vi: set sw=4 ts=4: */
 /*
  * sh.c -- a prototype Bourne shell grammar parser
  *      Intended to follow the original Thompson and Ritchie
  *      "small and simple is beautiful" philosophy, which
  *      incidentally is a good match to today's BusyBox.
  *
  * Copyright (C) 2000,2001  Larry Doolittle  <larry@doolittle.boa.org>
  *
  * Credits:
  *      The parser routines proper are all original material, first
  *      written Dec 2000 and Jan 2001 by Larry Doolittle.
  *      The execution engine, the builtins, and much of the underlying
  *      support has been adapted from busybox-0.49pre's lash,
  *      which is Copyright (C) 2000 by Lineo, Inc., and
  *      written by Erik Andersen <andersen@lineo.com>, <andersee@debian.org>.
  *      That, in turn, is based in part on ladsh.c, by Michael K. Johnson and
  *      Erik W. Troan, which they placed in the public domain.  I don't know
  *      how much of the Johnson/Troan code has survived the repeated rewrites.
  * Other credits:
  *      simple_itoa() was lifted from boa-0.93.15
  *      b_addchr() derived from similar w_addchar function in glibc-2.2
  *      setup_redirect(), redirect_opt_num(), and big chunks of main()
  *        and many builtins derived from contributions by Erik Andersen
  *      miscellaneous bugfixes from Matt Kraai
  *
  * There are two big (and related) architecture differences between
  * this parser and the lash parser.  One is that this version is
  * actually designed from the ground up to understand nearly all
  * of the Bourne grammar.  The second, consequential change is that
  * the parser and input reader have been turned inside out.  Now,
  * the parser is in control, and asks for input as needed.  The old
  * way had the input reader in control, and it asked for parsing to
  * take place as needed.  The new way makes it much easier to properly
  * handle the recursion implicit in the various substitutions, especially
  * across continuation lines.
  *
  * Bash grammar not implemented: (how many of these were in original sh?)
  *      $@ (those sure look like weird quoting rules)
  *      $_
  *      ! negation operator for pipes
  *      &> and >& redirection of stdout+stderr
  *      Brace Expansion
  *      Tilde Expansion
  *      fancy forms of Parameter Expansion
  *      aliases
  *      Arithmetic Expansion
  *      <(list) and >(list) Process Substitution
  *      reserved words: case, esac, select, function
  *      Here Documents ( << word )
  *      Functions
  * Major bugs:
  *      job handling woefully incomplete and buggy
  *      reserved word execution woefully incomplete and buggy
  * to-do:
  *      port selected bugfixes from post-0.49 busybox lash - done?
  *      finish implementing reserved words: for, while, until, do, done
  *      change { and } from special chars to reserved words
  *      builtins: break, continue, eval, return, set, trap, ulimit
  *      test magic exec
  *      handle children going into background
  *      clean up recognition of null pipes
  *      check setting of global_argc and global_argv
  *      control-C handling, probably with longjmp
  *      follow IFS rules more precisely, including update semantics
  *      figure out what to do with backslash-newline
  *      explain why we use signal instead of sigaction
  *      propagate syntax errors, die on resource errors?
  *      continuation lines, both explicit and implicit - done?
  *      memory leak finding and plugging - done?
  *      more testing, especially quoting rules and redirection
  *      document how quoting rules not precisely followed for variable assignments
  *      maybe change map[] to use 2-bit entries
  *      (eventually) remove all the printf's
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
  * General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
  */
 #include <ctype.h>     /* isalpha, isdigit */
 #include <unistd.h>    /* getpid */
 #include <stdlib.h>    /* getenv, atoi */
 #include <string.h>    /* strchr */
 #include <stdio.h>     /* popen etc. */
 #include <glob.h>      /* glob, of course */
 #include <stdarg.h>    /* va_list */
 #include <errno.h>
 #include <fcntl.h>
 #include <getopt.h>    /* should be pretty obvious */
 
 #include <sys/stat.h>  /* ulimit */
 #include <sys/types.h>
 #include <sys/wait.h>
 #include <signal.h>
 
 /* #include <dmalloc.h> */
 /* #define DEBUG_SHELL */
 
 #ifdef BB_VER
 #include "busybox.h"
 #include "cmdedit.h"
 #else
 #define applet_name "hush"
 #include "standalone.h"
 #define shell_main main
-#define BB_FEATURE_SH_SIMPLE_PROMPT
+#undef BB_FEATURE_SH_FANCY_PROMPT
 #endif
 
 typedef enum {
 	REDIRECT_INPUT     = 1,
 	REDIRECT_OVERWRITE = 2,
 	REDIRECT_APPEND    = 3,
 	REDIRECT_HEREIS    = 4,
 	REDIRECT_IO        = 5
 } redir_type;
 
 /* The descrip member of this structure is only used to make debugging
  * output pretty */
 struct {int mode; int default_fd; char *descrip;} redir_table[] = {
 	{ 0,                         0, "()" },
 	{ O_RDONLY,                  0, "<"  },
 	{ O_CREAT|O_TRUNC|O_WRONLY,  1, ">"  },
 	{ O_CREAT|O_APPEND|O_WRONLY, 1, ">>" },
 	{ O_RDONLY,                 -1, "<<" },
 	{ O_RDWR,                    1, "<>" }
 };
 
 typedef enum {
 	PIPE_SEQ = 1,
 	PIPE_AND = 2,
 	PIPE_OR  = 3,
 	PIPE_BG  = 4,
 } pipe_style;
 
 /* might eventually control execution */
 typedef enum {
 	RES_NONE  = 0,
 	RES_IF    = 1,
 	RES_THEN  = 2,
 	RES_ELIF  = 3,
 	RES_ELSE  = 4,
 	RES_FI    = 5,
 	RES_FOR   = 6,
 	RES_WHILE = 7,
 	RES_UNTIL = 8,
 	RES_DO    = 9,
 	RES_DONE  = 10,
 	RES_XXXX  = 11,
 	RES_SNTX  = 12
 } reserved_style;
 #define FLAG_END   (1<<RES_NONE)
 #define FLAG_IF    (1<<RES_IF)
 #define FLAG_THEN  (1<<RES_THEN)
 #define FLAG_ELIF  (1<<RES_ELIF)
 #define FLAG_ELSE  (1<<RES_ELSE)
 #define FLAG_FI    (1<<RES_FI)
 #define FLAG_FOR   (1<<RES_FOR)
 #define FLAG_WHILE (1<<RES_WHILE)
 #define FLAG_UNTIL (1<<RES_UNTIL)
 #define FLAG_DO    (1<<RES_DO)
 #define FLAG_DONE  (1<<RES_DONE)
 #define FLAG_START (1<<RES_XXXX)
 
 /* This holds pointers to the various results of parsing */
 struct p_context {
 	struct child_prog *child;
 	struct pipe *list_head;
 	struct pipe *pipe;
 	struct redir_struct *pending_redirect;
 	reserved_style w;
 	int old_flag;				/* for figuring out valid reserved words */
 	struct p_context *stack;
 	/* How about quoting status? */
 };
 
 struct redir_struct {
 	redir_type type;			/* type of redirection */
 	int fd;						/* file descriptor being redirected */
 	int dup;					/* -1, or file descriptor being duplicated */
 	struct redir_struct *next;	/* pointer to the next redirect in the list */ 
 	glob_t word;				/* *word.gl_pathv is the filename */
 };
 
 struct child_prog {
 	pid_t pid;					/* 0 if exited */
 	char **argv;				/* program name and arguments */
 	struct pipe *group;			/* if non-NULL, first in group or subshell */
 	int subshell;				/* flag, non-zero if group must be forked */
 	struct redir_struct *redirects;	/* I/O redirections */
 	glob_t glob_result;			/* result of parameter globbing */
 	int is_stopped;				/* is the program currently running? */
 	struct pipe *family;		/* pointer back to the child's parent pipe */
 };
 
 struct pipe {
 	int jobid;					/* job number */
 	int num_progs;				/* total number of programs in job */
 	int running_progs;			/* number of programs running */
 	char *text;					/* name of job */
 	char *cmdbuf;				/* buffer various argv's point into */
 	pid_t pgrp;					/* process group ID for the job */
 	struct child_prog *progs;	/* array of commands in pipe */
 	struct pipe *next;			/* to track background commands */
 	int stopped_progs;			/* number of programs alive, but stopped */
 	int job_context;			/* bitmask defining current context */
 	pipe_style followup;		/* PIPE_BG, PIPE_SEQ, PIPE_OR, PIPE_AND */
 	reserved_style r_mode;		/* supports if, for, while, until */
 };
 
 struct jobset {
 	struct pipe *head;			/* head of list of running jobs */
 	struct pipe *fg;			/* current foreground job */
 };
 
 struct close_me {
 	int fd;
 	struct close_me *next;
 };
 
 struct variables {
 	char *name;
 	char *value;
 	int flg_export;
 	int flg_read_only;
 	struct variables *next;
 };
 
 /* globals, connect us to the outside world
  * the first three support $?, $#, and $1 */
 char **global_argv;
 unsigned int global_argc;
 unsigned int last_return_code;
 extern char **environ; /* This is in <unistd.h>, but protected with __USE_GNU */
  
 /* Variables we export */
 unsigned int shell_context;  /* Used in cmdedit.c to reset the
                               * context when someone hits ^C */
 
 /* "globals" within this file */
 static char *ifs;
 static char map[256];
 static int fake_mode;
 static int interactive;
 static struct close_me *close_me_head;
 static const char *cwd;
 static struct jobset *job_list;
 static unsigned int last_bg_pid;
 static char *PS1;
 static char PS2[] = "> ";
 
 struct variables shell_ver = { "HUSH_VERSION", "0.01", 1, 1, 0 };
 
 struct variables *top_vars = &shell_ver;
 
 #define B_CHUNK (100)
 #define B_NOSPAC 1
 
 typedef struct {
 	char *data;
 	int length;
 	int maxlen;
 	int quote;
 	int nonnull;
 } o_string;
 #define NULL_O_STRING {NULL,0,0,0,0}
 /* used for initialization:
 	o_string foo = NULL_O_STRING; */
 
 /* I can almost use ordinary FILE *.  Is open_memstream() universally
  * available?  Where is it documented? */
 struct in_str {
 	const char *p;
 	int __promptme;
 	int promptmode;
 	FILE *file;
 	int (*get) (struct in_str *);
 	int (*peek) (struct in_str *);
 };
 #define b_getch(input) ((input)->get(input))
 #define b_peek(input) ((input)->peek(input))
 
 #define JOB_STATUS_FORMAT "[%d] %-22s %.40s\n"
 
 struct built_in_command {
 	char *cmd;					/* name */
 	char *descr;				/* description */
 	int (*function) (struct child_prog *);	/* function ptr */
 };
 
 /* belongs in busybox.h */
 static inline int max(int a, int b) {
 	return (a>b)?a:b;
 }
 
 /* This should be in utility.c */
 #ifdef DEBUG_SHELL
 static void debug_printf(const char *format, ...)
 {
 	va_list args;
 	va_start(args, format);
 	vfprintf(stderr, format, args);
 	va_end(args);
 }
 #else
 static inline void debug_printf(const char *format, ...) { }
 #endif
 #define final_printf debug_printf
 
 static void __syntax(char *file, int line) {
 	error_msg("syntax error %s:%d", file, line);
 }
 #define syntax() __syntax(__FILE__, __LINE__)
 
 /* Index of subroutines: */
 /*   function prototypes for builtins */
 static int builtin_cd(struct child_prog *child);
 static int builtin_env(struct child_prog *child);
 static int builtin_exec(struct child_prog *child);
 static int builtin_exit(struct child_prog *child);
 static int builtin_export(struct child_prog *child);
 static int builtin_fg_bg(struct child_prog *child);
 static int builtin_help(struct child_prog *child);
 static int builtin_jobs(struct child_prog *child);
 static int builtin_pwd(struct child_prog *child);
 static int builtin_read(struct child_prog *child);
 static int builtin_set(struct child_prog *child);
 static int builtin_shift(struct child_prog *child);
 static int builtin_source(struct child_prog *child);
 static int builtin_umask(struct child_prog *child);
 static int builtin_unset(struct child_prog *child);
 static int builtin_not_written(struct child_prog *child);
 /*   o_string manipulation: */
 static int b_check_space(o_string *o, int len);
 static int b_addchr(o_string *o, int ch);
 static void b_reset(o_string *o);
 static int b_addqchr(o_string *o, int ch, int quote);
 static int b_adduint(o_string *o, unsigned int i);
 /*  in_str manipulations: */
 static int static_get(struct in_str *i);
 static int static_peek(struct in_str *i);
 static int file_get(struct in_str *i);
 static int file_peek(struct in_str *i);
 static void setup_file_in_str(struct in_str *i, FILE *f);
 static void setup_string_in_str(struct in_str *i, const char *s);
 /*  close_me manipulations: */
 static void mark_open(int fd);
 static void mark_closed(int fd);
 static void close_all();
 /*  "run" the final data structures: */
 static char *indenter(int i);
 static int run_list_test(struct pipe *head, int indent);
 static int run_pipe_test(struct pipe *pi, int indent);
 /*  really run the final data structures: */
 static int setup_redirects(struct child_prog *prog, int squirrel[]);
 static int pipe_wait(struct pipe *pi);
 static int run_list_real(struct pipe *pi);
 static void pseudo_exec(struct child_prog *child) __attribute__ ((noreturn));
 int controlling_tty(int check_pgrp);
 static int run_pipe_real(struct pipe *pi);
 /*   extended glob support: */
 static int globhack(const char *src, int flags, glob_t *pglob);
 static int glob_needed(const char *s);
 static int xglob(o_string *dest, int flags, glob_t *pglob);
 /*   variable assignment: */
 static int is_assignment(const char *s);
 /*   data structure manipulation: */
 static int setup_redirect(struct p_context *ctx, int fd, redir_type style, struct in_str *input);
 static void initialize_context(struct p_context *ctx);
 static int done_word(o_string *dest, struct p_context *ctx);
 static int done_command(struct p_context *ctx);
 static int done_pipe(struct p_context *ctx, pipe_style type);
 /*   primary string parsing: */
 static int redirect_dup_num(struct in_str *input);
 static int redirect_opt_num(o_string *o);
 static int process_command_subs(o_string *dest, struct p_context *ctx, struct in_str *input, int subst_end);
 static int parse_group(o_string *dest, struct p_context *ctx, struct in_str *input, int ch);
 static void lookup_param(o_string *dest, struct p_context *ctx, o_string *src);
 static int handle_dollar(o_string *dest, struct p_context *ctx, struct in_str *input);
 static int parse_string(o_string *dest, struct p_context *ctx, const char *src);
 static int parse_stream(o_string *dest, struct p_context *ctx, struct in_str *input0, int end_trigger);
 /*   setup: */
 static int parse_stream_outer(struct in_str *inp);
 static int parse_string_outer(const char *s);
 static int parse_file_outer(FILE *f);
 /*   job management: */
 static void checkjobs();
 static void insert_bg_job(struct pipe *pi);
 static void remove_bg_job(struct pipe *pi);
 static void free_pipe(struct pipe *pi);
 /*     local variable support */
 static char *get_local_var(const char *var);
 static void  unset_local_var(const char *name);
 static int set_local_var(const char *s, int flg_export);
 
 
 /* Table of built-in functions.  They can be forked or not, depending on
  * context: within pipes, they fork.  As simple commands, they do not.
  * When used in non-forking context, they can change global variables
  * in the parent shell process.  If forked, of course they can not.
  * For example, 'unset foo | whatever' will parse and run, but foo will
  * still be set at the end. */
 static struct built_in_command bltins[] = {
 	{"bg", "Resume a job in the background", builtin_fg_bg},
 	{"break", "Exit for, while or until loop", builtin_not_written},
 	{"cd", "Change working directory", builtin_cd},
 	{"continue", "Continue for, while or until loop", builtin_not_written},
 	{"env", "Print all environment variables", builtin_env},
 	{"eval", "Construct and run shell command", builtin_not_written},
 	{"exec", "Exec command, replacing this shell with the exec'd process", 
 		builtin_exec},
 	{"exit", "Exit from shell()", builtin_exit},
 	{"export", "Set environment variable", builtin_export},
 	{"fg", "Bring job into the foreground", builtin_fg_bg},
 	{"jobs", "Lists the active jobs", builtin_jobs},
 	{"pwd", "Print current directory", builtin_pwd},
 	{"read", "Input environment variable", builtin_read},
 	{"return", "Return from a function", builtin_not_written},
 	{"set", "Set/unset shell local variables", builtin_set},
 	{"shift", "Shift positional parameters", builtin_shift},
 	{"trap", "Trap signals", builtin_not_written},
 	{"ulimit","Controls resource limits", builtin_not_written},
 	{"umask","Sets file creation mask", builtin_umask},
 	{"unset", "Unset environment variable", builtin_unset},
 	{".", "Source-in and run commands in a file", builtin_source},
 	{"help", "List shell built-in commands", builtin_help},
 	{NULL, NULL, NULL}
 };
 
 static const char *set_cwd(void)
 {
 	if(cwd==unknown)
 		cwd = NULL;     /* xgetcwd(arg) called free(arg) */
 	cwd = xgetcwd((char *)cwd);
 	if (!cwd)
 		cwd = unknown;
 	return cwd;
 }
 
 
 /* built-in 'cd <path>' handler */
 static int builtin_cd(struct child_prog *child)
 {
 	char *newdir;
 	if (child->argv[1] == NULL)
 		newdir = getenv("HOME");
 	else
 		newdir = child->argv[1];
 	if (chdir(newdir)) {
 		printf("cd: %s: %s\n", newdir, strerror(errno));
 		return EXIT_FAILURE;
 	}
 	set_cwd();
 	return EXIT_SUCCESS;
 }
 
 /* built-in 'env' handler */
 static int builtin_env(struct child_prog *dummy)
 {
 	char **e = environ;
 	if (e == NULL) return EXIT_FAILURE;
 	for (; *e; e++) {
 		puts(*e);
 	}
 	return EXIT_SUCCESS;
 }
 
 /* built-in 'exec' handler */
 static int builtin_exec(struct child_prog *child)
 {
 	if (child->argv[1] == NULL)
 		return EXIT_SUCCESS;   /* Really? */
 	child->argv++;
 	pseudo_exec(child);
 	/* never returns */
 }
 
 /* built-in 'exit' handler */
 static int builtin_exit(struct child_prog *child)
 {
 	if (child->argv[1] == NULL)
 		exit(last_return_code);
 	exit (atoi(child->argv[1]));
 }
 
 /* built-in 'export VAR=value' handler */
 static int builtin_export(struct child_prog *child)
 {
 	int res = 0;
 	char *name = child->argv[1];
 
 	if (name == NULL) {
 		return (builtin_env(child));
 	}
 
 	name = strdup(name);
 
 	if(name) {
 	    char *value = strchr(name, '=');
 
 	if (!value) {
 		char *tmp;
 		/* They are exporting something without an =VALUE */
 
 		value = get_local_var(name);
 		if (value) {
 			size_t ln = strlen(name);
 
 			tmp = realloc(name, ln+strlen(value)+2);
 			if(tmp==NULL)
 				res = -1;
 			else {
 				sprintf(tmp+ln, "=%s", value);
 				name = tmp;
 			}
 		} else {
 			/* bash not put error and set error code
 			   if exporting not defined variable */
 			res = 1;
 		}
 	    }
 	}
 	if (res<0)
 		perror_msg("export");
 	else if(res==0)
 		res = set_local_var(name, 1);
 	else
 		res = 0;
 	free(name);
 	return res;
 }
 
 /* built-in 'fg' and 'bg' handler */
 static int builtin_fg_bg(struct child_prog *child)
 {
 	int i, jobnum;
 	struct pipe *pi=NULL;
 
 	/* If they gave us no args, assume they want the last backgrounded task */
 	if (!child->argv[1]) {
 		for (pi = job_list->head; pi; pi = pi->next) {
 			if (pi->progs && pi->progs->pid == last_bg_pid) {
 				break;
 			}
 		}
 		if (!pi) {
 			error_msg("%s: no current job", child->argv[0]);
 			return EXIT_FAILURE;
 		}
 	} else {
 		if (sscanf(child->argv[1], "%%%d", &jobnum) != 1) {
 			error_msg("%s: bad argument '%s'", child->argv[0], child->argv[1]);
 			return EXIT_FAILURE;
 		}
 
 		for (pi = job_list->head; pi; pi = pi->next) {
 			if (pi->jobid == jobnum) {
 				break;
 			}
 		}
 		if (!pi) {
 			error_msg("%s: %d: no such job", child->argv[0], jobnum);
 			return EXIT_FAILURE;
 		}
 	}
 	if (*child->argv[0] == 'f') {
 		/* Make this job the foreground job */
 		signal(SIGTTOU, SIG_IGN);
 		/* suppress messages when run from /linuxrc mag@sysgo.de */
 		if (tcsetpgrp(0, pi->pgrp) && errno != ENOTTY)
 			perror_msg("tcsetpgrp-1"); 
 		signal(SIGTTOU, SIG_DFL);
 		job_list->fg = pi;
 	}
 
 	/* Restart the processes in the job */
 	for (i = 0; i < pi->num_progs; i++)
 		pi->progs[i].is_stopped = 0;
 
 	kill(-pi->pgrp, SIGCONT);
 
 	pi->stopped_progs = 0;
 	return EXIT_SUCCESS;
 }
 
 /* built-in 'help' handler */
 static int builtin_help(struct child_prog *dummy)
 {
 	struct built_in_command *x;
 
 	printf("\nBuilt-in commands:\n");
 	printf("-------------------\n");
 	for (x = bltins; x->cmd; x++) {
 		if (x->descr==NULL)
 			continue;
 		printf("%s\t%s\n", x->cmd, x->descr);
 	}
 	printf("\n\n");
 	return EXIT_SUCCESS;
 }
 
 /* built-in 'jobs' handler */
 static int builtin_jobs(struct child_prog *child)
 {
 	struct pipe *job;
 	char *status_string;
 
 	for (job = job_list->head; job; job = job->next) {
 		if (job->running_progs == job->stopped_progs)
 			status_string = "Stopped";
 		else
 			status_string = "Running";
 		printf(JOB_STATUS_FORMAT, job->jobid, status_string, job->text);
 	}
 	return EXIT_SUCCESS;
 }
 
 
 /* built-in 'pwd' handler */
 static int builtin_pwd(struct child_prog *dummy)
 {
 	puts(set_cwd());
 	return EXIT_SUCCESS;
 }
 
 /* built-in 'read VAR' handler */
 static int builtin_read(struct child_prog *child)
 {
 	int res;
 
 	if (child->argv[1]) {
 		char string[BUFSIZ];
 		char *var = 0;
 
 		string[0] = 0;  /* for correct work if stdin have "only EOF" */
 		/* read string */
 		fgets(string, sizeof(string), stdin);
 		chomp(string);
 		var = malloc(strlen(child->argv[1])+strlen(string)+2);
 		if(var) {
 			sprintf(var, "%s=%s", child->argv[1], string);
 			res = set_local_var(var, 0);
 		} else
 		res = -1;
 		if (res)
 			fprintf(stderr, "read: %m\n");
 		free(var);      /* not move up - saved errno */
 		return res;
 	} else {
 		do res=getchar(); while(res!='\n' && res!=EOF);
 		return 0;
 	}
 }
 
 /* built-in 'set VAR=value' handler */
 static int builtin_set(struct child_prog *child)
 {
 	char *temp = child->argv[1];
 	struct variables *e;
 
 	if (temp == NULL)
 		for(e = top_vars; e; e=e->next)
 			printf("%s=%s\n", e->name, e->value);
 	else
 		set_local_var(temp, 0);
 
 		return EXIT_SUCCESS;
 }
 
 
 /* Built-in 'shift' handler */
 static int builtin_shift(struct child_prog *child)
 {
 	int n=1;
 	if (child->argv[1]) {
 		n=atoi(child->argv[1]);
 	}
 	if (n>=0 && n<global_argc) {
 		/* XXX This probably breaks $0 */
 		global_argc -= n;
 		global_argv += n;
 		return EXIT_SUCCESS;
 	} else {
 		return EXIT_FAILURE;
 	}
 }
 
 /* Built-in '.' handler (read-in and execute commands from file) */
 static int builtin_source(struct child_prog *child)
 {
 	FILE *input;
 	int status;
 
 	if (child->argv[1] == NULL)
 		return EXIT_FAILURE;
 
 	/* XXX search through $PATH is missing */
 	input = fopen(child->argv[1], "r");
 	if (!input) {
 		error_msg("Couldn't open file '%s'", child->argv[1]);
 		return EXIT_FAILURE;
 	}
 
 	/* Now run the file */
 	/* XXX argv and argc are broken; need to save old global_argv
 	 * (pointer only is OK!) on this stack frame,
 	 * set global_argv=child->argv+1, recurse, and restore. */
 	mark_open(fileno(input));
 	status = parse_file_outer(input);
 	mark_closed(fileno(input));
 	fclose(input);
 	return (status);
 }
 
 static int builtin_umask(struct child_prog *child)
 {
 	mode_t new_umask;
 	const char *arg = child->argv[1];
 	char *end;
 	if (arg) {
 		new_umask=strtoul(arg, &end, 8);
 		if (*end!='\0' || end == arg) {
 			return EXIT_FAILURE;
 		}
 	} else {
 		printf("%.3o\n", (unsigned int) (new_umask=umask(0)));
 	}
 	umask(new_umask);
 	return EXIT_SUCCESS;
 }
 
 /* built-in 'unset VAR' handler */
 static int builtin_unset(struct child_prog *child)
 {
 	/* bash returned already true */
 	unset_local_var(child->argv[1]);
 	return EXIT_SUCCESS;
 }
 
 static int builtin_not_written(struct child_prog *child)
 {
 	printf("builtin_%s not written\n",child->argv[0]);
 	return EXIT_FAILURE;
 }
 
 static int b_check_space(o_string *o, int len)
 {
 	/* It would be easy to drop a more restrictive policy
 	 * in here, such as setting a maximum string length */
 	if (o->length + len > o->maxlen) {
 		char *old_data = o->data;
 		/* assert (data == NULL || o->maxlen != 0); */
 		o->maxlen += max(2*len, B_CHUNK);
 		o->data = realloc(o->data, 1 + o->maxlen);
 		if (o->data == NULL) {
 			free(old_data);
 		}
 	}
 	return o->data == NULL;
 }
 
 static int b_addchr(o_string *o, int ch)
 {
 	debug_printf("b_addchr: %c %d %p\n", ch, o->length, o);
 	if (b_check_space(o, 1)) return B_NOSPAC;
 	o->data[o->length] = ch;
 	o->length++;
 	o->data[o->length] = '\0';
 	return 0;
 }
 
 static void b_reset(o_string *o)
 {
 	o->length = 0;
 	o->nonnull = 0;
 	if (o->data != NULL) *o->data = '\0';
 }
 
 static void b_free(o_string *o)
 {
 	b_reset(o);
 	if (o->data != NULL) free(o->data);
 	o->data = NULL;
 	o->maxlen = 0;
 }
 
 /* My analysis of quoting semantics tells me that state information
  * is associated with a destination, not a source.
  */
 static int b_addqchr(o_string *o, int ch, int quote)
 {
 	if (quote && strchr("*?[\\",ch)) {
 		int rc;
 		rc = b_addchr(o, '\\');
 		if (rc) return rc;
 	}
 	return b_addchr(o, ch);
 }
 
 /* belongs in utility.c */
 char *simple_itoa(unsigned int i)
 {
 	/* 21 digits plus null terminator, good for 64-bit or smaller ints */
 	static char local[22];
 	char *p = &local[21];
 	*p-- = '\0';
 	do {
 		*p-- = '0' + i % 10;
 		i /= 10;
 	} while (i > 0);
 	return p + 1;
 }
 
 static int b_adduint(o_string *o, unsigned int i)
 {
 	int r;
 	char *p = simple_itoa(i);
 	/* no escape checking necessary */
 	do r=b_addchr(o, *p++); while (r==0 && *p);
 	return r;
 }
 
 static int static_get(struct in_str *i)
 {
 	int ch=*i->p++;
 	if (ch=='\0') return EOF;
 	return ch;
 }
 
 static int static_peek(struct in_str *i)
 {
 	return *i->p;
 }
 
 static inline void cmdedit_set_initial_prompt(void)
 {
-#ifdef BB_FEATURE_SH_SIMPLE_PROMPT
+#ifndef BB_FEATURE_SH_FANCY_PROMPT
 	PS1 = NULL;
 #else
 	PS1 = getenv("PS1");
 	if(PS1==0)
 		PS1 = "\\w \\$ ";
 #endif	
 }
 
 static inline void setup_prompt_string(int promptmode, char **prompt_str)
 {
 	debug_printf("setup_prompt_string %d ",promptmode);
-#ifdef BB_FEATURE_SH_SIMPLE_PROMPT
+#ifndef BB_FEATURE_SH_FANCY_PROMPT
 	/* Set up the prompt */
 	if (promptmode == 1) {
 		if (PS1)
 			free(PS1);
 		PS1=xmalloc(strlen(cwd)+4);
 		sprintf(PS1, "%s %s", cwd, ( geteuid() != 0 ) ?  "$ ":"# ");
 		*prompt_str = PS1;
 	} else {
 		*prompt_str = PS2;
 	}
 #else
 	*prompt_str = (promptmode==0)? PS1 : PS2;
 #endif
 	debug_printf("result %s\n",*prompt_str);
 }
 
 static void get_user_input(struct in_str *i)
 {
 	char *prompt_str;
 	static char the_command[BUFSIZ];
 
 	setup_prompt_string(i->promptmode, &prompt_str);
 #ifdef BB_FEATURE_COMMAND_EDITING
 	/*
 	 ** enable command line editing only while a command line
 	 ** is actually being read; otherwise, we'll end up bequeathing
 	 ** atexit() handlers and other unwanted stuff to our
 	 ** child processes (rob@sysgo.de)
 	 */
 	cmdedit_read_input(prompt_str, the_command);
 	cmdedit_terminate();
 #else
 	fputs(prompt_str, stdout);
 	fflush(stdout);
 	the_command[0]=fgetc(i->file);
 	the_command[1]='\0';
 #endif
 	i->p = the_command;
 }
 
 /* This is the magic location that prints prompts 
  * and gets data back from the user */
 static int file_get(struct in_str *i)
 {
 	int ch;
 
 	ch = 0;
 	/* If there is data waiting, eat it up */
 	if (i->p && *i->p) {
 		ch=*i->p++;
 	} else {
 		/* need to double check i->file because we might be doing something
 		 * more complicated by now, like sourcing or substituting. */
 		if (i->__promptme && interactive && i->file == stdin) {
 			get_user_input(i);
 			i->promptmode=2;
 			i->__promptme = 0;
 			if (i->p && *i->p) {
 				ch=*i->p++;
 			}
 		} else {
 			ch = fgetc(i->file);
 		}
 
 		debug_printf("b_getch: got a %d\n", ch);
 	}
 	if (ch == '\n') i->__promptme=1;
 	return ch;
 }
 
 /* All the callers guarantee this routine will never be
  * used right after a newline, so prompting is not needed.
  */
 static int file_peek(struct in_str *i)
 {
 	if (i->p && *i->p) {
 		return *i->p;
 	} else {
 		static char buffer[2];
 		buffer[0] = fgetc(i->file);
 		buffer[1] = '\0';
 		i->p = buffer;
 		debug_printf("b_peek: got a %d\n", *i->p);
 		return *i->p; 
 	}
 }
 
 static void setup_file_in_str(struct in_str *i, FILE *f)
 {
 	i->peek = file_peek;
 	i->get = file_get;
 	i->__promptme=1;
 	i->promptmode=1;
 	i->file = f;
 	i->p = NULL;
 }
 
 static void setup_string_in_str(struct in_str *i, const char *s)
 {
 	i->peek = static_peek;
 	i->get = static_get;
 	i->__promptme=1;
 	i->promptmode=1;
 	i->p = s;
 }
 
 static void mark_open(int fd)
 {
 	struct close_me *new = xmalloc(sizeof(struct close_me));
 	new->fd = fd;
 	new->next = close_me_head;
 	close_me_head = new;
 }
 
 static void mark_closed(int fd)
 {
 	struct close_me *tmp;
 	if (close_me_head == NULL || close_me_head->fd != fd)
 		error_msg_and_die("corrupt close_me");
 	tmp = close_me_head;
 	close_me_head = close_me_head->next;
 	free(tmp);
 }
 
 static void close_all()
 {
 	struct close_me *c;
 	for (c=close_me_head; c; c=c->next) {
 		close(c->fd);
 	}
 	close_me_head = NULL;
 }
 
 /* squirrel != NULL means we squirrel away copies of stdin, stdout,
  * and stderr if they are redirected. */
 static int setup_redirects(struct child_prog *prog, int squirrel[])
 {
 	int openfd, mode;
 	struct redir_struct *redir;
 
 	for (redir=prog->redirects; redir; redir=redir->next) {
 		if (redir->dup == -1) {
 			mode=redir_table[redir->type].mode;
 			openfd = open(redir->word.gl_pathv[0], mode, 0666);
 			if (openfd < 0) {
 			/* this could get lost if stderr has been redirected, but
 			   bash and ash both lose it as well (though zsh doesn't!) */
 				perror_msg("error opening %s", redir->word.gl_pathv[0]);
 				return 1;
 			}
 		} else {
 			openfd = redir->dup;
 		}
 
 		if (openfd != redir->fd) {
 			if (squirrel && redir->fd < 3) {
 				squirrel[redir->fd] = dup(redir->fd);
 			}
 			if (openfd == -3) {
 				close(openfd);
 			} else {
 				dup2(openfd, redir->fd);
 				close(openfd);
 			}
 		}
 	}
 	return 0;
 }
 
 static void restore_redirects(int squirrel[])
 {
 	int i, fd;
 	for (i=0; i<3; i++) {
 		fd = squirrel[i];
 		if (fd != -1) {
 			/* No error checking.  I sure wouldn't know what
 			 * to do with an error if I found one! */
 			dup2(fd, i);
 			close(fd);
 		}
 	}
 }
 
 /* XXX this definitely needs some more thought, work, and
  * cribbing from other shells */
 static int pipe_wait(struct pipe *pi)
 {
 	int rcode=0, i, pid, running, status;
 	running = pi->num_progs;
 	while (running) {
 		pid=waitpid(-1, &status, 0);
 		if (pid < 0) perror_msg_and_die("waitpid");
 		for (i=0; i < pi->num_progs; i++) {
 			if (pi->progs[i].pid == pid) {
 				if (i==pi->num_progs-1) rcode=WEXITSTATUS(status);
 				pi->progs[i].pid = 0;
 				running--;
 				break;
 			}
 		}
 	}
 	return rcode;
 }
 
 /* never returns */
 static void pseudo_exec(struct child_prog *child)
 {
 	int i, rcode;
 	struct built_in_command *x;
 	if (child->argv) {
 		for (i=0; is_assignment(child->argv[i]); i++) {
 			debug_printf("pid %d environment modification: %s\n",getpid(),child->argv[i]);
 			putenv(strdup(child->argv[i]));
 		}
 		child->argv+=i;  /* XXX this hack isn't so horrible, since we are about
 		                        to exit, and therefore don't need to keep data
 		                        structures consistent for free() use. */
 		/* If a variable is assigned in a forest, and nobody listens,
 		 * was it ever really set?
 		 */
 		if (child->argv[0] == NULL) exit(EXIT_SUCCESS);
 
 		/*
 		 * Check if the command matches any of the builtins.
 		 * Depending on context, this might be redundant.  But it's
 		 * easier to waste a few CPU cycles than it is to figure out
 		 * if this is one of those cases.
 		 */
 		for (x = bltins; x->cmd; x++) {
 			if (strcmp(child->argv[0], x->cmd) == 0 ) {
 				debug_printf("builtin exec %s\n", child->argv[0]);
 				exit(x->function(child));
 			}
 		}
 
 		/* Check if the command matches any busybox internal commands
 		 * ("applets") here.  
 		 * FIXME: This feature is not 100% safe, since
 		 * BusyBox is not fully reentrant, so we have no guarantee the things
 		 * from the .bss are still zeroed, or that things from .data are still
 		 * at their defaults.  We could exec ourself from /proc/self/exe, but I
 		 * really dislike relying on /proc for things.  We could exec ourself
 		 * from global_argv[0], but if we are in a chroot, we may not be able
 		 * to find ourself... */ 
 #ifdef BB_FEATURE_SH_STANDALONE_SHELL
 		{
 			int argc_l;
 			char** argv_l=child->argv;
 			char *name = child->argv[0];
 
 #ifdef BB_FEATURE_SH_APPLETS_ALWAYS_WIN
 			/* Following discussions from November 2000 on the busybox mailing
 			 * list, the default configuration, (without
 			 * get_last_path_component()) lets the user force use of an
 			 * external command by specifying the full (with slashes) filename.
 			 * If you enable BB_FEATURE_SH_APPLETS_ALWAYS_WIN, then applets
 			 * _aways_ override external commands, so if you want to run
 			 * /bin/cat, it will use BusyBox cat even if /bin/cat exists on the
 			 * filesystem and is _not_ busybox.  Some systems may want this,
 			 * most do not.  */
 			name = get_last_path_component(name);
 #endif
 			/* Count argc for use in a second... */
 			for(argc_l=0;*argv_l!=NULL; argv_l++, argc_l++);
 			optind = 1;
 			debug_printf("running applet %s\n", name);
 			run_applet_by_name(name, argc_l, child->argv);
 		}
 #endif
 		debug_printf("exec of %s\n",child->argv[0]);
 		execvp(child->argv[0],child->argv);
 		perror_msg("couldn't exec: %s",child->argv[0]);
 		exit(1);
 	} else if (child->group) {
 		debug_printf("runtime nesting to group\n");
 		interactive=0;    /* crucial!!!! */
 		rcode = run_list_real(child->group);
 		/* OK to leak memory by not calling run_list_test,
 		 * since this process is about to exit */
 		exit(rcode);
 	} else {
 		/* Can happen.  See what bash does with ">foo" by itself. */
 		debug_printf("trying to pseudo_exec null command\n");
 		exit(EXIT_SUCCESS);
 	}
 }
 
 static void insert_bg_job(struct pipe *pi)
 {
 	struct pipe *thejob;
 
 	/* Linear search for the ID of the job to use */
 	pi->jobid = 1;
 	for (thejob = job_list->head; thejob; thejob = thejob->next)
 		if (thejob->jobid >= pi->jobid)
 			pi->jobid = thejob->jobid + 1;
 
 	/* add thejob to the list of running jobs */
 	if (!job_list->head) {
 		thejob = job_list->head = xmalloc(sizeof(*thejob));
 	} else {
 		for (thejob = job_list->head; thejob->next; thejob = thejob->next) /* nothing */;
 		thejob->next = xmalloc(sizeof(*thejob));
 		thejob = thejob->next;
 	}
 
 	/* physically copy the struct job */
 	memcpy(thejob, pi, sizeof(struct pipe));
 	thejob->next = NULL;
 	thejob->running_progs = thejob->num_progs;
 	thejob->stopped_progs = 0;
 	thejob->text = xmalloc(BUFSIZ); /* cmdedit buffer size */
 
 	//if (pi->progs[0] && pi->progs[0].argv && pi->progs[0].argv[0])
 	{
 		char *bar=thejob->text;
 		char **foo=pi->progs[0].argv;
 		while(foo && *foo) {
 			bar += sprintf(bar, "%s ", *foo++);
 		}
 	}
 
 	/* we don't wait for background thejobs to return -- append it 
 	   to the list of backgrounded thejobs and leave it alone */
 	printf("[%d] %d\n", thejob->jobid, thejob->progs[0].pid);
 	last_bg_pid = thejob->progs[0].pid;
 }
 
 /* remove a backgrounded job from a jobset */
 static void remove_bg_job(struct pipe *pi)
 {
 	struct pipe *prev_pipe;
 
 	if (pi == job_list->head) {
 		job_list->head = pi->next;
 	} else {
 		prev_pipe = job_list->head;
 		while (prev_pipe->next != pi)
 			prev_pipe = prev_pipe->next;
 		prev_pipe->next = pi->next;
 	}
 
 	free_pipe(pi);
 	free(pi);
 }
 
 /* free up all memory from a pipe */
 static void free_pipe(struct pipe *pi)
 {
 	int i;
 
 	for (i = 0; i < pi->num_progs; i++) {
 		free(pi->progs[i].argv);
 		if (pi->progs[i].redirects)
 			free(pi->progs[i].redirects);
 	}
 	if (pi->progs)
 		free(pi->progs);
 	if (pi->text)
 		free(pi->text);
 	if (pi->cmdbuf)
 		free(pi->cmdbuf);
 	memset(pi, 0, sizeof(struct pipe));
 }
 
 
 /* Checks to see if any background processes have exited -- if they 
    have, figure out why and see if a job has completed */
 static void checkjobs()
 {
 	int status, ctty;
 	int prognum = 0;
 	struct pipe *pi;
 	pid_t childpid;
 
 	while ((childpid = waitpid(-1, &status, WNOHANG | WUNTRACED)) > 0) {
 		for (pi = job_list->head; pi; pi = pi->next) {
 			prognum = 0;
 			while (prognum < pi->num_progs &&
 				   pi->progs[prognum].pid != childpid) prognum++;
 			if (prognum < pi->num_progs)
 				break;
 		}
 
 		if (WIFEXITED(status) || WIFSIGNALED(status)) {
 			/* child exited */
 			pi->running_progs--;
 			pi->progs[prognum].pid = 0;
 
 			if (!pi->running_progs) {
 				printf(JOB_STATUS_FORMAT, pi->jobid, "Done", pi->text);
 				remove_bg_job(pi);
 			}
 		} else {
 			if(pi==NULL)
 				break;
 			/* child stopped */
 			pi->stopped_progs++;
 			pi->progs[prognum].is_stopped = 1;
 
 			if (pi->stopped_progs == pi->num_progs) {
 				printf(JOB_STATUS_FORMAT, pi->jobid, "Stopped", pi->text);
 			}
 		}
 	}
 
 	if (childpid == -1 && errno != ECHILD)
 		perror_msg("waitpid");
 
 	/* move the shell to the foreground */
 	if (interactive && (ctty=controlling_tty(0))!=-1) {
 		if (tcsetpgrp(ctty, getpgrp()))
 			perror_msg("tcsetpgrp-2");
 	}
 }
 
 /* Figure out our controlling tty, checking in order stderr,
  * stdin, and stdout.  If check_pgrp is set, also check that
  * we belong to the foreground process group associated with
  * that tty.  The value of ctty is needed in order to call
  * tcsetpgrp(ctty, ...); */
 int controlling_tty(int check_pgrp)
 {
 	pid_t curpgrp;
 	int ctty;
 
 	if ((curpgrp = tcgetpgrp(ctty = 2)) < 0
 		&& (curpgrp = tcgetpgrp(ctty = 0)) < 0
 		&& (curpgrp = tcgetpgrp(ctty = 1)) < 0)
 		return errno = ENOTTY, -1;
 
 	if (check_pgrp && curpgrp != getpgrp())
 		return errno = EPERM, -1;
 
 	return ctty;
 }
 
 /* run_pipe_real() starts all the jobs, but doesn't wait for anything
  * to finish.  See pipe_wait().
  *
  * return code is normally -1, when the caller has to wait for children
  * to finish to determine the exit status of the pipe.  If the pipe
  * is a simple builtin command, however, the action is done by the
  * time run_pipe_real returns, and the exit code is provided as the
  * return value.
  *
  * The input of the pipe is always stdin, the output is always
  * stdout.  The outpipe[] mechanism in BusyBox-0.48 lash is bogus,
  * because it tries to avoid running the command substitution in
  * subshell, when that is in fact necessary.  The subshell process
  * now has its stdout directed to the input of the appropriate pipe,
  * so this routine is noticeably simpler.
  */
 static int run_pipe_real(struct pipe *pi)
 {
 	int i;
 	int ctty;
 	int nextin, nextout;
 	int pipefds[2];				/* pipefds[0] is for reading */
 	struct child_prog *child;
 	struct built_in_command *x;
 
 	ctty = -1;
 	nextin = 0;
 	pi->pgrp = -1;
 
 	/* Check if we are supposed to run in the foreground */
 	if (interactive && pi->followup!=PIPE_BG) {
 		if ((ctty = controlling_tty(pi->pgrp<0)) < 0) return -1;
 	}
 
 	/* Check if this is a simple builtin (not part of a pipe).
 	 * Builtins within pipes have to fork anyway, and are handled in
 	 * pseudo_exec.  "echo foo | read bar" doesn't work on bash, either.
 	 */
 	if (pi->num_progs == 1 && pi->progs[0].argv != NULL) {
 		child = & (pi->progs[0]);
 		if (child->group && ! child->subshell) {
 			int squirrel[] = {-1, -1, -1};
 			int rcode;
 			debug_printf("non-subshell grouping\n");
 			setup_redirects(child, squirrel);
 			/* XXX could we merge code with following builtin case,
 			 * by creating a pseudo builtin that calls run_list_real? */
 			rcode = run_list_real(child->group);
 			restore_redirects(squirrel);
 			return rcode;
 		}
 		for (i=0; is_assignment(child->argv[i]); i++) { /* nothing */ }
 		if (i!=0 && child->argv[i]==NULL) {
 			/* assignments, but no command: set the local environment */
 			for (i=0; child->argv[i]!=NULL; i++) {
 				set_local_var(child->argv[i], 0);
 			}
 			return EXIT_SUCCESS;   /* don't worry about errors in set_local_var() yet */
 		}
 		for (x = bltins; x->cmd; x++) {
 			if (strcmp(child->argv[i], x->cmd) == 0 ) {
 				int squirrel[] = {-1, -1, -1};
 				int rcode;
 				if (x->function == builtin_exec && child->argv[i+1]==NULL) {
 					debug_printf("magic exec\n");
 					setup_redirects(child,NULL);
 					return EXIT_SUCCESS;
 				}
 				debug_printf("builtin inline %s\n", child->argv[0]);
 				/* XXX setup_redirects acts on file descriptors, not FILEs.
 				 * This is perfect for work that comes after exec().
 				 * Is it really safe for inline use?  Experimentally,
 				 * things seem to work with glibc. */
 				setup_redirects(child, squirrel);
 				for (i=0; is_assignment(child->argv[i]); i++) {
 					putenv(strdup(child->argv[i]));
 				}
 				child->argv+=i;  /* XXX horrible hack */
 				rcode = x->function(child);
 				child->argv-=i;  /* XXX restore hack so free() can work right */
 				restore_redirects(squirrel);
 				return rcode;
 			}
 		}
 	}
 
 	for (i = 0; i < pi->num_progs; i++) {
 		child = & (pi->progs[i]);
 
 		/* pipes are inserted between pairs of commands */
 		if ((i + 1) < pi->num_progs) {
 			if (pipe(pipefds)<0) perror_msg_and_die("pipe");
 			nextout = pipefds[1];
 		} else {
 			nextout=1;
 			pipefds[0] = -1;
 		}
 
 		/* XXX test for failed fork()? */
 		if (!(child->pid = fork())) {
 
 			signal(SIGTTOU, SIG_DFL);
 			
 			close_all();
 
 			if (nextin != 0) {
 				dup2(nextin, 0);
 				close(nextin);
 			}
 			if (nextout != 1) {
 				dup2(nextout, 1);
 				close(nextout);
 			}
 			if (pipefds[0]!=-1) {
 				close(pipefds[0]);  /* opposite end of our output pipe */
 			}
 
 			/* Like bash, explicit redirects override pipes,
 			 * and the pipe fd is available for dup'ing. */
 			setup_redirects(child,NULL);
 			
 			if (interactive && pi->followup!=PIPE_BG) {
 				/* If we (the child) win the race, put ourselves in the process
 				 * group whose leader is the first process in this pipe. */
 				if (pi->pgrp < 0) {
 					pi->pgrp = getpid();
 				}
 				if (setpgid(0, pi->pgrp) == 0) {
 					signal(SIGTTOU, SIG_IGN);
 					tcsetpgrp(ctty, pi->pgrp);
 					signal(SIGTTOU, SIG_DFL);
 				}
 			}
 
 			pseudo_exec(child);
 		}
 		/* Put our child in the process group whose leader is the
 		 * first process in this pipe. */
 		if (pi->pgrp < 0) {
 			pi->pgrp = child->pid;
 		}
 		/* Don't check for errors.  The child may be dead already,
 		 * in which case setpgid returns error code EACCES. */
 		setpgid(child->pid, pi->pgrp);
 
 		if (nextin != 0)
 			close(nextin);
 		if (nextout != 1)
 			close(nextout);
 
 		/* If there isn't another process, nextin is garbage 
 		   but it doesn't matter */
 		nextin = pipefds[0];
 	}
 	return -1;
 }
 
 static int run_list_real(struct pipe *pi)
 {
 	int rcode=0;
 	int if_code=0, next_if_code=0;  /* need double-buffer to handle elif */
 	reserved_style rmode, skip_more_in_this_rmode=RES_XXXX;
 	for (;pi;pi=pi->next) {
 		rmode = pi->r_mode;
 		debug_printf("rmode=%d  if_code=%d  next_if_code=%d skip_more=%d\n", rmode, if_code, next_if_code, skip_more_in_this_rmode);
 		if (rmode == skip_more_in_this_rmode) continue;
 		skip_more_in_this_rmode = RES_XXXX;
 		if (rmode == RES_THEN || rmode == RES_ELSE) if_code = next_if_code;
 		if (rmode == RES_THEN &&  if_code) continue;
 		if (rmode == RES_ELSE && !if_code) continue;
 		if (rmode == RES_ELIF && !if_code) continue;
 		if (pi->num_progs == 0) continue;
 		rcode = run_pipe_real(pi);
 		if (rcode!=-1) {
 			/* We only ran a builtin: rcode was set by the return value
 			 * of run_pipe_real(), and we don't need to wait for anything. */
 		} else if (pi->followup==PIPE_BG) {
 			/* XXX check bash's behavior with nontrivial pipes */
 			/* XXX compute jobid */
 			/* XXX what does bash do with attempts to background builtins? */
 			insert_bg_job(pi);
 			rcode = EXIT_SUCCESS;
 		} else {
 
 			if (interactive) {
 				/* move the new process group into the foreground */
 				/* suppress messages when run from /linuxrc mag@sysgo.de */
 				/* XXX probably this "0" should come from controlling_tty() */
 				if (tcsetpgrp(0, pi->pgrp) && errno != ENOTTY)
 					perror_msg("tcsetpgrp-3");
 				rcode = pipe_wait(pi);
 				if (tcsetpgrp(0, getpgrp()) && errno != ENOTTY)
 					perror_msg("tcsetpgrp-4");
 			} else {
 				rcode = pipe_wait(pi);
 				debug_printf("pipe_wait returned %d\n",rcode);
 			}
 		}
 		last_return_code=rcode;
 		if ( rmode == RES_IF || rmode == RES_ELIF )
 			next_if_code=rcode;  /* can be overwritten a number of times */
 		if ( (rcode==EXIT_SUCCESS && pi->followup==PIPE_OR) ||
 		     (rcode!=EXIT_SUCCESS && pi->followup==PIPE_AND) )
 			skip_more_in_this_rmode=rmode;
 	}
 	checkjobs();
 	return rcode;
 }
 
 /* broken, of course, but OK for testing */
 static char *indenter(int i)
 {
 	static char blanks[]="                                    ";
 	return &blanks[sizeof(blanks)-i-1];
 }
 
 /* return code is the exit status of the pipe */
 static int run_pipe_test(struct pipe *pi, int indent)
 {
 	char **p;
 	struct child_prog *child;
 	struct redir_struct *r, *rnext;
 	int a, i, ret_code=0;
 	char *ind = indenter(indent);
 	final_printf("%s run pipe: (pid %d)\n",ind,getpid());
 	for (i=0; i<pi->num_progs; i++) {
 		child = &pi->progs[i];
 		final_printf("%s  command %d:\n",ind,i);
 		if (child->argv) {
 			for (a=0,p=child->argv; *p; a++,p++) {
 				final_printf("%s   argv[%d] = %s\n",ind,a,*p);
 			}
 			globfree(&child->glob_result);
 			child->argv=NULL;
 		} else if (child->group) {
 			final_printf("%s   begin group (subshell:%d)\n",ind, child->subshell);
 			ret_code = run_list_test(child->group,indent+3);
 			final_printf("%s   end group\n",ind);
 		} else {
 			final_printf("%s   (nil)\n",ind);
 		}
 		for (r=child->redirects; r; r=rnext) {
 			final_printf("%s   redirect %d%s", ind, r->fd, redir_table[r->type].descrip);
 			if (r->dup == -1) {
 				final_printf(" %s\n", *r->word.gl_pathv);
 				globfree(&r->word);
 			} else {
 				final_printf("&%d\n", r->dup);
 			}
 			rnext=r->next;
 			free(r);
 		}
 		child->redirects=NULL;
 	}
 	free(pi->progs);   /* children are an array, they get freed all at once */
 	pi->progs=NULL;
 	return ret_code;
 }
 
 static int run_list_test(struct pipe *head, int indent)
 {
 	int rcode=0;   /* if list has no members */
 	struct pipe *pi, *next;
 	char *ind = indenter(indent);
 	for (pi=head; pi; pi=next) {
 		if (pi->num_progs == 0) break;
 		final_printf("%s pipe reserved mode %d\n", ind, pi->r_mode);
 		rcode = run_pipe_test(pi, indent);
 		final_printf("%s pipe followup code %d\n", ind, pi->followup);
 		next=pi->next;
 		pi->next=NULL;
 		free(pi);
 	}
 	return rcode;	
 }
 
 /* Select which version we will use */
 static int run_list(struct pipe *pi)
 {
 	int rcode=0;
 	if (fake_mode==0) {
 		rcode = run_list_real(pi);
 	} 
 	/* run_list_test has the side effect of clearing memory
 	 * In the long run that function can be merged with run_list_real,
 	 * but doing that now would hobble the debugging effort. */
 	run_list_test(pi,0);
 	return rcode;
 }
 
 /* The API for glob is arguably broken.  This routine pushes a non-matching
  * string into the output structure, removing non-backslashed backslashes.
  * If someone can prove me wrong, by performing this function within the
  * original glob(3) api, feel free to rewrite this routine into oblivion.
  * Return code (0 vs. GLOB_NOSPACE) matches glob(3).
  * XXX broken if the last character is '\\', check that before calling.
  */
 static int globhack(const char *src, int flags, glob_t *pglob)
 {
 	int cnt, pathc;
 	const char *s;
 	char *dest;
 	for (cnt=1, s=src; *s; s++) {
 		if (*s == '\\') s++;
 		cnt++;
 	}
 	dest = malloc(cnt);
 	if (!dest) return GLOB_NOSPACE;
 	if (!(flags & GLOB_APPEND)) {
 		pglob->gl_pathv=NULL;
 		pglob->gl_pathc=0;
 		pglob->gl_offs=0;
 		pglob->gl_offs=0;
 	}
 	pathc = ++pglob->gl_pathc;
 	pglob->gl_pathv = realloc(pglob->gl_pathv, (pathc+1)*sizeof(*pglob->gl_pathv));
 	if (pglob->gl_pathv == NULL) return GLOB_NOSPACE;
 	pglob->gl_pathv[pathc-1]=dest;
 	pglob->gl_pathv[pathc]=NULL;
 	for (s=src; *s; s++, dest++) {
 		if (*s == '\\') s++;
 		*dest = *s;
 	}
 	*dest='\0';
 	return 0;
 }
 
 /* XXX broken if the last character is '\\', check that before calling */
 static int glob_needed(const char *s)
 {
 	for (; *s; s++) {
 		if (*s == '\\') s++;
 		if (strchr("*[?",*s)) return 1;
 	}
 	return 0;
 }
 
 #if 0
 static void globprint(glob_t *pglob)
 {
 	int i;
 	debug_printf("glob_t at %p:\n", pglob);
 	debug_printf("  gl_pathc=%d  gl_pathv=%p  gl_offs=%d  gl_flags=%d\n",
 		pglob->gl_pathc, pglob->gl_pathv, pglob->gl_offs, pglob->gl_flags);
 	for (i=0; i<pglob->gl_pathc; i++)
 		debug_printf("pglob->gl_pathv[%d] = %p = %s\n", i,
 			pglob->gl_pathv[i], pglob->gl_pathv[i]);
 }
 #endif
 
 static int xglob(o_string *dest, int flags, glob_t *pglob)
 {
 	int gr;
 
  	/* short-circuit for null word */
 	/* we can code this better when the debug_printf's are gone */
  	if (dest->length == 0) {
  		if (dest->nonnull) {
  			/* bash man page calls this an "explicit" null */
  			gr = globhack(dest->data, flags, pglob);
  			debug_printf("globhack returned %d\n",gr);
  		} else {
 			return 0;
 		}
  	} else if (glob_needed(dest->data)) {
 		gr = glob(dest->data, flags, NULL, pglob);
 		debug_printf("glob returned %d\n",gr);
 		if (gr == GLOB_NOMATCH) {
 			/* quote removal, or more accurately, backslash removal */
 			gr = globhack(dest->data, flags, pglob);
 			debug_printf("globhack returned %d\n",gr);
 		}
 	} else {
 		gr = globhack(dest->data, flags, pglob);
 		debug_printf("globhack returned %d\n",gr);
 	}
 	if (gr == GLOB_NOSPACE)
 		error_msg_and_die("out of memory during glob");
 	if (gr != 0) { /* GLOB_ABORTED ? */
 		error_msg("glob(3) error %d",gr);
 	}
 	/* globprint(glob_target); */
 	return gr;
 }
 
 /* This is used to get/check local shell variables */
 static char *get_local_var(const char *s)
 {
 	struct variables *cur;
 
 	if (!s)
 		return NULL;
 	for (cur = top_vars; cur; cur=cur->next)
 		if(strcmp(cur->name, s)==0)
 			return cur->value;
 	return NULL;
 }
 
 /* This is used to set local shell variables
    flg_export==0 if only local (not exporting) variable
    flg_export==1 if "new" exporting environ
    flg_export>1  if current startup environ (not call putenv()) */
 static int set_local_var(const char *s, int flg_export)
 {
 	char *name, *value;
 	int result=0;
 	struct variables *cur;
 	char *newval = 0;
 
 	name=strdup(s);
 
 	/* Assume when we enter this function that we are already in
 	 * NAME=VALUE format.  So the first order of business is to
 	 * split 's' on the '=' into 'name' and 'value' */ 
 	value = strchr(name, '=');
 	if (value==0 || (newval = strdup(value+1))==0) {
 		result = -1;
 	} else {
 		*value++ = 0;
 
 		for(cur = top_vars; cur; cur = cur->next)
 			if(strcmp(cur->name, name)==0)
 			break;
 
 		if(cur) {
 			if(strcmp(cur->value, value)==0) {
 				result = cur->flg_export == flg_export;
 			} else {
 				if(cur->flg_read_only) {
 			result = -1;
 					error_msg("%s: readonly variable", name);
 				} else {
 					free(cur->value);
 					cur->value = newval;
 					newval = 0; /* protect free */
 		}
 	}
 		} else {
 			cur = malloc(sizeof(struct variables));
 			if(cur==0) {
 				result = -1;
 			} else {
 				cur->name = strdup(name);
 				if(cur->name == 0) {
 					free(cur);
 				result = -1;
 				} else {
 					struct variables *bottom = top_vars;
 
 					cur->value = newval;
 					newval = 0;     /* protect free */
 					cur->next = 0;
 					cur->flg_export = flg_export;
 					cur->flg_read_only = 0;
 					while(bottom->next) bottom=bottom->next;
 					bottom->next = cur;
 			}
 		}
 	}
 	}
 
 	if((result==0 && flg_export==1) || (result>0 && cur->flg_export>0)) {
 		*(value-1) = '=';
 		result = putenv(name);
 	} else {
 	free(name);
 		if(result>0)            /* equivalent to previous set */
 			result = 0;
 	}
 	free(newval);
 	return result;
 }
 
 static void unset_local_var(const char *name)
 {
 	struct variables *cur;
 
 	if (name) {
 		for (cur = top_vars; cur; cur=cur->next)
 			if(strcmp(cur->name, name)==0)
 				break;
 		if(cur!=0) {
 			struct variables *next = top_vars;
 			if(cur==next)
 		return;
 			else {
 				if(cur->flg_export)
 					unsetenv(cur->name);
 				free(cur->name);
 				free(cur->value);
 				while (next->next != cur)
 					next = next->next;
 				next->next = cur->next;
 			}
 			free(cur);
 		}
 	}
 }
 
 static int is_assignment(const char *s)
 {
 	if (s==NULL || !isalpha(*s)) return 0;
 	++s;
 	while(isalnum(*s) || *s=='_') ++s;
 	return *s=='=';
 }
 
 /* the src parameter allows us to peek forward to a possible &n syntax
  * for file descriptor duplication, e.g., "2>&1".
  * Return code is 0 normally, 1 if a syntax error is detected in src.
  * Resource errors (in xmalloc) cause the process to exit */
 static int setup_redirect(struct p_context *ctx, int fd, redir_type style,
 	struct in_str *input)
 {
 	struct child_prog *child=ctx->child;
 	struct redir_struct *redir = child->redirects;
 	struct redir_struct *last_redir=NULL;
 
 	/* Create a new redir_struct and drop it onto the end of the linked list */
 	while(redir) {
 		last_redir=redir;
 		redir=redir->next;
 	}
 	redir = xmalloc(sizeof(struct redir_struct));
 	redir->next=NULL;
 	if (last_redir) {
 		last_redir->next=redir;
 	} else {
 		child->redirects=redir;
 	}
 
 	redir->type=style;
 	redir->fd= (fd==-1) ? redir_table[style].default_fd : fd ;
 
 	debug_printf("Redirect type %d%s\n", redir->fd, redir_table[style].descrip);
 
 	/* Check for a '2>&1' type redirect */ 
 	redir->dup = redirect_dup_num(input);
 	if (redir->dup == -2) return 1;  /* syntax error */
 	if (redir->dup != -1) {
 		/* Erik had a check here that the file descriptor in question
 		 * is legit; I postpone that to "run time"
 		 * A "-" representation of "close me" shows up as a -3 here */
 		debug_printf("Duplicating redirect '%d>&%d'\n", redir->fd, redir->dup);
 	} else {
 		/* We do _not_ try to open the file that src points to,
 		 * since we need to return and let src be expanded first.
 		 * Set ctx->pending_redirect, so we know what to do at the
 		 * end of the next parsed word.
 		 */
 		ctx->pending_redirect = redir;
 	}
 	return 0;
 }
 
 struct pipe *new_pipe(void) {
 	struct pipe *pi;
 	pi = xmalloc(sizeof(struct pipe));
 	pi->num_progs = 0;
 	pi->progs = NULL;
 	pi->next = NULL;
 	pi->followup = 0;  /* invalid */
 	return pi;
 }
 
 static void initialize_context(struct p_context *ctx)
 {
 	ctx->pipe=NULL;
 	ctx->pending_redirect=NULL;
 	ctx->child=NULL;
 	ctx->list_head=new_pipe();
 	ctx->pipe=ctx->list_head;
 	ctx->w=RES_NONE;
 	ctx->stack=NULL;
 	done_command(ctx);   /* creates the memory for working child */
 }
 
 /* normal return is 0
  * if a reserved word is found, and processed, return 1
  * should handle if, then, elif, else, fi, for, while, until, do, done.
  * case, function, and select are obnoxious, save those for later.
  */
 int reserved_word(o_string *dest, struct p_context *ctx)
 {
 	struct reserved_combo {
 		char *literal;
 		int code;
 		long flag;
 	};
 	/* Mostly a list of accepted follow-up reserved words.
 	 * FLAG_END means we are done with the sequence, and are ready
 	 * to turn the compound list into a command.
 	 * FLAG_START means the word must start a new compound list.
 	 */
 	static struct reserved_combo reserved_list[] = {
 		{ "if",    RES_IF,    FLAG_THEN | FLAG_START },
 		{ "then",  RES_THEN,  FLAG_ELIF | FLAG_ELSE | FLAG_FI },
 		{ "elif",  RES_ELIF,  FLAG_THEN },
 		{ "else",  RES_ELSE,  FLAG_FI   },
 		{ "fi",    RES_FI,    FLAG_END  },
 		{ "for",   RES_FOR,   FLAG_DO   | FLAG_START },
 		{ "while", RES_WHILE, FLAG_DO   | FLAG_START },
 		{ "until", RES_UNTIL, FLAG_DO   | FLAG_START },
 		{ "do",    RES_DO,    FLAG_DONE },
 		{ "done",  RES_DONE,  FLAG_END  }
 	};
 	struct reserved_combo *r;
 	for (r=reserved_list;
 #define NRES sizeof(reserved_list)/sizeof(struct reserved_combo)
 		r<reserved_list+NRES; r++) {
 		if (strcmp(dest->data, r->literal) == 0) {
 			debug_printf("found reserved word %s, code %d\n",r->literal,r->code);
 			if (r->flag & FLAG_START) {
 				struct p_context *new = xmalloc(sizeof(struct p_context));
 				debug_printf("push stack\n");
 				*new = *ctx;   /* physical copy */
 				initialize_context(ctx);
 				ctx->stack=new;
 			} else if ( ctx->w == RES_NONE || ! (ctx->old_flag & (1<<r->code))) {
 				syntax();
 				ctx->w = RES_SNTX;
 				b_reset (dest);
 				return 1;
 			}
 			ctx->w=r->code;
 			ctx->old_flag = r->flag;
 			if (ctx->old_flag & FLAG_END) {
 				struct p_context *old;
 				debug_printf("pop stack\n");
 				old = ctx->stack;
 				old->child->group = ctx->list_head;
 				*ctx = *old;   /* physical copy */
 				free(old);
 			}
 			b_reset (dest);
 			return 1;
 		}
 	}
 	return 0;
 }
 
 /* normal return is 0.
  * Syntax or xglob errors return 1. */
 static int done_word(o_string *dest, struct p_context *ctx)
 {
 	struct child_prog *child=ctx->child;
 	glob_t *glob_target;
 	int gr, flags = 0;
 
 	debug_printf("done_word: %s %p\n", dest->data, child);
 	if (dest->length == 0 && !dest->nonnull) {
 		debug_printf("  true null, ignored\n");
 		return 0;
 	}
 	if (ctx->pending_redirect) {
 		glob_target = &ctx->pending_redirect->word;
 	} else {
 		if (child->group) {
 			syntax();
 			return 1;  /* syntax error, groups and arglists don't mix */
 		}
 		if (!child->argv) {
 			debug_printf("checking %s for reserved-ness\n",dest->data);
 			if (reserved_word(dest,ctx)) return ctx->w==RES_SNTX;
 		}
 		glob_target = &child->glob_result;
  		if (child->argv) flags |= GLOB_APPEND;
 	}
 	gr = xglob(dest, flags, glob_target);
 	if (gr != 0) return 1;
 
 	b_reset(dest);
 	if (ctx->pending_redirect) {
 		ctx->pending_redirect=NULL;
 		if (glob_target->gl_pathc != 1) {
 			error_msg("ambiguous redirect");
 			return 1;
 		}
 	} else {
 		child->argv = glob_target->gl_pathv;
 	}
 	return 0;
 }
 
 /* The only possible error here is out of memory, in which case
  * xmalloc exits. */
 static int done_command(struct p_context *ctx)
 {
 	/* The child is really already in the pipe structure, so
 	 * advance the pipe counter and make a new, null child.
 	 * Only real trickiness here is that the uncommitted
 	 * child structure, to which ctx->child points, is not
 	 * counted in pi->num_progs. */
 	struct pipe *pi=ctx->pipe;
 	struct child_prog *prog=ctx->child;
 
 	if (prog && prog->group == NULL
 	         && prog->argv == NULL
 	         && prog->redirects == NULL) {
 		debug_printf("done_command: skipping null command\n");
 		return 0;
 	} else if (prog) {
 		pi->num_progs++;
 		debug_printf("done_command: num_progs incremented to %d\n",pi->num_progs);
 	} else {
 		debug_printf("done_command: initializing\n");
 	}
 	pi->progs = xrealloc(pi->progs, sizeof(*pi->progs) * (pi->num_progs+1));
 
 	prog = pi->progs + pi->num_progs;
 	prog->redirects = NULL;
 	prog->argv = NULL;
 	prog->is_stopped = 0;
 	prog->group = NULL;
 	prog->glob_result.gl_pathv = NULL;
 	prog->family = pi;
 
 	ctx->child=prog;
 	/* but ctx->pipe and ctx->list_head remain unchanged */
 	return 0;
 }
 
 static int done_pipe(struct p_context *ctx, pipe_style type)
 {
 	struct pipe *new_p;
 	done_command(ctx);  /* implicit closure of previous command */
 	debug_printf("done_pipe, type %d\n", type);
 	ctx->pipe->followup = type;
 	ctx->pipe->r_mode = ctx->w;
 	new_p=new_pipe();
 	ctx->pipe->next = new_p;
 	ctx->pipe = new_p;
 	ctx->child = NULL;
 	done_command(ctx);  /* set up new pipe to accept commands */
 	return 0;
 }
 
 /* peek ahead in the in_str to find out if we have a "&n" construct,
  * as in "2>&1", that represents duplicating a file descriptor.
  * returns either -2 (syntax error), -1 (no &), or the number found.
  */
 static int redirect_dup_num(struct in_str *input)
 {
 	int ch, d=0, ok=0;
 	ch = b_peek(input);
 	if (ch != '&') return -1;
 
 	b_getch(input);  /* get the & */
 	ch=b_peek(input);
 	if (ch == '-') {
 		b_getch(input);
 		return -3;  /* "-" represents "close me" */
 	}
 	while (isdigit(ch)) {
 		d = d*10+(ch-'0');
 		ok=1;
 		b_getch(input);
 		ch = b_peek(input);
 	}
 	if (ok) return d;
 
 	error_msg("ambiguous redirect");
 	return -2;
 }
 
 /* If a redirect is immediately preceded by a number, that number is
  * supposed to tell which file descriptor to redirect.  This routine
  * looks for such preceding numbers.  In an ideal world this routine
  * needs to handle all the following classes of redirects...
  *     echo 2>foo     # redirects fd  2 to file "foo", nothing passed to echo
  *     echo 49>foo    # redirects fd 49 to file "foo", nothing passed to echo
  *     echo -2>foo    # redirects fd  1 to file "foo",    "-2" passed to echo
  *     echo 49x>foo   # redirects fd  1 to file "foo",   "49x" passed to echo
  * A -1 output from this program means no valid number was found, so the
  * caller should use the appropriate default for this redirection.
  */
 static int redirect_opt_num(o_string *o)
 {
 	int num;
 
 	if (o->length==0) return -1;
 	for(num=0; num<o->length; num++) {
 		if (!isdigit(*(o->data+num))) {
 			return -1;
 		}
 	}
 	/* reuse num (and save an int) */
 	num=atoi(o->data);
 	b_reset(o);
 	return num;
 }
 
 FILE *generate_stream_from_list(struct pipe *head)
 {
 	FILE *pf;
 #if 1
 	int pid, channel[2];
 	if (pipe(channel)<0) perror_msg_and_die("pipe");
 	pid=fork();
 	if (pid<0) {
 		perror_msg_and_die("fork");
 	} else if (pid==0) {
 		close(channel[0]);
 		if (channel[1] != 1) {
 			dup2(channel[1],1);
 			close(channel[1]);
 		}
 #if 0
 #define SURROGATE "surrogate response"
 		write(1,SURROGATE,sizeof(SURROGATE));
 		exit(run_list(head));
 #else
 		exit(run_list_real(head));   /* leaks memory */
 #endif
 	}
 	debug_printf("forked child %d\n",pid);
 	close(channel[1]);
 	pf = fdopen(channel[0],"r");
 	debug_printf("pipe on FILE *%p\n",pf);
 #else
 	run_list_test(head,0);
 	pf=popen("echo surrogate response","r");
 	debug_printf("started fake pipe on FILE *%p\n",pf);
 #endif
 	return pf;
 }
 
 /* this version hacked for testing purposes */
 /* return code is exit status of the process that is run. */
 static int process_command_subs(o_string *dest, struct p_context *ctx, struct in_str *input, int subst_end)
 {
 	int retcode;
 	o_string result=NULL_O_STRING;
 	struct p_context inner;
 	FILE *p;
 	struct in_str pipe_str;
 	initialize_context(&inner);
 
 	/* recursion to generate command */
 	retcode = parse_stream(&result, &inner, input, subst_end);
 	if (retcode != 0) return retcode;  /* syntax error or EOF */
 	done_word(&result, &inner);
 	done_pipe(&inner, PIPE_SEQ);
 	b_free(&result);
 
 	p=generate_stream_from_list(inner.list_head);
 	if (p==NULL) return 1;
 	mark_open(fileno(p));
 	setup_file_in_str(&pipe_str, p);
 
 	/* now send results of command back into original context */
 	retcode = parse_stream(dest, ctx, &pipe_str, '\0');
 	/* XXX In case of a syntax error, should we try to kill the child?
 	 * That would be tough to do right, so just read until EOF. */
 	if (retcode == 1) {
 		while (b_getch(&pipe_str)!=EOF) { /* discard */ };
 	}
 
 	debug_printf("done reading from pipe, pclose()ing\n");
 	/* This is the step that wait()s for the child.  Should be pretty
 	 * safe, since we just read an EOF from its stdout.  We could try
 	 * to better, by using wait(), and keeping track of background jobs
 	 * at the same time.  That would be a lot of work, and contrary
 	 * to the KISS philosophy of this program. */
 	mark_closed(fileno(p));
 	retcode=pclose(p);
 	debug_printf("pclosed, retcode=%d\n",retcode);
 	/* XXX this process fails to trim a single trailing newline */
 	return retcode;
 }
 
 static int parse_group(o_string *dest, struct p_context *ctx,
 	struct in_str *input, int ch)
 {
 	int rcode, endch=0;
 	struct p_context sub;
 	struct child_prog *child = ctx->child;
 	if (child->argv) {
 		syntax();
 		return 1;  /* syntax error, groups and arglists don't mix */
 	}
 	initialize_context(&sub);
 	switch(ch) {
 		case '(': endch=')'; child->subshell=1; break;
 		case '{': endch='}'; break;
 		default: syntax();   /* really logic error */
 	}
 	rcode=parse_stream(dest,&sub,input,endch);
 	done_word(dest,&sub); /* finish off the final word in the subcontext */
 	done_pipe(&sub, PIPE_SEQ);  /* and the final command there, too */
 	child->group = sub.list_head;
 	return rcode;
 	/* child remains "open", available for possible redirects */
 }
 
 /* basically useful version until someone wants to get fancier,
  * see the bash man page under "Parameter Expansion" */
 static void lookup_param(o_string *dest, struct p_context *ctx, o_string *src)
 {
 	const char *p=NULL;
 	if (src->data) { 
 		p = getenv(src->data);
 		if (!p) 
 			p = get_local_var(src->data);
 	}
 	if (p) parse_string(dest, ctx, p);   /* recursion */
 	b_free(src);
 }
 
 /* return code: 0 for OK, 1 for syntax error */
 static int handle_dollar(o_string *dest, struct p_context *ctx, struct in_str *input)
 {
 	int i, advance=0;
 	o_string alt=NULL_O_STRING;
 	char sep[]=" ";
 	int ch = input->peek(input);  /* first character after the $ */
 	debug_printf("handle_dollar: ch=%c\n",ch);
 	if (isalpha(ch)) {
 		while(ch=b_peek(input),isalnum(ch) || ch=='_') {
 			b_getch(input);
 			b_addchr(&alt,ch);
 		}
 		lookup_param(dest, ctx, &alt);
 	} else if (isdigit(ch)) {
 		i = ch-'0';  /* XXX is $0 special? */
 		if (i<global_argc) {
 			parse_string(dest, ctx, global_argv[i]); /* recursion */
 		}
 		advance = 1;
 	} else switch (ch) {
 		case '$':
 			b_adduint(dest,getpid());
 			advance = 1;
 			break;
 		case '!':
 			if (last_bg_pid > 0) b_adduint(dest, last_bg_pid);
 			advance = 1;
 			break;
 		case '?':
 			b_adduint(dest,last_return_code);
 			advance = 1;
 			break;
 		case '#':
 			b_adduint(dest,global_argc ? global_argc-1 : 0);
 			advance = 1;
 			break;
 		case '{':
 			b_getch(input);
 			/* XXX maybe someone will try to escape the '}' */
 			while(ch=b_getch(input),ch!=EOF && ch!='}') {
 				b_addchr(&alt,ch);
 			}
 			if (ch != '}') {
 				syntax();
 				return 1;
 			}
 			lookup_param(dest, ctx, &alt);
 			break;
 		case '(':
 			b_getch(input);
 			process_command_subs(dest, ctx, input, ')');
 			break;
 		case '*':
 			sep[0]=ifs[0];
 			for (i=1; i<global_argc; i++) {
 				parse_string(dest, ctx, global_argv[i]);
 				if (i+1 < global_argc) parse_string(dest, ctx, sep);
 			}
 			break;
 		case '@':
 		case '-':
 		case '_':
 			/* still unhandled, but should be eventually */
 			error_msg("unhandled syntax: $%c",ch);
 			return 1;
 			break;
 		default:
 			b_addqchr(dest,'$',dest->quote);
 	}
 	/* Eat the character if the flag was set.  If the compiler
 	 * is smart enough, we could substitute "b_getch(input);"
 	 * for all the "advance = 1;" above, and also end up with
 	 * a nice size-optimized program.  Hah!  That'll be the day.
 	 */
 	if (advance) b_getch(input);
 	return 0;
 }
 
 int parse_string(o_string *dest, struct p_context *ctx, const char *src)
 {
 	struct in_str foo;
 	setup_string_in_str(&foo, src);
 	return parse_stream(dest, ctx, &foo, '\0');
 }
 
 /* return code is 0 for normal exit, 1 for syntax error */
 int parse_stream(o_string *dest, struct p_context *ctx,
 	struct in_str *input, int end_trigger)
 {
 	unsigned int ch, m;
 	int redir_fd;
 	redir_type redir_style;
 	int next;
 
 	/* Only double-quote state is handled in the state variable dest->quote.
 	 * A single-quote triggers a bypass of the main loop until its mate is
 	 * found.  When recursing, quote state is passed in via dest->quote. */
 
 	debug_printf("parse_stream, end_trigger=%d\n",end_trigger);
 	while ((ch=b_getch(input))!=EOF) {
 		m = map[ch];
 		next = (ch == '\n') ? 0 : b_peek(input);
 		debug_printf("parse_stream: ch=%c (%d) m=%d quote=%d\n",
 			ch,ch,m,dest->quote);
 		if (m==0 || ((m==1 || m==2) && dest->quote)) {
 			b_addqchr(dest, ch, dest->quote);
 		} else {
 			if (m==2) {  /* unquoted IFS */
 				done_word(dest, ctx);
 				/* If we aren't performing a substitution, treat a newline as a
 				 * command separator.  */
 				if (end_trigger != '\0' && ch=='\n')
 					done_pipe(ctx,PIPE_SEQ);
 			}
 			if (ch == end_trigger && !dest->quote && ctx->w==RES_NONE) {
 				debug_printf("leaving parse_stream\n");
 				return 0;
 			}
 #if 0
 			if (ch=='\n') {
 				/* Yahoo!  Time to run with it! */
 				done_pipe(ctx,PIPE_SEQ);
 				run_list(ctx->list_head);
 				initialize_context(ctx);
 			}
 #endif
 			if (m!=2) switch (ch) {
 		case '#':
 			if (dest->length == 0 && !dest->quote) {
 				while(ch=b_peek(input),ch!=EOF && ch!='\n') { b_getch(input); }
 			} else {
 				b_addqchr(dest, ch, dest->quote);
 			}
 			break;
 		case '\\':
 			if (next == EOF) {
 				syntax();
 				return 1;
 			}
 			b_addqchr(dest, '\\', dest->quote);
 			b_addqchr(dest, b_getch(input), dest->quote);
 			break;
 		case '$':
 			if (handle_dollar(dest, ctx, input)!=0) return 1;
 			break;
 		case '\'':
 			dest->nonnull = 1;
 			while(ch=b_getch(input),ch!=EOF && ch!='\'') {
 				b_addchr(dest,ch);
 			}
 			if (ch==EOF) {
 				syntax();
 				return 1;
 			}
 			break;
 		case '"':
 			dest->nonnull = 1;
 			dest->quote = !dest->quote;
 			break;
 		case '`':
 			process_command_subs(dest, ctx, input, '`');
 			break;
 		case '>':
 			redir_fd = redirect_opt_num(dest);
 			done_word(dest, ctx);
 			redir_style=REDIRECT_OVERWRITE;
 			if (next == '>') {
 				redir_style=REDIRECT_APPEND;
 				b_getch(input);
 			} else if (next == '(') {
 				syntax();   /* until we support >(list) Process Substitution */
 				return 1;
 			}
 			setup_redirect(ctx, redir_fd, redir_style, input);
 			break;
 		case '<':
 			redir_fd = redirect_opt_num(dest);
 			done_word(dest, ctx);
 			redir_style=REDIRECT_INPUT;
 			if (next == '<') {
 				redir_style=REDIRECT_HEREIS;
 				b_getch(input);
 			} else if (next == '>') {
 				redir_style=REDIRECT_IO;
 				b_getch(input);
 			} else if (next == '(') {
 				syntax();   /* until we support <(list) Process Substitution */
 				return 1;
 			}
 			setup_redirect(ctx, redir_fd, redir_style, input);
 			break;
 		case ';':
 			done_word(dest, ctx);
 			done_pipe(ctx,PIPE_SEQ);
 			break;
 		case '&':
 			done_word(dest, ctx);
 			if (next=='&') {
 				b_getch(input);
 				done_pipe(ctx,PIPE_AND);
 			} else {
 				done_pipe(ctx,PIPE_BG);
 			}
 			break;
 		case '|':
 			done_word(dest, ctx);
 			if (next=='|') {
 				b_getch(input);
 				done_pipe(ctx,PIPE_OR);
 			} else {
 				/* we could pick up a file descriptor choice here
 				 * with redirect_opt_num(), but bash doesn't do it.
 				 * "echo foo 2| cat" yields "foo 2". */
 				done_command(ctx);
 			}
 			break;
 		case '(':
 		case '{':
 			if (parse_group(dest, ctx, input, ch)!=0) return 1;
 			break;
 		case ')':
 		case '}':
 			syntax();   /* Proper use of this character caught by end_trigger */
 			return 1;
 			break;
 		default:
 			syntax();   /* this is really an internal logic error */
 			return 1;
 			}
 		}
 	}
 	/* complain if quote?  No, maybe we just finished a command substitution
 	 * that was quoted.  Example:
 	 * $ echo "`cat foo` plus more" 
 	 * and we just got the EOF generated by the subshell that ran "cat foo"
 	 * The only real complaint is if we got an EOF when end_trigger != '\0',
 	 * that is, we were really supposed to get end_trigger, and never got
 	 * one before the EOF.  Can't use the standard "syntax error" return code,
 	 * so that parse_stream_outer can distinguish the EOF and exit smoothly. */
 	if (end_trigger != '\0') return -1;
 	return 0;
 }
 
 void mapset(const unsigned char *set, int code)
 {
 	const unsigned char *s;
 	for (s=set; *s; s++) map[*s] = code;
 }
 
 void update_ifs_map(void)
 {
 	/* char *ifs and char map[256] are both globals. */
 	ifs = getenv("IFS");
 	if (ifs == NULL) ifs=" \t\n";
 	/* Precompute a list of 'flow through' behavior so it can be treated
 	 * quickly up front.  Computation is necessary because of IFS.
 	 * Special case handling of IFS == " \t\n" is not implemented.
 	 * The map[] array only really needs two bits each, and on most machines
 	 * that would be faster because of the reduced L1 cache footprint.
 	 */
 	memset(map,0,256);        /* most characters flow through always */
 	mapset("\\$'\"`", 3);     /* never flow through */
 	mapset("<>;&|(){}#", 1);  /* flow through if quoted */
 	mapset(ifs, 2);           /* also flow through if quoted */
 }
 
 /* most recursion does not come through here, the exeception is
  * from builtin_source() */
 int parse_stream_outer(struct in_str *inp)
 {
 
 	struct p_context ctx;
 	o_string temp=NULL_O_STRING;
 	int rcode;
 	do {
 		initialize_context(&ctx);
 		update_ifs_map();
 		inp->promptmode=1;
 		rcode = parse_stream(&temp, &ctx, inp, '\n');
 		done_word(&temp, &ctx);
 		done_pipe(&ctx,PIPE_SEQ);
 		run_list(ctx.list_head);
 	} while (rcode != -1);   /* loop on syntax errors, return on EOF */
 	return 0;
 }
 
 static int parse_string_outer(const char *s)
 {
 	struct in_str input;
 	setup_string_in_str(&input, s);
 	return parse_stream_outer(&input);
 }
 
 static int parse_file_outer(FILE *f)
 {
 	int rcode;
 	struct in_str input;
 	setup_file_in_str(&input, f);
 	rcode = parse_stream_outer(&input);
 	return rcode;
 }
 
 
 /* I think Erik wrote this.  It looks imperfect at best */
 void grab_tty_control(void)
 {
 	pid_t initialpgrp;
 	do {
 		initialpgrp = tcgetpgrp(fileno(stderr));
 		if (initialpgrp < 0) {
 			error_msg("sh: can't access tty; job control disabled\n");
 		}
 		if (initialpgrp == -1)
 			initialpgrp = getpgrp();
 		else if (initialpgrp != getpgrp()) {
 			killpg(initialpgrp, SIGTTIN);
 			continue;
 		}
 	} while (0);
 }
 
 int shell_main(int argc, char **argv)
 {
 	int opt;
 	FILE *input;
 	struct jobset joblist_end = { NULL, NULL };
 	char **e = environ;
 
 	/* initialize globals */
 	if (e) {
 		for (; *e; e++)
 			set_local_var(*e, 2);   /* without call putenv() */
 	}
 	job_list = &joblist_end;
 
 	last_return_code=EXIT_SUCCESS;
 
 	/* XXX what should these be while sourcing /etc/profile? */
 	global_argc = argc;
 	global_argv = argv;
 
 	/* If we get started under a job aware app (like bash 
 	 * for example), make sure we are now in charge so we 
 	 * don't fight over who gets the foreground */
 	/* don't pay any attention to this signal; it just confuses 
 	   things and isn't really meant for shells anyway */
 	signal(SIGTTOU, SIG_IGN);
 	setpgid(0, getpid());
 	tcsetpgrp(fileno(stderr), getpid());
 
 	if (argv[0] && argv[0][0] == '-') {
 		debug_printf("\nsourcing /etc/profile\n");
 		input = xfopen("/etc/profile", "r");
 		mark_open(fileno(input));
 		parse_file_outer(input);
 		mark_closed(fileno(input));
 		fclose(input);
 	}
 	input=stdin;
 	
 	/* initialize the cwd -- this is never freed...*/
 	cwd = xgetcwd(0);
 	if (!cwd)
 		cwd = unknown;
 #ifdef BB_FEATURE_COMMAND_EDITING
 	cmdedit_set_initial_prompt();
 #else
 	PS1 = NULL;
 #endif
 	
 	while ((opt = getopt(argc, argv, "c:xif")) > 0) {
 		switch (opt) {
 			case 'c':
 				{
 					global_argv = argv+optind;
 					global_argc = argc-optind;
 					opt = parse_string_outer(optarg);
 					goto final_return;
 				}
 				break;
 			case 'i':
 				interactive++;
 				break;
 			case 'f':
 				fake_mode++;
 				break;
 			default:
 #ifndef BB_VER
 				fprintf(stderr, "Usage: sh [FILE]...\n"
 						"   or: sh -c command [args]...\n\n");
 				exit(EXIT_FAILURE);
 #else
 				show_usage();
 #endif
 		}
 	}
 	/* A shell is interactive if the `-i' flag was given, or if all of
 	 * the following conditions are met:
 	 *	  no -c command
 	 *    no arguments remaining or the -s flag given
 	 *    standard input is a terminal
 	 *    standard output is a terminal
 	 *    Refer to Posix.2, the description of the `sh' utility. */
 	if (argv[optind]==NULL && input==stdin &&
 			isatty(fileno(stdin)) && isatty(fileno(stdout))) {
 		interactive++;
 	}
 
 	debug_printf("\ninteractive=%d\n", interactive);
 	if (interactive) {
 		/* Looks like they want an interactive shell */
 		fprintf(stdout, "\nhush -- the humble shell v0.01 (testing)\n\n");
 		grab_tty_control();
 	}
 	if (argv[optind]==NULL) {
 		opt=parse_file_outer(stdin);
 		goto final_return;
 	}
 
 	debug_printf("\nrunning script '%s'\n", argv[optind]);
 	global_argv = argv+optind;
 	global_argc = argc-optind;
 	input = xfopen(argv[optind], "r");
 	opt = parse_file_outer(input);
 
 #ifdef BB_FEATURE_CLEAN_UP
 	fclose(input.file);
 #endif
 
 final_return:
 	return(opt?opt:last_return_code);
 }
diff --git a/shell/lash.c b/shell/lash.c
index cb17e2d..f1200ba 100644
--- a/shell/lash.c
+++ b/shell/lash.c
@@ -1,1940 +1,1940 @@
 /* vi: set sw=4 ts=4: */
 /*
  * lash -- the BusyBox Lame-Ass SHell
  *
  * Copyright (C) 1999,2000,2001 by Lineo, inc.
  * Written by Erik Andersen <andersen@lineo.com>, <andersee@debian.org>
  *
  * Based in part on ladsh.c by Michael K. Johnson and Erik W. Troan, which is
  * under the following liberal license: "We have placed this source code in the
  * public domain. Use it in any project, free or commercial."
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
  * General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
  *
  */
 
 /* The parsing engine of this program is officially at a dead-end.
  * Future work in that direction should move to the work posted
  * at http://doolittle.faludi.com/~larry/parser.html .
  * A start on the integration of that work with the rest of sh.c
  * is at http://codepoet.org/sh.c .
  */
 //
 //This works pretty well now, and is now on by default.
 #define BB_FEATURE_SH_ENVIRONMENT
 //
 //Backtick support has some problems, use at your own risk!
 //#define BB_FEATURE_SH_BACKTICKS
 //
 //If, then, else, etc. support..  This should now behave basically
 //like any other Bourne shell -- sortof...
 #define BB_FEATURE_SH_IF_EXPRESSIONS
 //
 /* This is currently sortof broken, only for the brave... */
 #undef HANDLE_CONTINUATION_CHARS
 //
 /* This would be great -- if wordexp wouldn't strip all quoting
  * out from the target strings...  As is, a parser needs  */
 #undef BB_FEATURE_SH_WORDEXP
 //
 //For debugging/development on the shell only...
 //#define DEBUG_SHELL
 
 
 #include <stdio.h>
 #include <stdlib.h>
 #include <ctype.h>
 #include <errno.h>
 #include <fcntl.h>
 #include <signal.h>
 #include <string.h>
 #include <sys/ioctl.h>
 #include <sys/wait.h>
 #include <unistd.h>
 #include <getopt.h>
 #include "busybox.h"
 #include "cmdedit.h"
 
 #ifdef BB_LOCALE_SUPPORT
 #include <locale.h>
 #endif
 
 //#define BB_FEATURE_SH_WORDEXP
 
 #ifdef BB_FEATURE_SH_WORDEXP
 #include <wordexp.h>
 #define expand_t	wordexp_t
 #undef BB_FEATURE_SH_BACKTICKS
 #else
 #include <glob.h>
 #define expand_t	glob_t
 #endif	
 
 
 static const int MAX_READ = 128;	/* size of input buffer for `read' builtin */
 #define JOB_STATUS_FORMAT "[%d] %-22s %.40s\n"
 
 
 enum redir_type { REDIRECT_INPUT, REDIRECT_OVERWRITE,
 	REDIRECT_APPEND
 };
 
 static const unsigned int DEFAULT_CONTEXT=0x1;
 static const unsigned int IF_TRUE_CONTEXT=0x2;
 static const unsigned int IF_FALSE_CONTEXT=0x4;
 static const unsigned int THEN_EXP_CONTEXT=0x8;
 static const unsigned int ELSE_EXP_CONTEXT=0x10;
 
 
 struct jobset {
 	struct job *head;			/* head of list of running jobs */
 	struct job *fg;				/* current foreground job */
 };
 
 struct redir_struct {
 	enum redir_type type;	/* type of redirection */
 	int fd;						/* file descriptor being redirected */
 	char *filename;				/* file to redirect fd to */
 };
 
 struct child_prog {
 	pid_t pid;					/* 0 if exited */
 	char **argv;				/* program name and arguments */
 	int num_redirects;			/* elements in redirection array */
 	struct redir_struct *redirects;	/* I/O redirects */
 	int is_stopped;				/* is the program currently running? */
 	struct job *family;			/* pointer back to the child's parent job */
 };
 
 struct job {
 	int jobid;					/* job number */
 	int num_progs;				/* total number of programs in job */
 	int running_progs;			/* number of programs running */
 	char *text;					/* name of job */
 	char *cmdbuf;				/* buffer various argv's point into */
 	pid_t pgrp;					/* process group ID for the job */
 	struct child_prog *progs;	/* array of programs in job */
 	struct job *next;			/* to track background commands */
 	int stopped_progs;			/* number of programs alive, but stopped */
 	unsigned int job_context;	/* bitmask defining current context */
 	struct jobset *job_list;
 };
 
 struct built_in_command {
 	char *cmd;					/* name */
 	char *descr;				/* description */
 	int (*function) (struct child_prog *);	/* function ptr */
 };
 
 struct close_me {
 	int fd;
 	struct close_me *next;
 };
 
 /* function prototypes for builtins */
 static int builtin_cd(struct child_prog *cmd);
 static int builtin_exec(struct child_prog *cmd);
 static int builtin_exit(struct child_prog *cmd);
 static int builtin_fg_bg(struct child_prog *cmd);
 static int builtin_help(struct child_prog *cmd);
 static int builtin_jobs(struct child_prog *dummy);
 static int builtin_pwd(struct child_prog *dummy);
 static int builtin_export(struct child_prog *cmd);
 static int builtin_source(struct child_prog *cmd);
 static int builtin_unset(struct child_prog *cmd);
 static int builtin_read(struct child_prog *cmd);
 #ifdef BB_FEATURE_SH_IF_EXPRESSIONS
 static int builtin_if(struct child_prog *cmd);
 static int builtin_then(struct child_prog *cmd);
 static int builtin_else(struct child_prog *cmd);
 static int builtin_fi(struct child_prog *cmd);
 /* function prototypes for shell stuff */
 static int run_command_predicate(char *cmd);
 #endif
 
 
 /* function prototypes for shell stuff */
 static void mark_open(int fd);
 static void mark_closed(int fd);
 static void close_all(void);
 static void checkjobs(struct jobset *job_list);
 static int get_command(FILE * source, char *command);
 static int parse_command(char **command_ptr, struct job *job, int *inbg);
 static int run_command(struct job *newjob, int inbg, int outpipe[2]);
 static int pseudo_exec(struct child_prog *cmd) __attribute__ ((noreturn));
 static int busy_loop(FILE * input);
 
 
 /* Table of built-in functions (these are non-forking builtins, meaning they
  * can change global variables in the parent shell process but they will not
  * work with pipes and redirects; 'unset foo | whatever' will not work) */
 static struct built_in_command bltins[] = {
 	{"bg", "Resume a job in the background", builtin_fg_bg},
 	{"cd", "Change working directory", builtin_cd},
 	{"exec", "Exec command, replacing this shell with the exec'd process", builtin_exec},
 	{"exit", "Exit from shell()", builtin_exit},
 	{"fg", "Bring job into the foreground", builtin_fg_bg},
 	{"jobs", "Lists the active jobs", builtin_jobs},
 	{"export", "Set environment variable", builtin_export},
 	{"unset", "Unset environment variable", builtin_unset},
 	{"read", "Input environment variable", builtin_read},
 	{".", "Source-in and run commands in a file", builtin_source},
 	/* to do: add ulimit */
 #ifdef BB_FEATURE_SH_IF_EXPRESSIONS
 	{"if", NULL, builtin_if},
 	{"then", NULL, builtin_then},
 	{"else", NULL, builtin_else},
 	{"fi", NULL, builtin_fi},
 #endif
 	{NULL, NULL, NULL}
 };
 
 /* Table of forking built-in functions (things that fork cannot change global
  * variables in the parent process, such as the current working directory) */
 static struct built_in_command bltins_forking[] = {
 	{"pwd", "Print current directory", builtin_pwd},
 	{"help", "List shell built-in commands", builtin_help},
 	{NULL, NULL, NULL}
 };
 
 
 /* Variables we export */
 unsigned int shell_context;  /* Used in cmdedit.c to reset the
 								context when someone hits ^C */
 
 
 /* Globals that are static to this file */
 static const char *cwd;
 static char *local_pending_command = NULL;
 static struct jobset job_list = { NULL, NULL };
 static int argc;
 static char **argv;
 static struct close_me *close_me_head;
 #ifdef BB_FEATURE_SH_ENVIRONMENT
 static int last_bg_pid;
 static int last_return_code;
 static int show_x_trace;
 #endif
 #ifdef BB_FEATURE_SH_IF_EXPRESSIONS
 static char syntax_err[]="syntax error near unexpected token";
 #endif
 
 static char *PS1;
 static char *PS2 = "> ";
 
 
 #ifdef DEBUG_SHELL
 static inline void debug_printf(const char *format, ...)
 {
 	va_list args;
 	va_start(args, format);
 	vfprintf(stderr, format, args);
 	va_end(args);
 }
 #else
 static inline void debug_printf(const char *format, ...) { }
 #endif
 
 /*
 	Most builtins need access to the struct child_prog that has
 	their arguments, previously coded as cmd->progs[0].  That coding
 	can exhibit a bug, if the builtin is not the first command in
 	a pipeline: "echo foo | exec sort" will attempt to exec foo.
 
 builtin   previous use      notes
 ------ -----------------  ---------
 cd      cmd->progs[0]
 exec    cmd->progs[0]  squashed bug: didn't look for applets or forking builtins
 exit    cmd->progs[0]
 fg_bg   cmd->progs[0], job_list->head, job_list->fg
 help    0
 jobs    job_list->head
 pwd     0
 export  cmd->progs[0]
 source  cmd->progs[0]
 unset   cmd->progs[0]
 read    cmd->progs[0]
 if      cmd->job_context,  cmd->text
 then    cmd->job_context,  cmd->text
 else    cmd->job_context,  cmd->text
 fi      cmd->job_context
 
 The use of cmd->text by if/then/else/fi is hopelessly hacky.
 Would it work to increment cmd->progs[0]->argv and recurse,
 somewhat like builtin_exec does?
 
 I added "struct job *family;" to struct child_prog,
 and switched API to builtin_foo(struct child_prog *child);
 So   cmd->text        becomes  child->family->text
      cmd->job_context  becomes  child->family->job_context
      cmd->progs[0]    becomes  *child
      job_list          becomes  child->family->job_list
  */
 
 /* built-in 'cd <path>' handler */
 static int builtin_cd(struct child_prog *child)
 {
 	char *newdir;
 
 	if (child->argv[1] == NULL)
 		newdir = getenv("HOME");
 	else
 		newdir = child->argv[1];
 	if (chdir(newdir)) {
 		printf("cd: %s: %m\n", newdir);
 		return EXIT_FAILURE;
 	}
 	cwd = xgetcwd((char *)cwd);
 	if (!cwd)
 		cwd = unknown;
 	return EXIT_SUCCESS;
 }
 
 /* built-in 'exec' handler */
 static int builtin_exec(struct child_prog *child)
 {
 	if (child->argv[1] == NULL)
 		return EXIT_SUCCESS;   /* Really? */
 	child->argv++;
 	close_all();
 	pseudo_exec(child);
 	/* never returns */
 }
 
 /* built-in 'exit' handler */
 static int builtin_exit(struct child_prog *child)
 {
 	if (child->argv[1] == NULL)
 		exit(EXIT_SUCCESS);
 
 	exit (atoi(child->argv[1]));
 }
 
 /* built-in 'fg' and 'bg' handler */
 static int builtin_fg_bg(struct child_prog *child)
 {
 	int i, jobNum;
 	struct job *job=NULL;
 	
 	if (!child->argv[1] || child->argv[2]) {
 		error_msg("%s: exactly one argument is expected",
 				child->argv[0]);
 		return EXIT_FAILURE;
 	}
 
 	if (sscanf(child->argv[1], "%%%d", &jobNum) != 1) {
 		error_msg("%s: bad argument '%s'",
 				child->argv[0], child->argv[1]);
 		return EXIT_FAILURE;
 	}
 
 	for (job = child->family->job_list->head; job; job = job->next) {
 		if (job->jobid == jobNum) {
 			break;
 		}
 	}
 
 	if (!job) {
 		error_msg("%s: unknown job %d",
 				child->argv[0], jobNum);
 		return EXIT_FAILURE;
 	}
 
 	if (*child->argv[0] == 'f') {
 		/* Make this job the foreground job */
 		/* suppress messages when run from /linuxrc mag@sysgo.de */
 		if (tcsetpgrp(0, job->pgrp) && errno != ENOTTY)
 			perror_msg("tcsetpgrp"); 
 		child->family->job_list->fg = job;
 	}
 
 	/* Restart the processes in the job */
 	for (i = 0; i < job->num_progs; i++)
 		job->progs[i].is_stopped = 0;
 
 	kill(-job->pgrp, SIGCONT);
 
 	job->stopped_progs = 0;
 
 	return EXIT_SUCCESS;
 }
 
 /* built-in 'help' handler */
 static int builtin_help(struct child_prog *dummy)
 {
 	struct built_in_command *x;
 
 	printf("\nBuilt-in commands:\n");
 	printf("-------------------\n");
 	for (x = bltins; x->cmd; x++) {
 		if (x->descr==NULL)
 			continue;
 		printf("%s\t%s\n", x->cmd, x->descr);
 	}
 	for (x = bltins_forking; x->cmd; x++) {
 		if (x->descr==NULL)
 			continue;
 		printf("%s\t%s\n", x->cmd, x->descr);
 	}
 	printf("\n\n");
 	return EXIT_SUCCESS;
 }
 
 /* built-in 'jobs' handler */
 static int builtin_jobs(struct child_prog *child)
 {
 	struct job *job;
 	char *status_string;
 
 	for (job = child->family->job_list->head; job; job = job->next) {
 		if (job->running_progs == job->stopped_progs)
 			status_string = "Stopped";
 		else
 			status_string = "Running";
 
 		printf(JOB_STATUS_FORMAT, job->jobid, status_string, job->text);
 	}
 	return EXIT_SUCCESS;
 }
 
 
 /* built-in 'pwd' handler */
 static int builtin_pwd(struct child_prog *dummy)
 {
 	cwd = xgetcwd((char *)cwd);
 	if (!cwd)
 		cwd = unknown;
 	puts(cwd);
 	return EXIT_SUCCESS;
 }
 
 /* built-in 'export VAR=value' handler */
 static int builtin_export(struct child_prog *child)
 {
 	int res;
 	char *v = child->argv[1];
 
 	if (v == NULL) {
 		char **e;
 		for (e = environ; *e; e++) {
 			puts(*e);
 		}
 		return 0;
 	}
 	res = putenv(v);
 	if (res)
 		fprintf(stderr, "export: %m\n");
-#ifndef BB_FEATURE_SH_SIMPLE_PROMPT
+#ifdef BB_FEATURE_SH_FANCY_PROMPT
 	if (strncmp(v, "PS1=", 4)==0)
 		PS1 = getenv("PS1");
 #endif
 
 #ifdef BB_LOCALE_SUPPORT
 	if(strncmp(v, "LC_ALL=", 7)==0)
 		setlocale(LC_ALL, getenv("LC_ALL"));
 	if(strncmp(v, "LC_CTYPE=", 9)==0)
 		setlocale(LC_CTYPE, getenv("LC_CTYPE"));
 #endif
 
 	return (res);
 }
 
 /* built-in 'read VAR' handler */
 static int builtin_read(struct child_prog *child)
 {
 	int res = 0, len, newlen;
 	char *s;
 	char string[MAX_READ];
 
 	if (child->argv[1]) {
 		/* argument (VAR) given: put "VAR=" into buffer */
 		strcpy(string, child->argv[1]);
 		len = strlen(string);
 		string[len++] = '=';
 		string[len]   = '\0';
 		fgets(&string[len], sizeof(string) - len, stdin);	/* read string */
 		newlen = strlen(string);
 		if(newlen > len)
 			string[--newlen] = '\0';	/* chomp trailing newline */
 		/*
 		** string should now contain "VAR=<value>"
 		** copy it (putenv() won't do that, so we must make sure
 		** the string resides in a static buffer!)
 		*/
 		res = -1;
 		if((s = strdup(string)))
 			res = putenv(s);
 		if (res)
 			fprintf(stderr, "read: %m\n");
 	}
 	else
 		fgets(string, sizeof(string), stdin);
 
 	return (res);
 }
 
 #ifdef BB_FEATURE_SH_IF_EXPRESSIONS
 /* Built-in handler for 'if' commands */
 static int builtin_if(struct child_prog *child)
 {
 	struct job *cmd = child->family;
 	int status;
 	char* charptr1=cmd->text+3; /* skip over the leading 'if ' */
 
 	/* Now run the 'if' command */
 	debug_printf( "job=%p entering builtin_if ('%s')-- context=%d\n", cmd, charptr1, cmd->job_context);
 	status = run_command_predicate(charptr1);
 	debug_printf( "if test returned ");
 	if (status == 0) {
 		debug_printf( "TRUE\n");
 		cmd->job_context |= IF_TRUE_CONTEXT;
 	} else {
 		debug_printf( "FALSE\n");
 		cmd->job_context |= IF_FALSE_CONTEXT;
 	}
 	debug_printf("job=%p builtin_if set job context to %x\n", cmd, cmd->job_context);
 	shell_context++;
 
 	return status;
 }
 
 /* Built-in handler for 'then' (part of the 'if' command) */
 static int builtin_then(struct child_prog *child)
 {
 	struct job *cmd = child->family;
 	char* charptr1=cmd->text+5; /* skip over the leading 'then ' */
 
 	debug_printf( "job=%p entering builtin_then ('%s')-- context=%d\n", cmd, charptr1, cmd->job_context);
 	if (! (cmd->job_context & (IF_TRUE_CONTEXT|IF_FALSE_CONTEXT))) {
 		shell_context = 0; /* Reset the shell's context on an error */
 		error_msg("%s `then'", syntax_err);
 		return EXIT_FAILURE;
 	}
 
 	cmd->job_context |= THEN_EXP_CONTEXT;
 	debug_printf("job=%p builtin_then set job context to %x\n", cmd, cmd->job_context);
 
 	/* If the if result was FALSE, skip the 'then' stuff */
 	if (cmd->job_context & IF_FALSE_CONTEXT) {
 		return EXIT_SUCCESS;
 	}
 
 	/* Seems the if result was TRUE, so run the 'then' command */
 	debug_printf( "'then' now running '%s'\n", charptr1);
 
 	return(run_command_predicate(charptr1));
 }
 
 /* Built-in handler for 'else' (part of the 'if' command) */
 static int builtin_else(struct child_prog *child)
 {
 	struct job *cmd = child->family;
 	char* charptr1=cmd->text+5; /* skip over the leading 'else ' */
 
 	debug_printf( "job=%p entering builtin_else ('%s')-- context=%d\n", cmd, charptr1, cmd->job_context);
 
 	if (! (cmd->job_context & THEN_EXP_CONTEXT)) {
 		shell_context = 0; /* Reset the shell's context on an error */
 		error_msg("%s `else'", syntax_err);
 		return EXIT_FAILURE;
 	}
 	/* If the if result was TRUE, skip the 'else' stuff */
 	if (cmd->job_context & IF_TRUE_CONTEXT) {
 		return EXIT_SUCCESS;
 	}
 
 	cmd->job_context |= ELSE_EXP_CONTEXT;
 	debug_printf("job=%p builtin_else set job context to %x\n", cmd, cmd->job_context);
 
 	/* Now run the 'else' command */
 	debug_printf( "'else' now running '%s'\n", charptr1);
 	return(run_command_predicate(charptr1));
 }
 
 /* Built-in handler for 'fi' (part of the 'if' command) */
 static int builtin_fi(struct child_prog *child)
 {
 	struct job *cmd = child->family;
 	debug_printf( "job=%p entering builtin_fi ('%s')-- context=%d\n", cmd, "", cmd->job_context);
 	if (! (cmd->job_context & (IF_TRUE_CONTEXT|IF_FALSE_CONTEXT))) {
 		shell_context = 0; /* Reset the shell's context on an error */
 		error_msg("%s `fi'", syntax_err);
 		return EXIT_FAILURE;
 	}
 	/* Clear out the if and then context bits */
 	cmd->job_context &= ~(IF_TRUE_CONTEXT|IF_FALSE_CONTEXT|THEN_EXP_CONTEXT|ELSE_EXP_CONTEXT);
 	debug_printf("job=%p builtin_fi set job context to %x\n", cmd, cmd->job_context);
 	shell_context--;
 	return EXIT_SUCCESS;
 }
 #endif
 
 /* Built-in '.' handler (read-in and execute commands from file) */
 static int builtin_source(struct child_prog *child)
 {
 	FILE *input;
 	int status;
 	int fd;
 
 	if (child->argv[1] == NULL)
 		return EXIT_FAILURE;
 
 	input = fopen(child->argv[1], "r");
 	if (!input) {
 		printf( "Couldn't open file '%s'\n", child->argv[1]);
 		return EXIT_FAILURE;
 	}
 
 	fd=fileno(input);
 	mark_open(fd);
 	/* Now run the file */
 	status = busy_loop(input);
 	fclose(input);
 	mark_closed(fd);
 	return (status);
 }
 
 /* built-in 'unset VAR' handler */
 static int builtin_unset(struct child_prog *child)
 {
 	if (child->argv[1] == NULL) {
 		printf( "unset: parameter required.\n");
 		return EXIT_FAILURE;
 	}
 	unsetenv(child->argv[1]);
 	return EXIT_SUCCESS;
 }
 
 #ifdef BB_FEATURE_SH_IF_EXPRESSIONS
 /* currently used by if/then/else.
  *
  * Reparsing the command line for this purpose is gross,
  * incorrect, and fundamentally unfixable; in particular,
  * think about what happens with command substitution.
  * We really need to pull out the run, wait, return status
  * functionality out of busy_loop so we can child->argv++
  * and use that, without going back through parse_command.
  */
 static int run_command_predicate(char *cmd)
 {
 	local_pending_command = xstrdup(cmd);
 	return( busy_loop(NULL));
 }
 #endif
 
 static void mark_open(int fd)
 {
 	struct close_me *new = xmalloc(sizeof(struct close_me));
 	new->fd = fd;
 	new->next = close_me_head;
 	close_me_head = new;
 }
 
 static void mark_closed(int fd)
 {
 	struct close_me *tmp;
 	if (close_me_head == NULL || close_me_head->fd != fd)
 		error_msg_and_die("corrupt close_me");
 	tmp = close_me_head;
 	close_me_head = close_me_head->next;
 	free(tmp);
 }
 
 static void close_all()
 {
 	struct close_me *c, *tmp;
 	for (c=close_me_head; c; c=tmp) {
 		close(c->fd);
 		tmp=c->next;
 		free(c);
 	}
 	close_me_head = NULL;
 }
 
 
 /* free up all memory from a job */
 static void free_job(struct job *cmd)
 {
 	int i;
 	struct jobset *keep;
 
 	for (i = 0; i < cmd->num_progs; i++) {
 		free(cmd->progs[i].argv);
 		if (cmd->progs[i].redirects)
 			free(cmd->progs[i].redirects);
 	}
 	if (cmd->progs)
 		free(cmd->progs);
 	if (cmd->text)
 		free(cmd->text);
 	if (cmd->cmdbuf)
 		free(cmd->cmdbuf);
 	keep = cmd->job_list;
 	memset(cmd, 0, sizeof(struct job));
 	cmd->job_list = keep;
 }
 
 /* remove a job from a jobset */
 static void remove_job(struct jobset *j_list, struct job *job)
 {
 	struct job *prevjob;
 
 	free_job(job);
 	if (job == j_list->head) {
 		j_list->head = job->next;
 	} else {
 		prevjob = j_list->head;
 		while (prevjob->next != job)
 			prevjob = prevjob->next;
 		prevjob->next = job->next;
 	}
 
 	free(job);
 }
 
 /* Checks to see if any background processes have exited -- if they 
    have, figure out why and see if a job has completed */
 static void checkjobs(struct jobset *j_list)
 {
 	struct job *job;
 	pid_t childpid;
 	int status;
 	int prognum = 0;
 
 	while ((childpid = waitpid(-1, &status, WNOHANG | WUNTRACED)) > 0) {
 		for (job = j_list->head; job; job = job->next) {
 			prognum = 0;
 			while (prognum < job->num_progs &&
 				   job->progs[prognum].pid != childpid) prognum++;
 			if (prognum < job->num_progs)
 				break;
 		}
 
 		/* This happens on backticked commands */
 		if(job==NULL)
 			return;
 
 		if (WIFEXITED(status) || WIFSIGNALED(status)) {
 			/* child exited */
 			job->running_progs--;
 			job->progs[prognum].pid = 0;
 
 			if (!job->running_progs) {
 				printf(JOB_STATUS_FORMAT, job->jobid, "Done", job->text);
 				remove_job(j_list, job);
 			}
 		} else {
 			/* child stopped */
 			job->stopped_progs++;
 			job->progs[prognum].is_stopped = 1;
 
 			if (job->stopped_progs == job->num_progs) {
 				printf(JOB_STATUS_FORMAT, job->jobid, "Stopped",
 					   job->text);
 			}
 		}
 	}
 
 	if (childpid == -1 && errno != ECHILD)
 		perror_msg("waitpid");
 }
 
 /* squirrel != NULL means we squirrel away copies of stdin, stdout,
  * and stderr if they are redirected. */
 static int setup_redirects(struct child_prog *prog, int squirrel[])
 {
 	int i;
 	int openfd;
 	int mode = O_RDONLY;
 	struct redir_struct *redir = prog->redirects;
 
 	for (i = 0; i < prog->num_redirects; i++, redir++) {
 		switch (redir->type) {
 		case REDIRECT_INPUT:
 			mode = O_RDONLY;
 			break;
 		case REDIRECT_OVERWRITE:
 			mode = O_WRONLY | O_CREAT | O_TRUNC;
 			break;
 		case REDIRECT_APPEND:
 			mode = O_WRONLY | O_CREAT | O_APPEND;
 			break;
 		}
 
 		openfd = open(redir->filename, mode, 0666);
 		if (openfd < 0) {
 			/* this could get lost if stderr has been redirected, but
 			   bash and ash both lose it as well (though zsh doesn't!) */
 			perror_msg("error opening %s", redir->filename);
 			return 1;
 		}
 
 		if (openfd != redir->fd) {
 			if (squirrel && redir->fd < 3) {
 				squirrel[redir->fd] = dup(redir->fd);
 			}
 			dup2(openfd, redir->fd);
 			close(openfd);
 		}
 	}
 
 	return 0;
 }
 
 static void restore_redirects(int squirrel[])
 {
 	int i, fd;
 	for (i=0; i<3; i++) {
 		fd = squirrel[i];
 		if (fd != -1) {
 			/* No error checking.  I sure wouldn't know what
 			 * to do with an error if I found one! */
 			dup2(fd, i);
 			close(fd);
 		}
 	}
 }
 
 static inline void cmdedit_set_initial_prompt(void)
 {
-#ifdef BB_FEATURE_SH_SIMPLE_PROMPT
+#ifndef BB_FEATURE_SH_FANCY_PROMPT
 	PS1 = NULL;
 #else
 	PS1 = getenv("PS1");
 	if(PS1==0)
 		PS1 = "\\w \\$ ";
 #endif	
 }
 
 static inline void setup_prompt_string(char **prompt_str)
 {
-#ifdef BB_FEATURE_SH_SIMPLE_PROMPT
+#ifndef BB_FEATURE_SH_FANCY_PROMPT
 	/* Set up the prompt */
 	if (shell_context == 0) {
 		if (PS1)
 			free(PS1);
 		PS1=xmalloc(strlen(cwd)+4);
 		sprintf(PS1, "%s %s", cwd, ( geteuid() != 0 ) ?  "$ ":"# ");
 		*prompt_str = PS1;
 	} else {
 		*prompt_str = PS2;
 	}
 #else
 	*prompt_str = (shell_context==0)? PS1 : PS2;
 #endif	
 }
 
 static int get_command(FILE * source, char *command)
 {
 	char *prompt_str;
 
 	if (source == NULL) {
 		if (local_pending_command) {
 			/* a command specified (-c option): return it & mark it done */
 			strcpy(command, local_pending_command);
 			free(local_pending_command);
 			local_pending_command = NULL;
 			return 0;
 		}
 		return 1;
 	}
 
 	if (source == stdin) {
 		setup_prompt_string(&prompt_str);
 
 #ifdef BB_FEATURE_COMMAND_EDITING
 		/*
 		** enable command line editing only while a command line
 		** is actually being read; otherwise, we'll end up bequeathing
 		** atexit() handlers and other unwanted stuff to our
 		** child processes (rob@sysgo.de)
 		*/
 		cmdedit_read_input(prompt_str, command);
 		cmdedit_terminate();
 		return 0;
 #else
 		fputs(prompt_str, stdout);
 #endif
 	}
 
 	if (!fgets(command, BUFSIZ - 2, source)) {
 		if (source == stdin)
 			printf("\n");
 		return 1;
 	}
 
 	return 0;
 }
 
 #ifdef BB_FEATURE_SH_ENVIRONMENT
 static char* itoa(register int i)
 {
 	static char a[7]; /* Max 7 ints */
 	register char *b = a + sizeof(a) - 1;
 	int   sign = (i < 0);
 
 	if (sign)
 		i = -i;
 	*b = 0;
 	do
 	{
 		*--b = '0' + (i % 10);
 		i /= 10;
 	}
 	while (i);
 	if (sign)
 		*--b = '-';
 	return b;
 }
 #endif	
 
 #if defined BB_FEATURE_SH_ENVIRONMENT && ! defined BB_FEATURE_SH_WORDEXP
 char * strsep_space( char *string, int * ix)
 {
 	char *token, *begin;
 
 	begin = string;
 
 	/* Short circuit the trivial case */
 	if ( !string || ! string[*ix])
 		return NULL;
 
 	/* Find the end of the token. */
 	while( string && string[*ix] && !isspace(string[*ix]) ) {
 		(*ix)++;
 	}
 
 	/* Find the end of any whitespace trailing behind 
 	 * the token and let that be part of the token */
 	while( string && string[*ix] && isspace(string[*ix]) ) {
 		(*ix)++;
 	}
 
 	if (! string && *ix==0) {
 		/* Nothing useful was found */
 		return NULL;
 	}
 
 	token = xmalloc(*ix+1);
 	token[*ix] = '\0';
 	strncpy(token, string,  *ix); 
 
 	return token;
 }
 #endif	
 
 
 static int expand_arguments(char *command)
 {
 #ifdef BB_FEATURE_SH_ENVIRONMENT
 	expand_t expand_result;
 	char *src, *dst, *var;
 	int ix = 0;
 	int i=0, length, total_length=0, retval;
 	const char *out_of_space = "out of space during expansion"; 
 #endif
 
 	/* get rid of the terminating \n */
 	chomp(command);
 	
 	/* Fix up escape sequences to be the Real Thing(tm) */
 	while( command && command[ix]) {
 		if (command[ix] == '\\') {
 			const char *tmp = command+ix+1;
 			command[ix] = process_escape_sequence(  &tmp );
 			memmove(command+ix + 1, tmp, strlen(tmp)+1);
 		}
 		ix++;
 	}
 
 #ifdef BB_FEATURE_SH_ENVIRONMENT
 
 
 #ifdef BB_FEATURE_SH_WORDEXP
 	/* This first part uses wordexp() which is a wonderful C lib 
 	 * function which expands nearly everything.  */ 
 	retval = wordexp (command, &expand_result, WRDE_SHOWERR);
 	if (retval == WRDE_NOSPACE) {
 		/* Mem may have been allocated... */
 		wordfree (&expand_result);
 		error_msg(out_of_space);
 		return FALSE;
 	}
 	if (retval < 0) {
 		/* Some other error.  */
 		error_msg("syntax error");
 		return FALSE;
 	}
 	
 	if (expand_result.we_wordc > 0) {
 		/* Convert from char** (one word per string) to a simple char*,
 		 * but don't overflow command which is BUFSIZ in length */
 		*command = '\0';
 		while (i < expand_result.we_wordc && total_length < BUFSIZ) {
 			length=strlen(expand_result.we_wordv[i])+1;
 			if (BUFSIZ-total_length-length <= 0) {
 				error_msg(out_of_space);
 				return FALSE;
 			}
 			strcat(command+total_length, expand_result.we_wordv[i++]);
 			strcat(command+total_length, " ");
 			total_length+=length;
 		}
 		wordfree (&expand_result);
 	}
 #else
 
 	/* Ok.  They don't have a recent glibc and they don't have uClibc.  Chances
 	 * are about 100% they don't have wordexp(). So instead the best we can do
 	 * is use glob and then fixup environment variables and such ourselves.
 	 * This is better then nothing, but certainly not perfect */
 
 	/* It turns out that glob is very stupid.  We have to feed it one word at a
 	 * time since it can't cope with a full string.  Here we convert command
 	 * (char*) into cmd (char**, one word per string) */
 	{
         
 		int flags = GLOB_NOCHECK
 #ifdef GLOB_BRACE
 				| GLOB_BRACE
 #endif	
 #ifdef GLOB_TILDE
 				| GLOB_TILDE
 #endif	
 			;
 		char *tmpcmd, *cmd, *cmd_copy;
 		/* We need a clean copy, so strsep can mess up the copy while
 		 * we write stuff into the original (in a minute) */
 		cmd = cmd_copy = strdup(command);
 		*command = '\0';
 		for (ix = 0, tmpcmd = cmd; 
 				(tmpcmd = strsep_space(cmd, &ix)) != NULL; cmd += ix, ix=0) {
 			if (*tmpcmd == '\0')
 				break;
 			/* we need to trim() the result for glob! */
 			trim(tmpcmd);
 			retval = glob(tmpcmd, flags, NULL, &expand_result);
 			free(tmpcmd); /* Free mem allocated by strsep_space */
 			if (retval == GLOB_NOSPACE) {
 				/* Mem may have been allocated... */
 				globfree (&expand_result);
 				error_msg(out_of_space);
 				return FALSE;
 			} else if (retval != 0) {
 				/* Some other error.  GLOB_NOMATCH shouldn't
 				 * happen because of the GLOB_NOCHECK flag in 
 				 * the glob call. */
 				error_msg("syntax error");
 				return FALSE;
 			} else {
 			/* Convert from char** (one word per string) to a simple char*,
 			 * but don't overflow command which is BUFSIZ in length */
 				for (i=0; i < expand_result.gl_pathc; i++) {
 					length=strlen(expand_result.gl_pathv[i]);
 					if (total_length+length+1 >= BUFSIZ) {
 						error_msg(out_of_space);
 						return FALSE;
 					}
 					strcat(command+total_length, " ");
 					total_length+=1;
 					strcat(command+total_length, expand_result.gl_pathv[i]);
 					total_length+=length;
 				}
 				globfree (&expand_result);
 			}
 		}
 		free(cmd_copy);
 		trim(command);
 	}
 	
 #endif	
 
 	/* Now do the shell variable substitutions which 
 	 * wordexp can't do for us, namely $? and $! */
 	src = command;
 	while((dst = strchr(src,'$')) != NULL){
 		var = NULL;
 		switch(*(dst+1)) {
 			case '?':
 				var = itoa(last_return_code);
 				break;
 			case '!':
 				if (last_bg_pid==-1)
 					*(var)='\0';
 				else
 					var = itoa(last_bg_pid);
 				break;
 				/* Everything else like $$, $#, $[0-9], etc should all be
 				 * expanded by wordexp(), so we can in theory skip that stuff
 				 * here, but just to be on the safe side (i.e. since uClibc
 				 * wordexp doesn't do this stuff yet), lets leave it in for
 				 * now. */
 			case '$':
 				var = itoa(getpid());
 				break;
 			case '#':
 				var = itoa(argc-1);
 				break;
 			case '0':case '1':case '2':case '3':case '4':
 			case '5':case '6':case '7':case '8':case '9':
 				{
 					int ixx=*(dst + 1)-48;
 					if (ixx >= argc) {
 						var='\0';
 					} else {
 						var = argv[ixx];
 					}
 				}
 				break;
 
 		}
 		if (var) {
 			/* a single character construction was found, and 
 			 * already handled in the case statement */
 			src=dst+2;
 		} else {
 			/* Looks like an environment variable */
 			char delim_hold;
 			int num_skip_chars=0;
 			int dstlen = strlen(dst);
 			/* Is this a ${foo} type variable? */
 			if (dstlen >=2 && *(dst+1) == '{') {
 				src=strchr(dst+1, '}');
 				num_skip_chars=1;
 			} else {
 				src=dst+1;
 				while(isalnum(*src) || *src=='_') src++;
 			}
 			if (src == NULL) {
 				src = dst+dstlen;
 			}
 			delim_hold=*src;
 			*src='\0';  /* temporary */
 			var = getenv(dst + 1 + num_skip_chars);
 			*src=delim_hold;
 			src += num_skip_chars;
 		}
 		if (var == NULL) {
 			/* Seems we got an un-expandable variable.  So delete it. */
 			var = "";
 		}
 		{
 			int subst_len = strlen(var);
 			int trail_len = strlen(src);
 			if (dst+subst_len+trail_len >= command+BUFSIZ) {
 				error_msg(out_of_space);
 				return FALSE;
 			}
 			/* Move stuff to the end of the string to accommodate
 			 * filling the created gap with the new stuff */
 			memmove(dst+subst_len, src, trail_len+1);
 			/* Now copy in the new stuff */
 			memcpy(dst, var, subst_len);
 			src = dst+subst_len;
 		}
 	}
 
 #endif	
 	return TRUE;
 }
 
 /* Return cmd->num_progs as 0 if no command is present (e.g. an empty
    line). If a valid command is found, command_ptr is set to point to
    the beginning of the next command (if the original command had more 
    then one job associated with it) or NULL if no more commands are 
    present. */
 static int parse_command(char **command_ptr, struct job *job, int *inbg)
 {
 	char *command;
 	char *return_command = NULL;
 	char *src, *buf, *chptr;
 	int argc_l = 0;
 	int done = 0;
 	int argv_alloced;
 	int i, saw_quote = 0;
 	char quote = '\0';
 	int count;
 	struct child_prog *prog;
 
 	/* skip leading white space */
 	while (**command_ptr && isspace(**command_ptr))
 		(*command_ptr)++;
 
 	/* this handles empty lines or leading '#' characters */
 	if (!**command_ptr || (**command_ptr == '#')) {
 		job->num_progs=0;
 		return 0;
 	}
 
 	*inbg = 0;
 	job->num_progs = 1;
 	job->progs = xmalloc(sizeof(*job->progs));
 
 	/* We set the argv elements to point inside of this string. The 
 	   memory is freed by free_job(). Allocate twice the original
 	   length in case we need to quote every single character.
 
 	   Getting clean memory relieves us of the task of NULL 
 	   terminating things and makes the rest of this look a bit 
 	   cleaner (though it is, admittedly, a tad less efficient) */
 	job->cmdbuf = command = xcalloc(2*strlen(*command_ptr) + 1, sizeof(char));
 	job->text = NULL;
 
 	prog = job->progs;
 	prog->num_redirects = 0;
 	prog->redirects = NULL;
 	prog->is_stopped = 0;
 	prog->family = job;
 
 	argv_alloced = 5;
 	prog->argv = xmalloc(sizeof(*prog->argv) * argv_alloced);
 	prog->argv[0] = job->cmdbuf;
 
 	buf = command;
 	src = *command_ptr;
 	while (*src && !done) {
 		if (quote == *src) {
 			quote = '\0';
 		} else if (quote) {
 			if (*src == '\\') {
 				src++;
 				if (!*src) {
 					error_msg("character expected after \\");
 					free_job(job);
 					return 1;
 				}
 
 				/* in shell, "\'" should yield \' */
 				if (*src != quote) {
 					*buf++ = '\\';
 					*buf++ = '\\';
 				}
 			} else if (*src == '*' || *src == '?' || *src == '[' ||
 					   *src == ']') *buf++ = '\\';
 			*buf++ = *src;
 		} else if (isspace(*src)) {
 			if (*prog->argv[argc_l] || saw_quote) {
 				buf++, argc_l++;
 				/* +1 here leaves room for the NULL which ends argv */
 				if ((argc_l + 1) == argv_alloced) {
 					argv_alloced += 5;
 					prog->argv = xrealloc(prog->argv,
 										  sizeof(*prog->argv) *
 										  argv_alloced);
 				}
 				prog->argv[argc_l] = buf;
 				saw_quote = 0;
 			}
 		} else
 			switch (*src) {
 			case '"':
 			case '\'':
 				quote = *src;
 				saw_quote = 1;
 				break;
 
 			case '#':			/* comment */
 				if (*(src-1)== '$')
 					*buf++ = *src;
 				else
 					done = 1;
 				break;
 
 			case '>':			/* redirects */
 			case '<':
 				i = prog->num_redirects++;
 				prog->redirects = xrealloc(prog->redirects,
 											  sizeof(*prog->redirects) *
 											  (i + 1));
 
 				prog->redirects[i].fd = -1;
 				if (buf != prog->argv[argc_l]) {
 					/* the stuff before this character may be the file number 
 					   being redirected */
 					prog->redirects[i].fd =
 						strtol(prog->argv[argc_l], &chptr, 10);
 
 					if (*chptr && *prog->argv[argc_l]) {
 						buf++, argc_l++;
 						prog->argv[argc_l] = buf;
 					}
 				}
 
 				if (prog->redirects[i].fd == -1) {
 					if (*src == '>')
 						prog->redirects[i].fd = 1;
 					else
 						prog->redirects[i].fd = 0;
 				}
 
 				if (*src++ == '>') {
 					if (*src == '>')
 						prog->redirects[i].type =
 							REDIRECT_APPEND, src++;
 					else
 						prog->redirects[i].type = REDIRECT_OVERWRITE;
 				} else {
 					prog->redirects[i].type = REDIRECT_INPUT;
 				}
 
 				/* This isn't POSIX sh compliant. Oh well. */
 				chptr = src;
 				while (isspace(*chptr))
 					chptr++;
 
 				if (!*chptr) {
 					error_msg("file name expected after %c", *(src-1));
 					free_job(job);
 					job->num_progs=0;
 					return 1;
 				}
 
 				prog->redirects[i].filename = buf;
 				while (*chptr && !isspace(*chptr))
 					*buf++ = *chptr++;
 
 				src = chptr - 1;	/* we src++ later */
 				prog->argv[argc_l] = ++buf;
 				break;
 
 			case '|':			/* pipe */
 				/* finish this command */
 				if (*prog->argv[argc_l] || saw_quote)
 					argc_l++;
 				if (!argc_l) {
 					error_msg("empty command in pipe");
 					free_job(job);
 					job->num_progs=0;
 					return 1;
 				}
 				prog->argv[argc_l] = NULL;
 
 				/* and start the next */
 				job->num_progs++;
 				job->progs = xrealloc(job->progs,
 									  sizeof(*job->progs) * job->num_progs);
 				prog = job->progs + (job->num_progs - 1);
 				prog->num_redirects = 0;
 				prog->redirects = NULL;
 				prog->is_stopped = 0;
 				prog->family = job;
 				argc_l = 0;
 
 				argv_alloced = 5;
 				prog->argv = xmalloc(sizeof(*prog->argv) * argv_alloced);
 				prog->argv[0] = ++buf;
 
 				src++;
 				while (*src && isspace(*src))
 					src++;
 
 				if (!*src) {
 					error_msg("empty command in pipe");
 					free_job(job);
 					job->num_progs=0;
 					return 1;
 				}
 				src--;			/* we'll ++ it at the end of the loop */
 
 				break;
 
 			case '&':			/* background */
 				*inbg = 1;
 			case ';':			/* multiple commands */
 				done = 1;
 				return_command = *command_ptr + (src - *command_ptr) + 1;
 				break;
 
 #ifdef BB_FEATURE_SH_BACKTICKS
 			case '`':
 				/* Exec a backtick-ed command */
 				/* Besides any previous brokenness, I have not
 				 * updated backtick handling for close_me support.
 				 * I don't know if it needs it or not.  -- LRD */
 				{
 					char* charptr1=NULL, *charptr2;
 					char* ptr=NULL;
 					struct job *newjob;
 					struct jobset njob_list = { NULL, NULL };
 					int pipefd[2];
 					int size;
 
 					ptr=strchr(++src, '`');
 					if (ptr==NULL) {
 						fprintf(stderr, "Unmatched '`' in command\n");
 						free_job(job);
 						return 1;
 					}
 
 					/* Make some space to hold just the backticked command */
 					charptr1 = charptr2 = xmalloc(1+ptr-src);
 					memcpy(charptr1, src, ptr-src);
 					charptr1[ptr-src] = '\0';
 					newjob = xmalloc(sizeof(struct job));
 					newjob->job_list = &njob_list;
 					/* Now parse and run the backticked command */
 					if (!parse_command(&charptr1, newjob, inbg) 
 							&& newjob->num_progs) {
 						pipe(pipefd);
 						run_command(newjob, 0, pipefd);
 					}
 					checkjobs(job->job_list);
 					free_job(newjob);  /* doesn't actually free newjob,
 					                     looks like a memory leak */
 					free(charptr2);
 					
 					/* Make a copy of any stuff left over in the command 
 					 * line after the second backtick */
 					charptr2 = xmalloc(strlen(ptr)+1);
 					memcpy(charptr2, ptr+1, strlen(ptr));
 
 
 					/* Copy the output from the backtick-ed command into the
 					 * command line, making extra room as needed  */
 					--src;
 					charptr1 = xmalloc(BUFSIZ);
 					while ( (size=full_read(pipefd[0], charptr1, BUFSIZ-1)) >0) {
 						int newsize=src - *command_ptr + size + 1 + strlen(charptr2);
 						if (newsize > BUFSIZ) {
 							*command_ptr=xrealloc(*command_ptr, newsize);
 						}
 						memcpy(src, charptr1, size); 
 						src+=size;
 					}
 					free(charptr1);
 					close(pipefd[0]);
 					if (*(src-1)=='\n')
 						--src;
 
 					/* Now paste into the *command_ptr all the stuff 
 					 * leftover after the second backtick */
 					memcpy(src, charptr2, strlen(charptr2)+1);
 					free(charptr2);
 
 					/* Now recursively call parse_command to deal with the new
 					 * and improved version of the command line with the backtick
 					 * results expanded in place... */
 					{
 						struct jobset *jl=job->job_list;
 						free_job(job);
 						job->job_list = jl;
 					}
 					return(parse_command(command_ptr, job, inbg));
 				}
 				break;
 #endif // BB_FEATURE_SH_BACKTICKS
 
 			case '\\':
 				src++;
 				if (!*src) {
 /* This is currently a little broken... */
 #ifdef HANDLE_CONTINUATION_CHARS
 					/* They fed us a continuation char, so continue reading stuff
 					 * on the next line, then tack that onto the end of the current
 					 * command */
 					char *command;
 					int newsize;
 					printf("erik: found a continue char at EOL...\n");
 					command = (char *) xcalloc(BUFSIZ, sizeof(char));
 					if (get_command(input, command)) {
 						error_msg("character expected after \\");
 						free(command);
 						free_job(job);
 						return 1;
 					}
 					newsize = strlen(*command_ptr) + strlen(command) + 2;
 					if (newsize > BUFSIZ) {
 						printf("erik: doing realloc\n");
 						*command_ptr=xrealloc(*command_ptr, newsize);
 					}
 					printf("erik: A: *command_ptr='%s'\n", *command_ptr);
 					memcpy(--src, command, strlen(command)); 
 					printf("erik: B: *command_ptr='%s'\n", *command_ptr);
 					free(command);
 					break;
 #else
 					error_msg("character expected after \\");
 					free_job(job);
 					return 1;
 #endif
 				}
 				if (*src == '*' || *src == '[' || *src == ']'
 					|| *src == '?') *buf++ = '\\';
 				/* fallthrough */
 			default:
 				*buf++ = *src;
 			}
 
 		src++;
 	}
 
 	if (*prog->argv[argc_l] || saw_quote) {
 		argc_l++;
 	}
 	if (!argc_l) {
 		free_job(job);
 		return 0;
 	}
 	prog->argv[argc_l] = NULL;
 
 	if (!return_command) {
 		job->text = xmalloc(strlen(*command_ptr) + 1);
 		strcpy(job->text, *command_ptr);
 	} else {
 		/* This leaves any trailing spaces, which is a bit sloppy */
 		count = return_command - *command_ptr;
 		job->text = xmalloc(count + 1);
 		strncpy(job->text, *command_ptr, count);
 		job->text[count] = '\0';
 	}
 
 	*command_ptr = return_command;
 	
 	return 0;
 }
 
 /* Run the child_prog, no matter what kind of command it uses.
  */
 static int pseudo_exec(struct child_prog *child)
 {
 	struct built_in_command *x;
 #ifdef BB_FEATURE_SH_STANDALONE_SHELL
 	char *name;
 #endif
 
 	/* Check if the command matches any of the non-forking builtins.
 	 * Depending on context, this might be redundant.  But it's
 	 * easier to waste a few CPU cycles than it is to figure out
 	 * if this is one of those cases.
 	 */
 	for (x = bltins; x->cmd; x++) {
 		if (strcmp(child->argv[0], x->cmd) == 0 ) {
 			exit(x->function(child));
 		}
 	}
 
 	/* Check if the command matches any of the forking builtins. */
 	for (x = bltins_forking; x->cmd; x++) {
 		if (strcmp(child->argv[0], x->cmd) == 0) {
 			applet_name=x->cmd;
 			exit (x->function(child));
 		}
 	}
 #ifdef BB_FEATURE_SH_STANDALONE_SHELL
 	/* Check if the command matches any busybox internal
 	 * commands ("applets") here.  Following discussions from
 	 * November 2000 on busybox@opensource.lineo.com, don't use
 	 * get_last_path_component().  This way explicit (with
 	 * slashes) filenames will never be interpreted as an
 	 * applet, just like with builtins.  This way the user can
 	 * override an applet with an explicit filename reference.
 	 * The only downside to this change is that an explicit
 	 * /bin/foo invocation will fork and exec /bin/foo, even if
 	 * /bin/foo is a symlink to busybox.
 	 */
 	name = child->argv[0];
 
 #ifdef BB_FEATURE_SH_APPLETS_ALWAYS_WIN
 	/* If you enable BB_FEATURE_SH_APPLETS_ALWAYS_WIN, then
 	 * if you run /bin/cat, it will use BusyBox cat even if 
 	 * /bin/cat exists on the filesystem and is _not_ busybox.
 	 * Some systems want this, others do not.  Choose wisely.  :-)
 	 */
 	name = get_last_path_component(name);
 #endif
 
 	{
 	    char** argv_l=child->argv;
 	    int argc_l;
 	    for(argc_l=0;*argv_l!=NULL; argv_l++, argc_l++);
 	    optind = 1;
 	    run_applet_by_name(name, argc_l, child->argv);
 	}
 #endif
 
 	execvp(child->argv[0], child->argv);
 	perror_msg_and_die("%s", child->argv[0]);
 }
 
 static void insert_job(struct job *newjob, int inbg)
 {
 	struct job *thejob;
 	struct jobset *j_list=newjob->job_list;
 
 	/* find the ID for thejob to use */
 	newjob->jobid = 1;
 	for (thejob = j_list->head; thejob; thejob = thejob->next)
 		if (thejob->jobid >= newjob->jobid)
 			newjob->jobid = thejob->jobid + 1;
 
 	/* add thejob to the list of running jobs */
 	if (!j_list->head) {
 		thejob = j_list->head = xmalloc(sizeof(*thejob));
 	} else {
 		for (thejob = j_list->head; thejob->next; thejob = thejob->next) /* nothing */;
 		thejob->next = xmalloc(sizeof(*thejob));
 		thejob = thejob->next;
 	}
 
 	*thejob = *newjob;   /* physically copy the struct job */
 	thejob->next = NULL;
 	thejob->running_progs = thejob->num_progs;
 	thejob->stopped_progs = 0;
 
 	if (inbg) {
 		/* we don't wait for background thejobs to return -- append it 
 		   to the list of backgrounded thejobs and leave it alone */
 		printf("[%d] %d\n", thejob->jobid,
 			   newjob->progs[newjob->num_progs - 1].pid);
 #ifdef BB_FEATURE_SH_ENVIRONMENT
 		last_bg_pid=newjob->progs[newjob->num_progs - 1].pid;
 #endif
 	} else {
 		newjob->job_list->fg = thejob;
 
 		/* move the new process group into the foreground */
 		/* suppress messages when run from /linuxrc mag@sysgo.de */
 		if (tcsetpgrp(0, newjob->pgrp) && errno != ENOTTY)
 			perror_msg("tcsetpgrp");
 	}
 }
 
 static int run_command(struct job *newjob, int inbg, int outpipe[2])
 {
 	/* struct job *thejob; */
 	int i;
 	int nextin, nextout;
 	int pipefds[2];				/* pipefd[0] is for reading */
 	struct built_in_command *x;
 	struct child_prog *child;
 
 	nextin = 0, nextout = 1;
 	for (i = 0; i < newjob->num_progs; i++) {
 		child = & (newjob->progs[i]);
 
 		if ((i + 1) < newjob->num_progs) {
 			if (pipe(pipefds)<0) perror_msg_and_die("pipe");
 			nextout = pipefds[1];
 		} else {
 			if (outpipe[1]!=-1) {
 				nextout = outpipe[1];
 			} else {
 				nextout = 1;
 			}
 		}
 
 #ifdef BB_FEATURE_SH_ENVIRONMENT
 		if (show_x_trace==TRUE) {
 			int j;
 			fputc('+', stderr);
 			for (j = 0; child->argv[j]; j++) {
 				fputc(' ', stderr);
 				fputs(child->argv[j], stderr);
 			}
 			fputc('\n', stderr);
 		}
 #endif
 
 		/* Check if the command matches any non-forking builtins,
 		 * but only if this is a simple command.
 		 * Non-forking builtins within pipes have to fork anyway,
 		 * and are handled in pseudo_exec.  "echo foo | read bar"
 		 * is doomed to failure, and doesn't work on bash, either.
 		 */
 		if (newjob->num_progs == 1) {
 			for (x = bltins; x->cmd; x++) {
 				if (strcmp(child->argv[0], x->cmd) == 0 ) {
 					int squirrel[] = {-1, -1, -1};
 					int rcode;
 					setup_redirects(child, squirrel);
 					rcode = x->function(child);
 					restore_redirects(squirrel);
 					return rcode;
 				}
 			}
 		}
 
 		if (!(child->pid = fork())) {
 			signal(SIGTTOU, SIG_DFL);
 
 			close_all();
 
 			if (outpipe[1]!=-1) {
 				close(outpipe[0]);
 			}
 			if (nextin != 0) {
 				dup2(nextin, 0);
 				close(nextin);
 			}
 
 			if (nextout != 1) {
 				dup2(nextout, 1);
 				dup2(nextout, 2);  /* Really? */
 				close(nextout);
 				close(pipefds[0]);
 			}
 
 			/* explicit redirects override pipes */
 			setup_redirects(child,NULL);
 
 			pseudo_exec(child);
 		}
 		if (outpipe[1]!=-1) {
 			close(outpipe[1]);
 		}
 
 		/* put our child in the process group whose leader is the
 		   first process in this pipe */
 		setpgid(child->pid, newjob->progs[0].pid);
 		if (nextin != 0)
 			close(nextin);
 		if (nextout != 1)
 			close(nextout);
 
 		/* If there isn't another process, nextin is garbage 
 		   but it doesn't matter */
 		nextin = pipefds[0];
 	}
 
 	newjob->pgrp = newjob->progs[0].pid;
 
 	insert_job(newjob, inbg);
 
 	return 0;
 }
 
 static int busy_loop(FILE * input)
 {
 	char *command;
 	char *next_command = NULL;
 	struct job newjob;
 	pid_t  parent_pgrp;
 	int i;
 	int inbg;
 	int status;
 	newjob.job_list = &job_list;
 	newjob.job_context = DEFAULT_CONTEXT;
 
 	/* save current owner of TTY so we can restore it on exit */
 	parent_pgrp = tcgetpgrp(0);
 
 	command = (char *) xcalloc(BUFSIZ, sizeof(char));
 
 	/* don't pay any attention to this signal; it just confuses 
 	   things and isn't really meant for shells anyway */
 	signal(SIGTTOU, SIG_IGN);
 
 	while (1) {
 		if (!job_list.fg) {
 			/* no job is in the foreground */
 
 			/* see if any background processes have exited */
 			checkjobs(&job_list);
 
 			if (!next_command) {
 				if (get_command(input, command))
 					break;
 				next_command = command;
 			}
 
 			if (expand_arguments(next_command) == FALSE) {
 				free(command);
 				command = (char *) xcalloc(BUFSIZ, sizeof(char));
 				next_command = NULL;
 				continue;
 			}
 
 			if (!parse_command(&next_command, &newjob, &inbg) &&
 				newjob.num_progs) {
 				int pipefds[2] = {-1,-1};
 				debug_printf( "job=%p fed to run_command by busy_loop()'\n", 
 						&newjob);
 				run_command(&newjob, inbg, pipefds);
 			}
 			else {
 				free(command);
 				command = (char *) xcalloc(BUFSIZ, sizeof(char));
 				next_command = NULL;
 			}
 		} else {
 			/* a job is running in the foreground; wait for it */
 			i = 0;
 			while (!job_list.fg->progs[i].pid ||
 				   job_list.fg->progs[i].is_stopped == 1) i++;
 
 			if (waitpid(job_list.fg->progs[i].pid, &status, WUNTRACED)<0)
 				perror_msg_and_die("waitpid(%d)",job_list.fg->progs[i].pid);
 
 			if (WIFEXITED(status) || WIFSIGNALED(status)) {
 				/* the child exited */
 				job_list.fg->running_progs--;
 				job_list.fg->progs[i].pid = 0;
 
 #ifdef BB_FEATURE_SH_ENVIRONMENT
 				last_return_code=WEXITSTATUS(status);
 				debug_printf("'%s' exited -- return code %d\n",
 						job_list.fg->text, last_return_code);
 #endif
 				if (!job_list.fg->running_progs) {
 					/* child exited */
 					remove_job(&job_list, job_list.fg);
 					job_list.fg = NULL;
 				}
 			} else {
 				/* the child was stopped */
 				job_list.fg->stopped_progs++;
 				job_list.fg->progs[i].is_stopped = 1;
 
 				if (job_list.fg->stopped_progs == job_list.fg->running_progs) {
 					printf("\n" JOB_STATUS_FORMAT, job_list.fg->jobid,
 						   "Stopped", job_list.fg->text);
 					job_list.fg = NULL;
 				}
 			}
 
 			if (!job_list.fg) {
 				/* move the shell to the foreground */
 				/* suppress messages when run from /linuxrc mag@sysgo.de */
 				if (tcsetpgrp(0, getpgrp()) && errno != ENOTTY)
 					perror_msg("tcsetpgrp"); 
 			}
 		}
 	}
 	free(command);
 
 	/* return controlling TTY back to parent process group before exiting */
 	if (tcsetpgrp(0, parent_pgrp))
 		perror_msg("tcsetpgrp");
 
 	/* return exit status if called with "-c" */
 	if (input == NULL && WIFEXITED(status))
 		return WEXITSTATUS(status);
 	
 	return 0;
 }
 
 
 #ifdef BB_FEATURE_CLEAN_UP
 void free_memory(void)
 {
 	if (cwd) {
 		free(cwd);
 	}
 	if (local_pending_command)
 		free(local_pending_command);
 
 	if (job_list.fg && !job_list.fg->running_progs) {
 		remove_job(&job_list, job_list.fg);
 	}
 }
 #endif
 
 
 int shell_main(int argc_l, char **argv_l)
 {
 	int opt, interactive=FALSE;
 	FILE *input = stdin;
 	argc = argc_l;
 	argv = argv_l;
 
 	/* These variables need re-initializing when recursing */
 	shell_context = 0;
 	local_pending_command = NULL;
 	close_me_head = NULL;
 	job_list.head = NULL;
 	job_list.fg = NULL;
 #ifdef BB_FEATURE_SH_ENVIRONMENT
 	last_bg_pid=1;
 	last_return_code=1;
 	show_x_trace=FALSE;
 #endif
 
 	if (argv[0] && argv[0][0] == '-') {
 		FILE *prof_input;
 		prof_input = fopen("/etc/profile", "r");
 		if (!prof_input) {
 			printf( "Couldn't open file '/etc/profile'\n");
 		} else {
 			int tmp_fd = fileno(prof_input);
 			mark_open(tmp_fd);	
 			/* Now run the file */
 			busy_loop(prof_input);
 			fclose(prof_input);
 			mark_closed(tmp_fd);
 		}
 	}
 
 	while ((opt = getopt(argc_l, argv_l, "cxi")) > 0) {
 		switch (opt) {
 			case 'c':
 				input = NULL;
 				if (local_pending_command != 0)
 					error_msg_and_die("multiple -c arguments");
 				local_pending_command = xstrdup(argv[optind]);
 				optind++;
 				argv = argv+optind;
 				break;
 #ifdef BB_FEATURE_SH_ENVIRONMENT
 			case 'x':
 				show_x_trace = TRUE;
 				break;
 #endif
 			case 'i':
 				interactive = TRUE;
 				break;
 			default:
 				show_usage();
 		}
 	}
 	/* A shell is interactive if the `-i' flag was given, or if all of
 	 * the following conditions are met:
 	 *	  no -c command
 	 *    no arguments remaining or the -s flag given
 	 *    standard input is a terminal
 	 *    standard output is a terminal
 	 *    Refer to Posix.2, the description of the `sh' utility. */
 	if (argv[optind]==NULL && input==stdin &&
 			isatty(fileno(stdin)) && isatty(fileno(stdout))) {
 		interactive=TRUE;
 	}
 	if (interactive==TRUE) {
 		//printf( "optind=%d  argv[optind]='%s'\n", optind, argv[optind]);
 		/* Looks like they want an interactive shell */
 		printf( "\n\n" BB_BANNER " Built-in shell (lash)\n");
 		printf( "Enter 'help' for a list of built-in commands.\n\n");
 	} else if (local_pending_command==NULL) {
 		//printf( "optind=%d  argv[optind]='%s'\n", optind, argv[optind]);
 		input = xfopen(argv[optind], "r");
 		mark_open(fileno(input));  /* be lazy, never mark this closed */
 	}
 
 	/* initialize the cwd -- this is never freed...*/
 	cwd = xgetcwd(0);
 	if (!cwd)
 		cwd = unknown;
 
 #ifdef BB_FEATURE_CLEAN_UP
 	atexit(free_memory);
 #endif
 
 #ifdef BB_FEATURE_COMMAND_EDITING
 	cmdedit_set_initial_prompt();
 #else
 	PS1 = NULL;
 #endif
 	
 	return (busy_loop(input));
 }
 
diff --git a/tail.c b/tail.c
index ff77bde..4fe92ba 100644
--- a/tail.c
+++ b/tail.c
@@ -1,247 +1,247 @@
 /* vi: set sw=4 ts=4: */
 /*
  * Mini tail implementation for busybox
  *
  *
  * Copyright (C) 2001 by Matt Kraai <kraai@alumni.carnegiemellon.edu>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
  * General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
  *
  */
 
 
 #include <fcntl.h>
 #include <getopt.h>
 #include <string.h>
 #include <stdlib.h>
 #include <unistd.h>
 #include <sys/types.h>
 #include "busybox.h"
 
 static const struct suffix_mult tail_suffixes[] = {
 	{ "b", 512 },
 	{ "k", 1024 },
 	{ "m", 1048576 },
 	{ NULL, 0 }
 };
 
 static const int BYTES = 0;
 static const int LINES = 1;
 
 static char *tailbuf;
 static int taillen;
 static int newline;
 
 static void tailbuf_append(char *buf, int len)
 {
 	tailbuf = xrealloc(tailbuf, taillen + len);
 	memcpy(tailbuf + taillen, buf, len);
 	taillen += len;
 }
 
 static void tailbuf_trunc()
 {
 	char *s;
 	s = memchr(tailbuf, '\n', taillen);
 	memmove(tailbuf, s + 1, taillen - ((s + 1) - tailbuf));
 	taillen -= (s + 1) - tailbuf;
 	newline = 0;
 }
 
 int tail_main(int argc, char **argv)
 {
 	int from_top = 0, units = LINES, count = 10, sleep_period = 1;
 	int show_headers = 0, hide_headers = 0, follow = 0;
 	int *fds, nfiles = 0, status = EXIT_SUCCESS, nread, nwrite, seen = 0;
 	char *s, *start, *end, buf[BUFSIZ];
 	int i, opt;
 
 	while ((opt = getopt(argc, argv, "c:fhn:q:s:v")) > 0) {
 		switch (opt) {
 			case 'f':
 				follow = 1;
 				break;
-#ifndef BB_FEATURE_SIMPLE_TAIL
+#ifdef BB_FEATURE_FANCY_TAIL
 			case 'c':
 				units = BYTES;
 				/* FALLS THROUGH */
 #endif
 			case 'n':
 				count = parse_number(optarg, tail_suffixes);
 				if (count < 0)
 					count = -count;
 				if (optarg[0] == '+')
 					from_top = 1;
 				break;
-#ifndef BB_FEATURE_SIMPLE_TAIL
+#ifdef BB_FEATURE_FANCY_TAIL
 			case 'q':
 				hide_headers = 1;
 				break;
 			case 's':
 				sleep_period = parse_number(optarg, 0);
 				break;
 			case 'v':
 				show_headers = 1;
 				break;
 #endif
 			default:
 				show_usage();
 		}
 	}
 
 	/* open all the files */
 	fds = (int *)xmalloc(sizeof(int) * (argc - optind + 1));
 	if (argc == optind) {
 		fds[nfiles++] = STDIN_FILENO;
 		argv[optind] = "standard input";
 	} else {
 		for (i = optind; i < argc; i++) {
 			if (strcmp(argv[i], "-") == 0) {
 				fds[nfiles++] = STDIN_FILENO;
 				argv[i] = "standard input";
 			} else if ((fds[nfiles++] = open(argv[i], O_RDONLY)) < 0) {
 				perror_msg("%s", argv[i]);
 				status = EXIT_FAILURE;
 			}
 		}
 	}
 	
-#ifndef BB_FEATURE_SIMPLE_TAIL
+#ifdef BB_FEATURE_FANCY_TAIL
 	/* tail the files */
 	if (!from_top && units == BYTES)
 		tailbuf = xmalloc(count);
 #endif
 
 	for (i = 0; i < nfiles; i++) {
 		if (fds[i] == -1)
 			continue;
 		seen = 0;
 		if (show_headers || (!hide_headers && nfiles > 1))
 			printf("%s==> %s <==\n", i == 0 ? "" : "\n", argv[optind + i]);
 		while ((nread = safe_read(fds[i], buf, sizeof(buf))) > 0) {
 			if (from_top) {
-#ifndef BB_FEATURE_SIMPLE_TAIL
+#ifdef BB_FEATURE_FANCY_TAIL
 				if (units == BYTES) {
 					if (count - 1 <= seen)
 						nwrite = nread;
 					else if (count - 1 <= seen + nread)
 						nwrite = nread + seen - (count - 1);
 					else
 						nwrite = 0;
 					seen += nread;
 				} else {
 #else
 				{
 #endif
 					if (count - 1 <= seen)
 						nwrite = nread;
 					else {
 						nwrite = 0;
 						for (s = memchr(buf, '\n', nread); s != NULL;
 								s = memchr(s+1, '\n', nread - (s + 1 - buf))) {
 							if (count - 1 <= ++seen) {
 								nwrite = nread - (s + 1 - buf);
 								break;
 							}
 						}
 					}
 				}
 				if (full_write(STDOUT_FILENO, buf + nread - nwrite,
 							nwrite) < 0) {
 					perror_msg("write");
 					status = EXIT_FAILURE;
 					break;
 				}
 			} else {
-#ifndef BB_FEATURE_SIMPLE_TAIL
+#ifdef BB_FEATURE_FANCY_TAIL
 				if (units == BYTES) {
 					if (nread < count) {
 						memmove(tailbuf, tailbuf + nread, count - nread);
 						memcpy(tailbuf + count - nread, buf, nread);
 					} else {
 						memcpy(tailbuf, buf + nread - count, count);
 					}
 					seen += nread;
 				} else {
 #else
 				{
 #endif
 					for (start = buf, end = memchr(buf, '\n', nread);
 							end != NULL; start = end+1,
 							end = memchr(start, '\n', nread - (start - buf))) {
 						if (newline && count <= seen)
 							tailbuf_trunc();
 						tailbuf_append(start, end - start + 1);
 						seen++;
 						newline = 1;
 					}
 					if (newline && count <= seen && nread - (start - buf) > 0)
 						tailbuf_trunc();
 					tailbuf_append(start, nread - (start - buf));
 				}
 			}
 		}
 
 		if (nread < 0) {
 			perror_msg("read");
 			status = EXIT_FAILURE;
 		}
 
-#ifndef BB_FEATURE_SIMPLE_TAIL
+#ifdef BB_FEATURE_FANCY_TAIL
 		if (!from_top && units == BYTES) {
 			if (count < seen)
 				seen = count;
 			if (full_write(STDOUT_FILENO, tailbuf + count - seen, seen) < 0) {
 				perror_msg("write");
 				status = EXIT_FAILURE;
 			}
 		}
 #endif
 
 		if (!from_top && units == LINES) {
 			if (full_write(STDOUT_FILENO, tailbuf, taillen) < 0) {
 				perror_msg("write");
 				status = EXIT_FAILURE;
 			}
 		}
 
 		taillen = 0;
 	}
 
 	while (follow) {
 		sleep(sleep_period);
 
 		for (i = 0; i < nfiles; i++) {
 			if (fds[i] == -1)
 				continue;
 
 			if ((nread = safe_read(fds[i], buf, sizeof(buf))) > 0) {
 				if (show_headers || (!hide_headers && nfiles > 1))
 					printf("\n==> %s <==\n", argv[optind + i]);
 
 				do {
 					full_write(STDOUT_FILENO, buf, nread);
 				} while ((nread = safe_read(fds[i], buf, sizeof(buf))) > 0);
 			}
 
 			if (nread < 0) {
 				perror_msg("read");
 				status = EXIT_FAILURE;
 			}
 		}
 	}
 
 	return status;
 }
diff --git a/usage.h b/usage.h
index b442e8b..63c00c6 100644
--- a/usage.h
+++ b/usage.h
@@ -1,1770 +1,1770 @@
 #define adjtimex_trivial_usage \
 	"[-q] [-o offset] [-f frequency] [-p timeconstant] [-t tick]"
 #define adjtimex_full_usage \
 	"Reads and optionally sets system timebase parameters.\n" \
 	"See adjtimex(2).\n\n" \
 	"Options:\n" \
 	"\t-q\t\tquiet mode - do not print\n" \
 	"\t-o offset\ttime offset, microseconds\n" \
 	"\t-f frequency\tfrequency adjust, integer kernel units (65536 is 1ppm)\n" \
 	"\t\t\t(positive values make the system clock run fast)\n" \
 	"\t-t tick\t\tmicroseconds per tick, usually 10000\n" \
 	"\t-p timeconstant\n"
 
 #define ar_trivial_usage \
 	"-[ovR]{ptx} ARCHIVE FILES"
 #define ar_full_usage \
 	"Extract or list FILES from an ar archive.\n\n" \
 	"Options:\n" \
 	"\t-o\t\tpreserve original dates\n" \
 	"\t-p\t\textract to stdout\n" \
 	"\t-t\t\tlist\n" \
 	"\t-x\t\textract\n" \
 	"\t-v\t\tverbosely list files processed\n" \
 	"\t-R\t\trecursive action"
 
 #define basename_trivial_usage \
 	"FILE [SUFFIX]"
 #define basename_full_usage \
 	"Strips directory path and suffixes from FILE.\n" \
 	"If specified, also removes any trailing SUFFIX."
 #define basename_example_usage \
 	"$ basename /usr/local/bin/foo\n" \
 	"foo\n" \
 	"$ basename /usr/local/bin/\n" \
 	"bin\n" \
 	"$ basename /foo/bar.txt .txt\n" \
 	"bar"
 
 #define cat_trivial_usage \
 	"[FILE]..."
 #define cat_full_usage \
 	"Concatenates FILE(s) and prints them to stdout."
 #define cat_example_usage \
 	"$ cat /proc/uptime\n" \
 	"110716.72 17.67"
 
 #define chgrp_trivial_usage \
 	"[OPTION]... GROUP FILE..."
 #define chgrp_full_usage \
 	"Change the group membership of each FILE to GROUP.\n" \
 	"\nOptions:\n" \
 	"\t-R\tChanges files and directories recursively."
 #define chgrp_example_usage \
 	"$ ls -l /tmp/foo\n" \
 	"-r--r--r--    1 andersen andersen        0 Apr 12 18:25 /tmp/foo\n" \
 	"$ chgrp root /tmp/foo\n" \
 	"$ ls -l /tmp/foo\n" \
 	"-r--r--r--    1 andersen root            0 Apr 12 18:25 /tmp/foo\n"
 
 #define chmod_trivial_usage \
 	"[-R] MODE[,MODE]... FILE..."
 #define chmod_full_usage \
 	"Each MODE is one or more of the letters ugoa, one of the\n" \
 	"symbols +-= and one or more of the letters rwxst.\n\n" \
 	"Options:\n" \
 	"\t-R\tChanges files and directories recursively."
 #define chmod_example_usage \
 	"$ ls -l /tmp/foo\n" \
 	"-rw-rw-r--    1 root     root            0 Apr 12 18:25 /tmp/foo\n" \
 	"$ chmod u+x /tmp/foo\n" \
 	"$ ls -l /tmp/foo\n" \
 	"-rwxrw-r--    1 root     root            0 Apr 12 18:25 /tmp/foo*\n" \
 	"$ chmod 444 /tmp/foo\n" \
 	"$ ls -l /tmp/foo\n" \
 	"-r--r--r--    1 root     root            0 Apr 12 18:25 /tmp/foo\n"
 
 #define chown_trivial_usage \
 	"[ -Rh ]...  OWNER[<.|:>[GROUP]] FILE..."
 #define chown_full_usage \
 	"Change the owner and/or group of each FILE to OWNER and/or GROUP.\n" \
 	"\nOptions:\n" \
 	"\t-R\tChanges files and directories recursively.\n" \
 	"\t-h\tDo not dereference symbolic links."
 #define chown_example_usage \
 	"$ ls -l /tmp/foo\n" \
 	"-r--r--r--    1 andersen andersen        0 Apr 12 18:25 /tmp/foo\n" \
 	"$ chown root /tmp/foo\n" \
 	"$ ls -l /tmp/foo\n" \
 	"-r--r--r--    1 root     andersen        0 Apr 12 18:25 /tmp/foo\n" \
 	"$ chown root.root /tmp/foo\n" \
 	"ls -l /tmp/foo\n" \
 	"-r--r--r--    1 root     root            0 Apr 12 18:25 /tmp/foo\n"
 
 #define chroot_trivial_usage \
 	"NEWROOT [COMMAND...]"
 #define chroot_full_usage \
 	"Run COMMAND with root directory set to NEWROOT."
 #define chroot_example_usage \
 	"$ ls -l /bin/ls\n" \
 	"lrwxrwxrwx    1 root     root          12 Apr 13 00:46 /bin/ls -> /BusyBox\n" \
 	"$ mount /dev/hdc1 /mnt -t minix\n" \
 	"$ chroot /mnt\n" \
 	"$ ls -l /bin/ls\n" \
 	"-rwxr-xr-x    1 root     root        40816 Feb  5 07:45 /bin/ls*\n"
 
 #define chvt_trivial_usage \
 	"N"
 #define chvt_full_usage \
 	"Changes the foreground virtual terminal to /dev/ttyN"
 
 #define clear_trivial_usage \
 	""
 #define clear_full_usage \
 	"Clear screen."
 
 #define cmp_trivial_usage \
 	"FILE1 [FILE2]"
 #define cmp_full_usage \
 	"\t-s\tquiet mode - do not print\n" \
 	"Compare files."
 
 #define cp_trivial_usage \
 	"[OPTION]... SOURCE DEST"
 #define cp_full_usage \
 	"Copies SOURCE to DEST, or multiple SOURCE(s) to DIRECTORY.\n" \
 	"\n" \
 	"\t-a\tSame as -dpR\n" \
 	"\t-d\tPreserves links\n" \
 	"\t-p\tPreserves file attributes if possible\n" \
 	"\t-f\tforce (implied; ignored) - always set\n" \
 	"\t-R\tCopies directories recursively"
 
 #define cut_trivial_usage \
 	"[OPTION]... [FILE]..."
 #define cut_full_usage \
 	"Prints selected fields from each input FILE to standard output.\n\n" \
 	"Options:\n" \
 	"\t-b LIST\t\tOutput only bytes from LIST\n" \
 	"\t-c LIST\t\tOutput only characters from LIST\n" \
 	"\t-d CHAR\t\tUse CHAR instead of tab as the field delimiter\n" \
 	"\t-s\t\tOutput only the lines containing delimiter\n" \
 	"\t-f N\t\tPrint only these fields\n" \
 	"\t-n\t\tIgnored"
 #define cut_example_usage \
 	"$ echo "Hello world" | cut -f 1 -d ' '\n" \
 	"Hello\n" \
 	"$ echo "Hello world" | cut -f 2 -d ' '\n" \
 	"world\n"
 
 #define date_trivial_usage \
 	"[OPTION]... [+FORMAT]"
 #define date_full_usage \
 	"Displays the current time in the given FORMAT, or sets the system date.\n" \
 	"\nOptions:\n" \
 	"\t-R\t\tOutputs RFC-822 compliant date string\n" \
 	"\t-d STRING\tdisplay time described by STRING, not `now'\n" \
 	"\t-s\t\tSets time described by STRING\n" \
 	"\t-u\t\tPrints or sets Coordinated Universal Time"
 #define date_example_usage \
 	"$ date\n" \
 	"Wed Apr 12 18:52:41 MDT 2000\n"
 
 #define dc_trivial_usage \
 	"expression ..."
 #define dc_full_usage \
 	"This is a Tiny RPN calculator that understands the\n" \
 	"following operations: +, -, /, *, and, or, not, eor.\n" \
 	"i.e. 'dc 2 2 add' -> 4, and 'dc 8 8 \\* 2 2 + /' -> 16"
 #define dc_example_usage \
 	"$ dc 2 2 +\n" \
 	"4\n" \
 	"$ dc 8 8 \* 2 2 + /\n" \
 	"16\n" \
 	"$ dc 0 1 and\n" \
 	"0\n" \
 	"$ dc 0 1 or\n" \
 	"1\n" \
 	"$ echo 72 9 div 8 mul | dc\n" \
 	"64\n"
 
 #define dd_trivial_usage \
 	"[if=FILE] [of=FILE] [bs=N] [count=N] [skip=N]\n" \
 	"\t  [seek=N] [conv=notrunc|sync]"
 #define dd_full_usage \
 	"Copy a file, converting and formatting according to options\n\n" \
 	"\tif=FILE\t\tread from FILE instead of stdin\n" \
 	"\tof=FILE\t\twrite to FILE instead of stdout\n" \
 	"\tbs=N\t\tread and write N bytes at a time\n" \
 	"\tcount=N\t\tcopy only N input blocks\n" \
 	"\tskip=N\t\tskip N input blocks\n" \
 	"\tseek=N\t\tskip N output blocks\n" \
 	"\tconv=notrunc\tdon't truncate output file\n" \
 	"\tconv=sync\tpad blocks with zeros\n" \
 	"\n" \
 	"Numbers may be suffixed by c (x1), w (x2), b (x512), kD (x1000), k (x1024),\n" \
 	"MD (x1000000), M (x1048576), GD (x1000000000) or G (x1073741824)."
 #define dd_example_usage \
 	"$ dd if=/dev/zero of=/dev/ram1 bs=1M count=4\n" \
 	"4+0 records in\n" \
 	"4+0 records out\n"
 
 #define deallocvt_trivial_usage \
 	"N"
 #define deallocvt_full_usage \
 	 "Deallocate unused virtual terminal /dev/ttyN"
 
 
 #ifdef BB_FEATURE_HUMAN_READABLE
   #define USAGE_HUMAN_READABLE(a) a
   #define USAGE_NOT_HUMAN_READABLE(a)
 #else
   #define USAGE_HUMAN_READABLE(a) 
   #define USAGE_NOT_HUMAN_READABLE(a) a
 #endif
 #define df_trivial_usage \
 	"[-" USAGE_HUMAN_READABLE("hm") USAGE_NOT_HUMAN_READABLE("") "k] [FILESYSTEM ...]"
 #define df_full_usage \
 	"Print the filesystem space used and space available.\n\n" \
 	"Options:\n" \
 	USAGE_HUMAN_READABLE( \
 	"\n\t-h\tprint sizes in human readable format (e.g., 1K 243M 2G )\n" \
 	"\t-m\tprint sizes in megabytes\n" \
 	"\t-k\tprint sizes in kilobytes(default)") USAGE_NOT_HUMAN_READABLE( \
 	"\n\t-k\tprint sizes in kilobytes(compatability)")
 #define df_example_usage \
 	"$ df\n" \
 	"Filesystem           1k-blocks      Used Available Use% Mounted on\n" \
 	"/dev/sda3              8690864   8553540    137324  98% /\n" \
 	"/dev/sda1                64216     36364     27852  57% /boot\n" \
 	"$ df /dev/sda3\n" \
 	"Filesystem           1k-blocks      Used Available Use% Mounted on\n" \
 	"/dev/sda3              8690864   8553540    137324  98% /\n"
 
 #define dirname_trivial_usage \
 	"[FILENAME ...]"
 #define dirname_full_usage \
 	"Strips non-directory suffix from FILENAME"
 #define dirname_example_usage \
 	"$ dirname /tmp/foo\n" \
 	"/tmp\n" \
 	"$ dirname /tmp/foo/\n" \
 	"/tmp\n"
 
 #define dmesg_trivial_usage \
 	"[-c] [-n LEVEL] [-s SIZE]"
 #define dmesg_full_usage \
 	"Prints or controls the kernel ring buffer\n\n" \
 	"Options:\n" \
 	"\t-c\t\tClears the ring buffer's contents after printing\n" \
 	"\t-n LEVEL\tSets console logging level\n" \
 	"\t-s SIZE\t\tUse a buffer of size SIZE"
 
 #define dos2unix_trivial_usage \
 	"[option] [FILE]"
 #define dos2unix_full_usage \
 	"Converts FILE from dos format to unix format.  When no option\n" \
 	"is given, the input is converted to the opposite output format.\n" \
 	"When no file is given, uses stdin for input and stdout for output." \
 	"Options:\n" \
 	"\t-u\toutput will be in UNIX format\n" \
 	"\t-d\toutput will be in DOS format\n\n" \
 
 #define dpkg_trivial_usage \
 	"[-i|-r|--unpack|--configure] my.deb"
 #define dpkg_full_usage \
 	"WORK IN PROGRESS, only useful for debian-installer"
 
 #define dpkg_deb_trivial_usage \
 	"[-cefItxX] FILE [argument]"
 #define dpkg_deb_full_usage \
 	"Perform actions on debian packages (.debs)\n\n" \
 	"Options:\n" \
 	"\t-c\tList contents of filesystem tree\n" \
 	"\t-e\tExtract control files to [argument] directory\n" \
 	"\t-f\tDisplay control field name starting with [argument]\n" \
 	"\t-I\tDisplay the control filenamed [argument]\n" \
 	"\t-t\tExtract filesystem tree to stdout in tar format\n" \
 	"\t-x\tExctract packages filesystem tree to directory\n" \
 	"\t-X\tVerbose extract"
 #define dpkg_deb_example_usage \
 	"$ dpkg-deb -X ./busybox_0.48-1_i386.deb /tmp\n"
 
 #define du_trivial_usage \
 	"[-ls" USAGE_HUMAN_READABLE("hm") USAGE_NOT_HUMAN_READABLE("") "k] [FILE]..."
 #define du_full_usage \
 	"Summarizes disk space used for each FILE and/or directory.\n" \
 	"Disk space is printed in units of 1024 bytes.\n\n" \
 	"Options:\n" \
 	"\t-l\tcount sizes many times if hard linked\n" \
 	"\t-s\tdisplay only a total for each argument" \
 	USAGE_HUMAN_READABLE( \
 	"\n\t-h\tprint sizes in human readable format (e.g., 1K 243M 2G )\n" \
 	"\t-m\tprint sizes in megabytes\n" \
 	"\t-k\tprint sizes in kilobytes(default)") USAGE_NOT_HUMAN_READABLE( \
 	"\n\t-k\tprint sizes in kilobytes(compatability)")
 #define du_example_usage \
 	"$ du\n" \
 	"16      ./CVS\n" \
 	"12      ./kernel-patches/CVS\n" \
 	"80      ./kernel-patches\n" \
 	"12      ./tests/CVS\n" \
 	"36      ./tests\n" \
 	"12      ./scripts/CVS\n" \
 	"16      ./scripts\n" \
 	"12      ./docs/CVS\n" \
 	"104     ./docs\n" \
 	"2417    .\n"
 
 #define dumpkmap_trivial_usage \
 	"> keymap"
 #define dumpkmap_full_usage \
 	"Prints out a binary keyboard translation table to standard output."
 #define dumpkmap_example_usage \
 	"$ dumpkmap > keymap\n"
 
 #define dutmp_trivial_usage \
 	"[FILE]"
 #define dutmp_full_usage \
 	"Dump utmp file format (pipe delimited) from FILE\n" \
 	"or stdin to stdout.  (i.e. 'dutmp /var/run/utmp')"
 #define dutmp_example_usage \
 	"$ dutmp /var/run/utmp\n" \
 	"8|7||si|||0|0|0|955637625|760097|0\n" \
 	"2|0|~|~~|reboot||0|0|0|955637625|782235|0\n" \
 	"1|20020|~|~~|runlevel||0|0|0|955637625|800089|0\n" \
 	"8|125||l4|||0|0|0|955637629|998367|0\n" \
 	"6|245|tty1|1|LOGIN||0|0|0|955637630|998974|0\n" \
 	"6|246|tty2|2|LOGIN||0|0|0|955637630|999498|0\n" \
 	"7|336|pts/0|vt00andersen|andersen|:0.0|0|0|0|955637763|0|0\n"
 
 #define echo_trivial_usage \
 	"[-neE] [ARG ...]"
 #define echo_full_usage \
 	"Prints the specified ARGs to stdout\n\n" \
 	"Options:\n" \
 	"\t-n\tsuppress trailing newline\n" \
 	"\t-e\tinterpret backslash-escaped characters (i.e. \\t=tab etc)\n" \
 	"\t-E\tdisable interpretation of backslash-escaped characters"
 #define echo_example_usage \
 	"$ echo "Erik is cool"\n" \
 	"Erik is cool\n" \
 	"$  echo -e "Erik\\nis\\ncool"\n" \
 	"Erik\n" \
 	"is\n" \
 	"cool\n" \
 	"$ echo "Erik\\nis\\ncool"\n" \
 	"Erik\\nis\\ncool\n"
 
 #define env_trivial_usage \
 	"[-iu] [-] [name=value]... [command]"
 #define env_full_usage \
 	"Prints the current environment or runs a program after setting\n" \
 	"up the specified environment.\n\n" \
 	"Options:\n" \
 	"\t-, -i\tstart with an empty environment\n" \
 	"\t-u\tremove variable from the environment\n"
 
 #define expr_trivial_usage \
 	"EXPRESSION"
 #define expr_full_usage \
 	"Prints the value of EXPRESSION to standard output.\n\n" \
 	"EXPRESSION may be:\n" \
 	"\tARG1 |  ARG2	ARG1 if it is neither null nor 0, otherwise ARG2\n" \
 	"\tARG1 &  ARG2	ARG1 if neither argument is null or 0, otherwise 0\n" \
 	"\tARG1 <  ARG2	ARG1 is less than ARG2\n" \
 	"\tARG1 <= ARG2	ARG1 is less than or equal to ARG2\n" \
 	"\tARG1 =  ARG2	ARG1 is equal to ARG2\n" \
 	"\tARG1 != ARG2	ARG1 is unequal to ARG2\n" \
 	"\tARG1 >= ARG2	ARG1 is greater than or equal to ARG2\n" \
 	"\tARG1 >  ARG2	ARG1 is greater than ARG2\n" \
 	"\tARG1 +  ARG2	arithmetic sum of ARG1 and ARG2\n" \
 	"\tARG1 -  ARG2	arithmetic difference of ARG1 and ARG2\n" \
 	"\tARG1 *  ARG2	arithmetic product of ARG1 and ARG2\n" \
 	"\tARG1 /  ARG2	arithmetic quotient of ARG1 divided by ARG2\n" \
 	"\tARG1 %  ARG2	arithmetic remainder of ARG1 divided by ARG2\n" \
 	"\tSTRING : REGEXP             anchored pattern match of REGEXP in STRING\n" \
 	"\tmatch STRING REGEXP         same as STRING : REGEXP\n" \
 	"\tsubstr STRING POS LENGTH    substring of STRING, POS counted from 1\n" \
 	"\tindex STRING CHARS          index in STRING where any CHARS is found,\n" \
 	"\t                            or 0\n" \
 	"\tlength STRING               length of STRING\n" \
 	"\tquote TOKEN                 interpret TOKEN as a string, even if\n" \
 	"\t                            it is a keyword like `match' or an\n" \
 	"\t                            operator like `/'\n" \
 	"\t( EXPRESSION )              value of EXPRESSION\n\n" \
 	"Beware that many operators need to be escaped or quoted for shells.\n" \
 	"Comparisons are arithmetic if both ARGs are numbers, else\n" \
 	"lexicographical.  Pattern matches return the string matched between \n" \
 	"\\( and \\) or null; if \\( and \\) are not used, they return the number \n" \
 	"of characters matched or 0."
 
 #define false_trivial_usage \
 	""
 #define false_full_usage \
 	"Return an exit code of FALSE (1)."
 #define false_example_usage \
 	"$ false\n" \
 	"$ echo $?\n" \
 	"1\n"
 
 #define fbset_trivial_usage \
 	"[options] [mode]"
 #define fbset_full_usage \
 	"Show and modify frame buffer settings"
 #define fbset_example_usage \
 	"$ fbset\n" \
 	"mode "1024x768-76"\n" \
 	"\t# D: 78.653 MHz, H: 59.949 kHz, V: 75.694 Hz\n" \
 	"\tgeometry 1024 768 1024 768 16\n" \
 	"\ttimings 12714 128 32 16 4 128 4\n" \
 	"\taccel false\n" \
 	"\trgba 5/11,6/5,5/0,0/0\n" \
 	"endmode\n"
 
 #define fdflush_trivial_usage \
 	"DEVICE"
 #define fdflush_full_usage \
 	"Forces floppy disk drive to detect disk change"
 
 #ifdef BB_FEATURE_FIND_TYPE
   #define USAGE_FIND_TYPE(a) a
 #else
   #define USAGE_FIND_TYPE(a)
 #endif
 #ifdef BB_FEATURE_FIND_PERM
   #define USAGE_FIND_PERM(a) a
 #else
   #define USAGE_FIND_PERM(a)
 #endif
 #ifdef BB_FEATURE_FIND_MTIME
   #define USAGE_FIND_MTIME(a) a
 #else
   #define USAGE_FIND_MTIME(a)
 #endif
 
 #define find_trivial_usage \
 	"[PATH...] [EXPRESSION]"
 #define find_full_usage \
 	"Search for files in a directory hierarchy.  The default PATH is\n" \
 	"the current directory; default EXPRESSION is '-print'\n" \
 	"\nEXPRESSION may consist of:\n" \
 	"\t-follow\t\tDereference symbolic links.\n" \
 	"\t-name PATTERN\tFile name (leading directories removed) matches PATTERN.\n" \
 	"\t-print\t\tPrint (default and assumed).\n" \
 	USAGE_FIND_TYPE( \
 	"\n\t-type X\t\tFiletype matches X (where X is one of: f,d,l,b,c,...)" \
 ) USAGE_FIND_PERM( \
 	"\n\t-perm PERMS\tPermissions match any of (+NNN); all of (-NNN);\n\t\t\tor exactly (NNN)" \
 ) USAGE_FIND_MTIME( \
 	"\n\t-mtime TIME\tModified time is greater than (+N); less than (-N);\n\t\t\tor exactly (N) days")
 #define find_example_usage \
 	"$ find / -name /etc/passwd\n" \
 	"/etc/passwd\n"
 
 #define free_trivial_usage \
 	""
 #define free_full_usage \
 	"Displays the amount of free and used system memory"
 #define free_example_usage \
 	"$ free\n" \
 	"              total         used         free       shared      buffers\n" \
 	"  Mem:       257628       248724         8904        59644        93124\n" \
 	" Swap:       128516         8404       120112\n" \
 	"Total:       386144       257128       129016\n" \
 
 #define freeramdisk_trivial_usage \
 	"DEVICE"
 #define freeramdisk_full_usage \
 	"Frees all memory used by the specified ramdisk."
 #define freeramdisk_example_usage \
 	"$ freeramdisk /dev/ram2\n"
 
 #define fsck_minix_trivial_usage \
 	"[-larvsmf] /dev/name"
 #define fsck_minix_full_usage \
 	"Performs a consistency check for MINIX filesystems.\n\n" \
 	"Options:\n" \
 	"\t-l\tLists all filenames\n" \
 	"\t-r\tPerform interactive repairs\n" \
 	"\t-a\tPerform automatic repairs\n" \
 	"\t-v\tverbose\n" \
 	"\t-s\tOutputs super-block information\n" \
 	"\t-m\tActivates MINIX-like \"mode not cleared\" warnings\n" \
 	"\t-f\tForce file system check."
 
 #define getopt_trivial_usage \
 	"[OPTIONS]..."
 #define getopt_full_usage \
 	"Parse command options\n" \
 	"\t-a, --alternative		Allow long options starting with single -\n" \
 	"\t-l, --longoptions=longopts	Long options to be recognized\n" \
 	"\t-n, --name=progname		The name under which errors are reported\n" \
 	"\t-o, --options=optstring	Short options to be recognized\n" \
 	"\t-q, --quiet			Disable error reporting by getopt(3)\n" \
 	"\t-Q, --quiet-output		No normal output\n" \
 	"\t-s, --shell=shell		Set shell quoting conventions\n" \
 	"\t-T, --test			Test for getopt(1) version\n" \
 	"\t-u, --unqote			Do not quote the output"
 #define getopt_example_usage \
         "$ cat getopt.test\n" \
         "#!/bin/sh\n" \
         "GETOPT=`getopt -o ab:c:: --long a-long,b-long:,c-long:: \\\n" \
         "       -n 'example.busybox' -- "$@"`\n" \
         "if [ $? != 0 ] ; then  exit 1 ; fi\n" \
         "eval set -- "$GETOPT"\n" \
         "while true ; do\n" \
         " case $1 in\n" \
         "   -a|--a-long) echo \"Option a\" ; shift ;;\n" \
         "   -b|--b-long) echo \"Option b, argument \`$2'\" ; shift 2 ;;\n" \
         "   -c|--c-long)\n" \
         "     case "$2" in\n" \
         "       \"\") echo \"Option c, no argument\"; shift 2 ;;\n" \
         "       *)  echo \"Option c, argument \`$2'\" ; shift 2 ;;\n" \
         "     esac ;;\n" \
         "   --) shift ; break ;;\n" \
         "   *) echo \"Internal error!\" ; exit 1 ;;\n" \
         " esac\n" \
         "done\n"
 
 #define grep_trivial_usage \
 	"[-ihHnqvs] PATTERN [FILEs...]"
 #define grep_full_usage \
 	"Search for PATTERN in each FILE or standard input.\n\n" \
 	"Options:\n" \
 	"\t-H\tprefix output lines with filename where match was found\n" \
 	"\t-h\tsuppress the prefixing filename on output\n" \
 	"\t-i\tignore case distinctions\n" \
 	"\t-l\tlist names of files that match\n" \
 	"\t-n\tprint line number with output lines\n" \
 	"\t-q\tbe quiet. Returns 0 if result was found, 1 otherwise\n" \
 	"\t-v\tselect non-matching lines\n" \
 	"\t-s\tsuppress file open/read error messages"
 #define grep_example_usage \
 	"$ grep root /etc/passwd\n" \
 	"root:x:0:0:root:/root:/bin/bash\n" \
 	"$ grep ^[rR]oo. /etc/passwd\n" \
 	"root:x:0:0:root:/root:/bin/bash\n"
 
 #define gunzip_trivial_usage \
 	"[OPTION]... FILE"
 #define gunzip_full_usage \
 	"Uncompress FILE (or standard input if FILE is '-').\n\n" \
 	"Options:\n" \
 	"\t-c\tWrite output to standard output\n" \
 	"\t-t\tTest compressed file integrity"
 #define gunzip_example_usage \
 	"$ ls -la /tmp/BusyBox*\n" \
 	"-rw-rw-r--    1 andersen andersen   557009 Apr 11 10:55 /tmp/BusyBox-0.43.tar.gz\n" \
 	"$ gunzip /tmp/BusyBox-0.43.tar.gz\n" \
 	"$ ls -la /tmp/BusyBox*\n" \
 	"-rw-rw-r--    1 andersen andersen  1761280 Apr 14 17:47 /tmp/BusyBox-0.43.tar\n"
 
 #define gzip_trivial_usage \
 	"[OPTION]... FILE"
 #define gzip_full_usage \
 	"Compress FILE with maximum compression.\n" \
 	"When FILE is '-', reads standard input.  Implies -c.\n\n" \
 	"Options:\n" \
 	"\t-c\tWrite output to standard output instead of FILE.gz\n" \
 	"\t-d\tdecompress"
 #define gzip_example_usage \
 	"$ ls -la /tmp/busybox*\n" \
 	"-rw-rw-r--    1 andersen andersen  1761280 Apr 14 17:47 /tmp/busybox.tar\n" \
 	"$ gzip /tmp/busybox.tar\n" \
 	"$ ls -la /tmp/busybox*\n" \
 	"-rw-rw-r--    1 andersen andersen   554058 Apr 14 17:49 /tmp/busybox.tar.gz\n"
 
 #define halt_trivial_usage \
 	""
 #define halt_full_usage \
 	"Halt the system."
 
 #define head_trivial_usage \
 	"[OPTION] [FILE]..."
 #define head_full_usage \
 	"Print first 10 lines of each FILE to standard output.\n" \
 	"With more than one FILE, precede each with a header giving the\n" \
 	"file name. With no FILE, or when FILE is -, read standard input.\n\n" \
 	"Options:\n" \
 	"\t-n NUM\t\tPrint first NUM lines instead of first 10"
 #define head_example_usage \
 	"$ head -n 2 /etc/passwd\n" \
 	"root:x:0:0:root:/root:/bin/bash\n" \
 	"daemon:x:1:1:daemon:/usr/sbin:/bin/sh\n"
 
 #define hostid_trivial_usage \
 	""
 #define hostid_full_usage \
 	"Print out a unique 32-bit identifier for the machine."
 
 #define hostname_trivial_usage \
 	"[OPTION] {hostname | -F FILE}"
 #define hostname_full_usage \
 	"Get or set the hostname or DNS domain name. If a hostname is given\n" \
 	"(or FILE with the -F parameter), the host name will be set.\n\n" \
 	"Options:\n" \
 	"\t-s\t\tShort\n" \
 	"\t-i\t\tAddresses for the hostname\n" \
 	"\t-d\t\tDNS domain name\n" \
 	"\t-F, --file FILE\tUse the contents of FILE to specify the hostname"
 #define hostname_example_usage \
 	"$ hostname\n" \
 	"sage \n"
 
 #define id_trivial_usage \
 	"[OPTIONS]... [USERNAME]"
 #define id_full_usage \
 	"Print information for USERNAME or the current user\n\n" \
 	"Options:\n" \
 	"\t-g\tprints only the group ID\n" \
 	"\t-u\tprints only the user ID\n" \
 	"\t-n\tprint a name instead of a number (with for -ug)\n" \
 	"\t-r\tprints the real user ID instead of the effective ID (with -ug)"
 #define id_example_usage \
 	"$ id\n" \
 	"uid=1000(andersen) gid=1000(andersen)\n"
 
 #ifdef BB_FEATURE_IFCONFIG_SLIP
   #define USAGE_SIOCSKEEPALIVE(a) a
 #else
   #define USAGE_SIOCSKEEPALIVE(a)
 #endif
 #ifdef BB_FEATURE_IFCONFIG_MEMSTART_IOADDR_IRQ
   #define USAGE_IFCONFIG_MII(a) a
 #else
   #define USAGE_IFCONFIG_MII(a)
 #endif
 #ifdef BB_FEATURE_IFCONFIG_HW
   #define USAGE_IFCONFIG_HW(a) a
 #else
   #define USAGE_IFCONFIG_HW(a)
 #endif
 #ifdef BB_FEATURE_IFCONFIG_STATUS
   #define USAGE_IFCONFIG_OPT_A(a) a
 #else
   #define USAGE_IFCONFIG_OPT_A(a)
 #endif
 
 #define ifconfig_trivial_usage \
 	USAGE_IFCONFIG_OPT_A("[-a]") " <interface> [<address>]"
 #define ifconfig_full_usage \
 	"configure a network interface\n\n" \
 	"Options:\n" \
 	"\t[[-]broadcast [<address>]]  [[-]pointopoint [<address>]]\n" \
 	"\t[netmask <address>]  [dstaddr <address>]\n" \
 	USAGE_SIOCSKEEPALIVE("\t[outfill <NN>] [keepalive <NN>]\n") \
 	"\t" USAGE_IFCONFIG_HW("[hw ether <address>]  ") \
     "[metric <NN>]  [mtu <NN>]\n" \
 	"\t[[-]trailers]  [[-]arp]  [[-]allmulti]\n" \
 	"\t[multicast]  [[-]promisc]  [txqueuelen <NN>]  [[-]dynamic]\n" \
 	USAGE_IFCONFIG_MII("\t[mem_start <NN>]  [io_addr <NN>]  [irq <NN>]\n") \
 	"\t[up|down] ..."
 
 #define init_trivial_usage \
 	""
 #define init_full_usage \
 	"Init is the parent of all processes."
 #define init_notes_usage \
 "This version of init is designed to be run only by the kernel.\n" \
 "\n" \
 "BusyBox init doesn't support multiple runlevels.  The runlevels field of\n" \
 "the /etc/inittab file is completely ignored by BusyBox init. If you want \n" \
 "runlevels, use sysvinit.\n" \
 "\n" \
 "BusyBox init works just fine without an inittab.  If no inittab is found, \n" \
 "it has the following default behavior:\n" \
 "\n" \
 "	::sysinit:/etc/init.d/rcS\n" \
 "	::askfirst:/bin/sh\n" \
 "	::ctrlaltdel:/sbin/reboot\n" \
 "	::shutdown:/sbin/swapoff -a\n" \
 "	::shutdown:/bin/umount -a -r\n" \
 "\n" \
 "if it detects that /dev/console is _not_ a serial console, it will also run:\n" \
 "\n" \
 "	tty2::askfirst:/bin/sh\n" \
 "	tty3::askfirst:/bin/sh\n" \
 "	tty4::askfirst:/bin/sh\n" \
 "\n" \
 "If you choose to use an /etc/inittab file, the inittab entry format is as follows:\n" \
 "\n" \
 "	<id>:<runlevels>:<action>:<process>\n" \
 "\n" \
 "	<id>: \n" \
 "\n" \
 "		WARNING: This field has a non-traditional meaning for BusyBox init!\n" \
 "		The id field is used by BusyBox init to specify the controlling tty for\n" \
 "		the specified process to run on.  The contents of this field are\n" \
 "		appended to "/dev/" and used as-is.  There is no need for this field to\n" \
 "		be unique, although if it isn't you may have strange results.  If this\n" \
 "		field is left blank, the controlling tty is set to the console.  Also\n" \
 "		note that if BusyBox detects that a serial console is in use, then only\n" \
 "		entries whose controlling tty is either the serial console or /dev/null\n" \
 "		will be run.  BusyBox init does nothing with utmp.  We don't need no\n" \
 "		stinkin' utmp.\n" \
 "\n" \
 "	<runlevels>: \n" \
 "\n" \
 "		The runlevels field is completely ignored.\n" \
 "\n" \
 "	<action>: \n" \
 "\n" \
 "		Valid actions include: sysinit, respawn, askfirst, wait, \n" \
 "		once, ctrlaltdel, and shutdown.\n" \
 "\n" \
 "		The available actions can be classified into two groups: actions\n" \
 "		that are run only once, and actions that are re-run when the specified\n" \
 "		process exits.\n" \
 "\n" \
 "		Run only-once actions:\n" \
 "\n" \
 "			'sysinit' is the first item run on boot.  init waits until all\n" \
 "			sysinit actions are completed before continuing.  Following the\n" \
 "			completion of all sysinit actions, all 'wait' actions are run.\n" \
 "			'wait' actions, like  'sysinit' actions, cause init to wait until\n" \
 "			the specified task completes.  'once' actions are asyncronous,\n" \
 "			therefore, init does not wait for them to complete.  'ctrlaltdel'\n" \
 "			actions are run when the system detects that someone on the system\n" \
 "                       console has pressed the CTRL-ALT-DEL key combination.  Typically one\n" \
 "                       wants to run 'reboot' at this point to cause the system to reboot.\n" \
 "			Finally the 'shutdown' action specifies the actions to taken when\n" \
 "                       init is told to reboot.  Unmounting filesystems and disabling swap\n" \
 "                       is a very good here\n" \
 "\n" \
 "		Run repeatedly actions:\n" \
 "\n" \
 "			'respawn' actions are run after the 'once' actions.  When a process\n" \
 "			started with a 'respawn' action exits, init automatically restarts\n" \
 "			it.  Unlike sysvinit, BusyBox init does not stop processes from\n" \
 "			respawning out of control.  The 'askfirst' actions acts just like\n" \
 "			respawn, except that before running the specified process it\n" \
 "			displays the line "Please press Enter to activate this console."\n" \
 "			and then waits for the user to press enter before starting the\n" \
 "			specified process.  \n" \
 "\n" \
 "		Unrecognized actions (like initdefault) will cause init to emit an\n" \
 "		error message, and then go along with its business.  All actions are\n" \
 "		run in the reverse order from how they appear in /etc/inittab.\n" \
 "\n" \
 "	<process>: \n" \
 "\n" \
 "		Specifies the process to be executed and it's command line.\n" \
 "\n" \
 "Example /etc/inittab file:\n" \
 "\n" \
 "	# This is run first except when booting in single-user mode.\n" \
 "	#\n" \
 "	::sysinit:/etc/init.d/rcS\n" \
 "	\n" \
 "	# /bin/sh invocations on selected ttys\n" \
 "	#\n" \
 "	# Start an "askfirst" shell on the console (whatever that may be)\n" \
 "	::askfirst:-/bin/sh\n" \
 "	# Start an "askfirst" shell on /dev/tty2-4\n" \
 "	tty2::askfirst:-/bin/sh\n" \
 "	tty3::askfirst:-/bin/sh\n" \
 "	tty4::askfirst:-/bin/sh\n" \
 "	\n" \
 "	# /sbin/getty invocations for selected ttys\n" \
 "	#\n" \
 "	tty4::respawn:/sbin/getty 38400 tty5\n" \
 "	tty5::respawn:/sbin/getty 38400 tty6\n" \
 "	\n" \
 "	\n" \
 "	# Example of how to put a getty on a serial line (for a terminal)\n" \
 "	#\n" \
 "	#::respawn:/sbin/getty -L ttyS0 9600 vt100\n" \
 "	#::respawn:/sbin/getty -L ttyS1 9600 vt100\n" \
 "	#\n" \
 "	# Example how to put a getty on a modem line.\n" \
 "	#::respawn:/sbin/getty 57600 ttyS2\n" \
 "	\n" \
 "	# Stuff to do before rebooting\n" \
 "	::ctrlaltdel:/sbin/reboot\n" \
 "	::shutdown:/bin/umount -a -r\n" \
 "	::shutdown:/sbin/swapoff -a\n"
 
 #define insmod_trivial_usage \
 	"[OPTION]... MODULE [symbol=value]..."
 #define insmod_full_usage \
 	"Loads the specified kernel modules into the kernel.\n\n" \
 	"Options:\n" \
 	"\t-f\tForce module to load into the wrong kernel version.\n" \
 	"\t-k\tMake module autoclean-able.\n" \
 	"\t-v\tverbose output\n"  \
 	"\t-L\tLock to prevent simultaneous loads of a module\n" \
 	"\t-x\tdo not export externs"
 
 #define kill_trivial_usage \
 	"[-signal] process-id [process-id ...]"
 #define kill_full_usage \
 	"Send a signal (default is SIGTERM) to the specified process(es).\n\n"\
 	"Options:\n" \
 	"\t-l\tList all signal names and numbers."
 #define kill_example_usage \
 	"$ ps | grep apache\n" \
 	"252 root     root     S [apache]\n" \
 	"263 www-data www-data S [apache]\n" \
 	"264 www-data www-data S [apache]\n" \
 	"265 www-data www-data S [apache]\n" \
 	"266 www-data www-data S [apache]\n" \
 	"267 www-data www-data S [apache]\n" \
 	"$ kill 252\n"
 
 #define killall_trivial_usage \
 	"[-signal] process-name [process-name ...]"
 #define killall_full_usage \
 	"Send a signal (default is SIGTERM) to the specified process(es).\n\n"\
 	"Options:\n" \
 	"\t-l\tList all signal names and numbers."
 #define killall_example_usage \
 	"$ killall apache\n" 
 
 #define klogd_trivial_usage \
 	"-n"
 #define klogd_full_usage \
 	"Kernel logger.\n"\
 	"Options:\n"\
 	"\t-n\tRun as a foreground process."
 
 #define length_trivial_usage \
 	"STRING"
 #define length_full_usage \
 	"Prints out the length of the specified STRING."
 #define length_example_usage \
 	"$ length Hello\n" \
 	"5\n"
 
 #define ln_trivial_usage \
 	"[OPTION] TARGET... LINK_NAME|DIRECTORY"
 #define ln_full_usage \
 	"Create a link named LINK_NAME or DIRECTORY to the specified TARGET\n"\
 	"\nYou may use '--' to indicate that all following arguments are non-options.\n\n" \
 	"Options:\n" \
 	"\t-s\tmake symbolic links instead of hard links\n" \
 	"\t-f\tremove existing destination files\n" \
 	"\t-n\tno dereference symlinks - treat like normal file"
 #define ln_example_usage \
 	"$ ln -s BusyBox /tmp/ls\n" \
 	"$ ls -l /tmp/ls\n" \
 	"lrwxrwxrwx    1 root     root            7 Apr 12 18:39 ls -> BusyBox*\n" 
 
 #define loadacm_trivial_usage \
 	"< mapfile"
 #define loadacm_full_usage \
 	"Loads an acm from standard input."
 #define loadacm_example_usage \
 	"$ loadacm < /etc/i18n/acmname\n" 
 
 #define loadfont_trivial_usage \
 	"< font"
 #define loadfont_full_usage \
 	"Loads a console font from standard input."
 #define loadfont_example_usage \
 	"$ loadfont < /etc/i18n/fontname\n" 
 
 #define loadkmap_trivial_usage \
 	"< keymap"
 #define loadkmap_full_usage \
 	"Loads a binary keyboard translation table from standard input."
 #define loadkmap_example_usage \
 	"$ loadkmap < /etc/i18n/lang-keymap\n" 
 
 #define logger_trivial_usage \
 	"[OPTION]... [MESSAGE]"
 #define logger_full_usage \
 	"Write MESSAGE to the system log.  If MESSAGE is omitted, log stdin.\n\n" \
 	"Options:\n" \
 	"\t-s\tLog to stderr as well as the system log.\n" \
 	"\t-t\tLog using the specified tag (defaults to user name).\n" \
 	"\t-p\tEnter the message with the specified priority.\n" \
 	"\t\tThis may be numerical or a ``facility.level'' pair."
 #define logger_example_usage \
 	"$ logger "hello"\n" 
 
 #define logname_trivial_usage \
 	""
 #define logname_full_usage \
 	"Print the name of the current user."
 #define logname_example_usage \
 	"$ logname\n" \
 	"root\n" 
 
 #define logread_trivial_usage \
         ""
 
 #define logread_full_usage \
         "Shows the messages from syslogd (using circular buffer)."
 
 #ifdef BB_FEATURE_LS_TIMESTAMPS
   #define USAGE_LS_TIMESTAMPS(a) a
 #else
   #define USAGE_LS_TIMESTAMPS(a)
 #endif
 #ifdef BB_FEATURE_LS_FILETYPES
   #define USAGE_LS_FILETYPES(a) a
 #else
   #define USAGE_LS_FILETYPES(a)
 #endif
 #ifdef BB_FEATURE_LS_FOLLOWLINKS
   #define USAGE_LS_FOLLOWLINKS(a) a
 #else
   #define USAGE_LS_FOLLOWLINKS(a)
 #endif
 #ifdef BB_FEATURE_LS_RECURSIVE
   #define USAGE_LS_RECURSIVE(a) a
 #else
   #define USAGE_LS_RECURSIVE(a)
 #endif
 #ifdef BB_FEATURE_LS_SORTFILES
   #define USAGE_LS_SORTFILES(a) a
 #else
   #define USAGE_LS_SORTFILES(a)
 #endif
 #ifdef BB_FEATURE_AUTOWIDTH
   #define USAGE_AUTOWIDTH(a) a
 #else
   #define USAGE_AUTOWIDTH(a)
 #endif
 #define ls_trivial_usage \
 	"[-1Aa" USAGE_LS_TIMESTAMPS("c") "Cd" USAGE_LS_TIMESTAMPS("e") USAGE_LS_FILETYPES("F") "iln" USAGE_LS_FILETYPES("p") USAGE_LS_FOLLOWLINKS("L") USAGE_LS_RECURSIVE("R") USAGE_LS_SORTFILES("rS") "s" USAGE_AUTOWIDTH("T") USAGE_LS_TIMESTAMPS("tu") USAGE_LS_SORTFILES("v") USAGE_AUTOWIDTH("w") "x" USAGE_LS_SORTFILES("X") USAGE_HUMAN_READABLE("h") USAGE_NOT_HUMAN_READABLE("") "k] [filenames...]"
 #define ls_full_usage \
 	"List directory contents\n\n" \
 	"Options:\n" \
 	"\t-1\tlist files in a single column\n" \
 	"\t-A\tdo not list implied . and ..\n" \
 	"\t-a\tdo not hide entries starting with .\n" \
 	"\t-C\tlist entries by columns\n" \
 	USAGE_LS_TIMESTAMPS("\t-c\twith -l: show ctime\n") \
 	"\t-d\tlist directory entries instead of contents\n" \
 	USAGE_LS_TIMESTAMPS("\t-e\tlist both full date and full time\n") \
 	USAGE_LS_FILETYPES("\t-F\tappend indicator (one of */=@|) to entries\n") \
 	"\t-i\tlist the i-node for each file\n" \
 	"\t-l\tuse a long listing format\n" \
 	"\t-n\tlist numeric UIDs and GIDs instead of names\n" \
 	USAGE_LS_FILETYPES("\t-p\tappend indicator (one of /=@|) to entries\n") \
 	USAGE_LS_FOLLOWLINKS("\t-L\tlist entries pointed to by symbolic links\n") \
 	USAGE_LS_RECURSIVE("\t-R\tlist subdirectories recursively\n") \
 	USAGE_LS_SORTFILES("\t-r\tsort the listing in reverse order\n") \
 	USAGE_LS_SORTFILES("\t-S\tsort the listing by file size\n") \
 	"\t-s\tlist the size of each file, in blocks\n" \
 	USAGE_AUTOWIDTH("\t-T NUM\tassume Tabstop every NUM columns\n") \
 	USAGE_LS_TIMESTAMPS("\t-t\twith -l: show modification time\n") \
 	USAGE_LS_TIMESTAMPS("\t-u\twith -l: show access time\n") \
 	USAGE_LS_SORTFILES("\t-v\tsort the listing by version\n") \
 	USAGE_AUTOWIDTH("\t-w NUM\tassume the terminal is NUM columns wide\n") \
 	"\t-x\tlist entries by lines instead of by columns\n" \
 	USAGE_LS_SORTFILES("\t-X\tsort the listing by extension\n") \
 	USAGE_HUMAN_READABLE( \
 	"\t-h\tprint sizes in human readable format (e.g., 1K 243M 2G )\n" \
 	"\t-k\tprint sizes in kilobytes(default)") USAGE_NOT_HUMAN_READABLE( \
 	"\t-k\tprint sizes in kilobytes(compatability)") 
 
 #define lsmod_trivial_usage \
 	""
 #define lsmod_full_usage \
 	"List the currently loaded kernel modules."
 
 #define makedevs_trivial_usage \
 	"NAME TYPE MAJOR MINOR FIRST LAST [s]"
 #define makedevs_full_usage \
 	"Creates a range of block or character special files\n\n" \
 	"TYPEs include:\n" \
 	"\tb:\tMake a block (buffered) device.\n" \
 	"\tc or u:\tMake a character (un-buffered) device.\n" \
 	"\tp:\tMake a named pipe. MAJOR and MINOR are ignored for named pipes.\n\n" \
 	"FIRST specifies the number appended to NAME to create the first device.\n" \
 	"LAST specifies the number of the last item that should be created.\n" \
 	"If 's' is the last argument, the base device is created as well.\n\n" \
 	"For example:\n" \
 	"\tmakedevs /dev/ttyS c 4 66 2 63   ->  ttyS2-ttyS63\n" \
 	"\tmakedevs /dev/hda b 3 0 0 8 s    ->  hda,hda1-hda8"
 #define makedevs_example_usage \
 	"$ makedevs /dev/ttyS c 4 66 2 63\n" \
 	"[creates ttyS2-ttyS63]\n" \
 	"$ makedevs /dev/hda b 3 0 0 8 s\n" \
 	"[creates hda,hda1-hda8]\n" 
 
 #define md5sum_trivial_usage \
 	"[OPTION] [FILE]...\n" \
 	"or: md5sum [OPTION] -c [FILE]"
 #define md5sum_full_usage \
 	"Print or check MD5 checksums.\n\n" \
 	"Options:\n" \
 	"With no FILE, or when FILE is -, read standard input.\n\n" \
 	"\t-b\tread files in binary mode\n" \
 	"\t-c\tcheck MD5 sums against given list\n" \
 	"\t-t\tread files in text mode (default)\n" \
 	"\t-g\tread a string\n" \
 	"\nThe following two options are useful only when verifying checksums:\n" \
 	"\t-s\tdon't output anything, status code shows success\n" \
 	"\t-w\twarn about improperly formated MD5 checksum lines"
 #define md5sum_example_usage \
 	"$ md5sum < busybox\n" \
 	"6fd11e98b98a58f64ff3398d7b324003\n" \
 	"$ md5sum busybox\n" \
 	"6fd11e98b98a58f64ff3398d7b324003  busybox\n" \
 	"$ md5sum -c -\n" \
 	"6fd11e98b98a58f64ff3398d7b324003  busybox\n" \
 	"busybox: OK\n" \
 	"^D\n"
 
 #define mkdir_trivial_usage \
 	"[OPTION] DIRECTORY..."
 #define mkdir_full_usage \
 	"Create the DIRECTORY(ies) if they do not already exist\n\n" \
 	"Options:\n" \
 	"\t-m\tset permission mode (as in chmod), not rwxrwxrwx - umask\n" \
 	"\t-p\tno error if existing, make parent directories as needed"
 #define mkdir_example_usage \
 	"$ mkdir /tmp/foo\n" \
 	"$ mkdir /tmp/foo\n" \
 	"/tmp/foo: File exists\n" \
 	"$ mkdir /tmp/foo/bar/baz\n" \
 	"/tmp/foo/bar/baz: No such file or directory\n" \
 	"$ mkdir -p /tmp/foo/bar/baz\n" 
 
 #define mkfifo_trivial_usage \
 	"[OPTIONS] name"
 #define mkfifo_full_usage \
 	"Creates a named pipe (identical to 'mknod name p')\n\n" \
 	"Options:\n" \
 	"\t-m\tcreate the pipe using the specified mode (default a=rw)"
 
 #define mkfs_minix_trivial_usage \
 	"[-c | -l filename] [-nXX] [-iXX] /dev/name [blocks]"
 #define mkfs_minix_full_usage \
 	"Make a MINIX filesystem.\n\n" \
 	"Options:\n" \
 	"\t-c\t\tCheck the device for bad blocks\n" \
 	"\t-n [14|30]\tSpecify the maximum length of filenames\n" \
 	"\t-i INODES\tSpecify the number of inodes for the filesystem\n" \
 	"\t-l FILENAME\tRead the bad blocks list from FILENAME\n" \
 	"\t-v\t\tMake a Minix version 2 filesystem"
 
 #define mknod_trivial_usage \
 	"[OPTIONS] NAME TYPE MAJOR MINOR"
 #define mknod_full_usage \
 	"Create a special file (block, character, or pipe).\n\n" \
 	"Options:\n" \
 	"\t-m\tcreate the special file using the specified mode (default a=rw)\n\n" \
 	"TYPEs include:\n" \
 	"\tb:\tMake a block (buffered) device.\n" \
 	"\tc or u:\tMake a character (un-buffered) device.\n" \
 	"\tp:\tMake a named pipe. MAJOR and MINOR are ignored for named pipes."
 #define mknod_example_usage \
 	"$ mknod /dev/fd0 b 2 0 \n" \
 	"$ mknod -m 644 /tmp/pipe p\n" 
 
 #define mkswap_trivial_usage \
 	"[-c] [-v0|-v1] device [block-count]"
 #define mkswap_full_usage \
 	"Prepare a disk partition to be used as a swap partition.\n\n" \
 	"Options:\n" \
 	"\t-c\t\tCheck for read-ability.\n" \
 	"\t-v0\t\tMake version 0 swap [max 128 Megs].\n" \
 	"\t-v1\t\tMake version 1 swap [big!] (default for kernels >\n\t\t\t2.1.117).\n" \
 	"\tblock-count\tNumber of block to use (default is entire partition)."
 
 #define mktemp_trivial_usage \
 	"[-q] TEMPLATE"
 #define mktemp_full_usage \
 	"Creates a temporary file with its name based on TEMPLATE.\n" \
 	"TEMPLATE is any name with six `Xs' (i.e. /tmp/temp.XXXXXX)."
 #define mktemp_example_usage \
 	"$ mktemp /tmp/temp.XXXXXX\n" \
 	"/tmp/temp.mWiLjM\n" \
 	"$ ls -la /tmp/temp.mWiLjM\n" \
 	"-rw-------    1 andersen andersen        0 Apr 25 17:10 /tmp/temp.mWiLjM\n" 
 
 #define more_trivial_usage \
 	"[FILE ...]"
 #define more_full_usage \
 	"More is a filter for viewing FILE one screenful at a time."
 #define more_example_usage \
 	"$ dmesg | more\n" 
 
 #ifdef BB_FEATURE_MOUNT_LOOP
   #define USAGE_MOUNT_LOOP(a) a
 #else
   #define USAGE_MOUNT_LOOP(a)
 #endif
 #ifdef BB_FEATURE_MTAB_SUPPORT
   #define USAGE_MTAB(a) a
 #else
   #define USAGE_MTAB(a)
 #endif
 #define mount_trivial_usage \
 	"[flags] DEVICE NODE [-o options,more-options]"
 #define mount_full_usage \
 	"Mount a filesystem\n\n" \
 	"Flags:\n"  \
 	"\t-a:\t\tMount all filesystems in fstab.\n" \
 	USAGE_MTAB( \
 	"\t-f:\t\t\"Fake\" Add entry to mount table but don't mount it.\n" \
 	"\t-n:\t\tDon't write a mount table entry.\n" \
 	) \
 	"\t-o option:\tOne of many filesystem options, listed below.\n" \
 	"\t-r:\t\tMount the filesystem read-only.\n" \
 	"\t-t fs-type:\tSpecify the filesystem type.\n" \
 	"\t-w:\t\tMount for reading and writing (default).\n" \
 	"\n" \
 	"Options for use with the \"-o\" flag:\n" \
 	"\tasync/sync:\tWrites are asynchronous / synchronous.\n" \
 	"\tatime/noatime:\tEnable / disable updates to inode access times.\n" \
 	"\tdev/nodev:\tAllow use of special device files / disallow them.\n" \
 	"\texec/noexec:\tAllow use of executable files / disallow them.\n" \
 	USAGE_MOUNT_LOOP( \
 	"\tloop:\t\tMounts a file via loop device.\n" \
 	) \
 	"\tsuid/nosuid:\tAllow set-user-id-root programs / disallow them.\n" \
 	"\tremount:\tRe-mount a mounted filesystem, changing its flags.\n" \
 	"\tro/rw:\t\tMount for read-only / read-write.\n" \
 	"\tbind:\t\tUse the linux 2.4.x \"bind\" feature.\n" \
 	"\nThere are EVEN MORE flags that are specific to each filesystem.\n" \
 	"You'll have to see the written documentation for those filesystems."
 #define mount_example_usage \
 	"$ mount\n" \
 	"/dev/hda3 on / type minix (rw)\n" \
 	"proc on /proc type proc (rw)\n" \
 	"devpts on /dev/pts type devpts (rw)\n" \
 	"$ mount /dev/fd0 /mnt -t msdos -o ro\n" \
 	"$ mount /tmp/diskimage /opt -t ext2 -o loop\n" 
 
 #define mt_trivial_usage \
 	"[-f device] opcode value"
 #define mt_full_usage \
 	"Control magnetic tape drive operation\n" \
 	"\nAvailable Opcodes:\n\n" \
 	"bsf bsfm bsr bss datacompression drvbuffer eof eom erase\n" \
 	"fsf fsfm fsr fss load lock mkpart nop offline ras1 ras2\n" \
 	"ras3 reset retension rew rewoffline seek setblk setdensity\n" \
 	"setpart tell unload unlock weof wset"
 
 #define mv_trivial_usage \
 	"SOURCE DEST\n" \
 	"or: mv SOURCE... DIRECTORY"
 #define mv_full_usage \
 	"Rename SOURCE to DEST, or move SOURCE(s) to DIRECTORY."
 #define mv_example_usage \
 	"$ mv /tmp/foo /bin/bar\n" 
 
 #define nc_trivial_usage \
 	"[IP] [port]" 
 #define nc_full_usage \
 	"Netcat opens a pipe to IP:port"
 #define nc_example_usage \
 	"$ nc foobar.somedomain.com 25\n" \
 	"220 foobar ESMTP Exim 3.12 #1 Sat, 15 Apr 2000 00:03:02 -0600\n" \
 	"help\n" \
 	"214-Commands supported:\n" \
 	"214-    HELO EHLO MAIL RCPT DATA AUTH\n" \
 	"214     NOOP QUIT RSET HELP\n" \
 	"quit\n" \
 	"221 foobar closing connection\n" 
 
 #define nslookup_trivial_usage \
 	"[HOST]"
 #define nslookup_full_usage \
 	"Queries the nameserver for the IP address of the given HOST"
 #define nslookup_example_usage \
 	"$ nslookup localhost\n" \
 	"Server:     default\n" \
 	"Address:    default\n" \
 	"\n" \
 	"Name:       debian\n" \
 	"Address:    127.0.0.1\n" 
 
-#ifdef BB_FEATURE_SIMPLE_PING
+#ifndef BB_FEATURE_FANCY_PING
 #define ping_trivial_usage "host"
 #define ping_full_usage    "Send ICMP ECHO_REQUEST packets to network hosts"
 #else
 #define ping_trivial_usage \
 	"[OPTION]... host"
 #define ping_full_usage \
 	"Send ICMP ECHO_REQUEST packets to network hosts.\n\n" \
 	"Options:\n" \
 	"\t-c COUNT\tSend only COUNT pings.\n" \
 	"\t-s SIZE\t\tSend SIZE data bytes in packets (default=56).\n" \
 	"\t-q\t\tQuiet mode, only displays output at start\n" \
 	"\t\t\tand when finished."
 #endif
 #define ping_example_usage \
 	"$ ping localhost\n" \
 	"PING slag (127.0.0.1): 56 data bytes\n" \
 	"64 bytes from 127.0.0.1: icmp_seq=0 ttl=255 time=20.1 ms\n" \
 	"\n" \
 	"--- debian ping statistics ---\n" \
 	"1 packets transmitted, 1 packets received, 0% packet loss\n" \
 	"round-trip min/avg/max = 20.1/20.1/20.1 ms\n" 
 
 #define pivot_root_trivial_usage \
 	"NEW_ROOT PUT_OLD"
 #define pivot_root_full_usage \
 	"Move the current root file system to PUT_OLD and make NEW_ROOT\n" \
 	"the new root file system."
 
 #define poweroff_trivial_usage \
 	""
 #define poweroff_full_usage \
 	"Halt the system and request that the kernel shut off the power."
 
 #define printf_trivial_usage \
 	"FORMAT [ARGUMENT...]"
 #define printf_full_usage \
 	"Formats and prints ARGUMENT(s) according to FORMAT,\n" \
 	"Where FORMAT controls the output exactly as in C printf."
 #define printf_example_usage \
 	"$ printf "Val=%d\\n" 5\n" \
 	"Val=5\n" 
 
 #define ps_trivial_usage \
 	""
 #define ps_full_usage \
 	"Report process status\n" \
 	"\nThis version of ps accepts no options."
 #define ps_example_usage \
 	"$ ps\n" \
 	"  PID  Uid      Gid State Command\n" \
 	"    1 root     root     S init\n" \
 	"    2 root     root     S [kflushd]\n" \
 	"    3 root     root     S [kupdate]\n" \
 	"    4 root     root     S [kpiod]\n" \
 	"    5 root     root     S [kswapd]\n" \
 	"  742 andersen andersen S [bash]\n" \
 	"  743 andersen andersen S -bash\n" \
 	"  745 root     root     S [getty]\n" \
 	" 2990 andersen andersen R ps\n"
 
 #define pwd_trivial_usage \
 	""
 #define pwd_full_usage \
 	"Print the full filename of the current working directory."
 #define pwd_example_usage \
 	"$ pwd\n" \
 	"/root\n"
 
 #define rdate_trivial_usage \
 	"[OPTION] HOST"
 #define rdate_full_usage \
 	"Get and possibly set the system date and time from a remote HOST.\n\n" \
 	"Options:\n" \
 	"\t-s\tSet the system date and time (default).\n" \
 	"\t-p\tPrint the date and time."
 
 #define readlink_trivial_usage \
 	""
 #define readlink_full_usage \
 	"Read a symbolic link."
 
 #define reboot_trivial_usage \
 	""
 #define reboot_full_usage \
 	"Reboot the system."
 
 #define renice_trivial_usage \
 	"priority pid [pid ...]"
 #define renice_full_usage \
 	"Changes priority of running processes. Allowed priorities range\n" \
 	"from 20 (the process runs only when nothing else is running) to 0\n" \
 	"(default priority) to -20 (almost nothing else ever gets to run)."
 
 #define reset_trivial_usage \
 	""
 #define reset_full_usage \
 	"Resets the screen."
 
 #define rm_trivial_usage \
 	"[OPTION]... FILE..."
 #define rm_full_usage \
 	"Remove (unlink) the FILE(s).  You may use '--' to\n" \
 	"indicate that all following arguments are non-options.\n\n" \
 	"Options:\n" \
 	"\t-i\t\talways prompt before removing each destination" \
 	"\t-f\t\tremove existing destinations, never prompt\n" \
 	"\t-r or -R\tremove the contents of directories recursively"
 #define rm_example_usage \
 	"$ rm -rf /tmp/foo\n"
 
 #define rmdir_trivial_usage \
 	"[OPTION]... DIRECTORY..."
 #define rmdir_full_usage \
 	"Remove the DIRECTORY(ies), if they are empty."
 #define rmdir_example_usage \
 	"# rmdir /tmp/foo\n"
 
 #define rmmod_trivial_usage \
 	"[OPTION]... [MODULE]..."
 #define rmmod_full_usage \
 	"Unloads the specified kernel modules from the kernel.\n\n" \
 	"Options:\n" \
 	"\t-a\tTry to remove all unused kernel modules."
 #define rmmod_example_usage \
 	"$ rmmod tulip\n"
 
 #define route_trivial_usage \
 	"[{add|del|flush}]"
 #define route_full_usage \
 	"Edit the kernel's routing tables"
 
 #define rpmunpack_trivial_usage \
 	"< package.rpm | gunzip | cpio -idmuv"
 #define rpmunpack_full_usage \
 	"Extracts an rpm archive."
 
 #define sed_trivial_usage \
 	"[-Vhnef] pattern [files...]"
 #define sed_full_usage \
 	"Options:\n" \
 	"\t-n\t\tsuppress automatic printing of pattern space\n" \
 	"\t-e script\tadd the script to the commands to be executed\n" \
 	"\t-f scriptfile\tadd the contents of script-file to the commands to be executed\n" \
 	"\t-h\t\tdisplay this help message\n" \
 	"\n" \
 	"If no -e or -f is given, the first non-option argument is taken as the\n" \
 	"sed script to interpret. All remaining arguments are names of input\n" \
 	"files; if no input files are specified, then the standard input is read."
 #define sed_example_usage \
 	"$ echo "foo" | sed -e 's/f[a-zA-Z]o/bar/g'\n" \
 	"bar\n"
 
 #define setkeycodes_trivial_usage \
 	"SCANCODE KEYCODE ..."
 #define setkeycodes_full_usage \
 	"Set entries into the kernel's scancode-to-keycode map,\n" \
 	"allowing unusual keyboards to generate usable keycodes.\n\n" \
 	"SCANCODE may be either xx or e0xx (hexadecimal),\n" \
 	"and KEYCODE is given in decimal"
 #define setkeycodes_example_usage \
 	"$ setkeycodes e030 127\n"
 
 #define sh_trivial_usage \
 	"[FILE]...\n" \
 	"or: sh -c command [args]..."
 #define sh_full_usage \
 	"lash: The BusyBox LAme SHell (command interpreter)"
 #define sh_notes_usage \
 "This command does not yet have proper documentation.\n" \
 "\n" \
 "Use lash just as you would use any other shell.  It properly handles pipes,\n" \
 "redirects, job control, can be used as the shell for scripts, and has a\n" \
 "sufficient set of builtins to do what is needed.  It does not (yet) support\n" \
 "Bourne Shell syntax.  If you need things like "if-then-else", "while", and such\n" \
 "use ash or bash.  If you just need a very simple and extremely small shell,\n" \
 "this will do the job."
 
 #define sleep_trivial_usage \
 	"N"
 #define sleep_full_usage \
 	"Pause for N seconds."
 #define sleep_example_usage \
 	"$ sleep 2\n" \
 	"[2 second delay results]\n"
 
 
 #ifdef BB_FEATURE_SORT_UNIQUE
   #define USAGE_SORT_UNIQUE(a) a
 #else
   #define USAGE_SORT_UNIQUE(a)
 #endif
 #ifdef BB_FEATURE_SORT_REVERSE
   #define USAGE_SORT_REVERSE(a) a
 #else
   #define USAGE_SORT_REVERSE(a)
 #endif
 #define sort_trivial_usage \
 	"[-n" USAGE_SORT_REVERSE("r") USAGE_SORT_UNIQUE("u") "] [FILE]..."
 #define sort_full_usage \
 	"Sorts lines of text in the specified files\n\n"\
 	"Options:\n" \
 	USAGE_SORT_UNIQUE("\t-u\tsuppress duplicate lines\n") \
 	USAGE_SORT_REVERSE("\t-r\tsort in reverse order\n") \
 	"\t-n\tsort numerics"
 #define sort_example_usage \
 	"$ echo -e \"e\\nf\\nb\\nd\\nc\\na\" | sort\n" \
 	"a\n" \
 	"b\n" \
 	"c\n" \
 	"d\n" \
 	"e\n" \
 	"f\n"
 
 #define stty_trivial_usage \
 	"[-a|g] [-F DEVICE] [SETTING]..."
 #define stty_full_usage \
 	"Without arguments, prints baud rate, line discipline," \
 	"\nand deviations from stty sane." \
 	"\n\nOptions:" \
 	"\n\t-F DEVICE\topen device instead of stdin" \
 	"\n\t-a\t\tprint all current settings in human-readable form" \
 	"\n\t-g\t\tprint in stty-readable form" \
 	"\n\t[SETTING]\tsee manpage"
 
 #define swapoff_trivial_usage \
 	"[OPTION] [DEVICE]"
 #define swapoff_full_usage \
 	"Stop swapping virtual memory pages on DEVICE.\n\n" \
 	"Options:\n" \
 	"\t-a\tStop swapping on all swap devices"
 
 #define swapon_trivial_usage \
 	"[OPTION] [DEVICE]"
 #define swapon_full_usage \
 	"Start swapping virtual memory pages on DEVICE.\n\n" \
 	"Options:\n" \
 	"\t-a\tStart swapping on all swap devices"
 
 #define sync_trivial_usage \
 	""
 #define sync_full_usage \
 	"Write all buffered filesystem blocks to disk."
 
 
 #ifdef BB_FEATURE_REMOTE_LOG
   #define USAGE_REMOTE_LOG(a) a
 #else
   #define USAGE_REMOTE_LOG(a)
 #endif
 #define syslogd_trivial_usage \
 	"[OPTION]..."
 #define syslogd_full_usage \
 	"Linux system and kernel logging utility.\n" \
 	"Note that this version of syslogd ignores /etc/syslog.conf.\n\n" \
 	"Options:\n" \
 	"\t-m NUM\t\tInterval between MARK lines (default=20min, 0=off)\n" \
 	"\t-n\t\tRun as a foreground process\n" \
 	"\t-O FILE\t\tUse an alternate log file (default=/var/log/messages)" \
 	USAGE_REMOTE_LOG( \
 	"\n\t-R HOST[:PORT]\tLog to IP or hostname on PORT (default PORT=514/UDP)\n" \
 	"\t-L\t\tLog locally and via network logging (default is network only)")
 #define syslogd_example_usage \
 	"$ syslogd -R masterlog:514\n" \
 	"$ syslogd -R 192.168.1.1:601\n"
 
 
-#ifdef BB_FEATURE_SIMPLE_TAIL
+#ifndef BB_FEATURE_FANCY_TAIL
   #define USAGE_UNSIMPLE_TAIL(a)
 #else
   #define USAGE_UNSIMPLE_TAIL(a) a
 #endif
 #define tail_trivial_usage \
 	"[OPTION]... [FILE]..."
 #define tail_full_usage \
 	"Print last 10 lines of each FILE to standard output.\n" \
 	"With more than one FILE, precede each with a header giving the\n" \
 	"file name. With no FILE, or when FILE is -, read standard input.\n\n" \
 	"Options:\n" \
 	USAGE_UNSIMPLE_TAIL("\t-c N[kbm]\toutput the last N bytes\n") \
 	"\t-n N[kbm]\tprint last N lines instead of last 10\n" \
 	"\t-f\t\toutput data as the file grows" \
 	USAGE_UNSIMPLE_TAIL( "\n\t-q\t\tnever output headers giving file names\n" \
 	"\t-s SEC\t\twait SEC seconds between reads with -f\n" \
 	"\t-v\t\talways output headers giving file names\n\n" \
 	"If the first character of N (bytes or lines) is a '+', output begins with \n" \
 	"the Nth item from the start of each file, otherwise, print the last N items\n" \
 	"in the file. N bytes may be suffixed by k (x1024), b (x512), or m (1024^2)." )
 #define tail_example_usage \
 	"$ tail -n 1 /etc/resolv.conf\n" \
 	"nameserver 10.0.0.1\n"
 
 #ifdef BB_FEATURE_TAR_CREATE
   #define USAGE_TAR_CREATE(a) a
 #else
   #define USAGE_TAR_CREATE(a)
 #endif
 #ifdef BB_FEATURE_TAR_EXCLUDE
   #define USAGE_TAR_EXCLUDE(a) a
 #else
   #define USAGE_TAR_EXCLUDE(a)
 #endif
 #define tar_trivial_usage \
 	"-[" USAGE_TAR_CREATE("c") "xtvO] " \
 	USAGE_TAR_EXCLUDE("[--exclude FILE] [-X FILE]") \
 	"[-f TARFILE] [FILE(s)] ..."
 #define tar_full_usage \
 	"Create, extract, or list files from a tar file.\n\n" \
 	"Main operation mode:\n" \
 	USAGE_TAR_CREATE("\tc\t\tcreate\n") \
 	"\tx\t\textract\n" \
 	"\tt\t\tlist\n" \
 	"\nFile selection:\n" \
 	"\tf\t\tname of TARFILE or \"-\" for stdin\n" \
 	"\tO\t\textract to stdout\n" \
 	USAGE_TAR_EXCLUDE( \
 	"\texclude\t\tfile to exclude\n" \
 	 "\tX\t\tfile with names to exclude\n" \
 	) \
 	"\nInformative output:\n" \
 	"\tv\t\tverbosely list files processed"
 #define tar_example_usage \
 	"$ zcat /tmp/tarball.tar.gz | tar -xf -\n" \
 	"$ tar -cf /tmp/tarball.tar /usr/local\n"
 
 #define tee_trivial_usage \
 	"[OPTION]... [FILE]..."
 #define tee_full_usage \
 	"Copy standard input to each FILE, and also to standard output.\n\n" \
 	"Options:\n" \
 	"\t-a\tappend to the given FILEs, do not overwrite"
 #define tee_example_usage \
 	"$ echo "Hello" | tee /tmp/foo\n" \
 	"$ cat /tmp/foo\n" \
 	"Hello\n"
 
 #define telnet_trivial_usage \
 	"HOST [PORT]"
 #define telnet_full_usage \
 	"Telnet is used to establish interactive communication with another\n"\
 	"computer over a network using the TELNET protocol."
 
 #define test_trivial_usage \
 	"EXPRESSION\n  or   [ EXPRESSION ]"
 #define test_full_usage \
 	"Checks file types and compares values returning an exit\n" \
 	"code determined by the value of EXPRESSION."
 #define test_example_usage \
 	"$ test 1 -eq 2\n" \
 	"$ echo $?\n" \
 	"1\n" \
 	"$ test 1 -eq 1\n" \
 	"$ echo $? \n" \
 	"0\n" \
 	"$ [ -d /etc ]\n" \
 	"$ echo $?\n" \
 	"0\n" \
 	"$ [ -d /junk ]\n" \
 	"$ echo $?\n" \
 	"1\n"
 
 #ifdef BB_FEATURE_TFTP_GET
   #define USAGE_TFTP_GET(a) a
 #else
   #define USAGE_TFTP_GET(a)
 #endif
 #ifdef BB_FEATURE_TFTP_PUT
   #define USAGE_TFTP_PUT(a) a
 #else
   #define USAGE_TFTP_PUT(a)
 #endif
 
 #define tftp_trivial_usage \
 	"command SOURCE DEST"
 #define tftp_full_usage \
 	"Transfers a file from/to a tftp server using \"octet\" mode.\n\n" \
 	"Commands:\n" \
         USAGE_TFTP_GET(	\
         "\tget\tGet file from server SOURCE and store to local DEST.\n" \
         ) \
         USAGE_TFTP_PUT(	\
 	"\tput\tPut local file SOURCE to server DEST.\n" \
 	) \
 	"\nWhen naming a server, use the syntax \"server:file\"."
 
 #define touch_trivial_usage \
 	"[-c] FILE [FILE ...]"
 #define touch_full_usage \
 	"Update the last-modified date on the given FILE[s].\n\n" \
 	"Options:\n" \
 	"\t-c\tDo not create any files"
 #define touch_example_usage \
 	"$ ls -l /tmp/foo\n" \
 	"/bin/ls: /tmp/foo: No such file or directory\n" \
 	"$ touch /tmp/foo\n" \
 	"$ ls -l /tmp/foo\n" \
 	"-rw-rw-r--    1 andersen andersen        0 Apr 15 01:11 /tmp/foo\n" 
 
 #define tr_trivial_usage \
 	"[-cds] STRING1 [STRING2]"
 #define tr_full_usage \
 	"Translate, squeeze, and/or delete characters from\n" \
 	"standard input, writing to standard output.\n\n" \
 	"Options:\n" \
 	"\t-c\ttake complement of STRING1\n" \
 	"\t-d\tdelete input characters coded STRING1\n" \
 	"\t-s\tsqueeze multiple output characters of STRING2 into one character"
 #define tr_example_usage \
 	"$ echo "gdkkn vnqkc" | tr [a-y] [b-z]\n" \
 	"hello world\n" 
 
 #define true_trivial_usage \
 	""
 #define true_full_usage \
 	"Return an exit code of TRUE (0)."
 #define true_example_usage \
 	"$ true\n" \
 	"$ echo $?\n" \
 	"0\n"
 
 #define tty_trivial_usage \
 	""
 #define tty_full_usage \
 	"Print the file name of the terminal connected to standard input.\n\n"\
 	"Options:\n" \
 	"\t-s\tprint nothing, only return an exit status"
 #define tty_example_usage \
 	"$ tty\n" \
 	"/dev/tty2\n"
 
 #ifdef BB_FEATURE_MOUNT_FORCE
   #define USAGE_MOUNT_FORCE(a) a
 #else
   #define USAGE_MOUNT_FORCE(a)
 #endif
 #define umount_trivial_usage \
 	"[flags] FILESYSTEM|DIRECTORY"
 #define umount_full_usage \
 	"Unmount file systems\n" \
 	"\nFlags:\n" "\t-a\tUnmount all file systems" \
 	USAGE_MTAB(" in /etc/mtab\n\t-n\tDon't erase /etc/mtab entries") \
 	"\n\t-r\tTry to remount devices as read-only if mount is busy" \
 	USAGE_MOUNT_FORCE("\n\t-f\tForce umount (i.e. unreachable NFS server)") \
 	USAGE_MOUNT_LOOP("\n\t-l\tDo not free loop device (if a loop device has been used)")
 #define umount_example_usage \
 	"$ umount /dev/hdc1 \n"
 
 #define uname_trivial_usage \
 	"[OPTION]..."
 #define uname_full_usage \
 	"Print certain system information.  With no OPTION, same as -s.\n\n" \
 	"Options:\n" \
 	"\t-a\tprint all information\n" \
 	"\t-m\tthe machine (hardware) type\n" \
 	"\t-n\tprint the machine's network node hostname\n" \
 	"\t-r\tprint the operating system release\n" \
 	"\t-s\tprint the operating system name\n" \
 	"\t-p\tprint the host processor type\n" \
 	"\t-v\tprint the operating system version"
 #define uname_example_usage \
 	"$ uname -a\n" \
 	"Linux debian 2.2.15pre13 #5 Tue Mar 14 16:03:50 MST 2000 i686 unknown\n" 
 
 #define uniq_trivial_usage \
 	"[OPTION]... [INPUT [OUTPUT]]"
 #define uniq_full_usage \
 	"Discard all but one of successive identical lines from INPUT\n" \
 	"(or standard input), writing to OUTPUT (or standard output).\n\n" \
 	"Options:\n" \
 	"\t-c\tprefix lines by the number of occurrences\n" \
 	"\t-d\tonly print duplicate lines\n" \
 	"\t-u\tonly print unique lines"
 #define uniq_example_usage \
 	"$ echo -e \"a\\na\\nb\\nc\\nc\\na\" | sort | uniq\n" \
 	"a\n" \
 	"b\n" \
 	"c\n"
 
 #define unix2dos_trivial_usage \
 	"[option] [FILE]"
 #define unix2dos_full_usage \
 	"Converts FILE from unix format to dos format.  When no option\n" \
 	"is given, the input is converted to the opposite output format.\n" \
 	"When no file is given, uses stdin for input and stdout for output." \
 	"Options:\n" \
 	"\t-u\toutput will be in UNIX format\n" \
 	"\t-d\toutput will be in DOS format\n\n" \
 
 #define update_trivial_usage \
 	"[options]"
 #define update_full_usage \
 	"Periodically flushes filesystem buffers.\n\n" \
 	"Options:\n" \
 	"\t-S\tforce use of sync(2) instead of flushing\n" \
 	"\t-s SECS\tcall sync this often (default 30)\n" \
 	"\t-f SECS\tflush some buffers this often (default 5)"
 
 #define uptime_trivial_usage \
 	""
 #define uptime_full_usage \
 	"Display the time since the last boot."
 #define uptime_example_usage \
 	"$ uptime\n" \
 	"  1:55pm  up  2:30, load average: 0.09, 0.04, 0.00\n" 
 
 #define usleep_trivial_usage \
 	"N" 
 #define usleep_full_usage \
 	"Pause for N microseconds."
 #define usleep_example_usage \
 	"$ usleep 1000000\n" \
 	"[pauses for 1 second]\n"
 
 #define uudecode_trivial_usage \
 	"[FILE]..."
 #define uudecode_full_usage \
 	"Uudecode a file that is uuencoded.\n\n" \
 	"Options:\n" \
 	"\t-o FILE\tdirect output to FILE" 
 #define uudecode_example_usage \
 	"$ uudecode -o busybox busybox.uu\n" \
 	"$ ls -l busybox\n" \
 	"-rwxr-xr-x   1 ams      ams        245264 Jun  7 21:35 busybox\n" 
 
 #define uuencode_trivial_usage \
 	"[OPTION] [INFILE] REMOTEFILE"
 #define uuencode_full_usage \
 	"Uuencode a file.\n\n" \
 	"Options:\n" \
 	"\t-m\tuse base64 encoding per RFC1521"
 #define uuencode_example_usage \
 	"$ uuencode busybox busybox\n" \
 	"begin 755 busybox\n" \
 	"<encoded file snipped>\n" \
 	"$ uudecode busybox busybox > busybox.uu\n" \
 	"$\n"
 
 #define vi_trivial_usage \
 	"[OPTION] [FILE]..."
 #define vi_full_usage \
 	"edit FILE.\n\n" \
 	"Options:\n" \
 	"\t-R\tRead-only- do not write to the file." 
 
 #define watchdog_trivial_usage \
 	"DEV"
 #define watchdog_full_usage \
 	"Periodically write to watchdog device DEV"
 
 #define wc_trivial_usage \
 	"[OPTION]... [FILE]..."
 #define wc_full_usage \
 	"Print line, word, and byte counts for each FILE, and a total line if\n" \
 	"more than one FILE is specified.  With no FILE, read standard input.\n\n" \
 	"Options:\n" \
 	"\t-c\tprint the byte counts\n" \
 	"\t-l\tprint the newline counts\n" \
 	"\t-L\tprint the length of the longest line\n" \
 	"\t-w\tprint the word counts"
 #define wc_example_usage \
 	"$ wc /etc/passwd\n" \
 	"     31      46    1365 /etc/passwd\n" 
 
 #define wget_trivial_usage \
 	"[-c|--continue] [-q|--quiet] [-O|--output-document file] [--header 'header: value'] url"
 #define wget_full_usage \
 	"wget retrieves files via HTTP or FTP\n\n" \
 	"Options:\n" \
 	"\t-c\tcontinue retrieval of aborted transfers\n" \
 	"\t-q\tquiet mode - do not print\n" \
 	"\t-O\tsave to filename ('-' for stdout)"
 
 #define which_trivial_usage \
 	"[COMMAND ...]"
 #define which_full_usage \
 	"Locates a COMMAND."
 #define which_example_usage \
 	"$ which login\n" \
 	"/bin/login\n"
 
 #define whoami_trivial_usage \
 	""
 #define whoami_full_usage \
 	"Prints the user name associated with the current effective user id."
 
 #define xargs_trivial_usage \
 	"[COMMAND] [ARGS...]"
 #define xargs_full_usage \
 	"Executes COMMAND on every item given by standard input."
 #define xargs_example_usage \
 	"$ ls | xargs gzip\n" \
 	"$ find . -name '*.c' -print | xargs rm\n" 
 
 #define yes_trivial_usage \
 	"[OPTION]... [STRING]..."
 #define yes_full_usage \
 	"Repeatedly outputs a line with all specified STRING(s), or 'y'."
 
 #define zcat_trivial_usage \
 	"FILE"
 #define zcat_full_usage \
 	"Uncompress to stdout."
