2008-09-04 13:44:00 +0000
commit 00809ebf02f7c3eb5713f522512207a3544635d5
Author: Carl-Daniel Hailfinger <c-d.hailfinger.devel.2006@gmx.net>
Date:   Thu Sep 4 13:44:00 2008 +0000

    This changes the python generated makefiles
    
            targets/*/*/Makefile
            targets/*/*/normal/Makefile
            targets/*/*/fallback/Makefile
    
    to use a common copy of romcc, and to leave this compiler untouched by
    'make clean' in targets/*/*/fallback/ and targets/*/*/normal/ .
    'make clean' in targets/*/*/ will clean romcc.
    
    Thanks to Mats for the initial idea and implementation of a tool to do
    this. This patch has almost the same behaviour as the original tool
    without having to run the tool each time.
    Tested for abuild-friendliness.
    
    The patch saves ~10-12 seconds for every target using romcc. For a full
    abuild run, this is ~20% time saved.
    For the first 38 abuild targets, total build time is down to 13m24s
    instead of 16m22s on my machine.
    
    Signed-off-by: Carl-Daniel Hailfinger <c-d.hailfinger.devel.2006@gmx.net>
    Acked-by: Mats Erik Andersson <mats.andersson@gisladisker.se>
    Acked-by: Stefan Reinauer <stepan@coresystems.de>
    
    
    git-svn-id: svn://svn.coreboot.org/coreboot/trunk@3564 2b7e53f0-3cfb-0310-b3e9-8179ed1497e1

diff --git a/src/config/Config.lb b/src/config/Config.lb
index fa2f820..eb37b1e 100644
--- a/src/config/Config.lb
+++ b/src/config/Config.lb
@@ -1,206 +1,206 @@
 ## This is Architecture independant part of the makefile
 
 uses HAVE_OPTION_TABLE
 uses CONFIG_AP_CODE_IN_CAR
 
 makedefine CPP:= $(CC) -x assembler-with-cpp -DASSEMBLY -E
 makedefine LIBGCC_FILE_NAME := $(shell $(CC) -print-libgcc-file-name)
 makedefine GCC_INC_DIR := $(shell LC_ALL=C $(CC) -print-search-dirs | sed -ne "s/install: \(.*\)/\1include/gp")
 
 makedefine CPPFLAGS := -I$(TOP)/src/include -I$(TOP)/src/arch/$(ARCH)/include -I$(GCC_INC_DIR) $(CPUFLAGS)
 makedefine CFLAGS := $(CPU_OPT) $(DISTRO_CFLAGS) $(CPPFLAGS) -Os -nostdinc -nostdlib -fno-builtin  -Wall
 
 makedefine HOSTCFLAGS:= -Os -Wall
 
 makerule ldscript.ld   
 	depends	"ldoptions $(LDSUBSCRIPTS-1)" 
 	action	"echo '/*ldoptions*/' > $@; cat ldoptions >> $@ ; for file in $(LDSUBSCRIPTS-1) ; do echo /\* $$file \*/ >> $@; cat $$file >> $@ ; done"
 end
 
 #makerule cpuflags   
 #	depends	"Makefile.settings" 
 #	action	"perl -e 'print \"CPUFLAGS :=\n\"; foreach $$var (split(\" \", $$ENV{VARIABLES})) { if (exists($$ENV{$$var})) { print \"CPUFLAGS += -D$$var\" . (length($$ENV{$$var})?\"=\x27$$ENV{$$var}\x27\":\"\") .\"\n\"} else { print \"CPUFLAGS += -U$$var\n\"} }' > $@"
 #end
 
 #makerule ldoptions   
 #	depends	"Makefile.settings" 
 #	action	"perl -e 'foreach $$var (split(\" \", $$ENV{VARIABLES})) { if ($$ENV{$$var} =~ m/^(0x[0-9a-fA-F]+|0[0-7]+|[0-9]+)$$/) { print \"$$var = $$ENV{$$var};\n\"; }}' > $@"
 #end
 
 makerule coreboot.strip  
 	depends	"coreboot" 
 	action	"$(OBJCOPY) -O binary coreboot coreboot.strip"
 end
 
 makerule coreboot.a
         depends "$(OBJECTS)"
         action  "rm -f coreboot.a"
         action  "$(CROSS_COMPILE)ar cr coreboot.a $(OBJECTS)"
 end
 
 
 makerule coreboot_ram.o
 	depends	"$(DRIVER) coreboot.a $(LIBGCC_FILE_NAME)" 
 	action	"$(CC) $(DISTRO_LFLAGS) -nostdlib -r -o $@ c_start.o $(DRIVER) coreboot.a $(LIBGCC_FILE_NAME)"
 end
 
 makerule coreboot_ram
 	depends	"coreboot_ram.o $(TOP)/src/config/coreboot_ram.ld ldoptions" 
 	action	"$(CC) $(DISTRO_LFLAGS) -nostdlib -nostartfiles -static -o $@ -T $(TOP)/src/config/coreboot_ram.ld coreboot_ram.o"
 	action 	"$(CROSS_COMPILE)nm -n coreboot_ram | sort > coreboot_ram.map"
 end
 
 ##
 ## By default compress the part of coreboot that runs from RAM
 ##
 makedefine COREBOOT_RAM-$(CONFIG_COMPRESS):=coreboot_ram.nrv2b
 makedefine COREBOOT_RAM-$(CONFIG_UNCOMPRESSED):=coreboot_ram.bin
 
 makerule coreboot_ram.bin 
 	depends	"coreboot_ram" 
 	action	"$(OBJCOPY) -O binary $< $@"
 end
 
 makerule coreboot_ram.nrv2b 
 	depends	"coreboot_ram.bin nrv2b" 
 	action	"./nrv2b e $< $@"
 end
 
 makerule coreboot_ram.rom
 	depends	"$(COREBOOT_RAM-1)" 
 	action	"cp $(COREBOOT_RAM-1) coreboot_ram.rom"
 end
 
 makedefine COREBOOT_APC:=
 
 if CONFIG_AP_CODE_IN_CAR
 	#for ap code in cache
 
 	makerule coreboot_apc.a
 		depends "apc_auto.o"
 		action  "rm -f coreboot_apc.a"
 		action  "$(CROSS_COMPILE)ar cr coreboot_apc.a apc_auto.o"
 	end
 
 	makerule coreboot_apc.o
 		depends "coreboot_apc.a c_start.o $(LIBGCC_FILE_NAME)"
         	action  "$(CC) $(DISTRO_LFLAGS) -nostdlib -r -o $@ c_start.o coreboot_apc.a $(LIBGCC_FILE_NAME)"
 	end
 
 	makerule coreboot_apc
 		depends "coreboot_apc.o $(TOP)/src/config/coreboot_apc.ld ldoptions"
 		action  "$(CC) $(DISTRO_LFLAGS) -nostdlib -nostartfiles -static -o $@ -T $(TOP)/src/config/coreboot_apc.ld coreboot_apc.o"
 		action  "$(CROSS_COMPILE)nm -n coreboot_apc | sort > coreboot_apc.map"
 	end
 
 	##
 	## By default compress the part of coreboot that runs from cache as ram
 	##
 	makedefine COREBOOT_APC-$(CONFIG_COMPRESS):=coreboot_apc.nrv2b
 	makedefine COREBOOT_APC-$(CONFIG_UNCOMPRESSED):=coreboot_apc.bin
 
 	makerule coreboot_apc.bin
 		depends "coreboot_apc"
 		action  "$(OBJCOPY) -O binary $< $@"
 	end
 
 	makerule coreboot_apc.nrv2b
         depends "coreboot_apc.bin nrv2b"
         action  "./nrv2b e $< $@"
 	end
 
 	makerule coreboot_apc.rom
 		depends "$(COREBOOT_APC-1)"
 		action  "cp $(COREBOOT_APC-1) coreboot_apc.rom"
 	end
 
 	makedefine COREBOOT_APC:=coreboot_apc.rom
 
 end
 
 makedefine COREBOOT_RAM_ROM:=coreboot_ram.rom
 
 makerule coreboot   
 	depends	"crt0.o $(INIT-OBJECTS) $(COREBOOT_APC) $(COREBOOT_RAM_ROM) ldscript.ld"
 	action	"$(CC) $(DISTRO_LFLAGS) -nostdlib -nostartfiles -static -o $@ -T ldscript.ld crt0.o $(INIT-OBJECTS)"
 	action	"$(CROSS_COMPILE)nm -n coreboot | sort > coreboot.map"
 end
 
 # the buildrom tool
 makerule buildrom 
 	depends	"$(TOP)/util/buildrom/buildrom.c" 
 	action	"$(HOSTCC) -o $@ $<"
 end
 
 # Force crt0.s (which has build time version code in it to rebuild every time)
 makedefine .PHONY : crt0.s
 makerule crt0.s   
 	depends	"crt0.S $(CRT0_INCLUDES)" 
 	action	"$(CPP) $(CPPFLAGS) -I. -I$(TOP)/src  $< > $@.new && mv $@.new $@"
 end
 
 makerule crt0.o  
 	depends	"crt0.s" 
 	action	"@$(CC) -c $(CPU_OPT) -o $@ $<"
 end
 
 makerule etags   
 	depends	"$(SOURCES)" 
 	action	"etags $(SOURCES)"
 end
 makerule tags   
 	depends	"$(SOURCES)" 
 	action	"ctags $(SOURCES)"
 end
 makerule corebootDoc.config
 	depends	"$(TOP)/src/config/corebootDoc.config" 
 	action "cat $(TOP)/src/config/corebootDoc.config > corebootDoc.config"
         action "echo 'INPUT=$(SOURCES)' >> corebootDoc.config"
 end
 makerule documentation   
 	depends	"corebootDoc.config"
 	action	"doxygen corebootDoc.config"
 end
 
-makerule ./romcc   
+makerule ../romcc   
 	depends	"$(TOP)/util/romcc/romcc.c" 
 	action	"$(HOSTCC) -g $(HOSTCFLAGS) $< -o $@"
 end
 
 makerule build_opt_tbl   
 	depends	"$(TOP)/util/options/build_opt_tbl.c $(TOP)/src/include/pc80/mc146818rtc.h $(TOP)/src/include/boot/coreboot_tables.h Makefile.settings Makefile"
 	action	"$(HOSTCC) $(HOSTCFLAGS) $(CPUFLAGS) $< -o $@" 
 end
 
 makerule option_table.c
 	depends	"build_opt_tbl $(MAINBOARD)/cmos.layout" 
 	action	"./build_opt_tbl -b  --config $(MAINBOARD)/cmos.layout --header option_table.h"
 end
 
 makerule option_table.h
 	depends	"build_opt_tbl $(MAINBOARD)/cmos.layout" 
 	action	"./build_opt_tbl -b  --config $(MAINBOARD)/cmos.layout --header option_table.h"
 end
 
 if HAVE_OPTION_TABLE
 object ./option_table.o 
 end
 
 makerule clean  
 	action	"rm -f coreboot.* *~"
 	action	"rm -f coreboot"
 	action	"rm -f ldscript.ld"
 	action	"rm -f a.out *.s *.l *.o *.E *.inc"
 	action	"rm -f TAGS tags romcc*"
 	action	"rm -f docipl buildrom* chips.c *chip.c coreboot_apc* coreboot_ram* coreboot_pay*"
 	action	"rm -f build_opt_tbl* nrv2b* option_table.c crt0.S"
 end
 
 # do standard config files that the user need not specify
 # for now, this is just 'lib', but it may be more later. 
 dir /lib
 dir /console
 dir /stream
 dir /devices
 dir /pc80
 dir /boot
diff --git a/src/mainboard/a-trend/atc-6220/Config.lb b/src/mainboard/a-trend/atc-6220/Config.lb
index 4a82679..8789503 100644
--- a/src/mainboard/a-trend/atc-6220/Config.lb
+++ b/src/mainboard/a-trend/atc-6220/Config.lb
@@ -1,141 +1,141 @@
 ##
 ## This file is part of the coreboot project.
 ##
 ## Copyright (C) 2007 Uwe Hermann <uwe@hermann-uwe.de>
 ##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2 of the License, or
 ## (at your option) any later version.
 ##
 ## This program is distributed in the hope that it will be useful,
 ## but WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ## GNU General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this program; if not, write to the Free Software
 ## Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 ##
 
 if USE_FALLBACK_IMAGE
 	default ROM_SECTION_SIZE = FALLBACK_SIZE
 	default ROM_SECTION_OFFSET = (ROM_SIZE - FALLBACK_SIZE)
 else
 	default ROM_SECTION_SIZE = (ROM_SIZE - FALLBACK_SIZE)
 	default ROM_SECTION_OFFSET = 0
 end
 default CONFIG_ROM_PAYLOAD_START = (0xffffffff - ROM_SIZE
 				    + ROM_SECTION_OFFSET + 1)
 default PAYLOAD_SIZE = (ROM_SECTION_SIZE - ROM_IMAGE_SIZE)
 default _ROMBASE = (CONFIG_ROM_PAYLOAD_START + PAYLOAD_SIZE)
 default XIP_ROM_SIZE = 64 * 1024
 default XIP_ROM_BASE = (_ROMBASE + ROM_IMAGE_SIZE - XIP_ROM_SIZE)
 arch i386 end
 driver mainboard.o
 if HAVE_PIRQ_TABLE
 	object irq_tables.o
 end
 makerule ./failover.E
-	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ./romcc"
-	action "./romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
+	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ../romcc"
+	action "../romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
 end
 makerule ./failover.inc
-	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ./romcc"
-	action "./romcc -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
+	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ../romcc"
+	action "../romcc -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
 end
 makerule ./auto.E
-	# depends	"$(MAINBOARD)/auto.c option_table.h ./romcc"
-	depends	"$(MAINBOARD)/auto.c ./romcc"
-	action	"./romcc -E -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	# depends	"$(MAINBOARD)/auto.c option_table.h ../romcc"
+	depends	"$(MAINBOARD)/auto.c ../romcc"
+	action	"../romcc -E -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 makerule ./auto.inc
-	# depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-	depends "$(MAINBOARD)/auto.c ./romcc"
-	action	"./romcc -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	# depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+	depends "$(MAINBOARD)/auto.c ../romcc"
+	action	"../romcc -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 mainboardinit cpu/x86/16bit/entry16.inc
 mainboardinit cpu/x86/32bit/entry32.inc
 ldscript /cpu/x86/16bit/entry16.lds
 ldscript /cpu/x86/32bit/entry32.lds
 if USE_FALLBACK_IMAGE
 	mainboardinit cpu/x86/16bit/reset16.inc
 	ldscript /cpu/x86/16bit/reset16.lds
 else
 	mainboardinit cpu/x86/32bit/reset32.inc
 	ldscript /cpu/x86/32bit/reset32.lds
 end
 mainboardinit arch/i386/lib/cpu_reset.inc
 mainboardinit arch/i386/lib/id.inc
 ldscript /arch/i386/lib/id.lds
 if USE_FALLBACK_IMAGE
 	ldscript /arch/i386/lib/failover.lds
 	mainboardinit ./failover.inc
 end
 mainboardinit cpu/x86/fpu/enable_fpu.inc
 mainboardinit cpu/x86/mmx/enable_mmx.inc
 mainboardinit ./auto.inc
 mainboardinit cpu/x86/mmx/disable_mmx.inc
 
 dir /pc80
 config chip.h
 
 chip northbridge/intel/i440bx		# Northbridge
   device apic_cluster 0 on		# APIC cluster
     chip cpu/intel/slot_2		# CPU (FIXME: It's slot 1, actually)
       device apic 0 on end		# APIC
     end
   end
   device pci_domain 0 on		# PCI domain
     device pci 0.0 on end		# Host bridge
     device pci 1.0 on end		# PCI/AGP bridge
     chip southbridge/intel/i82371eb	# Southbridge
       device pci 7.0 on			# ISA bridge
         chip superio/winbond/w83977tf	# Super I/O (FIXME: It's W83977EF!)
           device pnp 3f0.0 on		# Floppy
             io 0x60 = 0x3f0
             irq 0x70 = 6
             drq 0x74 = 2
           end
           device pnp 3f0.1 on		# Parallel port
             io 0x60 = 0x378
             irq 0x70 = 7
           end
           device pnp 3f0.2 on		# COM1
             io 0x60 = 0x3f8
             irq 0x70 = 4
           end
           device pnp 3f0.3 on		# COM2 / IR
             io 0x60 = 0x2f8
             irq 0x70 = 3
           end
           device pnp 3f0.5 on		# PS/2 keyboard
             io 0x60 = 0x60
             io 0x62 = 0x64
             irq 0x70 = 1		# PS/2 keyboard interrupt
             irq 0x72 = 12		# PS/2 mouse interrupt
           end
           device pnp 3f0.6 on		# Consumer IR
           end
           device pnp 3f0.7 on		# GPIO 1
           end
           device pnp 3f0.8 on		# GPIO 2
           end
           device pnp 3f0.a on		# ACPI
           end
         end
       end
       device pci 7.1 on	end		# IDE
       device pci 7.2 on	end		# USB
       device pci 7.3 on end		# ACPI
       register "ide0_enable" = "1"
       register "ide1_enable" = "1"
       register "ide_legacy_enable" = "1"
       # Enable UDMA/33 for higher speed if your IDE device(s) support it.
       register "ide0_drive0_udma33_enable" = "0"
       register "ide0_drive1_udma33_enable" = "0"
       register "ide1_drive0_udma33_enable" = "0"
       register "ide1_drive1_udma33_enable" = "0"
     end
   end
 end
diff --git a/src/mainboard/a-trend/atc-6240/Config.lb b/src/mainboard/a-trend/atc-6240/Config.lb
index 116e807..14fe163 100644
--- a/src/mainboard/a-trend/atc-6240/Config.lb
+++ b/src/mainboard/a-trend/atc-6240/Config.lb
@@ -1,151 +1,151 @@
 ##
 ## This file is part of the coreboot project.
 ##
 ## Copyright (C) 2008 Uwe Hermann <uwe@hermann-uwe.de>
 ##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2 of the License, or
 ## (at your option) any later version.
 ##
 ## This program is distributed in the hope that it will be useful,
 ## but WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ## GNU General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this program; if not, write to the Free Software
 ## Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 ##
 
 if USE_FALLBACK_IMAGE
 	default ROM_SECTION_SIZE = FALLBACK_SIZE
 	default ROM_SECTION_OFFSET = (ROM_SIZE - FALLBACK_SIZE)
 else
 	default ROM_SECTION_SIZE = (ROM_SIZE - FALLBACK_SIZE)
 	default ROM_SECTION_OFFSET = 0
 end
 default CONFIG_ROM_PAYLOAD_START = (0xffffffff - ROM_SIZE
 				    + ROM_SECTION_OFFSET + 1)
 default PAYLOAD_SIZE = (ROM_SECTION_SIZE - ROM_IMAGE_SIZE)
 default _ROMBASE = (CONFIG_ROM_PAYLOAD_START + PAYLOAD_SIZE)
 default XIP_ROM_SIZE = 64 * 1024
 default XIP_ROM_BASE = (_ROMBASE + ROM_IMAGE_SIZE - XIP_ROM_SIZE)
 arch i386 end
 driver mainboard.o
 if HAVE_PIRQ_TABLE
 	object irq_tables.o
 end
 makerule ./failover.E
-	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ./romcc"
-	action "./romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
+	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ../romcc"
+	action "../romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
 end
 makerule ./failover.inc
-	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ./romcc"
-	action "./romcc -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
+	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ../romcc"
+	action "../romcc -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
 end
 makerule ./auto.E
-	# depends	"$(MAINBOARD)/auto.c option_table.h ./romcc"
-	depends	"$(MAINBOARD)/auto.c ./romcc"
-	action	"./romcc -E -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	# depends	"$(MAINBOARD)/auto.c option_table.h ../romcc"
+	depends	"$(MAINBOARD)/auto.c ../romcc"
+	action	"../romcc -E -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 makerule ./auto.inc
-	# depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-	depends "$(MAINBOARD)/auto.c ./romcc"
-	action	"./romcc -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	# depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+	depends "$(MAINBOARD)/auto.c ../romcc"
+	action	"../romcc -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 mainboardinit cpu/x86/16bit/entry16.inc
 mainboardinit cpu/x86/32bit/entry32.inc
 ldscript /cpu/x86/16bit/entry16.lds
 ldscript /cpu/x86/32bit/entry32.lds
 if USE_FALLBACK_IMAGE
 	mainboardinit cpu/x86/16bit/reset16.inc
 	ldscript /cpu/x86/16bit/reset16.lds
 else
 	mainboardinit cpu/x86/32bit/reset32.inc
 	ldscript /cpu/x86/32bit/reset32.lds
 end
 mainboardinit arch/i386/lib/cpu_reset.inc
 mainboardinit arch/i386/lib/id.inc
 ldscript /arch/i386/lib/id.lds
 if USE_FALLBACK_IMAGE
 	ldscript /arch/i386/lib/failover.lds
 	mainboardinit ./failover.inc
 end
 mainboardinit cpu/x86/fpu/enable_fpu.inc
 mainboardinit cpu/x86/mmx/enable_mmx.inc
 mainboardinit ./auto.inc
 mainboardinit cpu/x86/mmx/disable_mmx.inc
 
 dir /pc80
 config chip.h
 
 chip northbridge/intel/i440bx		# Northbridge
   device apic_cluster 0 on		# APIC cluster
     chip cpu/intel/slot_2		# CPU (FIXME: It's slot 1, actually)
       device apic 0 on end		# APIC
     end
   end
   device pci_domain 0 on		# PCI domain
     device pci 0.0 on end		# Host bridge
     device pci 1.0 on end		# PCI/AGP bridge
     chip southbridge/intel/i82371eb	# Southbridge
       device pci 7.0 on			# ISA bridge
         chip superio/winbond/w83627hf	# Super I/O
           device pnp 3f0.0 on		# Floppy
             io 0x60 = 0x3f0
             irq 0x70 = 6
             drq 0x74 = 2
           end
           device pnp 3f0.1 on		# Parallel port
             io 0x60 = 0x378
             irq 0x70 = 7
             drq 0x74 = 3
           end
           device pnp 3f0.2 on		# COM1
             io 0x60 = 0x3f8
             irq 0x70 = 4
           end
           device pnp 3f0.3 on		# COM2 / IR
             io 0x60 = 0x2f8
             irq 0x70 = 3
           end
           device pnp 3f0.5 on		# PS/2 keyboard
             io 0x60 = 0x60
             io 0x62 = 0x64
             irq 0x70 = 1		# PS/2 keyboard interrupt
             irq 0x72 = 12		# PS/2 mouse interrupt
           end
           device pnp 3f0.6 on		# Consumer IR
             io 0x60 = 0x00
           end
           device pnp 3f0.7 on		# Game port / MIDI / GPIO 1
             io 0x60 = 0x201
             io 0x62 = 0x330
             irq 0x70 = 9
           end
           device pnp 3f0.8 off		# GPIO 2 / WDT
           end
           device pnp 3f0.9 off		# GPIO 3
           end
           device pnp 3f0.a off		# ACPI
           end
           device pnp 3f0.b off		# HWM (TODO)
           end
         end
       end
       device pci 7.1 on	end		# IDE
       device pci 7.2 on	end		# USB
       device pci 7.3 on end		# ACPI
       device pci c.0 on end		# Onboard audio (ES1371)
       register "ide0_enable" = "1"
       register "ide1_enable" = "1"
       register "ide_legacy_enable" = "1"
       # Enable UDMA/33 for higher speed if your IDE device(s) support it.
       register "ide0_drive0_udma33_enable" = "0"
       register "ide0_drive1_udma33_enable" = "0"
       register "ide1_drive0_udma33_enable" = "0"
       register "ide1_drive1_udma33_enable" = "0"
     end
   end
 end
diff --git a/src/mainboard/abit/be6-ii_v2_0/Config.lb b/src/mainboard/abit/be6-ii_v2_0/Config.lb
index 5ec6bf8..8995662 100644
--- a/src/mainboard/abit/be6-ii_v2_0/Config.lb
+++ b/src/mainboard/abit/be6-ii_v2_0/Config.lb
@@ -1,141 +1,141 @@
 ##
 ## This file is part of the coreboot project.
 ##
 ## Copyright (C) 2007 Uwe Hermann <uwe@hermann-uwe.de>
 ##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2 of the License, or
 ## (at your option) any later version.
 ##
 ## This program is distributed in the hope that it will be useful,
 ## but WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ## GNU General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this program; if not, write to the Free Software
 ## Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 ##
 
 if USE_FALLBACK_IMAGE
 	default ROM_SECTION_SIZE = FALLBACK_SIZE
 	default ROM_SECTION_OFFSET = (ROM_SIZE - FALLBACK_SIZE)
 else
 	default ROM_SECTION_SIZE = (ROM_SIZE - FALLBACK_SIZE)
 	default ROM_SECTION_OFFSET = 0
 end
 default CONFIG_ROM_PAYLOAD_START = (0xffffffff - ROM_SIZE
 				    + ROM_SECTION_OFFSET + 1)
 default PAYLOAD_SIZE = (ROM_SECTION_SIZE - ROM_IMAGE_SIZE)
 default _ROMBASE = (CONFIG_ROM_PAYLOAD_START + PAYLOAD_SIZE)
 default XIP_ROM_SIZE = 64 * 1024
 default XIP_ROM_BASE = (_ROMBASE + ROM_IMAGE_SIZE - XIP_ROM_SIZE)
 arch i386 end
 driver mainboard.o
 if HAVE_PIRQ_TABLE
 	object irq_tables.o
 end
 makerule ./failover.E
-	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ./romcc"
-	action "./romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
+	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ../romcc"
+	action "../romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
 end
 makerule ./failover.inc
-	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ./romcc"
-	action "./romcc -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
+	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ../romcc"
+	action "../romcc -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
 end
 makerule ./auto.E
-	# depends	"$(MAINBOARD)/auto.c option_table.h ./romcc"
-	depends	"$(MAINBOARD)/auto.c ./romcc"
-	action	"./romcc -E -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	# depends	"$(MAINBOARD)/auto.c option_table.h ../romcc"
+	depends	"$(MAINBOARD)/auto.c ../romcc"
+	action	"../romcc -E -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 makerule ./auto.inc
-	# depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-	depends "$(MAINBOARD)/auto.c ./romcc"
-	action	"./romcc -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	# depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+	depends "$(MAINBOARD)/auto.c ../romcc"
+	action	"../romcc -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 mainboardinit cpu/x86/16bit/entry16.inc
 mainboardinit cpu/x86/32bit/entry32.inc
 ldscript /cpu/x86/16bit/entry16.lds
 ldscript /cpu/x86/32bit/entry32.lds
 if USE_FALLBACK_IMAGE
 	mainboardinit cpu/x86/16bit/reset16.inc
 	ldscript /cpu/x86/16bit/reset16.lds
 else
 	mainboardinit cpu/x86/32bit/reset32.inc
 	ldscript /cpu/x86/32bit/reset32.lds
 end
 mainboardinit arch/i386/lib/cpu_reset.inc
 mainboardinit arch/i386/lib/id.inc
 ldscript /arch/i386/lib/id.lds
 if USE_FALLBACK_IMAGE
 	ldscript /arch/i386/lib/failover.lds
 	mainboardinit ./failover.inc
 end
 mainboardinit cpu/x86/fpu/enable_fpu.inc
 mainboardinit cpu/x86/mmx/enable_mmx.inc
 mainboardinit ./auto.inc
 mainboardinit cpu/x86/mmx/disable_mmx.inc
 
 dir /pc80
 config chip.h
 
 chip northbridge/intel/i440bx		# Northbridge
   device apic_cluster 0 on		# APIC cluster
     chip cpu/intel/slot_2		# CPU (FIXME: It's slot 1, actually)
       device apic 0 on end		# APIC
     end
   end
   device pci_domain 0 on		# PCI domain
     device pci 0.0 on end		# Host bridge
     device pci 1.0 on end		# PCI/AGP bridge
     chip southbridge/intel/i82371eb	# Southbridge
       device pci 7.0 on			# ISA bridge
         chip superio/winbond/w83977tf	# Super I/O (FIXME: It's W83977EF!)
           device pnp 3f0.0 on		# Floppy
             io 0x60 = 0x3f0
             irq 0x70 = 6
             drq 0x74 = 2
           end
           device pnp 3f0.1 on		# Parallel port
             io 0x60 = 0x378
             irq 0x70 = 7
           end
           device pnp 3f0.2 on		# COM1
             io 0x60 = 0x3f8
             irq 0x70 = 4
           end
           device pnp 3f0.3 on		# COM2 / IR
             io 0x60 = 0x2f8
             irq 0x70 = 3
           end
           device pnp 3f0.5 on		# PS/2 keyboard
             io 0x60 = 0x60
             io 0x62 = 0x64
             irq 0x70 = 1		# PS/2 keyboard interrupt
             irq 0x72 = 12		# PS/2 mouse interrupt
           end
           device pnp 3f0.6 on		# Consumer IR
           end
           device pnp 3f0.7 on		# GPIO 1
           end
           device pnp 3f0.8 on		# GPIO 2
           end
           device pnp 3f0.a on		# ACPI
           end
         end
       end
       device pci 7.1 on	end		# IDE, UDMA/33 (part of 82371EB)
       device pci 7.2 on	end		# USB
       device pci 7.3 on end		# ACPI
       device pci 13.0 on end		# IDE, UDMA/66 (HPT366 controller)
       register "ide0_enable" = "1"
       register "ide1_enable" = "1"
       register "ide_legacy_enable" = "1"
       register "ide0_drive0_udma33_enable" = "1"
       register "ide0_drive1_udma33_enable" = "1"
       register "ide1_drive0_udma33_enable" = "1"
       register "ide1_drive1_udma33_enable" = "1"
     end
   end
 end
diff --git a/src/mainboard/advantech/pcm-5820/Config.lb b/src/mainboard/advantech/pcm-5820/Config.lb
index 8b69702..9029973 100644
--- a/src/mainboard/advantech/pcm-5820/Config.lb
+++ b/src/mainboard/advantech/pcm-5820/Config.lb
@@ -1,138 +1,138 @@
 ##
 ## This file is part of the coreboot project.
 ##
 ## Copyright (C) 2007 Uwe Hermann <uwe@hermann-uwe.de>
 ##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2 of the License, or
 ## (at your option) any later version.
 ##
 ## This program is distributed in the hope that it will be useful,
 ## but WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ## GNU General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this program; if not, write to the Free Software
 ## Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 ##
 
 if USE_FALLBACK_IMAGE
 	default ROM_SECTION_SIZE = FALLBACK_SIZE
 	default ROM_SECTION_OFFSET = (ROM_SIZE - FALLBACK_SIZE)
 else
 	default ROM_SECTION_SIZE = (ROM_SIZE - FALLBACK_SIZE)
 	default ROM_SECTION_OFFSET = 0
 end
 default CONFIG_ROM_PAYLOAD_START = (0xffffffff - ROM_SIZE
 				    + ROM_SECTION_OFFSET + 1)
 default PAYLOAD_SIZE = (ROM_SECTION_SIZE - ROM_IMAGE_SIZE)
 default _ROMBASE = (CONFIG_ROM_PAYLOAD_START + PAYLOAD_SIZE)
 default XIP_ROM_SIZE = 64 * 1024
 default XIP_ROM_BASE = (_ROMBASE + ROM_IMAGE_SIZE - XIP_ROM_SIZE)
 arch i386 end
 driver mainboard.o
 if HAVE_PIRQ_TABLE
 	object irq_tables.o
 end
 makerule ./failover.E
-	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ./romcc"
-	action "./romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
+	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ../romcc"
+	action "../romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
 end
 makerule ./failover.inc
-	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ./romcc"
-	action "./romcc -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
+	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ../romcc"
+	action "../romcc -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
 end
 makerule ./auto.E
-	# depends	"$(MAINBOARD)/auto.c option_table.h ./romcc"
-	depends	"$(MAINBOARD)/auto.c ./romcc"
-	action	"./romcc -E -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	# depends	"$(MAINBOARD)/auto.c option_table.h ../romcc"
+	depends	"$(MAINBOARD)/auto.c ../romcc"
+	action	"../romcc -E -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 makerule ./auto.inc
-	# depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-	depends "$(MAINBOARD)/auto.c ./romcc"
-	action	"./romcc -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	# depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+	depends "$(MAINBOARD)/auto.c ../romcc"
+	action	"../romcc -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 mainboardinit cpu/x86/16bit/entry16.inc
 mainboardinit cpu/x86/32bit/entry32.inc
 ldscript /cpu/x86/16bit/entry16.lds
 ldscript /cpu/x86/32bit/entry32.lds
 if USE_FALLBACK_IMAGE
 	mainboardinit cpu/x86/16bit/reset16.inc
 	ldscript /cpu/x86/16bit/reset16.lds
 else
 	mainboardinit cpu/x86/32bit/reset32.inc
 	ldscript /cpu/x86/32bit/reset32.lds
 end
 mainboardinit arch/i386/lib/cpu_reset.inc
 mainboardinit arch/i386/lib/id.inc
 ldscript /arch/i386/lib/id.lds
 if USE_FALLBACK_IMAGE
 	ldscript /arch/i386/lib/failover.lds
 	mainboardinit ./failover.inc
 end
 mainboardinit cpu/x86/fpu/enable_fpu.inc
 mainboardinit cpu/amd/model_gx1/cpu_setup.inc
 mainboardinit cpu/amd/model_gx1/gx_setup.inc
 mainboardinit ./auto.inc
 
 dir /pc80
 config chip.h
 
 chip northbridge/amd/gx1		# Northbridge
   device pci_domain 0 on		# PCI domain
     device pci 0.0 on end		# Host bridge
     chip southbridge/amd/cs5530		# Southbridge
       device pci 12.0 on		# ISA bridge
         chip superio/winbond/w83977f	# SUper I/O
           device pnp 3f0.0 on		# Floppy
             io 0x60 = 0x3f0
             irq 0x70 = 6
             drq 0x74 = 2
           end
           device pnp 3f0.1 on		# Parallel port
             io 0x60 = 0x378
             irq 0x70 = 7
           end
           device pnp 3f0.2 on		# COM1
             io 0x60 = 0x3f8
             irq 0x70 = 4
           end
           device pnp 3f0.3 on		# COM2
             io 0x60 = 0x2f8
             irq 0x70 = 3
           end
           device pnp 3f0.4 on		# RTC / On-Now control
             io 0x60 = 0x70
             irq 0x70 = 8
           end
           device pnp 3f0.5 on		# PS/2 keyboard / mouse
             io 0x60 = 0x60
             io 0x62 = 0x64
             irq 0x70 = 1		# PS/2 keyboard interrupt
             irq 0x72 = 12		# PS/2 mouse interrupt
           end
           device pnp 3f0.6 on		# IR
             # TODO?
           end
           device pnp 3f0.7 on		# GPIO 1
             # TODO?
           end
           device pnp 3f0.8 on		# GPIO 2
             # TODO?
           end
         end
       end
       device pci 12.1 on end		# SMI
       device pci 12.2 on end		# IDE
       device pci 12.3 on end		# Audio (onboard)
       device pci 12.4 on end		# VGA
       device pci 13.0 on end		# USB
       register "ide0_enable" = "1"
       register "ide1_enable" = "1"
     end
   end
   chip cpu/amd/model_gx1		# CPU
   end
 end
diff --git a/src/mainboard/agami/aruma/Config.lb b/src/mainboard/agami/aruma/Config.lb
index 545e9d7..344ea92 100644
--- a/src/mainboard/agami/aruma/Config.lb
+++ b/src/mainboard/agami/aruma/Config.lb
@@ -1,460 +1,460 @@
 ##
 ## Compute the location and size of where this firmware image
 ## (coreboot plus bootloader) will live in the boot rom chip.
 ##
 if USE_FALLBACK_IMAGE
 	default ROM_SECTION_SIZE   = FALLBACK_SIZE
 	default ROM_SECTION_OFFSET = ( ROM_SIZE - FALLBACK_SIZE )
 else
 	default ROM_SECTION_SIZE   = ( ROM_SIZE - FALLBACK_SIZE )
 	default ROM_SECTION_OFFSET = 0
 end
 
 ##
 ## Compute the start location and size size of
 ## The coreboot bootloader.
 ##
 default PAYLOAD_SIZE            = ( ROM_SECTION_SIZE - ROM_IMAGE_SIZE )
 default CONFIG_ROM_PAYLOAD_START = (0xffffffff - ROM_SIZE + ROM_SECTION_OFFSET + 1)
 
 ##
 ## Compute where this copy of coreboot will start in the boot rom
 ##
 default _ROMBASE      = ( CONFIG_ROM_PAYLOAD_START + PAYLOAD_SIZE )
 
 ##
 ## Compute a range of ROM that can cached to speed up coreboot,
 ## execution speed.
 ##
 ## XIP_ROM_SIZE must be a power of 2.
 ## XIP_ROM_BASE must be a multiple of XIP_ROM_SIZE
 ##
 default XIP_ROM_SIZE=65536
 default XIP_ROM_BASE = ( _ROMBASE + ROM_IMAGE_SIZE - XIP_ROM_SIZE )
 
 arch i386 end 
 
 ##
 ## Build the objects we have code for in this directory.
 ##
 
 driver mainboard.o
 if HAVE_MP_TABLE object mptable.o end
 if HAVE_PIRQ_TABLE object irq_tables.o end
 
 #needed by irq_tables and mptable and acpi_tables
 #object get_bus_conf.o
 
 if HAVE_ACPI_TABLES
  	object acpi_tables_static.o
 	object fadt.o
 
 	object dsdt.o
 
 #	makerule dsdt.c
 #		depends "$(MAINBOARD)/dx/dsdt_lb.dsl"
 #		action  "iasl -tc $(MAINBOARD)/dx/dsdt_lb.dsl"
 #		action  "mv dsdt_lb.hex dsdt.c"
 #	end
 #	object ./dsdt.o
 #
 #	makerule ssdt.c
 #		depends "$(MAINBOARD)/ssdt_lb_x.dsl"
 #		action  "iasl -tc $(MAINBOARD)/ssdt_lb_x.dsl"
 #		action  "perl -pi -e 's/AmlCode/AmlCode_ssdt/g' ssdt_lb_x.hex"
 #		action  "mv ssdt_lb_x.hex ssdt.c"
 #	end
 #	object ./ssdt.o
 #	
 #	if ACPI_SSDTX_NUM
 #		makerule ssdt2.c
 #			depends "$(MAINBOARD)/dx/pci2.asl"
 #			action  "iasl -tc $(MAINBOARD)/dx/pci2.asl"
 #			action  "perl -pi -e 's/AmlCode/AmlCode_ssdt2/g' pci2.hex"
 #			action  "mv pci2.hex ssdt2.c"
 #		end
 #		object ./ssdt2.o
 #		makerule ssdt3.c
 #			depends "$(MAINBOARD)/dx/pci3.asl"
 #			action  "iasl -tc $(MAINBOARD)/dx/pci3.asl"
 #			action  "perl -pi -e 's/AmlCode/AmlCode_ssdt3/g' pci3.hex"
 #			action  "mv pci3.hex ssdt3.c"
 #		end
 #		object ./ssdt3.o
 #		makerule ssdt4.c
 #			depends "$(MAINBOARD)/dx/pci4.asl"
 #			action  "iasl -tc $(MAINBOARD)/dx/pci4.asl"
 #			action  "perl -pi -e 's/AmlCode/AmlCode_ssdt4/g' pci4.hex"
 #			action  "mv pci4.hex ssdt4.c"
 #		end
 #		object ./ssdt4.o
 #
 #	end
 end
 
 
 
 #object reset.o
 
 # FIXME: This should be solved generically.
 #object vgabios.o
 #driver atiragexl.o
 
 if USE_DCACHE_RAM
 
 	if CONFIG_USE_INIT
 		# compile cache_as_ram.c to auto.o
 		makerule ./cache_as_ram_auto.o
 		        depends "$(MAINBOARD)/cache_as_ram_auto.c option_table.h"
 		        action "$(CC) $(DISTRO_CFLAGS) -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/cache_as_ram_auto.c -Os -nostdinc -nostdlib -fno-builtin -Wall -c -o cache_as_ram_auto.o" 
 		end
 
 	else   
 		#compile cache_as_ram.c to auto.inc 
 		makerule ./cache_as_ram_auto.inc
 		        depends "$(MAINBOARD)/cache_as_ram_auto.c option_table.h"
 		        action "$(CC) $(DISTRO_CFLAGS) -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/cache_as_ram_auto.c -Os -nostdinc -nostdlib -fno-builtin -Wall -c -S -o $@"         
 		        action "perl -e 's/.rodata/.rom.data/g' -pi $@"
 		        action "perl -e 's/.text/.section .rom.text/g' -pi $@"
 		end
 
 	end
 else
   
 	##
 	## Romcc output
 	##
 	makerule ./failover.E
-        	depends "$(MAINBOARD)/failover.c ./romcc"
-	        action "./romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+        	depends "$(MAINBOARD)/failover.c ../romcc"
+	        action "../romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 	end
 
 	makerule ./failover.inc
-        	depends "$(MAINBOARD)/failover.c ./romcc"
-	        action "./romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+        	depends "$(MAINBOARD)/failover.c ../romcc"
+	        action "../romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 	end
 
 	makerule ./auto.E
-        	depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-	        action  "./romcc -E -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+        	depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+	        action  "../romcc -E -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 	end
 	makerule ./auto.inc
-        	depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-	        action  "./romcc    -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+        	depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+	        action  "../romcc    -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 	end
 
 end
 ##
 ## Build our 16 bit and 32 bit coreboot entry code
 ##
 
 mainboardinit cpu/x86/16bit/entry16.inc
 ldscript /cpu/x86/16bit/entry16.lds
 
 mainboardinit cpu/x86/32bit/entry32.inc
 if USE_DCACHE_RAM
 	if CONFIG_USE_INIT
 		ldscript /cpu/x86/32bit/entry32.lds
 	end
 
 	if CONFIG_USE_INIT
 		ldscript /cpu/amd/car/cache_as_ram.lds
 	end
 end
 
 ##
 ## Build our reset vector (This is where coreboot is entered)
 ##
 if USE_FALLBACK_IMAGE 
 	mainboardinit cpu/x86/16bit/reset16.inc 
 	ldscript /cpu/x86/16bit/reset16.lds 
 else
 	mainboardinit cpu/x86/32bit/reset32.inc 
 	ldscript /cpu/x86/32bit/reset32.lds 
 end
 
 if USE_DCACHE_RAM
 else
 	### Should this be in the northbridge code?
 	mainboardinit arch/i386/lib/cpu_reset.inc
 end
 
 ##
 ## Include an id string (For safe flashing)
 ##
 mainboardinit arch/i386/lib/id.inc
 ldscript /arch/i386/lib/id.lds
 
 if USE_DCACHE_RAM
 	##
 	## Setup Cache-As-Ram
 	##
 	mainboardinit cpu/amd/car/cache_as_ram.inc
 end
 
 ###
 ### This is the early phase of coreboot startup 
 ### Things are delicate and we test to see if we should
 ### failover to another image.
 ###
 if USE_FALLBACK_IMAGE
 	if USE_DCACHE_RAM
 		ldscript /arch/i386/lib/failover.lds
 	else
 		ldscript /arch/i386/lib/failover.lds
 		mainboardinit ./failover.inc
 	end
 end
 
 ###
 ### O.k. We aren't just an intermediary anymore!
 ###
 
 ##
 ## Setup RAM
 ##
 if USE_DCACHE_RAM
 
 	if CONFIG_USE_INIT
 		initobject cache_as_ram_auto.o
 	else
 		mainboardinit ./cache_as_ram_auto.inc
 	end
 
 else
 
 	##
 	## Setup RAM
 	##
 	mainboardinit cpu/x86/fpu/enable_fpu.inc
 	mainboardinit cpu/x86/mmx/enable_mmx.inc
 	mainboardinit cpu/x86/sse/enable_sse.inc
 	mainboardinit ./auto.inc
 	mainboardinit cpu/x86/sse/disable_sse.inc
 	mainboardinit cpu/x86/mmx/disable_mmx.inc
 
 end
 
 ##
 ## Include the secondary Configuration files 
 ##
 
 dir /pc80
 
 config chip.h
 
 # config for agami/aruma
 chip northbridge/amd/amdk8/root_complex
         device apic_cluster 0 on
                 chip cpu/amd/socket_940
                         device apic 0 on end
                 end
         end
 	device pci_domain 0 on
 	    chip northbridge/amd/amdk8
 		device pci 18.0 on end #  device pci 18.0 
 		device pci 18.0 on 
 			#  devices on link 1, link 1 == LDT 1 
 			chip southbridge/amd/amd8131
 				# the on/off keyword is mandatory
 				device pci 0.0 on end
 				device pci 0.1 on end
 				device pci 1.0 on end
 				device pci 1.1 on end
 			end # 8131
 			chip southbridge/amd/amd8111
 				# this "device pci 0.0" is the parent the next one
 				# PCI bridge
 				device pci 0.0 on
 					device pci 0.0 on end
 					device pci 0.1 on end
 					device pci 0.2 off end
 					device pci 1.0 off end
 					#chip drivers/ati/ragexl
 					chip drivers/pci/onboard
 						device pci 4.0 on end
 						register "rom_address" = "0xfff80000"
 					end
 				end
 				device pci 1.0 on
 					chip superio/winbond/w83627hf
                                                device pnp 2e.0 on #  Floppy
                                                         io 0x60 = 0x3f0
                                                         irq 0x70 = 6
                                                         drq 0x74 = 2
                                                 end
                                                 device pnp 2e.1 off #  Parallel Port
                                                         io 0x60 = 0x378
                                                         irq 0x70 = 7
                                                 end
                                                 device pnp 2e.2 on #  Com1
                                                         io 0x60 = 0x3f8
                                                         irq 0x70 = 4
                                                 end
                                                 device pnp 2e.3 on #  Com2
                                                         io 0x60 = 0x2f8
                                                         irq 0x70 = 3
                                                 end
                                                 device pnp 2e.5 on #  Keyboard
                                                         io 0x60 = 0x60
                                                         io 0x62 = 0x64
                                                         irq 0x70 = 1
                                                         irq 0x72 = 12
                                                 end
                                                 device pnp 2e.6 off #  CIR
                                                         io 0x60 = 0x100
                                                 end
                                                 device pnp 2e.7 off # GAME_MIDI_GIPO1
                                                         io 0x60 = 0x201
                                                         io 0x62 = 0x330
                                                         irq 0x70 = 9
                                                 end
                                                 device pnp 2e.8 off end # GPIO2
                                                 device pnp 2e.9 off end # GPIO3
                                                 device pnp 2e.a off end #  ACPI
                                                 device pnp 2e.b on #  HW Monitor
                                                         io 0x60 = 0x290
                                                         irq 0x70 = 5
                                                 end
 					end
 				end
 				device pci 1.1 on end
 				device pci 1.2 on end
 				device pci 1.3 on 
                                         chip drivers/i2c/i2cmux2 # pca9545 smbus mux
                                                 device i2c 71 on     #pca9545 channel0
                                                         chip drivers/i2c/adm1026
                                                                 device i2c 2d on end
                                                         end
                                                 end
 						device i2c 71 on     #pca9545 channel1
                                                         chip drivers/generic/generic # fan board / pstray behind another mux
                                                                 device i2c 2d on end
                                                         end
                                                 end
                                         end
                                         chip drivers/i2c/i2cmux2 # pca9543 smbus mux
                                                 device i2c 73 on     #pca9543 channel0
 							chip drivers/generic/generic #dimm 0-0-0
 								device i2c 50 on end
 							end
 							chip drivers/generic/generic #dimm 0-0-1
 								device i2c 51 on end
 							end 
 							chip drivers/generic/generic #dimm 0-1-0
 								device i2c 52 on end
 							end 
 							chip drivers/generic/generic #dimm 0-1-1
 								device i2c 53 on end
 							end 
 						end
 
                                                 device i2c 73 on     #pca9543 channel1
 							chip drivers/generic/generic #dimm 1-0-0
 								device i2c 50 on end 
 							end
 							chip drivers/generic/generic #dimm 1-0-1
 								device i2c 51 on end
 							end 
 							chip drivers/generic/generic #dimm 1-1-0
 								device i2c 52 on end
 							end 
 							chip drivers/generic/generic #dimm 1-1-1
 								device i2c 53 on end
 							end 
 						end
 					end # chip end
 					chip drivers/generic/generic # ICS950405AF
 						device i2c 69 on end
 					end
 				end
 				device pci 1.5 off end
 				device pci 1.6 on end
 				register "ide0_enable" = "1"
 				register "ide1_enable" = "1"
 			end # 8111
 		end # LDT1
 		device pci 18.0 on end # LDT2
 		device pci 18.1 on end
 		device pci 18.2 on end
 		device pci 18.3 on end
 	    end
 
 		chip northbridge/amd/amdk8
 			device pci 19.0 on end # LDT0
 			device pci 19.0 on end # LDT1
 			device pci 19.0 on # LDT2
 				chip southbridge/amd/amd8131
 					# the on/off keyword is mandatory
 					device pci 0.0 on end
 					device pci 0.1 on end
 					device pci 1.0 on end
 					device pci 1.1 on end
 				end
 				chip southbridge/amd/amd8131
 					# the on/off keyword is mandatory
 					device pci 0.0 on end
 					device pci 0.1 on end
 					device pci 1.0 on end
 					device pci 1.1 on end
 				end
 			end # LDT2
 			device pci 19.1 on end
 			device pci 19.2 on end
 			device pci 19.3 on end
 		end
 
                 chip northbridge/amd/amdk8
                         device pci 1a.0 on end
                         device pci 1a.0 on end
                         device pci 1a.0 on # LDT2
 				chip southbridge/amd/amd8131
 					# the on/off keyword is mandatory
 					device pci 0.0 on end
 					device pci 0.1 on end
 					device pci 1.0 on end
 					device pci 1.1 on end
 				end
 				chip southbridge/amd/amd8131
 					# the on/off keyword is mandatory
 					device pci 0.0 on end
 					device pci 0.1 on end
 					device pci 1.0 on end
 					device pci 1.1 on end
 				end
 
 			end # LDT2
                         device pci 1a.1 on end
                         device pci 1a.2 on end
                         device pci 1a.3 on end
                 end
 
                 chip northbridge/amd/amdk8
                         device pci 1b.0 on end
                         device pci 1b.0 on # LDT1
 				chip southbridge/amd/amd8131
 					# the on/off keyword is mandatory
 					device pci 0.0 on end
 					device pci 0.1 on end
 					device pci 1.0 on end
 					device pci 1.1 on end
 				end
 				chip southbridge/amd/amd8131
 					# the on/off keyword is mandatory
 					device pci 0.0 on end
 					device pci 0.1 on end
 					device pci 1.0 on end
 					device pci 1.1 on end
 				end
 
 			end
                         device pci 1b.0 on end
                         device pci 1b.1 on end
                         device pci 1b.2 on end
                         device pci 1b.3 on end
                 end
 
 
 	end 
 end
 
diff --git a/src/mainboard/amd/rumba/Config.lb b/src/mainboard/amd/rumba/Config.lb
index f7a9616..e8f7fe8 100644
--- a/src/mainboard/amd/rumba/Config.lb
+++ b/src/mainboard/amd/rumba/Config.lb
@@ -1,146 +1,146 @@
 ##
 ## Compute the location and size of where this firmware image
 ## (coreboot plus bootloader) will live in the boot rom chip.
 ##
 if USE_FALLBACK_IMAGE
 	default ROM_SECTION_SIZE   = FALLBACK_SIZE
 	default ROM_SECTION_OFFSET = ( ROM_SIZE - FALLBACK_SIZE )
 else
 	default ROM_SECTION_SIZE   = ( ROM_SIZE - FALLBACK_SIZE )
 	default ROM_SECTION_OFFSET = 0
 end
 
 ##
 ## Compute the start location and size size of
 ## The coreboot bootloader.
 ##
 default CONFIG_ROM_PAYLOAD_START = (0xffffffff - ROM_SIZE + ROM_SECTION_OFFSET + 1)
 default PAYLOAD_SIZE            = ( ROM_SECTION_SIZE - ROM_IMAGE_SIZE )
 
 ##
 ## Compute where this copy of coreboot will start in the boot rom
 ##
 default _ROMBASE      = ( CONFIG_ROM_PAYLOAD_START + PAYLOAD_SIZE )
 
 ##
 ## Compute a range of ROM that can cached to speed up coreboot,
 ## execution speed.
 ##
 ## XIP_ROM_SIZE must be a power of 2.
 ## XIP_ROM_BASE must be a multiple of XIP_ROM_SIZE
 ##
 default XIP_ROM_SIZE=65536
 default XIP_ROM_BASE = ( _ROMBASE + ROM_IMAGE_SIZE - XIP_ROM_SIZE )
 
 ##
 ## Set all of the defaults for an x86 architecture
 ##
 
 arch i386 end
 
 ##
 ## Build the objects we have code for in this directory.
 ##
 
 driver mainboard.o
 
 if HAVE_PIRQ_TABLE object irq_tables.o end
 #object reset.o
 
 ##
 ## Romcc output
 ##
 makerule ./failover.E
-	depends "$(MAINBOARD)/failover.c ./romcc" 
-	action "./romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+	depends "$(MAINBOARD)/failover.c ../romcc" 
+	action "../romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 end
 
 makerule ./failover.inc
-	depends "$(MAINBOARD)/failover.c ./romcc"
-	action "./romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+	depends "$(MAINBOARD)/failover.c ../romcc"
+	action "../romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 end
 
 makerule ./auto.E 
-	depends	"$(MAINBOARD)/auto.c option_table.h ./romcc" 
-	action	"./romcc -E -mcpu=p2 -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	depends	"$(MAINBOARD)/auto.c option_table.h ../romcc" 
+	action	"../romcc -E -mcpu=p2 -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 makerule ./auto.inc 
-	depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-	action	"./romcc    -mcpu=p2 -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+	action	"../romcc    -mcpu=p2 -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 
 ##
 ## Build our 16 bit and 32 bit coreboot entry code
 ##
 mainboardinit cpu/x86/16bit/entry16.inc
 mainboardinit cpu/x86/32bit/entry32.inc
 ldscript /cpu/x86/16bit/entry16.lds
 ldscript /cpu/x86/32bit/entry32.lds
 
 ##
 ## Build our reset vector (This is where coreboot is entered)
 ##
 if USE_FALLBACK_IMAGE 
 	mainboardinit cpu/x86/16bit/reset16.inc 
 	ldscript /cpu/x86/16bit/reset16.lds 
 else
 	mainboardinit cpu/x86/32bit/reset32.inc 
 	ldscript /cpu/x86/32bit/reset32.lds 
 end
 
 ### Should this be in the northbridge code?
 mainboardinit arch/i386/lib/cpu_reset.inc
 
 ##
 ## Include an id string (For safe flashing)
 ##
 mainboardinit arch/i386/lib/id.inc
 ldscript /arch/i386/lib/id.lds
 
 ###
 ### This is the early phase of coreboot startup 
 ### Things are delicate and we test to see if we should
 ### failover to another image.
 ###
 if USE_FALLBACK_IMAGE
 	ldscript /arch/i386/lib/failover.lds 
 	mainboardinit ./failover.inc
 end
 
 ###
 ### O.k. We aren't just an intermediary anymore!
 ###
 
 ##
 ## Setup RAM
 ##
 mainboardinit cpu/x86/fpu/enable_fpu.inc
 mainboardinit ./auto.inc
 
 ##
 ## Include the secondary Configuration files 
 ##
 dir /pc80
 config chip.h
 
 chip northbridge/amd/gx2
 	device apic_cluster 0 on
 		chip cpu/amd/model_gx2
 			device apic 0 on end
 		end
 	end
   	device pci_domain 0 on 
     		device pci 1.0 on end
 		device pci 1.1 on end
       		chip southbridge/amd/cs5536
 			register "lpc_serirq_enable" = "0x80"  # enabled with default timing
         		device pci d.0 on end	# Realtek 8139 LAN
         		device pci f.0 on end	# ISA Bridge
         		device pci f.2 on end	# IDE Controller
         		device pci f.3 on end 	# Audio
         		device pci f.4 on end	# OHCI
 			device pci f.4 on end	# UHCI
       		end
     	end
 end
 
diff --git a/src/mainboard/arima/hdama/Config.lb b/src/mainboard/arima/hdama/Config.lb
index e6ad8da..cd5bd38 100644
--- a/src/mainboard/arima/hdama/Config.lb
+++ b/src/mainboard/arima/hdama/Config.lb
@@ -1,386 +1,386 @@
 ##
 ## Compute the location and size of where this firmware image
 ## (coreboot plus bootloader) will live in the boot rom chip.
 ##
 if USE_FALLBACK_IMAGE
 	default ROM_SECTION_SIZE   = FALLBACK_SIZE
 	default ROM_SECTION_OFFSET = ( ROM_SIZE - FALLBACK_SIZE )
 else
 	default ROM_SECTION_SIZE   = ( ROM_SIZE - FALLBACK_SIZE )
 	default ROM_SECTION_OFFSET = 0
 end
 
 ##
 ## Compute the start location and size size of
 ## The coreboot bootloader.
 ##
 default PAYLOAD_SIZE            = ( ROM_SECTION_SIZE - ROM_IMAGE_SIZE )
 default CONFIG_ROM_PAYLOAD_START = (0xffffffff - ROM_SIZE + ROM_SECTION_OFFSET + 1)
 
 ##
 ## Compute where this copy of coreboot will start in the boot rom
 ##
 default _ROMBASE      = ( CONFIG_ROM_PAYLOAD_START + PAYLOAD_SIZE )
 
 ##
 ## Compute a range of ROM that can cached to speed up coreboot,
 ## execution speed.
 ##
 ## XIP_ROM_SIZE must be a power of 2.
 ## XIP_ROM_BASE must be a multiple of XIP_ROM_SIZE
 ##
 default XIP_ROM_SIZE=131072
 default XIP_ROM_BASE = ( _ROMBASE + ROM_IMAGE_SIZE - XIP_ROM_SIZE )
 
 ##
 ## Set all of the defaults for an x86 architecture
 ##
 
 arch i386 end
 
 ##
 ## Build the objects we have code for in this directory.
 ##
 
 driver mainboard.o
 if HAVE_MP_TABLE object mptable.o end
 if HAVE_PIRQ_TABLE object irq_tables.o end
 
 if USE_DCACHE_RAM
 
 if CONFIG_USE_INIT
 
 makerule ./auto.o
         depends "$(MAINBOARD)/cache_as_ram_auto.c option_table.h"
         action "$(CC) $(DISTRO_CFLAGS) -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/cache_as_ram_auto.c -Os -nostdinc -nostdlib -fno-builtin -Wall -c -o auto.o" 
 end
 
 else    
                 
 makerule ./auto.inc
         depends "$(MAINBOARD)/cache_as_ram_auto.c option_table.h"
         action "$(CC) $(DISTRO_CFLAGS) -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/cache_as_ram_auto.c -Os -nostdinc -nostdlib -fno-builtin -Wall -c -S -o $@"         
         action "perl -e 's/.rodata/.rom.data/g' -pi $@"
         action "perl -e 's/.text/.section .rom.text/g' -pi $@"
 end
 
 end
 else
 ##
 ## Romcc output
 ##
 makerule ./failover.E
-	depends "$(MAINBOARD)/failover.c ./romcc"
-	action "./romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+	depends "$(MAINBOARD)/failover.c ../romcc"
+	action "../romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 end
 
 makerule ./failover.inc
-	depends "$(MAINBOARD)/failover.c ./romcc"
-	action "./romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+	depends "$(MAINBOARD)/failover.c ../romcc"
+	action "../romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 end
 
 makerule ./auto.E
-	depends	"$(MAINBOARD)/auto.c option_table.h ./romcc"
-	action	"./romcc -E -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	depends	"$(MAINBOARD)/auto.c option_table.h ../romcc"
+	action	"../romcc -E -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 makerule ./auto.inc
-	depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-	action	"./romcc    -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+	action	"../romcc    -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 
 end
 
 ##
 ## Build our 16 bit and 32 bit coreboot entry code
 ##
 if USE_FALLBACK_IMAGE
         mainboardinit cpu/x86/16bit/entry16.inc
         ldscript /cpu/x86/16bit/entry16.lds
 end
 
 mainboardinit cpu/x86/32bit/entry32.inc
 
 if USE_DCACHE_RAM
         if CONFIG_USE_INIT
                 ldscript /cpu/x86/32bit/entry32.lds
         end
 
         if CONFIG_USE_INIT
                 ldscript      /cpu/amd/car/cache_as_ram.lds
         end
 end
 
 ##
 ## Build our reset vector (This is where coreboot is entered)
 ##
 if USE_FALLBACK_IMAGE 
 	mainboardinit cpu/x86/16bit/reset16.inc
 	ldscript /cpu/x86/16bit/reset16.lds
 else
 	mainboardinit cpu/x86/32bit/reset32.inc
 	ldscript /cpu/x86/32bit/reset32.lds
 end
 
 if USE_DCACHE_RAM
 else
 ### Should this be in the northbridge code?
 mainboardinit arch/i386/lib/cpu_reset.inc
 end
 
 ##
 ## Include an id string (For safe flashing)
 ##
 mainboardinit arch/i386/lib/id.inc
 ldscript /arch/i386/lib/id.lds
 
 if USE_DCACHE_RAM
 ##
 ## Setup Cache-As-Ram
 ##
 mainboardinit cpu/amd/car/cache_as_ram.inc
 end
 
 ###
 ### This is the early phase of coreboot startup 
 ### Things are delicate and we test to see if we should
 ### failover to another image.
 ###
 if USE_FALLBACK_IMAGE
 if USE_DCACHE_RAM
        ldscript /arch/i386/lib/failover.lds
 else
        ldscript /arch/i386/lib/failover.lds
         mainboardinit ./failover.inc
 end
 end
 
 ###
 ### O.k. We aren't just an intermediary anymore!
 ###
 
 ##
 ## Setup RAM
 ##
 if USE_DCACHE_RAM
 
 if CONFIG_USE_INIT
 initobject auto.o
 else
 mainboardinit ./auto.inc
 end
 
 else
 
 ##
 ## Setup RAM
 ##
 mainboardinit cpu/x86/fpu/enable_fpu.inc
 mainboardinit cpu/x86/mmx/enable_mmx.inc
 mainboardinit cpu/x86/sse/enable_sse.inc
 mainboardinit ./auto.inc
 mainboardinit cpu/x86/sse/disable_sse.inc
 mainboardinit cpu/x86/mmx/disable_mmx.inc
 end
 
 ##
 ## Include the secondary Configuration files 
 ##
 config chip.h
 
 # config for arima/hdama
 chip northbridge/amd/amdk8/root_complex
 	device apic_cluster 0 on
 		chip cpu/amd/socket_940
 			device apic 0 on end
 		end
 	end
 	device pci_domain 0 on
 		chip northbridge/amd/amdk8
 			device pci 18.0 on #  northbridge 
 				#  devices on link 0, link 0 == LDT 0 
 				chip southbridge/amd/amd8131
 					# the on/off keyword is mandatory
 					device pci 0.0 on	# PCIX bridge
 						## On board NIC A
 						#chip drivers/generic/generic
 						#	device pci 3.0 on	
 						#		irq 0 = 0x13
 						#	end
 						#end
 						## On board NIC B
 						#chip drivers/generic/generic
 						#	device pci 4.0 on
 						#		irq 0 = 0x13
 						#	end
 						#end
 						## PCI Slot 3
 						#chip drivers/generic/generic
 						#	device pci 1.0 on
 						#		irq 0 = 0x11
 						#		irq 1 = 0x12
 						#		irq 2 = 0x13
 						#		irq 3 = 0x10
 						#	end
 						#end 
 						## PCI Slot 4
 						#chip drivers/generic/generic
 						#	device pci 2.0 on
 						#		irq 0 = 0x12
 						#		irq 1 = 0x13
 						#		irq 2 = 0x10
 						#		irq 3 = 0x11
 						#	end
 						#end 
 					end
 					device pci 0.1 on end	# IOAPIC
 					device pci 1.0 on 	# PCIX bridge
 						## PCI Slot 1
 						#chip drivers/generic/generic
 						#	device pci 1.0 on
 						#		irq 0 = 0x11
 						#		irq 1 = 0x12
 						#		irq 2 = 0x13
 						#		irq 3 = 0x10
 						#	end
 						#end
 						## PCI Slot 2
 						#chip drivers/generic/generic
 						#	device pci 2.0 on
 						#		irq 0 = 0x12
 						#		irq 1 = 0x13
 						#		irq 2 = 0x10
 						#		irq 3 = 0x11
 						#	end
 						#end 
 					end
 					device pci 1.1 on end	# IOAPIC
 				end
 				chip southbridge/amd/amd8111
 					# this "device pci 0.0" is the parent of the next one
 					# PCI bridge
 					device pci 0.0 on
 						device pci 0.0 on  end	# USB0
 						device pci 0.1 on  end	# USB1
 						device pci 0.2 off end	# USB 2.0
 						device pci 1.0 off end	# LAN
 						chip drivers/pci/onboard
 							device pci 6.0 on end # ATI Rage XL
 							register "rom_address" = "0xfff80000"
 						end
 						## PCI Slot 5 (correct?)
 						#chip drivers/generic/generic
 						#	device pci 5.0 on
 						#		irq 0 = 0x11
 						#		irq 1 = 0x12
 						#		irq 2 = 0x13
 						#		irq 3 = 0x10
 						#	end
 						#end 
 						## PCI Slot 6 (correct?)
 						#chip drivers/generic/generic
 						#	device pci 4.0 on
 						#		irq 0 = 0x10
 						#		irq 1 = 0x11
 						#		irq 2 = 0x12
 						#		irq 3 = 0x13
 						#	end
 						#end 
 
 					end
 					# LPC bridge
 					device pci 1.0 on
 						chip superio/nsc/pc87360
 							device	pnp 2e.0 off  # Floppy 
 								 io 0x60 = 0x3f0
 								irq 0x70 = 6
 								drq 0x74 = 2
 							end
 							device pnp 2e.1 off  # Parallel Port
 								 io 0x60 = 0x378
 								irq 0x70 = 7
 							end
 							device pnp 2e.2 off # Com 2
 								 io 0x60 = 0x2f8
 								irq 0x70 = 3
 							end
 							device pnp 2e.3 on  # Com 1
 								 io 0x60 = 0x3f8
 								irq 0x70 = 4
 							end
 							device pnp 2e.4 off end # SWC
 							device pnp 2e.5 off end # Mouse
 							device pnp 2e.6 on  # Keyboard
 								 io 0x60 = 0x60
 								 io 0x62 = 0x64
 								irq 0x70 = 1
 							end
 							device pnp 2e.7 off end # GPIO
 							device pnp 2e.8 off end # ACB
 							device pnp 2e.9 off end # FSCM
 							device pnp 2e.a off end # WDT  
 						end
 					end
 					device pci 1.1 on end	# IDE
 					device pci 1.2 on end	# SMBus 2.0
 					device pci 1.3 on 	# System Management
 						chip drivers/generic/generic
 							#phillips pca9545 smbus mux
 							device i2c 70 on 
 								# analog_devices adm1026	
 								chip drivers/generic/generic
 									device i2c 2c on end
 								end
 							end
 							device i2c 70 on end
 							device i2c 70 on end
 							device i2c 70 on end
 						end
 						chip drivers/generic/generic #dimm 0-0-0
 							device i2c 50 on end
 						end
 						chip drivers/generic/generic #dimm 0-0-1
 							device i2c 51 on end
 						end 
 						chip drivers/generic/generic #dimm 0-1-0
 							device i2c 52 on end
 						end 
 						chip drivers/generic/generic #dimm 0-1-1
 							device i2c 53 on end
 						end 
 						chip drivers/generic/generic #dimm 1-0-0
 							device i2c 54 on end 
 						end
 						chip drivers/generic/generic #dimm 1-0-1
 							device i2c 55 on end
 						end 
 						chip drivers/generic/generic #dimm 1-1-0
 							device i2c 56 on end
 						end 
 						chip drivers/generic/generic #dimm 1-1-1
 							device i2c 57 on end
 						end 
 					end
 					device pci 1.5 off end	# AC97 Audio
 					device pci 1.6 on  end	# AC97 Modem
 					register "ide0_enable" = "1"
 					register "ide1_enable" = "1"
 				end
 			end #  device pci 18.0 
 			
 			device pci 18.0 on end # LDT1
 			device pci 18.0 on end # LDT2
 			device pci 18.1 on end
 			device pci 18.2 on end
 			device pci 18.3 on end
 		end  # chip northbridge/amd/amdk8
 		chip northbridge/amd/amdk8
 			device pci 19.0 on end
 			device pci 19.0 on end
 			device pci 19.0 on end
 			device pci 19.1 on end
 			device pci 19.2 on end
 			device pci 19.3 on end
 		end
 	end 
 end
 
diff --git a/src/mainboard/asi/mb_5blgp/Config.lb b/src/mainboard/asi/mb_5blgp/Config.lb
index b841591..d25a22f 100644
--- a/src/mainboard/asi/mb_5blgp/Config.lb
+++ b/src/mainboard/asi/mb_5blgp/Config.lb
@@ -1,137 +1,137 @@
 ##
 ## This file is part of the coreboot project.
 ##
 ## Copyright (C) 2008 Uwe Hermann <uwe@hermann-uwe.de>
 ##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2 of the License, or
 ## (at your option) any later version.
 ##
 ## This program is distributed in the hope that it will be useful,
 ## but WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ## GNU General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this program; if not, write to the Free Software
 ## Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 ##
 
 if USE_FALLBACK_IMAGE
 	default ROM_SECTION_SIZE = FALLBACK_SIZE
 	default ROM_SECTION_OFFSET = (ROM_SIZE - FALLBACK_SIZE)
 else
 	default ROM_SECTION_SIZE = (ROM_SIZE - FALLBACK_SIZE)
 	default ROM_SECTION_OFFSET = 0
 end
 default CONFIG_ROM_PAYLOAD_START = (0xffffffff - ROM_SIZE
 				    + ROM_SECTION_OFFSET + 1)
 default PAYLOAD_SIZE = (ROM_SECTION_SIZE - ROM_IMAGE_SIZE)
 default _ROMBASE = (CONFIG_ROM_PAYLOAD_START + PAYLOAD_SIZE)
 default XIP_ROM_SIZE = 64 * 1024
 default XIP_ROM_BASE = (_ROMBASE + ROM_IMAGE_SIZE - XIP_ROM_SIZE)
 arch i386 end
 driver mainboard.o
 if HAVE_PIRQ_TABLE
 	object irq_tables.o
 end
 makerule ./failover.E
-	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ./romcc"
-	action "./romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
+	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ../romcc"
+	action "../romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
 end
 makerule ./failover.inc
-	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ./romcc"
-	action "./romcc -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
+	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ../romcc"
+	action "../romcc -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
 end
 makerule ./auto.E
-	# depends	"$(MAINBOARD)/auto.c option_table.h ./romcc"
-	depends	"$(MAINBOARD)/auto.c ./romcc"
-	action	"./romcc -E -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	# depends	"$(MAINBOARD)/auto.c option_table.h ../romcc"
+	depends	"$(MAINBOARD)/auto.c ../romcc"
+	action	"../romcc -E -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 makerule ./auto.inc
-	# depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-	depends "$(MAINBOARD)/auto.c ./romcc"
-	action	"./romcc -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	# depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+	depends "$(MAINBOARD)/auto.c ../romcc"
+	action	"../romcc -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 mainboardinit cpu/x86/16bit/entry16.inc
 mainboardinit cpu/x86/32bit/entry32.inc
 ldscript /cpu/x86/16bit/entry16.lds
 ldscript /cpu/x86/32bit/entry32.lds
 if USE_FALLBACK_IMAGE
 	mainboardinit cpu/x86/16bit/reset16.inc
 	ldscript /cpu/x86/16bit/reset16.lds
 else
 	mainboardinit cpu/x86/32bit/reset32.inc
 	ldscript /cpu/x86/32bit/reset32.lds
 end
 mainboardinit arch/i386/lib/cpu_reset.inc
 mainboardinit arch/i386/lib/id.inc
 ldscript /arch/i386/lib/id.lds
 if USE_FALLBACK_IMAGE
 	ldscript /arch/i386/lib/failover.lds
 	mainboardinit ./failover.inc
 end
 mainboardinit cpu/x86/fpu/enable_fpu.inc
 mainboardinit cpu/amd/model_gx1/cpu_setup.inc
 mainboardinit cpu/amd/model_gx1/gx_setup.inc
 mainboardinit ./auto.inc
 
 dir /pc80
 config chip.h
 
 chip northbridge/amd/gx1		# Northbridge
   device pci_domain 0 on		# PCI domain
     device pci 0.0 on end		# Host bridge
     chip southbridge/amd/cs5530		# Southbridge
       device pci 0f.0 on end		# Ethernet
       device pci 12.0 on		# ISA bridge
         chip superio/nsc/pc87351	# Super I/O
           device pnp 2e.0 off		# Floppy
             io 0x60 = 0x3f0
             irq 0x70 = 6
             drq 0x74 = 2
           end
           device pnp 2e.1 on		# Parallel port
             io 0x60 = 0x378
             irq 0x70 = 7
           end
           device pnp 2e.2 on		# COM2
             io 0x60 = 0x2f8
             irq 0x70 = 3
           end
           device pnp 2e.e on		# COM1
             io 0x60 = 0x3f8
             irq 0x70 = 4
           end
           device pnp 2e.4 on		# System wake-up control (SWC)
             irq 0x60 = 0x500
           end
           device pnp 2e.5 on		# PS/2 mouse
             irq 0x70 = 12
           end
           device pnp 2e.6 on		# PS/2 keyboard
             io 0x60 = 0x60
             io 0x62 = 0x64
             irq 0x70 = 1
           end
           device pnp 2e.7 on		# GPIO
             irq 0x60 = 0x800
           end
           device pnp 2e.8 on		# Fan speed control
             irq 0x60 = 0x900
           end
         end
       end
       device pci 12.1 off end		# SMI
       device pci 12.2 on end		# IDE
       device pci 12.3 on end		# Audio
       device pci 12.4 on end		# VGA
       device pci 13.0 on end		# USB
       register "ide0_enable" = "1"
       register "ide1_enable" = "0"	# No connector on this board
     end
   end
   chip cpu/amd/model_gx1		# CPU
   end
 end
diff --git a/src/mainboard/asi/mb_5blmp/Config.lb b/src/mainboard/asi/mb_5blmp/Config.lb
index fdf8f83..1dc2192 100644
--- a/src/mainboard/asi/mb_5blmp/Config.lb
+++ b/src/mainboard/asi/mb_5blmp/Config.lb
@@ -1,184 +1,184 @@
 ##
 ## Compute the location and size of where this firmware image
 ## (coreboot plus bootloader) will live in the boot rom chip.
 ##
 if USE_FALLBACK_IMAGE
 	default ROM_SECTION_SIZE   = FALLBACK_SIZE
 	default ROM_SECTION_OFFSET = ( ROM_SIZE - FALLBACK_SIZE )
 else
 	default ROM_SECTION_SIZE   = ( ROM_SIZE - FALLBACK_SIZE )
 	default ROM_SECTION_OFFSET = 0
 end
 
 ##
 ## Compute the start location and size size of
 ## The coreboot bootloader.
 ##
 default CONFIG_ROM_PAYLOAD_START = (0xffffffff - ROM_SIZE + ROM_SECTION_OFFSET + 1)
 default PAYLOAD_SIZE            = ( ROM_SECTION_SIZE - ROM_IMAGE_SIZE )
 
 ##
 ## Compute where this copy of coreboot will start in the boot rom
 ##
 default _ROMBASE      = ( CONFIG_ROM_PAYLOAD_START + PAYLOAD_SIZE )
 
 ##
 ## Compute a range of ROM that can cached to speed up coreboot,
 ## execution speed.
 ##
 ## XIP_ROM_SIZE must be a power of 2.
 ## XIP_ROM_BASE must be a multiple of XIP_ROM_SIZE
 ##
 default XIP_ROM_SIZE=65536
 default XIP_ROM_BASE = ( _ROMBASE + ROM_IMAGE_SIZE - XIP_ROM_SIZE )
 
 ##
 ## Set all of the defaults for an x86 architecture
 ##
 
 arch i386 end
 
 ##
 ## Build the objects we have code for in this directory.
 ##
 
 driver mainboard.o
 
 if HAVE_PIRQ_TABLE
 	object irq_tables.o
 end
 
 ##
 ## Romcc output
 ##
 # makerule ./failover.E
-# 	depends "$(MAINBOARD)/failover.c ./romcc" 
-# 	action "./romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+# 	depends "$(MAINBOARD)/failover.c ../romcc" 
+# 	action "../romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 # end
 # 
 # makerule ./failover.inc
-# 	depends "$(MAINBOARD)/failover.c ./romcc"
-# 	action "./romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+# 	depends "$(MAINBOARD)/failover.c ../romcc"
+# 	action "../romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 # end
 
 makerule ./auto.E 
-	depends	"$(MAINBOARD)/auto.c ./romcc" 
-	action	"./romcc -E -mcpu=i386 -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	depends	"$(MAINBOARD)/auto.c ../romcc" 
+	action	"../romcc -E -mcpu=i386 -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 makerule ./auto.inc 
-	depends "$(MAINBOARD)/auto.c ./romcc"
-	action	"./romcc    -mcpu=i386 -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	depends "$(MAINBOARD)/auto.c ../romcc"
+	action	"../romcc    -mcpu=i386 -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 
 ##
 ## Build our 16 bit and 32 bit coreboot entry code
 ##
 mainboardinit cpu/x86/16bit/entry16.inc
 mainboardinit cpu/x86/32bit/entry32.inc
 ldscript /cpu/x86/16bit/entry16.lds
 ldscript /cpu/x86/32bit/entry32.lds
 
 ##
 ## Build our reset vector (This is where coreboot is entered)
 ##
 if USE_FALLBACK_IMAGE 
 	mainboardinit cpu/x86/16bit/reset16.inc 
 	ldscript /cpu/x86/16bit/reset16.lds 
 else
 	mainboardinit cpu/x86/32bit/reset32.inc 
 	ldscript /cpu/x86/32bit/reset32.lds 
 end
 
 ### Should this be in the northbridge code?
 mainboardinit arch/i386/lib/cpu_reset.inc
 
 ##
 ## Include an id string (For safe flashing)
 ##
 mainboardinit arch/i386/lib/id.inc
 ldscript /arch/i386/lib/id.lds
 
 ###
 ### This is the early phase of coreboot startup 
 ### Things are delicate and we test to see if we should
 ### failover to another image.
 ###
 # if USE_FALLBACK_IMAGE
 # 	ldscript /arch/i386/lib/failover.lds 
 # 	mainboardinit ./failover.inc
 # end
 
 ###
 ### O.k. We aren't just an intermediary anymore!
 ###
 
 ##
 ## Setup RAM
 ##
 mainboardinit cpu/x86/fpu/enable_fpu.inc
 mainboardinit cpu/amd/model_gx1/cpu_setup.inc
 mainboardinit cpu/amd/model_gx1/gx_setup.inc
 mainboardinit ./auto.inc
 
 ##
 ## Include the secondary Configuration files 
 ##
 dir /pc80
 config chip.h
 
 chip northbridge/amd/gx1		# Northbridge
   device pci_domain 0 on
     device pci 0.0 on end		# Host bridge
     chip southbridge/amd/cs5530		# Southbridge
       device pci 0f.0 off end		# Ethernet (Realtek RTL8139B)
       device pci 12.0 on		# ISA bridge
         chip superio/nsc/pc87351	# Super I/O
           device pnp 2e.4 on		# PS/2 keyboard (+ mouse?)
             io 0x60 = 0x60
             io 0x62 = 0x64
             irq 0x70 = 1
             # irq 0x72 = 12
           end
           device pnp 2e.a on		# PS/2 mouse
             irq 0x70 = 12
           end
           device pnp 2e.e on		# COM1
             io 0x60 = 0x3f8
             irq 0x70 = 4
           end
           device pnp 2e.f off		# Floppy
             io 0x60 = 0x3f2
             irq 0x70 = 6
             drq 0x74 = 2
           end
           device pnp 2e.10 on		# Parallel port
             io 0x60 = 0x378
             irq 0x70 = 7
           end
           device pnp 2e.12 on		# COM2
             io 0x60 = 0x2f8
             irq 0x70 = 3
           end
         end
       end
       device pci 12.1 off end		# SMI
       device pci 12.2 on  end		# IDE
       device pci 12.3 on  end		# Audio
       device pci 12.4 on  end		# VGA (onboard)
       # device pci 12.4 on		# VGA (onboard)
       #   chip drivers/pci/onboard
       #     device pci 12.4 on end
       #     register "rom_address" = "0xfffc0000" # 256 KB image
       #     # register "rom_address" = "0xfff80000" # 512 KB image
       #     # register "rom_address" = "0xfff00000" # 1 MB image
       #   end
       # end
       device pci 13.0 on end		# USB
       register "ide0_enable" = "1"
       register "ide1_enable" = "1"
     end
   end
   chip cpu/amd/model_gx1		# CPU
   end
 end
 
diff --git a/src/mainboard/asus/mew-am/Config.lb b/src/mainboard/asus/mew-am/Config.lb
index 4545daa..78c5c2f 100644
--- a/src/mainboard/asus/mew-am/Config.lb
+++ b/src/mainboard/asus/mew-am/Config.lb
@@ -1,144 +1,144 @@
 ##
 ## This file is part of the coreboot project.
 ##
 ## Copyright (C) 2007 Uwe Hermann <uwe@hermann-uwe.de>
 ##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2 of the License, or
 ## (at your option) any later version.
 ##
 ## This program is distributed in the hope that it will be useful,
 ## but WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ## GNU General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this program; if not, write to the Free Software
 ## Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 ##
 
 if USE_FALLBACK_IMAGE
 	default ROM_SECTION_SIZE = FALLBACK_SIZE
 	default ROM_SECTION_OFFSET = (ROM_SIZE - FALLBACK_SIZE)
 else
 	default ROM_SECTION_SIZE = (ROM_SIZE - FALLBACK_SIZE)
 	default ROM_SECTION_OFFSET = 0
 end
 default CONFIG_ROM_PAYLOAD_START = (0xffffffff - ROM_SIZE
 				    + ROM_SECTION_OFFSET + 1)
 default PAYLOAD_SIZE = (ROM_SECTION_SIZE - ROM_IMAGE_SIZE)
 default _ROMBASE = (CONFIG_ROM_PAYLOAD_START + PAYLOAD_SIZE)
 default XIP_ROM_SIZE = 64 * 1024
 default XIP_ROM_BASE = (_ROMBASE + ROM_IMAGE_SIZE - XIP_ROM_SIZE)
 arch i386 end
 driver mainboard.o
 if HAVE_PIRQ_TABLE
 	object irq_tables.o
 end
 makerule ./failover.E
-	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ./romcc"
-	action "./romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
+	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ../romcc"
+	action "../romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
 end
 makerule ./failover.inc
-	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ./romcc"
-	action "./romcc -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
+	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ../romcc"
+	action "../romcc -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
 end
 makerule ./auto.E
-	# depends	"$(MAINBOARD)/auto.c option_table.h ./romcc"
-	depends	"$(MAINBOARD)/auto.c ./romcc"
+	# depends	"$(MAINBOARD)/auto.c option_table.h ../romcc"
+	depends	"$(MAINBOARD)/auto.c ../romcc"
 	# Note: The -mcpu=p2 is important, or else... 'too few registers'.
-	action	"./romcc -mcpu=p2 -E -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	action	"../romcc -mcpu=p2 -E -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 makerule ./auto.inc
-	# depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-	depends "$(MAINBOARD)/auto.c ./romcc"
+	# depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+	depends "$(MAINBOARD)/auto.c ../romcc"
 	# Note: The -mcpu=p2 is important, or else... 'too few registers'.
-	action	"./romcc -mcpu=p2 -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	action	"../romcc -mcpu=p2 -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 mainboardinit cpu/x86/16bit/entry16.inc
 mainboardinit cpu/x86/32bit/entry32.inc
 ldscript /cpu/x86/16bit/entry16.lds
 ldscript /cpu/x86/32bit/entry32.lds
 if USE_FALLBACK_IMAGE
 	mainboardinit cpu/x86/16bit/reset16.inc
 	ldscript /cpu/x86/16bit/reset16.lds
 else
 	mainboardinit cpu/x86/32bit/reset32.inc
 	ldscript /cpu/x86/32bit/reset32.lds
 end
 mainboardinit arch/i386/lib/cpu_reset.inc
 mainboardinit arch/i386/lib/id.inc
 ldscript /arch/i386/lib/id.lds
 if USE_FALLBACK_IMAGE
 	ldscript /arch/i386/lib/failover.lds
 	mainboardinit ./failover.inc
 end
 mainboardinit cpu/x86/fpu/enable_fpu.inc
 mainboardinit cpu/x86/mmx/enable_mmx.inc
 mainboardinit ./auto.inc
 mainboardinit cpu/x86/mmx/disable_mmx.inc
 
 dir /pc80
 config chip.h
 
 # TODO: On-board graphics.
 chip northbridge/intel/i82810		# Northbridge
   device apic_cluster 0 on		# APIC cluster
     chip cpu/intel/socket_PGA370	# CPU
       device apic 0 on end		# APIC
     end
   end
   device pci_domain 0 on		# PCI domain
     device pci 0.0 on end		# Graphics Memory Controller Hub (GMCH)
     device pci 1.0 on end		# Chipset Graphics Controller (CGC)
     chip southbridge/intel/i82801xx	# Southbridge
       device pci 1e.0 on end		# PCI bridge
       device pci 1f.0 on		# ISA bridge
         chip superio/smsc/smscsuperio	# Super I/O
           device pnp 2e.0 on		# Floppy
             io 0x60 = 0x3f0
             irq 0x70 = 6
             drq 0x74 = 2
           end
           device pnp 2e.3 on		# Parallel port
             io 0x60 = 0x378
             irq 0x70 = 7
             drq 0x74 = 4
           end
           device pnp 2e.4 on		# COM1
             io 0x60 = 0x3f8
             irq 0x70 = 4
           end
           device pnp 2e.5 on		# COM2 / IR
             io 0x60 = 0x2f8
             irq 0x70 = 3
           end
           device pnp 2e.7 on		# PS/2 keyboard / mouse
             io 0x60 = 0x60
             io 0x62 = 0x64
             irq 0x70 = 1		# PS/2 keyboard interrupt
             irq 0x72 = 12		# PS/2 mouse interrupt
           end
           device pnp 2e.9 on		# Game port
             io 0x60 = 0x201
           end
           device pnp 2e.a on		# Power-management events (PME)
             io 0x60 = 0x600
           end
           device pnp 2e.b on		# MIDI port (MPU-401)
             io 0x60 = 0x330
             irq 0x70 = 5
           end
         end
       end
       device pci 1f.1 on end		# IDE
       device pci 1f.2 on end		# USB
       device pci 1f.3 on end		# SMbus
       device pci 1f.5 off end		# AC'97 audio (N/A, uses CS4280 chip)
       device pci 1f.6 off end		# AC'97 modem (N/A)
       register "ide0_enable" = "1"
       register "ide1_enable" = "1"
     end
   end
 end
diff --git a/src/mainboard/asus/mew-vm/Config.lb b/src/mainboard/asus/mew-vm/Config.lb
index 76a74a3..cdd98f5 100644
--- a/src/mainboard/asus/mew-vm/Config.lb
+++ b/src/mainboard/asus/mew-vm/Config.lb
@@ -1,182 +1,182 @@
 ##
 ## Compute the location and size of where this firmware image
 ## (coreboot plus bootloader) will live in the boot rom chip.
 ##
 if USE_FALLBACK_IMAGE
 	default ROM_SECTION_SIZE   = FALLBACK_SIZE
 	default ROM_SECTION_OFFSET = ( ROM_SIZE - FALLBACK_SIZE )
 else
 	default ROM_SECTION_SIZE   = ( ROM_SIZE - FALLBACK_SIZE )
 	default ROM_SECTION_OFFSET = 0
 end
 
 ##
 ## Compute the start location and size size of
 ## The coreboot bootloader.
 ##
 default CONFIG_ROM_PAYLOAD_START = (0xffffffff - ROM_SIZE + ROM_SECTION_OFFSET + 1)
 default PAYLOAD_SIZE            = ( ROM_SECTION_SIZE - ROM_IMAGE_SIZE )
 
 ##
 ## Compute where this copy of coreboot will start in the boot rom
 ##
 default _ROMBASE      = ( CONFIG_ROM_PAYLOAD_START + PAYLOAD_SIZE )
 
 ##
 ## Compute a range of ROM that can cached to speed up coreboot,
 ## execution speed.
 ##
 ## XIP_ROM_SIZE must be a power of 2.
 ## XIP_ROM_BASE must be a multiple of XIP_ROM_SIZE
 ##
 default XIP_ROM_SIZE=65536
 default XIP_ROM_BASE = ( _ROMBASE + ROM_IMAGE_SIZE - XIP_ROM_SIZE )
 
 ##
 ## Set all of the defaults for an x86 architecture
 ##
 
 arch i386 end
 
 ##
 ## Build the objects we have code for in this directory.
 ##
 
 driver mainboard.o
 
 if HAVE_PIRQ_TABLE object irq_tables.o end
 #object reset.o
 
 ##
 ## Romcc output
 ##
 makerule ./failover.E
-	depends "$(MAINBOARD)/failover.c ./romcc" 
-	action "./romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+	depends "$(MAINBOARD)/failover.c ../romcc" 
+	action "../romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 end
 
 makerule ./failover.inc
-	depends "$(MAINBOARD)/failover.c ./romcc"
-	action "./romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+	depends "$(MAINBOARD)/failover.c ../romcc"
+	action "../romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 end
 
 makerule ./auto.E 
-	depends	"$(MAINBOARD)/auto.c option_table.h ./romcc" 
-	action	"./romcc -E -mcpu=p2 -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	depends	"$(MAINBOARD)/auto.c option_table.h ../romcc" 
+	action	"../romcc -E -mcpu=p2 -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 makerule ./auto.inc 
-	depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-	action	"./romcc    -mcpu=p2 -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+	action	"../romcc    -mcpu=p2 -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 
 ##
 ## Build our 16 bit and 32 bit coreboot entry code
 ##
 mainboardinit cpu/x86/16bit/entry16.inc
 mainboardinit cpu/x86/32bit/entry32.inc
 ldscript /cpu/x86/16bit/entry16.lds
 ldscript /cpu/x86/32bit/entry32.lds
 
 ##
 ## Build our reset vector (This is where coreboot is entered)
 ##
 if USE_FALLBACK_IMAGE 
 	mainboardinit cpu/x86/16bit/reset16.inc 
 	ldscript /cpu/x86/16bit/reset16.lds 
 else
 	mainboardinit cpu/x86/32bit/reset32.inc 
 	ldscript /cpu/x86/32bit/reset32.lds 
 end
 
 ### Should this be in the northbridge code?
 mainboardinit arch/i386/lib/cpu_reset.inc
 
 ##
 ## Include an id string (For safe flashing)
 ##
 mainboardinit arch/i386/lib/id.inc
 ldscript /arch/i386/lib/id.lds
 
 ###
 ### This is the early phase of coreboot startup 
 ### Things are delicate and we test to see if we should
 ### failover to another image.
 ###
 if USE_FALLBACK_IMAGE
 	ldscript /arch/i386/lib/failover.lds 
 	mainboardinit ./failover.inc
 end
 
 ###
 ### O.k. We aren't just an intermediary anymore!
 ###
 
 ##
 ## Setup RAM
 ##
 mainboardinit cpu/x86/fpu/enable_fpu.inc
 mainboardinit cpu/x86/mmx/enable_mmx.inc
 mainboardinit ./auto.inc
 mainboardinit cpu/x86/mmx/disable_mmx.inc
 
 ##
 ## Include the secondary Configuration files 
 ##
 dir /pc80
 config chip.h
 
 chip northbridge/intel/i82810
 	device pci_domain 0 on 
 		device pci 0.0 on end # Host bridge
 		device pci 1.0 on # Onboard Video
 			#chip drivers/pci/onboard
 			#	device pci 1.0 on end
 			#	register "rom_address" = "0xfff80000"
 		        #end
 		end
 		chip southbridge/intel/i82801xx # Southbridge
 			device pci 1e.0 on # PCI Bridge
 				#chip drivers/pci/onboard
 				#	device pci 1.0 on end
 				#	register "rom_address" = "0xfff80000"
 			        #end
 			end
 			device pci 1f.0 on  # ISA/LPC? Bridge
 				chip superio/smsc/lpc47b272
 					device pnp 2e.0 off # Floppy
 						io 0x60 = 0x3f0
 						irq 0x70 = 6
 						drq 0x74 = 2
 					end
 					device pnp 2e.3 off # Parallel Port
 						io 0x60 = 0x378
 						irq 0x70 = 7
 					end
 					device pnp 2e.4 on # Com1
 						io 0x60 = 0x3f8
 						irq 0x70 = 4
 					end
 					device pnp 2e.5 off # Com2
 						io 0x60 = 0x2f8
 						irq 0x70 = 3
 					end
 					device pnp 2e.7 on # Keyboard
 						io 0x60 = 0x60
 						io 0x62 = 0x64
 						irq 0x70 = 1 # Keyboard interrupt
 						irq 0x72 = 12 # Mouse interrupt
 					end
 					device pnp 2e.a off end # ACPI
 				end
 			end
 			device pci 1f.1 on end # IDE
 			device pci 1f.2 on end # USB
 			device pci 1f.3 on end # SMBus
 			device pci 1f.5 off end # AC'97, no header on MEW-VM
 			device pci 1f.6 off end # AC'97 Modem (MC'97)
 		end
 	end
 	chip cpu/intel/socket_PGA370
 	end
 end
 
diff --git a/src/mainboard/asus/p2b-f/Config.lb b/src/mainboard/asus/p2b-f/Config.lb
index 040364e..c8a5f21 100644
--- a/src/mainboard/asus/p2b-f/Config.lb
+++ b/src/mainboard/asus/p2b-f/Config.lb
@@ -1,141 +1,141 @@
 ##
 ## This file is part of the coreboot project.
 ##
 ## Copyright (C) 2007 Uwe Hermann <uwe@hermann-uwe.de>
 ##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2 of the License, or
 ## (at your option) any later version.
 ##
 ## This program is distributed in the hope that it will be useful,
 ## but WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ## GNU General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this program; if not, write to the Free Software
 ## Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 ##
 
 if USE_FALLBACK_IMAGE
 	default ROM_SECTION_SIZE = FALLBACK_SIZE
 	default ROM_SECTION_OFFSET = (ROM_SIZE - FALLBACK_SIZE)
 else
 	default ROM_SECTION_SIZE = (ROM_SIZE - FALLBACK_SIZE)
 	default ROM_SECTION_OFFSET = 0
 end
 default CONFIG_ROM_PAYLOAD_START = (0xffffffff - ROM_SIZE
 				    + ROM_SECTION_OFFSET + 1)
 default PAYLOAD_SIZE = (ROM_SECTION_SIZE - ROM_IMAGE_SIZE)
 default _ROMBASE = (CONFIG_ROM_PAYLOAD_START + PAYLOAD_SIZE)
 default XIP_ROM_SIZE = 64 * 1024
 default XIP_ROM_BASE = (_ROMBASE + ROM_IMAGE_SIZE - XIP_ROM_SIZE)
 arch i386 end
 driver mainboard.o
 if HAVE_PIRQ_TABLE
 	object irq_tables.o
 end
 makerule ./failover.E
-	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ./romcc"
-	action "./romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
+	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ../romcc"
+	action "../romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
 end
 makerule ./failover.inc
-	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ./romcc"
-	action "./romcc -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
+	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ../romcc"
+	action "../romcc -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
 end
 makerule ./auto.E
-	# depends	"$(MAINBOARD)/auto.c option_table.h ./romcc"
-	depends	"$(MAINBOARD)/auto.c ./romcc"
-	action	"./romcc -E -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	# depends	"$(MAINBOARD)/auto.c option_table.h ../romcc"
+	depends	"$(MAINBOARD)/auto.c ../romcc"
+	action	"../romcc -E -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 makerule ./auto.inc
-	# depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-	depends "$(MAINBOARD)/auto.c ./romcc"
-	action	"./romcc -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	# depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+	depends "$(MAINBOARD)/auto.c ../romcc"
+	action	"../romcc -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 mainboardinit cpu/x86/16bit/entry16.inc
 mainboardinit cpu/x86/32bit/entry32.inc
 ldscript /cpu/x86/16bit/entry16.lds
 ldscript /cpu/x86/32bit/entry32.lds
 if USE_FALLBACK_IMAGE
 	mainboardinit cpu/x86/16bit/reset16.inc
 	ldscript /cpu/x86/16bit/reset16.lds
 else
 	mainboardinit cpu/x86/32bit/reset32.inc
 	ldscript /cpu/x86/32bit/reset32.lds
 end
 mainboardinit arch/i386/lib/cpu_reset.inc
 mainboardinit arch/i386/lib/id.inc
 ldscript /arch/i386/lib/id.lds
 if USE_FALLBACK_IMAGE
 	ldscript /arch/i386/lib/failover.lds
 	mainboardinit ./failover.inc
 end
 mainboardinit cpu/x86/fpu/enable_fpu.inc
 mainboardinit cpu/x86/mmx/enable_mmx.inc
 mainboardinit ./auto.inc
 mainboardinit cpu/x86/mmx/disable_mmx.inc
 
 dir /pc80
 config chip.h
 
 chip northbridge/intel/i440bx		# Northbridge
   device apic_cluster 0 on		# APIC cluster
     chip cpu/intel/slot_2		# CPU (FIXME: It's slot 1, actually)
       device apic 0 on end		# APIC
     end
   end
   device pci_domain 0 on		# PCI domain
     device pci 0.0 on end		# Host bridge
     device pci 1.0 on end		# PCI/AGP bridge
     chip southbridge/intel/i82371eb	# Southbridge
       device pci 4.0 on			# ISA bridge
         chip superio/winbond/w83977tf	# Super I/O (FIXME: It's W83977EF!)
           device pnp 3f0.0 on		# Floppy
             io 0x60 = 0x3f0
             irq 0x70 = 6
             drq 0x74 = 2
           end
           device pnp 3f0.1 on		# Parallel port
             io 0x60 = 0x378
             irq 0x70 = 7
           end
           device pnp 3f0.2 on		# COM1
             io 0x60 = 0x3f8
             irq 0x70 = 4
           end
           device pnp 3f0.3 on		# COM2 / IR
             io 0x60 = 0x2f8
             irq 0x70 = 3
           end
           device pnp 3f0.5 on		# PS/2 keyboard
             io 0x60 = 0x60
             io 0x62 = 0x64
             irq 0x70 = 1		# PS/2 keyboard interrupt
             irq 0x72 = 12		# PS/2 mouse interrupt
           end
           device pnp 3f0.6 on		# Consumer IR
           end
           device pnp 3f0.7 on		# GPIO 1
           end
           device pnp 3f0.8 on		# GPIO 2
           end
           device pnp 3f0.a on		# ACPI
           end
         end
       end
       device pci 4.1 on	end		# IDE
       device pci 4.2 on	end		# USB
       device pci 4.3 on end		# ACPI
       register "ide0_enable" = "1"
       register "ide1_enable" = "1"
       register "ide_legacy_enable" = "1"
       # Enable UDMA/33 for higher speed if your IDE device(s) support it.
       register "ide0_drive0_udma33_enable" = "0"
       register "ide0_drive1_udma33_enable" = "0"
       register "ide1_drive0_udma33_enable" = "0"
       register "ide1_drive1_udma33_enable" = "0"
     end
   end
 end
diff --git a/src/mainboard/asus/p2b/Config.lb b/src/mainboard/asus/p2b/Config.lb
index ad82298..690ddfb 100644
--- a/src/mainboard/asus/p2b/Config.lb
+++ b/src/mainboard/asus/p2b/Config.lb
@@ -1,141 +1,141 @@
 ##
 ## This file is part of the coreboot project.
 ##
 ## Copyright (C) 2007 Uwe Hermann <uwe@hermann-uwe.de>
 ##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2 of the License, or
 ## (at your option) any later version.
 ##
 ## This program is distributed in the hope that it will be useful,
 ## but WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ## GNU General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this program; if not, write to the Free Software
 ## Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 ##
 
 if USE_FALLBACK_IMAGE
 	default ROM_SECTION_SIZE = FALLBACK_SIZE
 	default ROM_SECTION_OFFSET = (ROM_SIZE - FALLBACK_SIZE)
 else
 	default ROM_SECTION_SIZE = (ROM_SIZE - FALLBACK_SIZE)
 	default ROM_SECTION_OFFSET = 0
 end
 default CONFIG_ROM_PAYLOAD_START = (0xffffffff - ROM_SIZE
 				    + ROM_SECTION_OFFSET + 1)
 default PAYLOAD_SIZE = (ROM_SECTION_SIZE - ROM_IMAGE_SIZE)
 default _ROMBASE = (CONFIG_ROM_PAYLOAD_START + PAYLOAD_SIZE)
 default XIP_ROM_SIZE = 64 * 1024
 default XIP_ROM_BASE = (_ROMBASE + ROM_IMAGE_SIZE - XIP_ROM_SIZE)
 arch i386 end
 driver mainboard.o
 if HAVE_PIRQ_TABLE
 	object irq_tables.o
 end
 makerule ./failover.E
-	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ./romcc"
-	action "./romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
+	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ../romcc"
+	action "../romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
 end
 makerule ./failover.inc
-	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ./romcc"
-	action "./romcc -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
+	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ../romcc"
+	action "../romcc -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
 end
 makerule ./auto.E
-	# depends	"$(MAINBOARD)/auto.c option_table.h ./romcc"
-	depends	"$(MAINBOARD)/auto.c ./romcc"
-	action	"./romcc -E -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	# depends	"$(MAINBOARD)/auto.c option_table.h ../romcc"
+	depends	"$(MAINBOARD)/auto.c ../romcc"
+	action	"../romcc -E -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 makerule ./auto.inc
-	# depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-	depends "$(MAINBOARD)/auto.c ./romcc"
-	action	"./romcc -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	# depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+	depends "$(MAINBOARD)/auto.c ../romcc"
+	action	"../romcc -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 mainboardinit cpu/x86/16bit/entry16.inc
 mainboardinit cpu/x86/32bit/entry32.inc
 ldscript /cpu/x86/16bit/entry16.lds
 ldscript /cpu/x86/32bit/entry32.lds
 if USE_FALLBACK_IMAGE
 	mainboardinit cpu/x86/16bit/reset16.inc
 	ldscript /cpu/x86/16bit/reset16.lds
 else
 	mainboardinit cpu/x86/32bit/reset32.inc
 	ldscript /cpu/x86/32bit/reset32.lds
 end
 mainboardinit arch/i386/lib/cpu_reset.inc
 mainboardinit arch/i386/lib/id.inc
 ldscript /arch/i386/lib/id.lds
 if USE_FALLBACK_IMAGE
 	ldscript /arch/i386/lib/failover.lds
 	mainboardinit ./failover.inc
 end
 mainboardinit cpu/x86/fpu/enable_fpu.inc
 mainboardinit cpu/x86/mmx/enable_mmx.inc
 mainboardinit ./auto.inc
 mainboardinit cpu/x86/mmx/disable_mmx.inc
 
 dir /pc80
 config chip.h
 
 chip northbridge/intel/i440bx		# Northbridge
   device apic_cluster 0 on		# APIC cluster
     chip cpu/intel/slot_2		# CPU (FIXME: It's slot 1, actually)
       device apic 0 on end		# APIC
     end
   end
   device pci_domain 0 on		# PCI domain
     device pci 0.0 on end		# Host bridge
     device pci 1.0 on end		# PCI/AGP bridge
     chip southbridge/intel/i82371eb	# Southbridge
       device pci 4.0 on			# ISA bridge
         chip superio/winbond/w83977tf	# Super I/O
           device pnp 3f0.0 on		# Floppy
             io 0x60 = 0x3f0
             irq 0x70 = 6
             drq 0x74 = 2
           end
           device pnp 3f0.1 on		# Parallel port
             io 0x60 = 0x378
             irq 0x70 = 7
           end
           device pnp 3f0.2 on		# COM1
             io 0x60 = 0x3f8
             irq 0x70 = 4
           end
           device pnp 3f0.3 on		# COM2 / IR
             io 0x60 = 0x2f8
             irq 0x70 = 3
           end
           device pnp 3f0.5 on		# PS/2 keyboard / mouse
             io 0x60 = 0x60
             io 0x62 = 0x64
             irq 0x70 = 1		# PS/2 keyboard interrupt
             irq 0x72 = 12		# PS/2 mouse interrupt
           end
           device pnp 3f0.7 on		# GPIO 1
           end
           device pnp 3f0.8 on		# GPIO 2
           end
           device pnp 3f0.9 on		# GPIO 3
           end
           device pnp 3f0.a on		# ACPI
           end
         end
       end
       device pci 4.1 on	end		# IDE
       device pci 4.2 on	end		# USB
       device pci 4.3 on end		# ACPI
       register "ide0_enable" = "1"
       register "ide1_enable" = "1"
       register "ide_legacy_enable" = "1"
       # Enable UDMA/33 for higher speed if your IDE device(s) support it.
       register "ide0_drive0_udma33_enable" = "0"
       register "ide0_drive1_udma33_enable" = "0"
       register "ide1_drive0_udma33_enable" = "0"
       register "ide1_drive1_udma33_enable" = "0"
     end
   end
 end
diff --git a/src/mainboard/asus/p3b-f/Config.lb b/src/mainboard/asus/p3b-f/Config.lb
index a107d67..ee739c3 100644
--- a/src/mainboard/asus/p3b-f/Config.lb
+++ b/src/mainboard/asus/p3b-f/Config.lb
@@ -1,142 +1,142 @@
 ##
 ## This file is part of the coreboot project.
 ##
 ## Copyright (C) 2007 Uwe Hermann <uwe@hermann-uwe.de>
 ##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2 of the License, or
 ## (at your option) any later version.
 ##
 ## This program is distributed in the hope that it will be useful,
 ## but WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ## GNU General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this program; if not, write to the Free Software
 ## Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 ##
 
 if USE_FALLBACK_IMAGE
 	default ROM_SECTION_SIZE = FALLBACK_SIZE
 	default ROM_SECTION_OFFSET = (ROM_SIZE - FALLBACK_SIZE)
 else
 	default ROM_SECTION_SIZE = (ROM_SIZE - FALLBACK_SIZE)
 	default ROM_SECTION_OFFSET = 0
 end
 default CONFIG_ROM_PAYLOAD_START = (0xffffffff - ROM_SIZE
 				    + ROM_SECTION_OFFSET + 1)
 default PAYLOAD_SIZE = (ROM_SECTION_SIZE - ROM_IMAGE_SIZE)
 default _ROMBASE = (CONFIG_ROM_PAYLOAD_START + PAYLOAD_SIZE)
 default XIP_ROM_SIZE = 64 * 1024
 default XIP_ROM_BASE = (_ROMBASE + ROM_IMAGE_SIZE - XIP_ROM_SIZE)
 arch i386 end
 driver mainboard.o
 if HAVE_PIRQ_TABLE
 	object irq_tables.o
 end
 makerule ./failover.E
-	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ./romcc"
-	action "./romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
+	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ../romcc"
+	action "../romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
 end
 makerule ./failover.inc
-	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ./romcc"
-	action "./romcc -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
+	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ../romcc"
+	action "../romcc -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
 end
 makerule ./auto.E
-	# depends	"$(MAINBOARD)/auto.c option_table.h ./romcc"
-	depends	"$(MAINBOARD)/auto.c ./romcc"
-	action	"./romcc -E -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	# depends	"$(MAINBOARD)/auto.c option_table.h ../romcc"
+	depends	"$(MAINBOARD)/auto.c ../romcc"
+	action	"../romcc -E -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 makerule ./auto.inc
-	# depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-	depends "$(MAINBOARD)/auto.c ./romcc"
-	action	"./romcc -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	# depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+	depends "$(MAINBOARD)/auto.c ../romcc"
+	action	"../romcc -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 mainboardinit cpu/x86/16bit/entry16.inc
 mainboardinit cpu/x86/32bit/entry32.inc
 ldscript /cpu/x86/16bit/entry16.lds
 ldscript /cpu/x86/32bit/entry32.lds
 if USE_FALLBACK_IMAGE
 	mainboardinit cpu/x86/16bit/reset16.inc
 	ldscript /cpu/x86/16bit/reset16.lds
 else
 	mainboardinit cpu/x86/32bit/reset32.inc
 	ldscript /cpu/x86/32bit/reset32.lds
 end
 mainboardinit arch/i386/lib/cpu_reset.inc
 mainboardinit arch/i386/lib/id.inc
 ldscript /arch/i386/lib/id.lds
 if USE_FALLBACK_IMAGE
 	ldscript /arch/i386/lib/failover.lds
 	mainboardinit ./failover.inc
 end
 mainboardinit cpu/x86/fpu/enable_fpu.inc
 mainboardinit cpu/x86/mmx/enable_mmx.inc
 mainboardinit ./auto.inc
 mainboardinit cpu/x86/mmx/disable_mmx.inc
 
 dir /pc80
 config chip.h
 
 # TODO
 chip northbridge/intel/i440bx		# Northbridge
   device apic_cluster 0 on		# APIC cluster
     chip cpu/intel/slot_2		# CPU (FIXME: It's slot 1, actually)
       device apic 0 on end		# APIC
     end
   end
   device pci_domain 0 on		# PCI domain
     device pci 0.0 on end		# Host bridge
     device pci 1.0 on end		# PCI/AGP bridge
     chip southbridge/intel/i82371eb	# Southbridge
       device pci 4.0 on			# ISA bridge
         chip superio/winbond/w83977tf	# Super I/O (FIXME: It's W83977EF!)
           device pnp 3f0.0 on		# Floppy
             io 0x60 = 0x3f0
             irq 0x70 = 6
             drq 0x74 = 2
           end
           device pnp 3f0.1 on		# Parallel port
             io 0x60 = 0x378
             irq 0x70 = 7
           end
           device pnp 3f0.2 on		# COM1
             io 0x60 = 0x3f8
             irq 0x70 = 4
           end
           device pnp 3f0.3 on		# COM2 / IR
             io 0x60 = 0x2f8
             irq 0x70 = 3
           end
           device pnp 3f0.5 on		# PS/2 keyboard
             io 0x60 = 0x60
             io 0x62 = 0x64
             irq 0x70 = 1		# PS/2 keyboard interrupt
             irq 0x72 = 12		# PS/2 mouse interrupt
           end
           device pnp 3f0.6 on		# Consumer IR
           end
           device pnp 3f0.7 on		# GPIO 1
           end
           device pnp 3f0.8 on		# GPIO 2
           end
           device pnp 3f0.a on		# ACPI
           end
         end
       end
       device pci 4.1 on	end		# IDE
       device pci 4.2 on	end		# USB
       device pci 4.3 on end		# ACPI
       register "ide0_enable" = "1"
       register "ide1_enable" = "1"
       register "ide_legacy_enable" = "1"
       # Enable UDMA/33 for higher speed if your IDE device(s) support it.
       register "ide0_drive0_udma33_enable" = "0"
       register "ide0_drive1_udma33_enable" = "0"
       register "ide1_drive0_udma33_enable" = "0"
       register "ide1_drive1_udma33_enable" = "0"
     end
   end
 end
diff --git a/src/mainboard/axus/tc320/Config.lb b/src/mainboard/axus/tc320/Config.lb
index bc1d8e4..c6561c0 100644
--- a/src/mainboard/axus/tc320/Config.lb
+++ b/src/mainboard/axus/tc320/Config.lb
@@ -1,135 +1,135 @@
 ##
 ## This file is part of the coreboot project.
 ##
 ## Copyright (C) 2007 Juergen Beisert <juergen@kreuzholzen.de>
 ##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2 of the License, or
 ## (at your option) any later version.
 ##
 ## This program is distributed in the hope that it will be useful,
 ## but WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ## GNU General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this program; if not, write to the Free Software
 ## Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 ##
 
 if USE_FALLBACK_IMAGE
 	default ROM_SECTION_SIZE = FALLBACK_SIZE
 	default ROM_SECTION_OFFSET = (ROM_SIZE - FALLBACK_SIZE)
 else
 	default ROM_SECTION_SIZE = (ROM_SIZE - FALLBACK_SIZE)
 	default ROM_SECTION_OFFSET = 0
 end
 default CONFIG_ROM_PAYLOAD_START = (0xffffffff - ROM_SIZE
 				   + ROM_SECTION_OFFSET + 1)
 default PAYLOAD_SIZE = (ROM_SECTION_SIZE - ROM_IMAGE_SIZE)
 default _ROMBASE = (CONFIG_ROM_PAYLOAD_START + PAYLOAD_SIZE)
 default XIP_ROM_SIZE = 64 * 1024
 default XIP_ROM_BASE = (_ROMBASE + ROM_IMAGE_SIZE - XIP_ROM_SIZE)
 arch i386 end
 driver mainboard.o
 if HAVE_PIRQ_TABLE object irq_tables.o end
 makerule ./failover.E
-	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ./romcc"
-	action "./romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
+	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ../romcc"
+	action "../romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
 end
 makerule ./failover.inc
-	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ./romcc"
-	action "./romcc -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
+	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ../romcc"
+	action "../romcc -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
 end
 makerule ./auto.E
-	# depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-	depends	"$(MAINBOARD)/auto.c ./romcc"
-	action	"./romcc -E -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	# depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+	depends	"$(MAINBOARD)/auto.c ../romcc"
+	action	"../romcc -E -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 makerule ./auto.inc
-	# depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-	depends "$(MAINBOARD)/auto.c ./romcc"
-	action	"./romcc -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	# depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+	depends "$(MAINBOARD)/auto.c ../romcc"
+	action	"../romcc -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 mainboardinit cpu/x86/16bit/entry16.inc
 mainboardinit cpu/x86/32bit/entry32.inc
 ldscript /cpu/x86/16bit/entry16.lds
 ldscript /cpu/x86/32bit/entry32.lds
 if USE_FALLBACK_IMAGE
 	mainboardinit cpu/x86/16bit/reset16.inc
 	ldscript /cpu/x86/16bit/reset16.lds
 else
 	mainboardinit cpu/x86/32bit/reset32.inc
 	ldscript /cpu/x86/32bit/reset32.lds
 end
 mainboardinit arch/i386/lib/cpu_reset.inc
 mainboardinit arch/i386/lib/id.inc
 ldscript /arch/i386/lib/id.lds
 if USE_FALLBACK_IMAGE
 	ldscript /arch/i386/lib/failover.lds
 	mainboardinit ./failover.inc
 end
 mainboardinit cpu/x86/fpu/enable_fpu.inc
 mainboardinit cpu/amd/model_gx1/cpu_setup.inc
 mainboardinit cpu/amd/model_gx1/gx_setup.inc
 mainboardinit ./auto.inc
 
 dir /pc80
 config chip.h
 
 chip northbridge/amd/gx1		# Northbridge
   device pci_domain 0 on		# PCI domain
     device pci 0.0 on end		# Host bridge
     chip southbridge/amd/cs5530		# Southbridge
       device pci 12.0 on		# ISA bridge
         chip superio/nsc/pc97317	# Super I/O
           device pnp 2e.0 on		# PS/2 keyboard
             io 0x60 = 0x60
             io 0x62 = 0x64
             irq 0x70 = 1
           end
           device pnp 2e.1 on		# PS/2 mouse
             irq 0x70 = 12
           end
           device pnp 2e.2 on		# RTC, advanced power control (APC)
             io 0x60 = 0x70
             irq 0x70 = 8
           end
           device pnp 2e.3 off		# Floppy (N/A on this board)
             io 0x60 = 0x3f0
             irq 0x70 = 6
             drq 0x74 = 2
           end
           device pnp 2e.4 on		# Parallel port
             io 0x60 = 0x378
             irq 0x70 = 7
           end
           device pnp 2e.5 off		# COM2
             io 0x60 = 0x2f8
             irq 0x70 = 3
           end
           device pnp 2e.6 on		# COM1
             io 0x60 = 0x3f8
             irq 0x70 = 4
           end
           device pnp 2e.7 on		# GPIO
             io 0x60 = 0xe0
           end
           device pnp 2e.8 on		# Power management
             io 0x60 = 0xe800
           end
         end
       end
       device pci 12.1 off end		# SMI
       device pci 12.2 off end		# IDE
       device pci 12.3 on end		# Audio
       device pci 12.4 on end		# VGA (onboard)
       device pci 13.0 on end		# USB
       # register "ide0_enable" = "1"
       # register "ide1_enable" = "1"
     end
   end
   chip cpu/amd/model_gx1		# CPU
   end
 end
diff --git a/src/mainboard/azza/pt-6ibd/Config.lb b/src/mainboard/azza/pt-6ibd/Config.lb
index fcab34c..4336783 100644
--- a/src/mainboard/azza/pt-6ibd/Config.lb
+++ b/src/mainboard/azza/pt-6ibd/Config.lb
@@ -1,141 +1,141 @@
 ##
 ## This file is part of the coreboot project.
 ##
 ## Copyright (C) 2007 Uwe Hermann <uwe@hermann-uwe.de>
 ##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2 of the License, or
 ## (at your option) any later version.
 ##
 ## This program is distributed in the hope that it will be useful,
 ## but WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ## GNU General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this program; if not, write to the Free Software
 ## Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 ##
 
 if USE_FALLBACK_IMAGE
 	default ROM_SECTION_SIZE = FALLBACK_SIZE
 	default ROM_SECTION_OFFSET = (ROM_SIZE - FALLBACK_SIZE)
 else
 	default ROM_SECTION_SIZE = (ROM_SIZE - FALLBACK_SIZE)
 	default ROM_SECTION_OFFSET = 0
 end
 default CONFIG_ROM_PAYLOAD_START = (0xffffffff - ROM_SIZE
 				    + ROM_SECTION_OFFSET + 1)
 default PAYLOAD_SIZE = (ROM_SECTION_SIZE - ROM_IMAGE_SIZE)
 default _ROMBASE = (CONFIG_ROM_PAYLOAD_START + PAYLOAD_SIZE)
 default XIP_ROM_SIZE = 64 * 1024
 default XIP_ROM_BASE = (_ROMBASE + ROM_IMAGE_SIZE - XIP_ROM_SIZE)
 arch i386 end
 driver mainboard.o
 if HAVE_PIRQ_TABLE
 	object irq_tables.o
 end
 makerule ./failover.E
-	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ./romcc"
-	action "./romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
+	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ../romcc"
+	action "../romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
 end
 makerule ./failover.inc
-	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ./romcc"
-	action "./romcc -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
+	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ../romcc"
+	action "../romcc -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
 end
 makerule ./auto.E
-	# depends	"$(MAINBOARD)/auto.c option_table.h ./romcc"
-	depends	"$(MAINBOARD)/auto.c ./romcc"
-	action	"./romcc -E -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	# depends	"$(MAINBOARD)/auto.c option_table.h ../romcc"
+	depends	"$(MAINBOARD)/auto.c ../romcc"
+	action	"../romcc -E -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 makerule ./auto.inc
-	# depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-	depends "$(MAINBOARD)/auto.c ./romcc"
-	action	"./romcc -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	# depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+	depends "$(MAINBOARD)/auto.c ../romcc"
+	action	"../romcc -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 mainboardinit cpu/x86/16bit/entry16.inc
 mainboardinit cpu/x86/32bit/entry32.inc
 ldscript /cpu/x86/16bit/entry16.lds
 ldscript /cpu/x86/32bit/entry32.lds
 if USE_FALLBACK_IMAGE
 	mainboardinit cpu/x86/16bit/reset16.inc
 	ldscript /cpu/x86/16bit/reset16.lds
 else
 	mainboardinit cpu/x86/32bit/reset32.inc
 	ldscript /cpu/x86/32bit/reset32.lds
 end
 mainboardinit arch/i386/lib/cpu_reset.inc
 mainboardinit arch/i386/lib/id.inc
 ldscript /arch/i386/lib/id.lds
 if USE_FALLBACK_IMAGE
 	ldscript /arch/i386/lib/failover.lds
 	mainboardinit ./failover.inc
 end
 mainboardinit cpu/x86/fpu/enable_fpu.inc
 mainboardinit cpu/x86/mmx/enable_mmx.inc
 mainboardinit ./auto.inc
 mainboardinit cpu/x86/mmx/disable_mmx.inc
 
 dir /pc80
 config chip.h
 
 chip northbridge/intel/i440bx		# Northbridge
   device apic_cluster 0 on		# APIC cluster
     chip cpu/intel/slot_2		# CPU (FIXME: It's slot 1, actually)
       device apic 0 on end		# APIC
     end
   end
   device pci_domain 0 on		# PCI domain
     device pci 0.0 on end		# Host bridge
     device pci 1.0 on end		# PCI/AGP bridge
     chip southbridge/intel/i82371eb	# Southbridge
       device pci 7.0 on			# ISA bridge
         chip superio/winbond/w83977tf	# Super I/O (FIXME: It's W83977EF!)
           device pnp 3f0.0 on		# Floppy
             io 0x60 = 0x3f0
             irq 0x70 = 6
             drq 0x74 = 2
           end
           device pnp 3f0.1 on		# Parallel port
             io 0x60 = 0x378
             irq 0x70 = 7
           end
           device pnp 3f0.2 on		# COM1
             io 0x60 = 0x3f8
             irq 0x70 = 4
           end
           device pnp 3f0.3 on		# COM2 / IR
             io 0x60 = 0x2f8
             irq 0x70 = 3
           end
           device pnp 3f0.5 on		# PS/2 keyboard / mouse
             io 0x60 = 0x60
             io 0x62 = 0x64
             irq 0x70 = 1		# PS/2 keyboard interrupt
             irq 0x72 = 12		# PS/2 mouse interrupt
           end
           device pnp 3f0.6 on		# Consumer IR
           end
           device pnp 3f0.7 on		# GPIO 1
           end
           device pnp 3f0.8 on		# GPIO 2
           end
           device pnp 3f0.a on		# ACPI
           end
         end
       end
       device pci 7.1 on	end		# IDE
       device pci 7.2 on	end		# USB
       device pci 7.3 on end		# ACPI
       register "ide0_enable" = "1"
       register "ide1_enable" = "1"
       register "ide_legacy_enable" = "1"
       # Enable UDMA/33 for higher speed if your IDE device(s) support it.
       register "ide0_drive0_udma33_enable" = "0"
       register "ide0_drive1_udma33_enable" = "0"
       register "ide1_drive0_udma33_enable" = "0"
       register "ide1_drive1_udma33_enable" = "0"
     end
   end
 end
diff --git a/src/mainboard/bcom/winnet100/Config.lb b/src/mainboard/bcom/winnet100/Config.lb
index 5a79410..4b03d9f 100644
--- a/src/mainboard/bcom/winnet100/Config.lb
+++ b/src/mainboard/bcom/winnet100/Config.lb
@@ -1,137 +1,137 @@
 ##
 ## This file is part of the coreboot project.
 ##
 ## Copyright (C) 2007 Juergen Beisert <juergen@kreuzholzen.de>
 ##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2 of the License, or
 ## (at your option) any later version.
 ##
 ## This program is distributed in the hope that it will be useful,
 ## but WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ## GNU General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this program; if not, write to the Free Software
 ## Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 ##
 
 if USE_FALLBACK_IMAGE
 	default ROM_SECTION_SIZE = FALLBACK_SIZE
 	default ROM_SECTION_OFFSET = (ROM_SIZE - FALLBACK_SIZE)
 else
 	default ROM_SECTION_SIZE = (ROM_SIZE - FALLBACK_SIZE)
 	default ROM_SECTION_OFFSET = 0
 end
 default CONFIG_ROM_PAYLOAD_START = (0xffffffff - ROM_SIZE + ROM_SECTION_OFFSET + 1)
 default PAYLOAD_SIZE = (ROM_SECTION_SIZE - ROM_IMAGE_SIZE)
 default _ROMBASE = (CONFIG_ROM_PAYLOAD_START + PAYLOAD_SIZE)
 default XIP_ROM_SIZE = 64 * 1024
 default XIP_ROM_BASE = (_ROMBASE + ROM_IMAGE_SIZE - XIP_ROM_SIZE)
 arch i386 end
 driver mainboard.o
 if HAVE_PIRQ_TABLE
 	object irq_tables.o
 end
 makerule ./failover.E
-	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ./romcc"
-	action "./romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
+	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ../romcc"
+	action "../romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
 end
 makerule ./failover.inc
-	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ./romcc"
-	action "./romcc -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
+	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ../romcc"
+	action "../romcc -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
 end
 makerule ./auto.E
-	# depends	"$(MAINBOARD)/auto.c option_table.h ./romcc"
-	depends	"$(MAINBOARD)/auto.c ./romcc"
-	action	"./romcc -E -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	# depends	"$(MAINBOARD)/auto.c option_table.h ../romcc"
+	depends	"$(MAINBOARD)/auto.c ../romcc"
+	action	"../romcc -E -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 makerule ./auto.inc
-	# depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-	depends "$(MAINBOARD)/auto.c ./romcc"
-	action	"./romcc -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	# depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+	depends "$(MAINBOARD)/auto.c ../romcc"
+	action	"../romcc -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 mainboardinit cpu/x86/16bit/entry16.inc
 mainboardinit cpu/x86/32bit/entry32.inc
 ldscript /cpu/x86/16bit/entry16.lds
 ldscript /cpu/x86/32bit/entry32.lds
 if USE_FALLBACK_IMAGE
 	mainboardinit cpu/x86/16bit/reset16.inc
 	ldscript /cpu/x86/16bit/reset16.lds
 else
 	mainboardinit cpu/x86/32bit/reset32.inc
 	ldscript /cpu/x86/32bit/reset32.lds
 end
 mainboardinit arch/i386/lib/cpu_reset.inc
 mainboardinit arch/i386/lib/id.inc
 ldscript /arch/i386/lib/id.lds
 if USE_FALLBACK_IMAGE
 	ldscript /arch/i386/lib/failover.lds
 	mainboardinit ./failover.inc
 end
 mainboardinit cpu/x86/fpu/enable_fpu.inc
 mainboardinit cpu/amd/model_gx1/cpu_setup.inc
 mainboardinit cpu/amd/model_gx1/gx_setup.inc
 mainboardinit ./auto.inc
 
 dir /pc80
 config chip.h
 
 chip northbridge/amd/gx1		# Northbridge
   device pci_domain 0 on		# PCI domain
     device pci 0.0 on end		# Host bridge
     chip southbridge/amd/cs5530		# Southbridge
       device pci 0f.0 on end		# Ethernet (onboard)
       device pci 12.0 on		# ISA bridge
         chip superio/nsc/pc97317	# Super I/O
           device pnp 2e.0 on		# PS/2 keyboard
             io 0x60 = 0x60
             io 0x62 = 0x64
             irq 0x70 = 1
           end
           device pnp 2e.1 on		# PS/2 mouse
             irq 0x70 = 12
           end
           device pnp 2e.2 on		# RTC, Advanced power control (APC)
             io 0x60 = 0x70
             irq 0x70 = 8
           end
           device pnp 2e.3 off		# Floppy (N/A on this board)
             io 0x60 = 0x3f0
             irq 0x70 = 6
             drq 0x74 = 2
           end
           device pnp 2e.4 on		# Parallel port
             io 0x60 = 0x378
             irq 0x70 = 7
           end
           device pnp 2e.5 on		# COM2 (used for smartcard reader)
             io 0x60 = 0x2f8
             irq 0x70 = 3
           end
           device pnp 2e.6 on		# COM1
             io 0x60 = 0x3f8
             irq 0x70 = 4
           end
           device pnp 2e.7 on		# GPIO
             io 0x60 = 0xe0
           end
           device pnp 2e.8 on		# Power management
             io 0x60 = 0xe8
           end
         end
       end
       device pci 12.1 off end		# SMI
       device pci 12.2 on end		# IDE
       device pci 12.3 on end		# Audio
       device pci 12.4 on end		# VGA (onboard)
       device pci 13.0 on end		# USB
       register "ide0_enable" = "1"
       register "ide1_enable" = "0"	# Not available/needed on this board
     end
   end
   chip cpu/amd/model_gx1		# CPU
   end
 end
diff --git a/src/mainboard/biostar/m6tba/Config.lb b/src/mainboard/biostar/m6tba/Config.lb
index 1ebb5b1..d05e7db 100644
--- a/src/mainboard/biostar/m6tba/Config.lb
+++ b/src/mainboard/biostar/m6tba/Config.lb
@@ -1,135 +1,135 @@
 ##
 ## This file is part of the coreboot project.
 ##
 ## Copyright (C) 2007 Uwe Hermann <uwe@hermann-uwe.de>
 ##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2 of the License, or
 ## (at your option) any later version.
 ##
 ## This program is distributed in the hope that it will be useful,
 ## but WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ## GNU General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this program; if not, write to the Free Software
 ## Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 ##
 
 if USE_FALLBACK_IMAGE
 	default ROM_SECTION_SIZE = FALLBACK_SIZE
 	default ROM_SECTION_OFFSET = (ROM_SIZE - FALLBACK_SIZE)
 else
 	default ROM_SECTION_SIZE = (ROM_SIZE - FALLBACK_SIZE)
 	default ROM_SECTION_OFFSET = 0
 end
 default CONFIG_ROM_PAYLOAD_START = (0xffffffff - ROM_SIZE
 				    + ROM_SECTION_OFFSET + 1)
 default PAYLOAD_SIZE = (ROM_SECTION_SIZE - ROM_IMAGE_SIZE)
 default _ROMBASE = (CONFIG_ROM_PAYLOAD_START + PAYLOAD_SIZE)
 default XIP_ROM_SIZE = 64 * 1024
 default XIP_ROM_BASE = (_ROMBASE + ROM_IMAGE_SIZE - XIP_ROM_SIZE)
 arch i386 end
 driver mainboard.o
 if HAVE_PIRQ_TABLE
 	object irq_tables.o
 end
 makerule ./failover.E
-	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ./romcc"
-	action "./romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
+	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ../romcc"
+	action "../romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
 end
 makerule ./failover.inc
-	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ./romcc"
-	action "./romcc -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
+	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ../romcc"
+	action "../romcc -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
 end
 makerule ./auto.E
-	# depends	"$(MAINBOARD)/auto.c option_table.h ./romcc"
-	depends	"$(MAINBOARD)/auto.c ./romcc"
-	action	"./romcc -E -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	# depends	"$(MAINBOARD)/auto.c option_table.h ../romcc"
+	depends	"$(MAINBOARD)/auto.c ../romcc"
+	action	"../romcc -E -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 makerule ./auto.inc
-	# depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-	depends "$(MAINBOARD)/auto.c ./romcc"
-	action	"./romcc -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	# depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+	depends "$(MAINBOARD)/auto.c ../romcc"
+	action	"../romcc -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 mainboardinit cpu/x86/16bit/entry16.inc
 mainboardinit cpu/x86/32bit/entry32.inc
 ldscript /cpu/x86/16bit/entry16.lds
 ldscript /cpu/x86/32bit/entry32.lds
 if USE_FALLBACK_IMAGE
 	mainboardinit cpu/x86/16bit/reset16.inc
 	ldscript /cpu/x86/16bit/reset16.lds
 else
 	mainboardinit cpu/x86/32bit/reset32.inc
 	ldscript /cpu/x86/32bit/reset32.lds
 end
 mainboardinit arch/i386/lib/cpu_reset.inc
 mainboardinit arch/i386/lib/id.inc
 ldscript /arch/i386/lib/id.lds
 if USE_FALLBACK_IMAGE
 	ldscript /arch/i386/lib/failover.lds
 	mainboardinit ./failover.inc
 end
 mainboardinit cpu/x86/fpu/enable_fpu.inc
 mainboardinit cpu/x86/mmx/enable_mmx.inc
 mainboardinit ./auto.inc
 mainboardinit cpu/x86/mmx/disable_mmx.inc
 
 dir /pc80
 config chip.h
 
 chip northbridge/intel/i440bx		# Northbridge
   device apic_cluster 0 on		# APIC cluster
     chip cpu/intel/slot_2		# CPU (FIXME: It's slot 1, actually)
       device apic 0 on end		# APIC
     end
   end
   device pci_domain 0 on		# PCI domain
     device pci 0.0 on end		# Host bridge
     device pci 1.0 on end		# PCI/AGP bridge
     chip southbridge/intel/i82371eb	# Southbridge
       device pci 7.0 on			# ISA bridge
         chip superio/smsc/smscsuperio	# Super I/O
           device pnp 3f0.0 on		# Floppy
             io 0x60 = 0x3f0
             irq 0x70 = 6
             drq 0x74 = 2
           end
           device pnp 3f0.3 on		# Parallel port
             io 0x60 = 0x378
             irq 0x70 = 7
           end
           device pnp 3f0.4 on		# COM1
             io 0x60 = 0x3f8
             irq 0x70 = 4
           end
           device pnp 3f0.5 on		# COM2 / IR
             io 0x60 = 0x2f8
             irq 0x70 = 3
           end
           device pnp 3f0.7 on		# PS/2 keyboard / mouse
             io 0x60 = 0x60
             io 0x62 = 0x64
             irq 0x70 = 1		# PS/2 keyboard interrupt
             irq 0x72 = 12		# PS/2 mouse interrupt
           end
           device pnp 3f0.8 on		# Aux I/O
           end
         end
       end
       device pci 7.1 on	end		# IDE
       device pci 7.2 on	end		# USB
       device pci 7.3 on end		# ACPI
       register "ide0_enable" = "1"
       register "ide1_enable" = "1"
       register "ide_legacy_enable" = "1"
       # Enable UDMA/33 for higher speed if your IDE device(s) support it.
       register "ide0_drive0_udma33_enable" = "0"
       register "ide0_drive1_udma33_enable" = "0"
       register "ide1_drive0_udma33_enable" = "0"
       register "ide1_drive1_udma33_enable" = "0"
     end
   end
 end
diff --git a/src/mainboard/compaq/deskpro_en_sff_p600/Config.lb b/src/mainboard/compaq/deskpro_en_sff_p600/Config.lb
index 72e8a9d..ba63dbd 100644
--- a/src/mainboard/compaq/deskpro_en_sff_p600/Config.lb
+++ b/src/mainboard/compaq/deskpro_en_sff_p600/Config.lb
@@ -1,145 +1,145 @@
 ##
 ## This file is part of the coreboot project.
 ##
 ## Copyright (C) 2007 Uwe Hermann <uwe@hermann-uwe.de>
 ##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2 of the License, or
 ## (at your option) any later version.
 ##
 ## This program is distributed in the hope that it will be useful,
 ## but WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ## GNU General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this program; if not, write to the Free Software
 ## Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 ##
 
 if USE_FALLBACK_IMAGE
 	default ROM_SECTION_SIZE = FALLBACK_SIZE
 	default ROM_SECTION_OFFSET = (ROM_SIZE - FALLBACK_SIZE)
 else
 	default ROM_SECTION_SIZE = (ROM_SIZE - FALLBACK_SIZE)
 	default ROM_SECTION_OFFSET = 0
 end
 default CONFIG_ROM_PAYLOAD_START = (0xffffffff - ROM_SIZE
 				    + ROM_SECTION_OFFSET + 1)
 default PAYLOAD_SIZE = (ROM_SECTION_SIZE - ROM_IMAGE_SIZE)
 default _ROMBASE = (CONFIG_ROM_PAYLOAD_START + PAYLOAD_SIZE)
 default XIP_ROM_SIZE = 64 * 1024
 default XIP_ROM_BASE = (_ROMBASE + ROM_IMAGE_SIZE - XIP_ROM_SIZE)
 arch i386 end
 driver mainboard.o
 if HAVE_PIRQ_TABLE
 	object irq_tables.o
 end
 makerule ./failover.E
-	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ./romcc"
-	action "./romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
+	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ../romcc"
+	action "../romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
 end
 makerule ./failover.inc
-	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ./romcc"
-	action "./romcc -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
+	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ../romcc"
+	action "../romcc -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
 end
 makerule ./auto.E
-	# depends	"$(MAINBOARD)/auto.c option_table.h ./romcc"
-	depends	"$(MAINBOARD)/auto.c ./romcc"
-	action	"./romcc -E -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	# depends	"$(MAINBOARD)/auto.c option_table.h ../romcc"
+	depends	"$(MAINBOARD)/auto.c ../romcc"
+	action	"../romcc -E -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 makerule ./auto.inc
-	# depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-	depends "$(MAINBOARD)/auto.c ./romcc"
-	action	"./romcc -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	# depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+	depends "$(MAINBOARD)/auto.c ../romcc"
+	action	"../romcc -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 mainboardinit cpu/x86/16bit/entry16.inc
 mainboardinit cpu/x86/32bit/entry32.inc
 ldscript /cpu/x86/16bit/entry16.lds
 ldscript /cpu/x86/32bit/entry32.lds
 if USE_FALLBACK_IMAGE
 	mainboardinit cpu/x86/16bit/reset16.inc
 	ldscript /cpu/x86/16bit/reset16.lds
 else
 	mainboardinit cpu/x86/32bit/reset32.inc
 	ldscript /cpu/x86/32bit/reset32.lds
 end
 mainboardinit arch/i386/lib/cpu_reset.inc
 mainboardinit arch/i386/lib/id.inc
 ldscript /arch/i386/lib/id.lds
 if USE_FALLBACK_IMAGE
 	ldscript /arch/i386/lib/failover.lds
 	mainboardinit ./failover.inc
 end
 mainboardinit cpu/x86/fpu/enable_fpu.inc
 mainboardinit cpu/x86/mmx/enable_mmx.inc
 mainboardinit ./auto.inc
 mainboardinit cpu/x86/mmx/disable_mmx.inc
 
 dir /pc80
 config chip.h
 
 chip northbridge/intel/i440bx		# Northbridge
   device apic_cluster 0 on		# APIC cluster
     chip cpu/intel/slot_2		# CPU (FIXME: It's slot 1, actually)
       device apic 0 on end		# APIC
     end
   end
   device pci_domain 0 on		# PCI domain
     device pci 0.0 on end		# Host bridge
     device pci 1.0 on end		# PCI/AGP bridge
     device pci a.0 on end		# NIC (onboard)
     chip southbridge/intel/i82371eb	# Southbridge
       device pci 14.0 on		# ISA bridge
         # chip superio/nsc/pc97307	# Super I/O
         chip superio/nsc/pc97317	# Super I/O (FIXME: Should be PC97307!)
           device pnp 15c.0 on		# PS/2 keyboard
             io 0x60 = 0x60
             io 0x62 = 0x64
             irq 0x70 = 1
           end
           device pnp 15c.1 on		# PS/2 mouse
             irq 0x70 = 12
           end
           device pnp 15c.2 on		# RTC, APC
             io 0x60 = 0x70
             irq 0x70 = 8
           end
           device pnp 15c.3 on		# Floppy
             io 0x60 = 0x3f0
             irq 0x70 = 6
             drq 0x74 = 2
           end
           device pnp 15c.4 on		# Parallel port
             io 0x60 = 0x378
             irq 0x70 = 7
           end
           device pnp 15c.5 on		# COM2 / IR
             io 0x60 = 0x2f8
             irq 0x70 = 3
           end
           device pnp 15c.6 on		# COM1
             io 0x60 = 0x3f8
             irq 0x70 = 4
           end
           device pnp 15c.7 on		# GPIO 1
           end
           device pnp 15c.8 on		# Power management
           end
         end
       end
       device pci 14.1 on end		# IDE
       device pci 14.2 on end		# USB
       device pci 14.3 on end		# ACPI
       register "ide0_enable" = "1"
       register "ide1_enable" = "1"
       register "ide_legacy_enable" = "1"
       # Enable UDMA/33 for higher speed if your IDE device(s) support it.
       register "ide0_drive0_udma33_enable" = "0"
       register "ide0_drive1_udma33_enable" = "0"
       register "ide1_drive0_udma33_enable" = "0"
       register "ide1_drive1_udma33_enable" = "0"
     end
   end
 end
diff --git a/src/mainboard/dell/s1850/Config.lb b/src/mainboard/dell/s1850/Config.lb
index 6be46d3..a194685 100644
--- a/src/mainboard/dell/s1850/Config.lb
+++ b/src/mainboard/dell/s1850/Config.lb
@@ -1,205 +1,205 @@
 ##
 ## Only use the option table in a normal image
 ##
 default USE_OPTION_TABLE = !USE_FALLBACK_IMAGE
 
 ##
 ## Compute the location and size of where this firmware image
 ## (coreboot plus bootloader) will live in the boot rom chip.
 ##
 if USE_FALLBACK_IMAGE
 	default ROM_SECTION_SIZE   = FALLBACK_SIZE
 	default ROM_SECTION_OFFSET = ( ROM_SIZE - FALLBACK_SIZE )
 else
 	default ROM_SECTION_SIZE   = ( ROM_SIZE - FALLBACK_SIZE )
 	default ROM_SECTION_OFFSET = 0
 end
 
 ##
 ## Compute the start location and size size of
 ## The coreboot bootloader.
 ##
 default PAYLOAD_SIZE            = ( ROM_SECTION_SIZE - ROM_IMAGE_SIZE )
 default CONFIG_ROM_PAYLOAD_START = (0xffffffff - ROM_SIZE + ROM_SECTION_OFFSET + 1)
 
 ##
 ## Compute where this copy of coreboot will start in the boot rom
 ##
 default _ROMBASE      = ( CONFIG_ROM_PAYLOAD_START + PAYLOAD_SIZE )
 
 ##
 ## Compute a range of ROM that can cached to speed up coreboot,
 ## execution speed.
 ##
 ## XIP_ROM_SIZE must be a power of 2.
 ## XIP_ROM_BASE must be a multiple of XIP_ROM_SIZE
 ##
 default XIP_ROM_SIZE=131072
 default XIP_ROM_BASE = ( _ROMBASE + ROM_IMAGE_SIZE - XIP_ROM_SIZE )
 
 ##
 ## Set all of the defaults for an x86 architecture
 ##
 
 arch i386 end
 
 ##
 ## Build the objects we have code for in this directory.
 ##
 
 driver mainboard.o
 if HAVE_MP_TABLE object mptable.o end
 if HAVE_PIRQ_TABLE object irq_tables.o end
 object reset.o
 
 ##
 ## Romcc output
 ##
 makerule ./failover.E
-	depends "$(MAINBOARD)/failover.c ./romcc" 
-	action "./romcc -fno-simplify-phi -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+	depends "$(MAINBOARD)/failover.c ../romcc" 
+	action "../romcc -fno-simplify-phi -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 end
 
 makerule ./failover.inc
-	depends "$(MAINBOARD)/failover.c ./romcc"
-	action "./romcc -fno-simplify-phi -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+	depends "$(MAINBOARD)/failover.c ../romcc"
+	action "../romcc -fno-simplify-phi -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 end
 
 makerule ./auto.E 
-	depends	"$(MAINBOARD)/auto.c option_table.h ./romcc" 
-	action	"./romcc -fno-simplify-phi -E -mcpu=p4 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	depends	"$(MAINBOARD)/auto.c option_table.h ../romcc" 
+	action	"../romcc -fno-simplify-phi -E -mcpu=p4 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 makerule ./auto.inc 
-	depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-	action	"./romcc -fno-simplify-phi -mcpu=p4 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+	action	"../romcc -fno-simplify-phi -mcpu=p4 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 
 ##
 ## Build our 16 bit and 32 bit coreboot entry code
 ##
 mainboardinit cpu/x86/16bit/entry16.inc
 mainboardinit cpu/x86/32bit/entry32.inc
 ldscript /cpu/x86/16bit/entry16.lds
 ldscript /cpu/x86/32bit/entry32.lds
 
 ##
 ## Build our reset vector (This is where coreboot is entered)
 ##
 if USE_FALLBACK_IMAGE 
 	mainboardinit cpu/x86/16bit/reset16.inc
 	ldscript /cpu/x86/16bit/reset16.lds
 else
 	mainboardinit cpu/x86/32bit/reset32.inc
 	ldscript /cpu/x86/32bit/reset32.lds
 end
 
 ### Should this be in the northbridge code?
 mainboardinit arch/i386/lib/cpu_reset.inc
 
 ##
 ## Include an id string (For safe flashing)
 ##
 mainboardinit arch/i386/lib/id.inc
 ldscript /arch/i386/lib/id.lds
 
 ###
 ### This is the early phase of coreboot startup 
 ### Things are delicate and we test to see if we should
 ### failover to another image.
 ###
 if USE_FALLBACK_IMAGE
 	ldscript /arch/i386/lib/failover.lds 
 	mainboardinit ./failover.inc
 end
 
 ###
 ### O.k. We aren't just an intermediary anymore!
 ###
 
 ##
 ## Setup RAM
 ##
 mainboardinit cpu/x86/fpu/enable_fpu.inc
 mainboardinit cpu/x86/mmx/enable_mmx.inc
 mainboardinit cpu/x86/sse/enable_sse.inc
 mainboardinit ./auto.inc
 mainboardinit cpu/x86/sse/disable_sse.inc
 mainboardinit cpu/x86/mmx/disable_mmx.inc
 
 ##
 ## Include the secondary Configuration files 
 ##
 dir /pc80
 config chip.h
 
 chip northbridge/intel/e7520 # mch
 	device pci_domain 0 on 
 		chip southbridge/intel/i82801er # i82801er
 			# USB ports
 			device pci 1d.0 on end
 			device pci 1d.1 on end
 			device pci 1d.2 on end 
 			device pci 1d.3 on end
 			device pci 1d.7 on end
 		
 			# -> Bridge
 			device pci 1e.0 on end
 		
 			# -> ISA
 			device pci 1f.0 on 
 				chip superio/nsc/pc8374
 					device pnp 2e.0 off end
 					device pnp 2e.1 off end
 					device pnp 2e.2 off end
 					device pnp 2e.3 on 
 						 io 0x60 = 0x3f8
 						irq 0x70 = 4
 					end
 					device pnp 2e.4 off end
 					device pnp 2e.5 off end
 					device pnp 2e.6 off end
 					device pnp 2e.7 off end
 					device pnp 2e.8 off end
 				end
 			end
 			# -> IDE
 			device pci 1f.1 on end
 			# -> SATA 
 			device pci 1f.2 on end
 			device pci 1f.3 on end
 
 			register "pirq_a_d" = "0x8a07030b"
 			register "pirq_e_h" = "0x85808080"
 		end
 		device pci 00.0 on end 
 		device pci 00.1 on end
 		device pci 01.0 on end 
 		device pci 02.0 on 
 			chip southbridge/intel/pxhd # pxhd1
 				# Bus bridges and ioapics usually bus 1
 				device pci 0.0 on 
 				# On board gig e1000
 					chip drivers/generic/generic 
         		        	        device pci 03.0 on end
         		        	        device pci 03.1 on end
         		        	end
 				end
 				device pci 0.1 on end
 				device pci 0.2 on end
 				device pci 0.3 on end
 			end
 		end
 		device pci 04.0 on end
 		device pci 06.0 on end
 	end
 	device apic_cluster 0 on
 		chip cpu/intel/socket_mPGA604_800Mhz # cpu 0
 			device apic 0 on end
 		end
 		chip cpu/intel/socket_mPGA604_800Mhz # cpu 1
 			device apic 6 on end
 		end
 	end
 	register "intrline" = "0x00070100"
 end
 
diff --git a/src/mainboard/digitallogic/adl855pc/Config.lb b/src/mainboard/digitallogic/adl855pc/Config.lb
index 7e6dcff..3932903 100644
--- a/src/mainboard/digitallogic/adl855pc/Config.lb
+++ b/src/mainboard/digitallogic/adl855pc/Config.lb
@@ -1,191 +1,191 @@
 ##
 ## Compute the location and size of where this firmware image
 ## (coreboot plus bootloader) will live in the boot rom chip.
 ##
 if USE_FALLBACK_IMAGE
 	default ROM_SECTION_SIZE   = FALLBACK_SIZE
 	default ROM_SECTION_OFFSET = ( ROM_SIZE - FALLBACK_SIZE )
 else
 	default ROM_SECTION_SIZE   = ( ROM_SIZE - FALLBACK_SIZE )
 	default ROM_SECTION_OFFSET = 0
 end
 
 ##
 ## Compute the start location and size size of
 ## The coreboot bootloader.
 ##
 default PAYLOAD_SIZE            = ( ROM_SECTION_SIZE - ROM_IMAGE_SIZE )
 default CONFIG_ROM_PAYLOAD_START = (0xffffffff - ROM_SIZE + ROM_SECTION_OFFSET + 1)
 
 ##
 ## Compute where this copy of coreboot will start in the boot rom
 ##
 default _ROMBASE      = ( CONFIG_ROM_PAYLOAD_START + PAYLOAD_SIZE )
 
 ##
 ## Compute a range of ROM that can cached to speed up coreboot,
 ## execution speed.
 ##
 ## XIP_ROM_SIZE must be a power of 2.
 ## XIP_ROM_BASE must be a multiple of XIP_ROM_SIZE
 ##
 default XIP_ROM_SIZE=65536
 default XIP_ROM_BASE = ( _ROMBASE + ROM_IMAGE_SIZE - XIP_ROM_SIZE )
 
 ##
 ## Set all of the defaults for an x86 architecture
 ##
 
 arch i386 end
 
 ##
 ## Build the objects we have code for in this directory.
 ##
 
 driver mainboard.o
 if HAVE_PIRQ_TABLE object irq_tables.o end
 #object reset.o
 
 ##
 ## Romcc output
 ##
 makerule ./failover.E
-	depends "$(MAINBOARD)/failover.c ./romcc" 
-	action "./romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+	depends "$(MAINBOARD)/failover.c ../romcc" 
+	action "../romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 end
 
 makerule ./failover.inc
-	depends "$(MAINBOARD)/failover.c ./romcc"
-	action "./romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+	depends "$(MAINBOARD)/failover.c ../romcc"
+	action "../romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 end
 
 makerule ./auto.E 
-	depends	"$(MAINBOARD)/auto.c option_table.h ./romcc" 
-	action	"./romcc -E -mcpu=p3 -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	depends	"$(MAINBOARD)/auto.c option_table.h ../romcc" 
+	action	"../romcc -E -mcpu=p3 -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 makerule ./auto.inc 
-	depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-	action	"./romcc    -mcpu=p3 -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+	action	"../romcc    -mcpu=p3 -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 
 ##
 ## Build our 16 bit and 32 bit coreboot entry code
 ##
 mainboardinit cpu/x86/16bit/entry16.inc
 mainboardinit cpu/x86/32bit/entry32.inc
 ldscript /cpu/x86/16bit/entry16.lds
 ldscript /cpu/x86/32bit/entry32.lds
 
 ##
 ## Build our reset vector (This is where coreboot is entered)
 ##
 if USE_FALLBACK_IMAGE 
 	mainboardinit cpu/x86/16bit/reset16.inc 
 	ldscript /cpu/x86/16bit/reset16.lds 
 else
 	mainboardinit cpu/x86/32bit/reset32.inc 
 	ldscript /cpu/x86/32bit/reset32.lds 
 end
 
 ### Should this be in the northbridge code?
 mainboardinit arch/i386/lib/cpu_reset.inc
 
 ##
 ## Include an id string (For safe flashing)
 ##
 mainboardinit arch/i386/lib/id.inc
 ldscript /arch/i386/lib/id.lds
 
 ###
 ### This is the early phase of coreboot startup 
 ### Things are delicate and we test to see if we should
 ### failover to another image.
 ###
 if USE_FALLBACK_IMAGE
 	ldscript /arch/i386/lib/failover.lds 
 	mainboardinit ./failover.inc
 end
 
 ###
 ### O.k. We aren't just an intermediary anymore!
 ###
 
 ##
 ## Setup RAM
 ##
 mainboardinit cpu/x86/fpu/enable_fpu.inc
 mainboardinit cpu/x86/mmx/enable_mmx.inc
 mainboardinit cpu/x86/sse/enable_sse.inc
 mainboardinit ./auto.inc
 mainboardinit cpu/x86/sse/disable_sse.inc
 mainboardinit cpu/x86/mmx/disable_mmx.inc
 
 ##
 ## Include the secondary Configuration files 
 ##
 dir /pc80
 config chip.h
 
 ## This does not look right but it is a literal conversion of the
 ## old version of this file.
 chip northbridge/intel/i855pm
 	device pci_domain 0 on 
 		device pci 0.0 on end
 		device pci 1.0 on end
 		chip southbridge/intel/i82801dbm
 #			pci 11.0 on end
 #			pci 11.1 on end
 #			pci 11.2 on end
 #			pci 11.3 on end
 #			pci 11.4 on end
 #			pci 11.5 on end
 #			pci 11.6 on end
 #			pci 12.0 on end
 			register "enable_usb" = "0"
 			register "enable_native_ide" = "0"
 			register "enable_usb" = "0"
 			register "enable_native_ide" = "0"
 			chip superio/winbond/w83627hf # link 1
                 	        device pnp 2e.0 on      #  Floppy
                 	                 io 0x60 = 0x3f0
                 	                irq 0x70 = 6
                 	                drq 0x74 = 2
 				end
                 	        device pnp 2e.1 off     #  Parallel Port
                 	                 io 0x60 = 0x378
                 	                irq 0x70 = 7
 				end
                 	        device pnp 2e.2 on      #  Com1
                 	                 io 0x60 = 0x3f8
                 	                irq 0x70 = 4
 				end
                 	        device pnp 2e.3 off     #  Com2
                 	                io 0x60 = 0x2f8
                 	                irq 0x70 = 3
 				end
                 	        device pnp 2e.5 on      #  Keyboard
                 	                 io 0x60 = 0x60
                 	                 io 0x62 = 0x64
                 	                irq 0x70 = 1
 					irq 0x72 = 12
 				end
                 	        device pnp 2e.6 off end #  CIR
                 	        device pnp 2e.7 off end #  GAME_MIDI_GIPO1
                 	        device pnp 2e.8 off end #  GPIO2
                 	        device pnp 2e.9 off end #  GPIO3
                 	        device pnp 2e.a off end #  ACPI
                 	        device pnp 2e.b on      #  HW Monitor
  					 io 0x60 = 0x290
 				end
 				register "com1" = "{1}"
 			#	register "com1" = "{1, 0, 0x3f8, 4}"
 			#	register "lpt" = "{1}"
                 	end
 		end
 	end
 	device apic_cluster 0 on 
 		chip cpu/intel/socket_mPGA479M
 			device apic 0 on end
 		end
 	end
 end
diff --git a/src/mainboard/digitallogic/msm586seg/Config.lb b/src/mainboard/digitallogic/msm586seg/Config.lb
index bd3f195..235d3b0 100644
--- a/src/mainboard/digitallogic/msm586seg/Config.lb
+++ b/src/mainboard/digitallogic/msm586seg/Config.lb
@@ -1,148 +1,148 @@
 ##
 ## Compute the location and size of where this firmware image
 ## (coreboot plus bootloader) will live in the boot rom chip.
 ##
 default ROM_SIZE = 512 * 1024 
 default FALLBACK_SIZE = 0x10000
 if USE_FALLBACK_IMAGE
 	default ROM_SECTION_SIZE   = FALLBACK_SIZE
 	default ROM_SECTION_OFFSET = ( ROM_SIZE - FALLBACK_SIZE )
 else
 	default ROM_SECTION_SIZE   = ( ROM_SIZE - FALLBACK_SIZE )
 	default ROM_SECTION_OFFSET = 0
 end
 
 ##
 ## Compute the start location and size size of
 ## The coreboot bootloader.
 ##
 default PAYLOAD_SIZE            = ( ROM_SECTION_SIZE - ROM_IMAGE_SIZE )
 default CONFIG_ROM_PAYLOAD_START = (0xffffffff - ROM_SIZE + ROM_SECTION_OFFSET + 1)
 
 ##
 ## Compute where this copy of coreboot will start in the boot rom
 ##
 default _ROMBASE      = ( CONFIG_ROM_PAYLOAD_START + PAYLOAD_SIZE )
 
 ##
 ## Compute a range of ROM that can cached to speed up coreboot,
 ## execution speed.
 ##
 ## XIP_ROM_SIZE must be a power of 2.
 ## XIP_ROM_BASE must be a multiple of XIP_ROM_SIZE
 ##
 default XIP_ROM_SIZE=32*1024
 default XIP_ROM_BASE = ( _ROMBASE + ROM_IMAGE_SIZE - XIP_ROM_SIZE )
 
 ##
 ## Set all of the defaults for an x86 architecture
 ##
 
 arch i386 end
 
 ##
 ## Build the objects we have code for in this directory.
 ##
 
 driver mainboard.o
 if HAVE_PIRQ_TABLE object irq_tables.o end
 object reset.o
 
 ##
 ## Romcc output
 ##
 makerule ./failover.E
-	depends "$(MAINBOARD)/failover.c ./romcc" 
-	action "./romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+	depends "$(MAINBOARD)/failover.c ../romcc" 
+	action "../romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 end
 
 makerule ./failover.inc
-	depends "$(MAINBOARD)/failover.c ./romcc"
-	action "./romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+	depends "$(MAINBOARD)/failover.c ../romcc"
+	action "../romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 end
 
 makerule ./auto.E 
-	depends	"$(MAINBOARD)/auto.c option_table.h ./romcc" 
-	action	"./romcc -E -mcpu=i386 -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	depends	"$(MAINBOARD)/auto.c option_table.h ../romcc" 
+	action	"../romcc -E -mcpu=i386 -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 makerule ./auto.inc 
-	depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-	action	"./romcc    -mcpu=i386 -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+	action	"../romcc    -mcpu=i386 -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 
 ##
 ## Build our 16 bit and 32 bit coreboot entry code
 ##
 mainboardinit cpu/x86/16bit/entry16.inc
 mainboardinit cpu/x86/32bit/entry32.inc
 ldscript /cpu/x86/16bit/entry16.lds
 ldscript /cpu/x86/32bit/entry32.lds
 
 ##
 ## Build our reset vector (This is where coreboot is entered)
 ##
 if USE_FALLBACK_IMAGE 
 	mainboardinit cpu/x86/16bit/reset16.inc 
 	ldscript /cpu/x86/16bit/reset16.lds 
 else
 	mainboardinit cpu/x86/32bit/reset32.inc 
 	ldscript /cpu/x86/32bit/reset32.lds 
 end
 
 ### Should this be in the northbridge code?
 mainboardinit arch/i386/lib/cpu_reset.inc
 
 ##
 ## Include an id string (For safe flashing)
 ##
 mainboardinit arch/i386/lib/id.inc
 ldscript /arch/i386/lib/id.lds
 
 ###
 ### This is the early phase of coreboot startup 
 ### Things are delicate and we test to see if we should
 ### failover to another image.
 ###
 if USE_FALLBACK_IMAGE
 	ldscript /arch/i386/lib/failover.lds 
 	mainboardinit ./failover.inc
 end
 
 
 # VGA console
 if CONFIG_CONSOLE_VGA
 	default CONFIG_PCI_ROM_RUN=1
 end
 ###
 ### O.k. We aren't just an intermediary anymore!
 ###
 
 ##
 ## Setup RAM
 ##
 mainboardinit cpu/x86/fpu/enable_fpu.inc
 mainboardinit ./auto.inc
 
 ##
 ## Include the secondary Configuration files 
 ##
 dir /pc80
 dir /devices
 config chip.h
 
 chip cpu/amd/sc520
 	device pci_domain 0 on 
 		device pci 0.0 on end
 	
 		chip drivers/pci/onboard
 			device pci 12.0 on end # enet
 		end
 		chip drivers/pci/onboard
 			device pci 14.0 on end # 69000
 			register "rom_address" = "0x2000000"
 		end
 #		register "com1" = "{1}"
 #		register "com1" = "{1, 0, 0x3f8, 4}"
 	end
 
 end
diff --git a/src/mainboard/eaglelion/5bcm/Config.lb b/src/mainboard/eaglelion/5bcm/Config.lb
index 9ad2948..8f21b18 100644
--- a/src/mainboard/eaglelion/5bcm/Config.lb
+++ b/src/mainboard/eaglelion/5bcm/Config.lb
@@ -1,181 +1,181 @@
 ##
 ## Compute the location and size of where this firmware image
 ## (coreboot plus bootloader) will live in the boot rom chip.
 ##
 if USE_FALLBACK_IMAGE
 	default ROM_SECTION_SIZE   = FALLBACK_SIZE
 	default ROM_SECTION_OFFSET = ( ROM_SIZE - FALLBACK_SIZE )
 else
 	default ROM_SECTION_SIZE   = ( ROM_SIZE - FALLBACK_SIZE )
 	default ROM_SECTION_OFFSET = 0
 end
 
 ##
 ## Compute the start location and size size of
 ## The coreboot bootloader.
 ##
 default CONFIG_ROM_PAYLOAD_START = (0xffffffff - ROM_SIZE + ROM_SECTION_OFFSET + 1)
 default PAYLOAD_SIZE            = ( ROM_SECTION_SIZE - ROM_IMAGE_SIZE )
 
 ##
 ## Compute where this copy of coreboot will start in the boot rom
 ##
 default _ROMBASE      = ( CONFIG_ROM_PAYLOAD_START + PAYLOAD_SIZE )
 
 ##
 ## Compute a range of ROM that can cached to speed up coreboot,
 ## execution speed.
 ##
 ## XIP_ROM_SIZE must be a power of 2.
 ## XIP_ROM_BASE must be a multiple of XIP_ROM_SIZE
 ##
 default XIP_ROM_SIZE=65536
 default XIP_ROM_BASE = ( _ROMBASE + ROM_IMAGE_SIZE - XIP_ROM_SIZE )
 
 ##
 ## Set all of the defaults for an x86 architecture
 ##
 
 arch i386 end
 
 ##
 ## Build the objects we have code for in this directory.
 ##
 
 driver mainboard.o
 
 if HAVE_PIRQ_TABLE object irq_tables.o end
 #object reset.o
 
 ##
 ## Romcc output
 ##
 makerule ./failover.E
-	depends "$(MAINBOARD)/failover.c ./romcc" 
-	action "./romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+	depends "$(MAINBOARD)/failover.c ../romcc" 
+	action "../romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 end
 
 makerule ./failover.inc
-	depends "$(MAINBOARD)/failover.c ./romcc"
-	action "./romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+	depends "$(MAINBOARD)/failover.c ../romcc"
+	action "../romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 end
 
 makerule ./auto.E 
-	depends	"$(MAINBOARD)/auto.c option_table.h ./romcc" 
-	action	"./romcc -E -mcpu=i386 -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	depends	"$(MAINBOARD)/auto.c option_table.h ../romcc" 
+	action	"../romcc -E -mcpu=i386 -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 makerule ./auto.inc 
-	depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-	action	"./romcc    -mcpu=i386 -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+	action	"../romcc    -mcpu=i386 -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 
 ##
 ## Build our 16 bit and 32 bit coreboot entry code
 ##
 mainboardinit cpu/x86/16bit/entry16.inc
 mainboardinit cpu/x86/32bit/entry32.inc
 ldscript /cpu/x86/16bit/entry16.lds
 ldscript /cpu/x86/32bit/entry32.lds
 
 ##
 ## Build our reset vector (This is where coreboot is entered)
 ##
 if USE_FALLBACK_IMAGE 
 	mainboardinit cpu/x86/16bit/reset16.inc 
 	ldscript /cpu/x86/16bit/reset16.lds 
 else
 	mainboardinit cpu/x86/32bit/reset32.inc 
 	ldscript /cpu/x86/32bit/reset32.lds 
 end
 
 ### Should this be in the northbridge code?
 mainboardinit arch/i386/lib/cpu_reset.inc
 
 ##
 ## Include an id string (For safe flashing)
 ##
 mainboardinit arch/i386/lib/id.inc
 ldscript /arch/i386/lib/id.lds
 
 ###
 ### This is the early phase of coreboot startup 
 ### Things are delicate and we test to see if we should
 ### failover to another image.
 ###
 if USE_FALLBACK_IMAGE
 	ldscript /arch/i386/lib/failover.lds 
 	mainboardinit ./failover.inc
 end
 
 ###
 ### O.k. We aren't just an intermediary anymore!
 ###
 
 ##
 ## Setup RAM
 ##
 mainboardinit cpu/x86/fpu/enable_fpu.inc
 mainboardinit cpu/amd/model_gx1/cpu_setup.inc
 mainboardinit cpu/amd/model_gx1/gx_setup.inc
 mainboardinit ./auto.inc
 
 ##
 ## Include the secondary Configuration files 
 ##
 dir /pc80
 config chip.h
 
 chip northbridge/amd/gx1
   device pci_domain 0 on 
     device pci 0.0 on end
       chip southbridge/amd/cs5530
         device pci 12.0 on
           chip superio/nsc/pc97317
             device pnp 2e.0 on		# Keyboard
                io 0x60 = 0x60
                io 0x62 = 0x64
               irq 0x70 = 1
             end
             device pnp 2e.1 on		# Mouse
               irq 0x70 = 12
             end
             device pnp 2e.2 on		# RTC
                io 0x60 = 0x70
               irq 0x70 = 8
             end
             device pnp 2e.3 off		# FDC
             end
             device pnp 2e.4 on		# Parallel Port
                io 0x60 = 0x378
               irq 0x70 = 7
             end
             device pnp 2e.5 on		# COM2
                io 0x60 = 0x2f8
               irq 0x70 = 3
             end
             device pnp 2e.6 on		# COM1
                io 0x60 = 0x3f8
               irq 0x70 = 4
             end
             device pnp 2e.7 on		# GPIO
                io 0x60 = 0xe0
             end
             device pnp 2e.8 on		# Power Management
                io 0x60 = 0xe800
             end
             register "com1" = "{115200}"
             register "com2" = "{38400}"
           end
         device pci 12.1 off end		# SMI
         device pci 12.2 on  end		# IDE
         device pci 12.3 off end 	# Audio
         device pci 12.4 off end		# VGA
       end
     end
   end
 
   chip cpu/amd/model_gx1
   end
 
 end
 
diff --git a/src/mainboard/emulation/qemu-x86/Config.lb b/src/mainboard/emulation/qemu-x86/Config.lb
index b6f3e90..49cbb95 100644
--- a/src/mainboard/emulation/qemu-x86/Config.lb
+++ b/src/mainboard/emulation/qemu-x86/Config.lb
@@ -1,121 +1,121 @@
 ##
 ## Compute the location and size of where this firmware image
 ## (coreboot plus bootloader) will live in the boot rom chip.
 ##
 default ROM_SIZE = 256 * 1024 
 default ROM_SECTION_SIZE   = ROM_SIZE
 default ROM_SECTION_OFFSET = 0
 
 ##
 ## Compute the start location and size size of
 ## The coreboot bootloader.
 ##
 default PAYLOAD_SIZE            = ( ROM_SECTION_SIZE - ROM_IMAGE_SIZE )
 default CONFIG_ROM_PAYLOAD_START = (0xffffffff - ROM_SIZE + ROM_SECTION_OFFSET + 1)
 
 ##
 ## Compute where this copy of coreboot will start in the boot rom
 ##
 default _ROMBASE      = ( CONFIG_ROM_PAYLOAD_START + PAYLOAD_SIZE )
 
 ##
 ## Compute a range of ROM that can cached to speed up coreboot,
 ## execution speed.
 ##
 ## XIP_ROM_SIZE must be a power of 2.
 ## XIP_ROM_BASE must be a multiple of XIP_ROM_SIZE
 ##
 default XIP_ROM_SIZE=32*1024
 default XIP_ROM_BASE = ( _ROMBASE + ROM_IMAGE_SIZE - XIP_ROM_SIZE )
 
 ##
 ## Set all of the defaults for an x86 architecture
 ##
 
 arch i386 end
 
 ##
 ## Build the objects we have code for in this directory.
 ##
 
 driver mainboard.o
 object vgabios.o
 if HAVE_PIRQ_TABLE object irq_tables.o end
 #object reset.o
 
 ##
 ## Romcc output
 ##
 makerule ./failover.E
-	depends "$(MAINBOARD)/failover.c ./romcc" 
-	action "./romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+	depends "$(MAINBOARD)/failover.c ../romcc" 
+	action "../romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 end
 
 makerule ./failover.inc
-	depends "$(MAINBOARD)/failover.c ./romcc"
-	action "./romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+	depends "$(MAINBOARD)/failover.c ../romcc"
+	action "../romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 end
 
 makerule ./auto.E 
-	depends	"$(MAINBOARD)/auto.c option_table.h ./romcc" 
-	action	"./romcc -E -mcpu=i386 -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	depends	"$(MAINBOARD)/auto.c option_table.h ../romcc" 
+	action	"../romcc -E -mcpu=i386 -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 makerule ./auto.inc 
-	depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-	action	"./romcc    -mcpu=i386 -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+	action	"../romcc    -mcpu=i386 -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 
 ##
 ## Build our 16 bit and 32 bit coreboot entry code
 ##
 mainboardinit cpu/x86/16bit/entry16.inc
 mainboardinit cpu/x86/32bit/entry32.inc
 ldscript /cpu/x86/16bit/entry16.lds
 ldscript /cpu/x86/32bit/entry32.lds
 
 ##
 ## Build our reset vector (This is where coreboot is entered)
 ##
 mainboardinit cpu/x86/16bit/reset16.inc 
 ldscript /cpu/x86/16bit/reset16.lds 
 
 ### Should this be in the northbridge code?
 mainboardinit arch/i386/lib/cpu_reset.inc
 
 ##
 ## Include an id string (For safe flashing)
 ##
 mainboardinit arch/i386/lib/id.inc
 ldscript /arch/i386/lib/id.lds
 
 ###
 ### O.k. We aren't just an intermediary anymore!
 ###
 
 ##
 ## Setup RAM
 ##
 mainboardinit cpu/x86/fpu/enable_fpu.inc
 mainboardinit ./auto.inc
 
 ##
 ## Include the secondary Configuration files 
 ##
 dir /pc80
 config chip.h
 
 chip cpu/emulation/qemu-x86
 	device pci_domain 0 on 
 		device pci 0.0 on end
 
 		chip southbridge/intel/i82371eb # southbridge
 			device pci 01.0 on end
 			device pci 01.1 on end
 			register "ide0_enable" = "1"
 			register "ide1_enable" = "1"
 		end
 
 #		register "com1" = "{1}"
 #		register "com1" = "{1, 0, 0x3f8, 4}"
 	end
 end
diff --git a/src/mainboard/gigabyte/ga-6bxc/Config.lb b/src/mainboard/gigabyte/ga-6bxc/Config.lb
index c23f073..c3b7135 100644
--- a/src/mainboard/gigabyte/ga-6bxc/Config.lb
+++ b/src/mainboard/gigabyte/ga-6bxc/Config.lb
@@ -1,139 +1,139 @@
 ##
 ## This file is part of the coreboot project.
 ##
 ## Copyright (C) 2007 Uwe Hermann <uwe@hermann-uwe.de>
 ##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2 of the License, or
 ## (at your option) any later version.
 ##
 ## This program is distributed in the hope that it will be useful,
 ## but WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ## GNU General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this program; if not, write to the Free Software
 ## Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 ##
 
 if USE_FALLBACK_IMAGE
 	default ROM_SECTION_SIZE = FALLBACK_SIZE
 	default ROM_SECTION_OFFSET = (ROM_SIZE - FALLBACK_SIZE)
 else
 	default ROM_SECTION_SIZE = (ROM_SIZE - FALLBACK_SIZE)
 	default ROM_SECTION_OFFSET = 0
 end
 default CONFIG_ROM_PAYLOAD_START = (0xffffffff - ROM_SIZE
 				    + ROM_SECTION_OFFSET + 1)
 default PAYLOAD_SIZE = (ROM_SECTION_SIZE - ROM_IMAGE_SIZE)
 default _ROMBASE = (CONFIG_ROM_PAYLOAD_START + PAYLOAD_SIZE)
 default XIP_ROM_SIZE = 64 * 1024
 default XIP_ROM_BASE = (_ROMBASE + ROM_IMAGE_SIZE - XIP_ROM_SIZE)
 arch i386 end
 driver mainboard.o
 if HAVE_PIRQ_TABLE
 	object irq_tables.o
 end
 makerule ./failover.E
-	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ./romcc"
-	action "./romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
+	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ../romcc"
+	action "../romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
 end
 makerule ./failover.inc
-	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ./romcc"
-	action "./romcc -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
+	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ../romcc"
+	action "../romcc -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
 end
 makerule ./auto.E
-	# depends	"$(MAINBOARD)/auto.c option_table.h ./romcc"
-	depends	"$(MAINBOARD)/auto.c ./romcc"
-	action	"./romcc -E -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	# depends	"$(MAINBOARD)/auto.c option_table.h ../romcc"
+	depends	"$(MAINBOARD)/auto.c ../romcc"
+	action	"../romcc -E -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 makerule ./auto.inc
-	# depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-	depends "$(MAINBOARD)/auto.c ./romcc"
-	action	"./romcc -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	# depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+	depends "$(MAINBOARD)/auto.c ../romcc"
+	action	"../romcc -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 mainboardinit cpu/x86/16bit/entry16.inc
 mainboardinit cpu/x86/32bit/entry32.inc
 ldscript /cpu/x86/16bit/entry16.lds
 ldscript /cpu/x86/32bit/entry32.lds
 if USE_FALLBACK_IMAGE
 	mainboardinit cpu/x86/16bit/reset16.inc
 	ldscript /cpu/x86/16bit/reset16.lds
 else
 	mainboardinit cpu/x86/32bit/reset32.inc
 	ldscript /cpu/x86/32bit/reset32.lds
 end
 mainboardinit arch/i386/lib/cpu_reset.inc
 mainboardinit arch/i386/lib/id.inc
 ldscript /arch/i386/lib/id.lds
 if USE_FALLBACK_IMAGE
 	ldscript /arch/i386/lib/failover.lds
 	mainboardinit ./failover.inc
 end
 mainboardinit cpu/x86/fpu/enable_fpu.inc
 mainboardinit cpu/x86/mmx/enable_mmx.inc
 mainboardinit ./auto.inc
 mainboardinit cpu/x86/mmx/disable_mmx.inc
 
 dir /pc80
 config chip.h
 
 chip northbridge/intel/i440bx		# Northbridge
   device apic_cluster 0 on		# APIC cluster
     chip cpu/intel/slot_2		# CPU (FIXME: It's slot 1, actually)
       device apic 0 on end		# APIC
     end
   end
   device pci_domain 0 on		# PCI domain
     device pci 0.0 on end		# Host bridge
     device pci 1.0 on end		# PCI/AGP bridge
     chip southbridge/intel/i82371eb	# Southbridge
       device pci 7.0 on			# ISA bridge
         chip superio/ite/it8671f	# Super I/O
           device pnp 3f0.0 on		# Floppy
             io 0x60 = 0x3f0
             irq 0x70 = 6
             drq 0x74 = 2
           end
           device pnp 3f0.1 on		# COM1
             io 0x60 = 0x3f8
             irq 0x70 = 4
           end
           device pnp 3f0.2 on		# COM2 / IR
             io 0x60 = 0x2f8
             irq 0x70 = 3
           end
           device pnp 3f0.3 on		# Parallel port
             io 0x60 = 0x378
             irq 0x70 = 7
           end
           device pnp 3f0.4 on		# APC
           end
           device pnp 3f0.5 on		# PS/2 keyboard
             io 0x60 = 0x60
             io 0x62 = 0x64
             irq 0x70 = 1
           end
           device pnp 3f0.6 on		# PS/2 mouse
             irq 0x70 = 12
           end
           device pnp 3f0.7 on		# GPIO
           end
         end
       end
       device pci 7.1 on	end		# IDE
       device pci 7.2 on	end		# USB
       device pci 7.3 on end		# ACPI
       register "ide0_enable" = "1"
       register "ide1_enable" = "1"
       register "ide_legacy_enable" = "1"
       # Enable UDMA/33 for higher speed if your IDE device(s) support it.
       register "ide0_drive0_udma33_enable" = "0"
       register "ide0_drive1_udma33_enable" = "0"
       register "ide1_drive0_udma33_enable" = "0"
       register "ide1_drive1_udma33_enable" = "0"
     end
   end
 end
diff --git a/src/mainboard/ibm/e325/Config.lb b/src/mainboard/ibm/e325/Config.lb
index d0ed9fd..68f7120 100644
--- a/src/mainboard/ibm/e325/Config.lb
+++ b/src/mainboard/ibm/e325/Config.lb
@@ -1,272 +1,272 @@
 ##
 ## Compute the location and size of where this firmware image
 ## (coreboot plus bootloader) will live in the boot rom chip.
 ##
 if USE_FALLBACK_IMAGE
 	default ROM_SECTION_SIZE   = FALLBACK_SIZE
 	default ROM_SECTION_OFFSET = ( ROM_SIZE - FALLBACK_SIZE )
 else
 	default ROM_SECTION_SIZE   = ( ROM_SIZE - FALLBACK_SIZE )
 	default ROM_SECTION_OFFSET = 0
 end
 
 ##
 ## Compute the start location and size size of
 ## The coreboot bootloader.
 ##
 default PAYLOAD_SIZE            = ( ROM_SECTION_SIZE - ROM_IMAGE_SIZE )
 default CONFIG_ROM_PAYLOAD_START = (0xffffffff - ROM_SIZE + ROM_SECTION_OFFSET + 1)
 
 ##
 ## Compute where this copy of coreboot will start in the boot rom
 ##
 default _ROMBASE      = ( CONFIG_ROM_PAYLOAD_START + PAYLOAD_SIZE )
 
 ##
 ## Compute a range of ROM that can cached to speed up coreboot,
 ## execution speed.
 ##
 ## XIP_ROM_SIZE must be a power of 2.
 ## XIP_ROM_BASE must be a multiple of XIP_ROM_SIZE
 ##
 default XIP_ROM_SIZE=65536
 default XIP_ROM_BASE = ( _ROMBASE + ROM_IMAGE_SIZE - XIP_ROM_SIZE )
 
 ##
 ## Set all of the defaults for an x86 architecture
 ##
 
 arch i386 end
 
 ##
 ## Build the objects we have code for in this directory.
 ##
 
 driver mainboard.o
 if HAVE_MP_TABLE object mptable.o end
 if HAVE_PIRQ_TABLE object irq_tables.o end
 #object reset.o
 
 if USE_DCACHE_RAM
 
 if CONFIG_USE_INIT
 
 makerule ./auto.o
         depends "$(MAINBOARD)/cache_as_ram_auto.c option_table.h"
         action "$(CC) $(DISTRO_CFLAGS) -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/cache_as_ram_auto.c -Os -nostdinc -nostdlib -fno-builtin -Wall -c -o auto.o" 
 end
 
 else    
                 
 makerule ./auto.inc
         depends "$(MAINBOARD)/cache_as_ram_auto.c option_table.h"
         action "$(CC) $(DISTRO_CFLAGS) -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/cache_as_ram_auto.c -Os -nostdinc -nostdlib -fno-builtin -Wall -c -S -o $@"         
         action "perl -e 's/.rodata/.rom.data/g' -pi $@"
         action "perl -e 's/.text/.section .rom.text/g' -pi $@"
 end
 
 end
 else
 ##
 ## Romcc output
 ##
 makerule ./failover.E
-	depends "$(MAINBOARD)/failover.c ./romcc" 
-	action "./romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+	depends "$(MAINBOARD)/failover.c ../romcc" 
+	action "../romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 end
 
 makerule ./failover.inc
-	depends "$(MAINBOARD)/failover.c ./romcc"
-	action "./romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+	depends "$(MAINBOARD)/failover.c ../romcc"
+	action "../romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 end
 
 makerule ./auto.E 
-	depends	"$(MAINBOARD)/auto.c option_table.h ./romcc" 
-	action	"./romcc -E -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	depends	"$(MAINBOARD)/auto.c option_table.h ../romcc" 
+	action	"../romcc -E -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 makerule ./auto.inc 
-	depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-	action	"./romcc    -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+	action	"../romcc    -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 
 end
 
 ##
 ## Build our 16 bit and 32 bit coreboot entry code
 ##
 if USE_FALLBACK_IMAGE
         mainboardinit cpu/x86/16bit/entry16.inc
         ldscript /cpu/x86/16bit/entry16.lds
 end
 
 mainboardinit cpu/x86/32bit/entry32.inc
 
 if USE_DCACHE_RAM
         if CONFIG_USE_INIT
                 ldscript /cpu/x86/32bit/entry32.lds
         end
 
         if CONFIG_USE_INIT
                 ldscript      /cpu/amd/car/cache_as_ram.lds
         end
 end
 
 ##
 ## Build our reset vector (This is where coreboot is entered)
 ##
 if USE_FALLBACK_IMAGE 
 	mainboardinit cpu/x86/16bit/reset16.inc 
 	ldscript /cpu/x86/16bit/reset16.lds 
 else
 	mainboardinit cpu/x86/32bit/reset32.inc 
 	ldscript /cpu/x86/32bit/reset32.lds 
 end
 
 if USE_DCACHE_RAM
 else
 ### Should this be in the northbridge code?
 mainboardinit arch/i386/lib/cpu_reset.inc
 end
 
 ##
 ## Include an id string (For safe flashing)
 ##
 mainboardinit arch/i386/lib/id.inc
 ldscript /arch/i386/lib/id.lds
 
 if USE_DCACHE_RAM
 ##
 ## Setup Cache-As-Ram
 ##
 mainboardinit cpu/amd/car/cache_as_ram.inc
 end
 
 ###
 ### This is the early phase of coreboot startup 
 ### Things are delicate and we test to see if we should
 ### failover to another image.
 ###
 if USE_FALLBACK_IMAGE
 if USE_DCACHE_RAM
        ldscript /arch/i386/lib/failover.lds
 else
        ldscript /arch/i386/lib/failover.lds
         mainboardinit ./failover.inc
 end
 end
 
 ###
 ### O.k. We aren't just an intermediary anymore!
 ###
 
 ##
 ## Setup RAM
 ##
 if USE_DCACHE_RAM
 
 if CONFIG_USE_INIT
 initobject auto.o
 else
 mainboardinit ./auto.inc
 end
 
 else
 
 ##
 ## Setup RAM
 ##
 mainboardinit cpu/x86/fpu/enable_fpu.inc
 mainboardinit cpu/x86/mmx/enable_mmx.inc
 mainboardinit cpu/x86/sse/enable_sse.inc
 mainboardinit ./auto.inc
 mainboardinit cpu/x86/sse/disable_sse.inc
 mainboardinit cpu/x86/mmx/disable_mmx.inc
 end
 
 ##
 ## Include the secondary Configuration files 
 ##
 config chip.h
 
 
 chip northbridge/amd/amdk8/root_complex
 	device pci_domain 0 on
 		chip northbridge/amd/amdk8
 			device pci 18.0 on end # LDT 0
 			device pci 18.0 on     # LDT 1
 				chip southbridge/amd/amd8131
 					device pci 0.0 on end
 					device pci 0.1 on end
 					device pci 1.0 on end
 					device pci 1.1 on end
 				end
 				chip southbridge/amd/amd8111
 					device pci 0.0 on
 						device pci 0.0 on end
 						device pci 0.1 on end
 						device pci 0.2 on end
 						device pci 1.0 off end
 					end
 					device pci 1.0 on
 						chip superio/nsc/pc87366
 							device	pnp 2e.0 off  # Floppy 
 								 io 0x60 = 0x3f0
 								irq 0x70 = 6
 								drq 0x74 = 2
 							end
 							device pnp 2e.1 off  # Parallel Port
 								 io 0x60 = 0x378
 								irq 0x70 = 7
 							end
 							device pnp 2e.2 off # Com 2
 								 io 0x60 = 0x2f8
 								irq 0x70 = 3
 							end
 							device pnp 2e.3 on  # Com 1
 								 io 0x60 = 0x3f8
 								irq 0x70 = 4
 							end
 							device pnp 2e.4 off end # SWC
 							device pnp 2e.5 off end # Mouse
 							device pnp 2e.6 on  # Keyboard
 								 io 0x60 = 0x60
 								 io 0x62 = 0x64
 								irq 0x70 = 1
 							end
 							device pnp 2e.7 off end # GPIO
 							device pnp 2e.8 off end # ACB
 							device pnp 2e.9 off end # FSCM
 							device pnp 2e.a off end # WDT  
 						end
 					end
 					device pci 1.1 on end
 					device pci 1.2 on end
 					device pci 1.3 on end
 					device pci 1.5 off end
 					device pci 1.6 off end
 				end
 			end #  device pci 18.0 
 			device pci 18.0 on end # LDT2
 			device pci 18.1 on end
 			device pci 18.2 on end
 			device pci 18.3 on end
 		end
 		chip northbridge/amd/amdk8
 			device pci 19.0 on end
 			device pci 19.0 on end
 			device pci 19.0 on end
 			device pci 19.1 on end
 			device pci 19.2 on end
 			device pci 19.3 on end
 		end
 	end 
 	device apic_cluster 0 on
 		chip cpu/amd/socket_940
 			device apic 0 on end
 		end
 		chip cpu/amd/socket_940
 			device apic 1 on end
 		end
 	end
 end
 
diff --git a/src/mainboard/ibm/e326/Config.lb b/src/mainboard/ibm/e326/Config.lb
index 44137a2..ccf3164 100644
--- a/src/mainboard/ibm/e326/Config.lb
+++ b/src/mainboard/ibm/e326/Config.lb
@@ -1,268 +1,268 @@
 ##
 ## Compute the location and size of where this firmware image
 ## (coreboot plus bootloader) will live in the boot rom chip.
 ##
 if USE_FALLBACK_IMAGE
 	default ROM_SECTION_SIZE   = FALLBACK_SIZE
 	default ROM_SECTION_OFFSET = ( ROM_SIZE - FALLBACK_SIZE )
 else
 	default ROM_SECTION_SIZE   = ( ROM_SIZE - FALLBACK_SIZE )
 	default ROM_SECTION_OFFSET = 0
 end
 
 ##
 ## Compute the start location and size size of
 ## The coreboot bootloader.
 ##
 default PAYLOAD_SIZE            = ( ROM_SECTION_SIZE - ROM_IMAGE_SIZE )
 default CONFIG_ROM_PAYLOAD_START = (0xffffffff - ROM_SIZE + ROM_SECTION_OFFSET + 1)
 
 ##
 ## Compute where this copy of coreboot will start in the boot rom
 ##
 default _ROMBASE      = ( CONFIG_ROM_PAYLOAD_START + PAYLOAD_SIZE )
 
 ##
 ## Compute a range of ROM that can cached to speed up coreboot,
 ## execution speed.
 ##
 ## XIP_ROM_SIZE must be a power of 2.
 ## XIP_ROM_BASE must be a multiple of XIP_ROM_SIZE
 ##
 default XIP_ROM_SIZE=65536
 default XIP_ROM_BASE = ( _ROMBASE + ROM_IMAGE_SIZE - XIP_ROM_SIZE )
 
 ##
 ## Set all of the defaults for an x86 architecture
 ##
 
 arch i386 end
 
 ##
 ## Build the objects we have code for in this directory.
 ##
 
 driver mainboard.o
 if HAVE_MP_TABLE object mptable.o end
 if HAVE_PIRQ_TABLE object irq_tables.o end
 #object reset.o
 
 if USE_DCACHE_RAM
 
 if CONFIG_USE_INIT
 
 makerule ./auto.o
         depends "$(MAINBOARD)/cache_as_ram_auto.c option_table.h"
         action "$(CC) $(DISTRO_CFLAGS) -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/cache_as_ram_auto.c -Os -nostdinc -nostdlib -fno-builtin -Wall -c -o auto.o" 
 end
 
 else    
                 
 makerule ./auto.inc
         depends "$(MAINBOARD)/cache_as_ram_auto.c option_table.h"
         action "$(CC) $(DISTRO_CFLAGS) -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/cache_as_ram_auto.c -Os -nostdinc -nostdlib -fno-builtin -Wall -c -S -o $@"         
         action "perl -e 's/.rodata/.rom.data/g' -pi $@"
         action "perl -e 's/.text/.section .rom.text/g' -pi $@"
 end
 
 end
 else
 ##
 ## Romcc output
 ##
 makerule ./failover.E
-	depends "$(MAINBOARD)/failover.c ./romcc" 
-	action "./romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+	depends "$(MAINBOARD)/failover.c ../romcc" 
+	action "../romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 end
 
 makerule ./failover.inc
-	depends "$(MAINBOARD)/failover.c ./romcc"
-	action "./romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+	depends "$(MAINBOARD)/failover.c ../romcc"
+	action "../romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 end
 
 makerule ./auto.E 
-	depends	"$(MAINBOARD)/auto.c option_table.h ./romcc" 
-	action	"./romcc -E -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	depends	"$(MAINBOARD)/auto.c option_table.h ../romcc" 
+	action	"../romcc -E -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 makerule ./auto.inc 
-	depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-	action	"./romcc    -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+	action	"../romcc    -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 
 end
 
 ##
 ## Build our 16 bit and 32 bit coreboot entry code
 ##
 if USE_FALLBACK_IMAGE
         mainboardinit cpu/x86/16bit/entry16.inc
         ldscript /cpu/x86/16bit/entry16.lds
 end
 
 mainboardinit cpu/x86/32bit/entry32.inc
 
 if USE_DCACHE_RAM
         if CONFIG_USE_INIT
                 ldscript /cpu/x86/32bit/entry32.lds
         end
 
         if CONFIG_USE_INIT
                 ldscript      /cpu/amd/car/cache_as_ram.lds
         end
 end
 
 ##
 ## Build our reset vector (This is where coreboot is entered)
 ##
 if USE_FALLBACK_IMAGE 
 	mainboardinit cpu/x86/16bit/reset16.inc 
 	ldscript /cpu/x86/16bit/reset16.lds 
 else
 	mainboardinit cpu/x86/32bit/reset32.inc 
 	ldscript /cpu/x86/32bit/reset32.lds 
 end
 
 if USE_DCACHE_RAM
 else
 ### Should this be in the northbridge code?
 mainboardinit arch/i386/lib/cpu_reset.inc
 end
 
 ##
 ## Include an id string (For safe flashing)
 ##
 mainboardinit arch/i386/lib/id.inc
 ldscript /arch/i386/lib/id.lds
 
 if USE_DCACHE_RAM
 ##
 ## Setup Cache-As-Ram
 ##
 mainboardinit cpu/amd/car/cache_as_ram.inc
 end
 
 ###
 ### This is the early phase of coreboot startup 
 ### Things are delicate and we test to see if we should
 ### failover to another image.
 ###
 if USE_FALLBACK_IMAGE
 if USE_DCACHE_RAM
        ldscript /arch/i386/lib/failover.lds
 else
        ldscript /arch/i386/lib/failover.lds
         mainboardinit ./failover.inc
 end
 end
 
 ###
 ### O.k. We aren't just an intermediary anymore!
 ###
 
 ##
 ## Setup RAM
 ##
 if USE_DCACHE_RAM
 
 if CONFIG_USE_INIT
 initobject auto.o
 else
 mainboardinit ./auto.inc
 end
 
 else
 
 ##
 ## Setup RAM
 ##
 mainboardinit cpu/x86/fpu/enable_fpu.inc
 mainboardinit cpu/x86/mmx/enable_mmx.inc
 mainboardinit cpu/x86/sse/enable_sse.inc
 mainboardinit ./auto.inc
 mainboardinit cpu/x86/sse/disable_sse.inc
 mainboardinit cpu/x86/mmx/disable_mmx.inc
 end
 
 ##
 ## Include the secondary Configuration files 
 ##
 config chip.h
 
 
 chip northbridge/amd/amdk8/root_complex
 	device apic_cluster 0 on
 		chip cpu/amd/socket_940
 			device apic 0 on end
 		end
 	end
 
 	device pci_domain 0 on
 		chip northbridge/amd/amdk8
 			device pci 18.0 on end # LDT 0
 			device pci 18.0 on     # LDT 1
 				chip southbridge/amd/amd8131
 					device pci 0.0 on end
 					device pci 0.1 on end
 					device pci 1.0 on end
 					device pci 1.1 on end
 				end
 				chip southbridge/amd/amd8111
 					device pci 0.0 on
 						device pci 0.0 on end
 						device pci 0.1 on end
 						device pci 0.2 on end
 						device pci 1.0 off end
                                                 chip drivers/pci/onboard
                                                         device pci 5.0 on end # ATI Rage XL
                                                         register "rom_address" = "0xfff80000"
                                                 end
 					end
 					device pci 1.0 on
 						chip superio/nsc/pc87366
 							device	pnp 2e.0 off  # Floppy 
 								 io 0x60 = 0x3f0
 								irq 0x70 = 6
 								drq 0x74 = 2
 							end
 							device pnp 2e.1 off  # Parallel Port
 								 io 0x60 = 0x378
 								irq 0x70 = 7
 							end
 							device pnp 2e.2 off # Com 2
 								 io 0x60 = 0x2f8
 								irq 0x70 = 3
 							end
 							device pnp 2e.3 on  # Com 1
 								 io 0x60 = 0x3f8
 								irq 0x70 = 4
 							end
 							device pnp 2e.4 off end # SWC
 							device pnp 2e.5 off end # Mouse
 							device pnp 2e.6 on  # Keyboard
 								 io 0x60 = 0x60
 								 io 0x62 = 0x64
 								irq 0x70 = 1
 							end
 							device pnp 2e.7 off end # GPIO
 							device pnp 2e.8 off end # ACB
 							device pnp 2e.9 off end # FSCM
 							device pnp 2e.a off end # WDT  
 						end
 					end
 					device pci 1.1 on end
 					device pci 1.2 on end
 					device pci 1.3 on end
 					device pci 1.5 off end
 					device pci 1.6 off end
 					register "ide0_enable" = "1"
 					register "ide1_enable" = "1"
 				end
 			end #  device pci 18.0 
 			device pci 18.0 on end # LDT2
 			device pci 18.1 on end
 			device pci 18.2 on end
 			device pci 18.3 on end
 		end
 	end 
 end
 
diff --git a/src/mainboard/iei/juki-511p/Config.lb b/src/mainboard/iei/juki-511p/Config.lb
index aac4951..6f9fbab 100644
--- a/src/mainboard/iei/juki-511p/Config.lb
+++ b/src/mainboard/iei/juki-511p/Config.lb
@@ -1,167 +1,167 @@
 ##
 ## Compute the location and size of where this firmware image
 ## (coreboot plus bootloader) will live in the boot rom chip.
 ##
 default ROM_SIZE = 256 * 1024 
 default ROM_SECTION_SIZE   = ROM_SIZE
 default ROM_SECTION_OFFSET = 0
 
 ##
 ## Compute the start location and size size of
 ## The coreboot bootloader.
 ##
 default PAYLOAD_SIZE            = ( ROM_SECTION_SIZE - ROM_IMAGE_SIZE )
 default CONFIG_ROM_PAYLOAD_START = (0xffffffff - ROM_SIZE + ROM_SECTION_OFFSET + 1)
 
 ##
 ## Compute where this copy of coreboot will start in the boot rom
 ##
 default _ROMBASE      = ( CONFIG_ROM_PAYLOAD_START + PAYLOAD_SIZE )
 
 ##
 ## Compute a range of ROM that can cached to speed up coreboot,
 ## execution speed.
 ##
 ## XIP_ROM_SIZE must be a power of 2.
 ## XIP_ROM_BASE must be a multiple of XIP_ROM_SIZE
 ##
 default XIP_ROM_SIZE=65536
 default XIP_ROM_BASE = ( _ROMBASE + ROM_IMAGE_SIZE - XIP_ROM_SIZE )
 
 ##
 ## Set all of the defaults for an x86 architecture
 ##
 
 arch i386 end
 
 ##
 ## Build the objects we have code for in this directory.
 ##
 
 driver mainboard.o
 
 if HAVE_PIRQ_TABLE object irq_tables.o end
 #object reset.o
 
 ##
 ## Romcc output
 ##
 makerule ./failover.E
-	depends "$(MAINBOARD)/failover.c ./romcc" 
-	action "./romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+	depends "$(MAINBOARD)/failover.c ../romcc" 
+	action "../romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 end
 
 makerule ./failover.inc
-	depends "$(MAINBOARD)/failover.c ./romcc"
-	action "./romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+	depends "$(MAINBOARD)/failover.c ../romcc"
+	action "../romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 end
 
 makerule ./auto.E 
-	depends	"$(MAINBOARD)/auto.c option_table.h ./romcc" 
-	action	"./romcc -E -mcpu=i386 -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	depends	"$(MAINBOARD)/auto.c option_table.h ../romcc" 
+	action	"../romcc -E -mcpu=i386 -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 makerule ./auto.inc 
-	depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-	action	"./romcc    -mcpu=i386 -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+	action	"../romcc    -mcpu=i386 -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 
 ##
 ## Build our 16 bit and 32 bit coreboot entry code
 ##
 mainboardinit cpu/x86/16bit/entry16.inc
 mainboardinit cpu/x86/32bit/entry32.inc
 ldscript /cpu/x86/16bit/entry16.lds
 ldscript /cpu/x86/32bit/entry32.lds
 
 ##
 ## Build our reset vector (This is where coreboot is entered)
 ##
 mainboardinit cpu/x86/16bit/reset16.inc 
 ldscript /cpu/x86/16bit/reset16.lds 
 
 ### Should this be in the northbridge code?
 mainboardinit arch/i386/lib/cpu_reset.inc
 
 ##
 ## Include an id string (For safe flashing)
 ##
 mainboardinit arch/i386/lib/id.inc
 ldscript /arch/i386/lib/id.lds
 
 ###
 ### O.k. We aren't just an intermediary anymore!
 ###
 
 ##
 ## Setup RAM
 ##
 mainboardinit cpu/x86/fpu/enable_fpu.inc
 mainboardinit cpu/amd/model_gx1/cpu_setup.inc
 mainboardinit cpu/amd/model_gx1/gx_setup.inc
 mainboardinit ./auto.inc
 
 ##
 ## Include the secondary Configuration files 
 ##
 #dir /pc80
 #config chip.h
 
 chip northbridge/amd/gx1
   device pci_domain 0 on
     device pci 0.0 on end
       chip southbridge/amd/cs5530
 
         device pci 12.0 on
           chip superio/winbond/w83977f
             device pnp 3f0.0 on		# FDC
               irq 0x70 = 6
             end
             device pnp 3f0.1 on		# Parallel port
               io 0x60 = 0x378
               irq 0x70 = 7
             end
             device pnp 3f0.2 on		# COM1
               io 0x60 = 0x3f8
               irq 0x70 = 4
             end
             register "com1" = "{115200}"
             device pnp 3f0.3 on		# COM2
               io 0x60 = 0x2f8
               irq 0x70 = 3
             end
             register "com2" = "{115200}"
             device pnp 3f0.4 on		# RTC
               io 0x60 = 0x070
               irq 0x70 = 8
             end
             device pnp 3f0.5 on		# Keyboard
               io 0x60 = 0x60
               io 0x62 = 0x64
               irq 0x70 = 1		# Int  1 for PS/2 keyboard
               irq 0x72 = 12		# Int 12 for PS/2 mouse
             end
             device pnp 3f0.6 off	# IR
             end
             device pnp 3f0.7 off	# GPIO1
             end
             device pnp 3f0.8 off	# GPIO
             end
           end
         device pci 12.1 on end		# SMI
         device pci 12.2 on end		# IDE
         device pci 12.3 on end		# Audio
         device pci 12.4 on end		# VGA onboard
 
       end
 
       device pci 0e.0 on end		# ETH0
       device pci 13.0 on end		# USB
 
     end
   end
 
   chip cpu/amd/model_gx1
   end
 
 end
 
diff --git a/src/mainboard/iei/nova4899r/Config.lb b/src/mainboard/iei/nova4899r/Config.lb
index 3b4094a..ef36ac1 100644
--- a/src/mainboard/iei/nova4899r/Config.lb
+++ b/src/mainboard/iei/nova4899r/Config.lb
@@ -1,193 +1,193 @@
 ##
 ## Compute the location and size of where this firmware image
 ## (coreboot plus bootloader) will live in the boot rom chip.
 ##
 if USE_FALLBACK_IMAGE
 	default ROM_SECTION_SIZE   = FALLBACK_SIZE
 	default ROM_SECTION_OFFSET = ( ROM_SIZE - FALLBACK_SIZE )
 else
 	default ROM_SECTION_SIZE   = ( ROM_SIZE - FALLBACK_SIZE )
 	default ROM_SECTION_OFFSET = 0
 end
 
 ##
 ## Compute the start location and size size of
 ## The coreboot bootloader.
 ##
 default CONFIG_ROM_PAYLOAD_START = (0xffffffff - ROM_SIZE + ROM_SECTION_OFFSET + 1)
 default PAYLOAD_SIZE            = ( ROM_SECTION_SIZE - ROM_IMAGE_SIZE )
 
 ##
 ## Compute where this copy of coreboot will start in the boot rom
 ##
 default _ROMBASE      = ( CONFIG_ROM_PAYLOAD_START + PAYLOAD_SIZE )
 
 ##
 ## Compute a range of ROM that can cached to speed up coreboot,
 ## execution speed.
 ##
 ## XIP_ROM_SIZE must be a power of 2.
 ## XIP_ROM_BASE must be a multiple of XIP_ROM_SIZE
 ##
 default XIP_ROM_SIZE=65536
 default XIP_ROM_BASE = ( _ROMBASE + ROM_IMAGE_SIZE - XIP_ROM_SIZE )
 
 ##
 ## Set all of the defaults for an x86 architecture
 ##
 
 arch i386 end
 
 ##
 ## Build the objects we have code for in this directory.
 ##
 
 driver mainboard.o
 
 if HAVE_PIRQ_TABLE object irq_tables.o end
 #object reset.o
 
 ##
 ## Romcc output
 ##
 makerule ./failover.E
-	depends "$(MAINBOARD)/failover.c ./romcc" 
-	action "./romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+	depends "$(MAINBOARD)/failover.c ../romcc" 
+	action "../romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 end
 
 makerule ./failover.inc
-	depends "$(MAINBOARD)/failover.c ./romcc"
-	action "./romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+	depends "$(MAINBOARD)/failover.c ../romcc"
+	action "../romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 end
 
 makerule ./auto.E 
-	depends	"$(MAINBOARD)/auto.c option_table.h ./romcc" 
-	action	"./romcc -E -mcpu=i386 -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	depends	"$(MAINBOARD)/auto.c option_table.h ../romcc" 
+	action	"../romcc -E -mcpu=i386 -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 makerule ./auto.inc 
-	depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-	action	"./romcc    -mcpu=i386 -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+	action	"../romcc    -mcpu=i386 -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 
 ##
 ## Build our 16 bit and 32 bit coreboot entry code
 ##
 mainboardinit cpu/x86/16bit/entry16.inc
 mainboardinit cpu/x86/32bit/entry32.inc
 ldscript /cpu/x86/16bit/entry16.lds
 ldscript /cpu/x86/32bit/entry32.lds
 
 ##
 ## Build our reset vector (This is where coreboot is entered)
 ##
 if USE_FALLBACK_IMAGE 
 	mainboardinit cpu/x86/16bit/reset16.inc 
 	ldscript /cpu/x86/16bit/reset16.lds 
 else
 	mainboardinit cpu/x86/32bit/reset32.inc 
 	ldscript /cpu/x86/32bit/reset32.lds 
 end
 
 ### Should this be in the northbridge code?
 mainboardinit arch/i386/lib/cpu_reset.inc
 
 ##
 ## Include an id string (For safe flashing)
 ##
 mainboardinit arch/i386/lib/id.inc
 ldscript /arch/i386/lib/id.lds
 
 ###
 ### This is the early phase of coreboot startup 
 ### Things are delicate and we test to see if we should
 ### failover to another image.
 ###
 if USE_FALLBACK_IMAGE
 	ldscript /arch/i386/lib/failover.lds 
 	mainboardinit ./failover.inc
 end
 
 ###
 ### O.k. We aren't just an intermediary anymore!
 ###
 
 ##
 ## Setup RAM
 ##
 mainboardinit cpu/x86/fpu/enable_fpu.inc
 mainboardinit cpu/amd/model_gx1/cpu_setup.inc
 mainboardinit cpu/amd/model_gx1/gx_setup.inc
 mainboardinit ./auto.inc
 
 ##
 ## Include the secondary Configuration files 
 ##
 #dir /pc80
 #config chip.h
 
 chip northbridge/amd/gx1
   device pci_domain 0 on
     device pci 0.0 on end
       chip southbridge/amd/cs5530
         device pci 0a.0 on  end		# ETH0
         device pci 0b.0 off end		# ETH1
         device pci 0c.0 on  end		# ETH2
         device pci 0f.0 on  end		# PCI slot
         device pci 12.0 on
           chip superio/winbond/w83977tf
             device pnp 2e.0 on		# FDC
               irq 0x70 = 6
             end
             device pnp 2e.1 on		# Parallel Port
                io 0x60 = 0x378
               irq 0x70 = 7
             end
             device pnp 2e.2 on		# COM1
                io 0x60 = 0x3f8
               irq 0x70 = 4
             end
             register "com1" = "{115200}"
             device pnp 2e.3 on		# COM2
                io 0x60 = 0x2f8
               irq 0x70 = 3
             end
             register "com2" = "{115200}"
             device pnp 2e.4 off		# Reserved
             end
             device pnp 2e.5 on		# Keyboard
                io 0x60 = 0x60
                io 0x62 = 0x64
               irq 0x70 = 0x01		# Int  1 for PS/2 keyboard
               irq 0x72 = 0x0c		# Int 12 for PS/2 mouse
             end
             device pnp 2e.6 on		# IR
                io 0x60 = 0x2e8
               irq 0x70 = 3
             end
             device pnp 2e.7 on		# GAME/MIDI/GPIO1
                io 0x60 = 0x290
             end
             device pnp 2e.8 on		# GPIO2
                io 0x60 = 0x110
             end
             device pnp 2e.9 on		# GPIO3
                io 0x60 = 0x120
             end
             device pnp 2e.A on		# Power Management
                io 0x60 = 0xe800
             end
           end
         device pci 12.1 on  end		# SMI
         device pci 12.2 on  end		# IDE
         device pci 12.3 on  end		# Audio
         device pci 12.4 on  end		# VGA onboard
       end
       device pci 13.0 on end		# USB
     end
   end
 
   chip cpu/amd/model_gx1
   end
 
 end
 
diff --git a/src/mainboard/intel/jarrell/Config.lb b/src/mainboard/intel/jarrell/Config.lb
index 5f0e697..6e33f86 100644
--- a/src/mainboard/intel/jarrell/Config.lb
+++ b/src/mainboard/intel/jarrell/Config.lb
@@ -1,213 +1,213 @@
 ##
 ## Only use the option table in a normal image
 ##
 default USE_OPTION_TABLE = !USE_FALLBACK_IMAGE
 
 ##
 ## Compute the location and size of where this firmware image
 ## (coreboot plus bootloader) will live in the boot rom chip.
 ##
 if USE_FALLBACK_IMAGE
 	default ROM_SECTION_SIZE   = FALLBACK_SIZE
 	default ROM_SECTION_OFFSET = ( ROM_SIZE - FALLBACK_SIZE )
 else
 	default ROM_SECTION_SIZE   = ( ROM_SIZE - FALLBACK_SIZE )
 	default ROM_SECTION_OFFSET = 0
 end
 
 ##
 ## Compute the start location and size size of
 ## The coreboot bootloader.
 ##
 default PAYLOAD_SIZE            = ( ROM_SECTION_SIZE - ROM_IMAGE_SIZE )
 default CONFIG_ROM_PAYLOAD_START = (0xffffffff - ROM_SIZE + ROM_SECTION_OFFSET + 1)
 
 ##
 ## Compute where this copy of coreboot will start in the boot rom
 ##
 default _ROMBASE      = ( CONFIG_ROM_PAYLOAD_START + PAYLOAD_SIZE )
 
 ##
 ## Compute a range of ROM that can cached to speed up coreboot,
 ## execution speed.
 ##
 ## XIP_ROM_SIZE must be a power of 2.
 ## XIP_ROM_BASE must be a multiple of XIP_ROM_SIZE
 ##
 default XIP_ROM_SIZE=131072
 default XIP_ROM_BASE = ( _ROMBASE + ROM_IMAGE_SIZE - XIP_ROM_SIZE )
 
 ##
 ## Set all of the defaults for an x86 architecture
 ##
 
 arch i386 end
 
 ##
 ## Build the objects we have code for in this directory.
 ##
 
 driver mainboard.o
 if HAVE_MP_TABLE object mptable.o end
 if HAVE_PIRQ_TABLE object irq_tables.o end
 object reset.o
 
 ##
 ## Romcc output
 ##
 makerule ./failover.E
-	depends "$(MAINBOARD)/failover.c ./romcc" 
-	action "./romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+	depends "$(MAINBOARD)/failover.c ../romcc" 
+	action "../romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 end
 
 makerule ./failover.inc
-	depends "$(MAINBOARD)/failover.c ./romcc"
-	action "./romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+	depends "$(MAINBOARD)/failover.c ../romcc"
+	action "../romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 end
 
 makerule ./auto.E 
-	depends	"$(MAINBOARD)/auto.c option_table.h ./romcc" 
-	action	"./romcc -E -mcpu=p4 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	depends	"$(MAINBOARD)/auto.c option_table.h ../romcc" 
+	action	"../romcc -E -mcpu=p4 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 makerule ./auto.inc 
-	depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-	action	"./romcc    -mcpu=p4 -fno-simplify-phi -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+	action	"../romcc    -mcpu=p4 -fno-simplify-phi -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 
 ##
 ## Build our 16 bit and 32 bit coreboot entry code
 ##
 mainboardinit cpu/x86/16bit/entry16.inc
 mainboardinit cpu/x86/32bit/entry32.inc
 ldscript /cpu/x86/16bit/entry16.lds
 ldscript /cpu/x86/32bit/entry32.lds
 
 ##
 ## Build our reset vector (This is where coreboot is entered)
 ##
 if USE_FALLBACK_IMAGE 
 	mainboardinit cpu/x86/16bit/reset16.inc
 	ldscript /cpu/x86/16bit/reset16.lds
 else
 	mainboardinit cpu/x86/32bit/reset32.inc
 	ldscript /cpu/x86/32bit/reset32.lds
 end
 
 ### Should this be in the northbridge code?
 mainboardinit arch/i386/lib/cpu_reset.inc
 
 ##
 ## Include an id string (For safe flashing)
 ##
 mainboardinit arch/i386/lib/id.inc
 ldscript /arch/i386/lib/id.lds
 
 ###
 ### This is the early phase of coreboot startup 
 ### Things are delicate and we test to see if we should
 ### failover to another image.
 ###
 if USE_FALLBACK_IMAGE
 	ldscript /arch/i386/lib/failover.lds 
 	mainboardinit ./failover.inc
 end
 
 ###
 ### O.k. We aren't just an intermediary anymore!
 ###
 
 ##
 ## Setup RAM
 ##
 mainboardinit cpu/x86/fpu/enable_fpu.inc
 mainboardinit cpu/x86/mmx/enable_mmx.inc
 mainboardinit cpu/x86/sse/enable_sse.inc
 mainboardinit ./auto.inc
 mainboardinit cpu/x86/sse/disable_sse.inc
 mainboardinit cpu/x86/mmx/disable_mmx.inc
 
 ##
 ## Include the secondary Configuration files 
 ##
 dir /pc80
 config chip.h
 
 chip northbridge/intel/e7520
 	device pci_domain 0 on 
 		device pci 00.0 on end
 		device pci 00.1 on end
 		device pci 01.0 on end
 		device pci 02.0 on 
 			chip southbridge/intel/pxhd # pxhd1
 				device pci 00.0 on end
 				device pci 00.1 on end
 				device pci 00.2 on
 					chip drivers/generic/generic
 						device pci 04.0 on end
 						device pci 04.1 on end
 					end
 				end
 				device pci 00.3 on end
 			end
 		end
 		device pci 06.0 on end
 		chip southbridge/intel/i82801er # i82801er
 			device pci 1d.0 on end
 			device pci 1d.1 on end
 			device pci 1d.2 on end
 			device pci 1d.3 off end
 			device pci 1d.7 on end
 			device pci 1e.0 on
 				chip drivers/ati/ragexl
 					device pci 0c.0 on end
 				end
 			end
 			device pci 1f.0 on 
 				chip superio/nsc/pc87427
 					device pnp 2e.0 off end
 					device pnp 2e.2 on
 #						 io 0x60 = 0x2f8
 #						irq 0x70 = 3
 						 io 0x60 = 0x3f8
 						irq 0x70 = 4
 					end
 					device pnp 2e.3 on
 #						 io 0x60 = 0x3f8
 #						irq 0x70 = 4
 						 io 0x60 = 0x2f8
 						irq 0x70 = 3
 					end
 					device pnp 2e.4 off end
 					device pnp 2e.5 off end
 					device pnp 2e.6 on
 						 io 0x60 = 0x60
 						 io 0x62 = 0x64
 						irq 0x70 = 1
 					end
 					device pnp 2e.7 off end
 					device pnp 2e.9 off end
 					device pnp 2e.a off end
 					device pnp 2e.f on end
 					device pnp 2e.10 off end
 					device pnp 2e.14 off end
 				end
 			end
 			device pci 1f.1 on end
 			device pci 1f.2 off end
 			device pci 1f.3 on end 
 			device pci 1f.5 off end
 			device pci 1f.6 off end
 			register "gpio[40]" = "ICH5R_GPIO_USE_AS_GPIO"
 			register "gpio[48]" = "ICH5R_GPIO_USE_AS_GPIO | ICH5R_GPIO_SEL_OUTPUT | ICH5R_GPIO_LVL_LOW"
 			register "gpio[41]" = "ICH5R_GPIO_USE_AS_GPIO | ICH5R_GPIO_SEL_INPUT"
 		end
 	end
 	device apic_cluster 0 on
 		chip cpu/intel/socket_mPGA604_800Mhz # cpu 0
 			device apic 0 on end
 		end
 		chip cpu/intel/socket_mPGA604_800Mhz # cpu 1
 			device apic 6 on end
 		end
 	end
 end
diff --git a/src/mainboard/intel/mtarvon/Config.lb b/src/mainboard/intel/mtarvon/Config.lb
index f91ab8e..fb95201 100644
--- a/src/mainboard/intel/mtarvon/Config.lb
+++ b/src/mainboard/intel/mtarvon/Config.lb
@@ -1,190 +1,190 @@
 ##
 ## This file is part of the coreboot project.
 ##
 ## Copyright (C) 2008 Arastra, Inc.
 ##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License version 2 as
 ## published by the Free Software Foundation.
 ##
 ## This program is distributed in the hope that it will be useful,
 ## but WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ## GNU General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this program; if not, write to the Free Software
 ## Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 ##
 
 ##
 ## Compute the location and size of where this firmware image
 ## (coreboot plus bootloader) will live in the boot ROM chip
 ##
 if USE_FALLBACK_IMAGE
         default ROM_SECTION_SIZE = FALLBACK_SIZE
         default ROM_SECTION_OFFSET = ( ROM_SIZE - FALLBACK_SIZE )
 else
         default ROM_SECTION_SIZE = ( ROM_SIZE - FALLBACK_SIZE )
         default ROM_SECTION_OFFSET = 0
 end
 
 ##
 ## Compute the start location and size size of the coreboot bootloader
 ##
 default PAYLOAD_SIZE = ( ROM_SECTION_SIZE - ROM_IMAGE_SIZE )
 default CONFIG_ROM_PAYLOAD_START = (0xffffffff - ROM_SIZE + ROM_SECTION_OFFSET + 1)
 
 ##
 ## Compute where this copy of coreboot will start in the boot ROM
 ##
 default _ROMBASE = ( CONFIG_ROM_PAYLOAD_START + PAYLOAD_SIZE )
 
 ##
 ## Compute a range of ROM that can cached to speed up coreboot,
 ## execution speed.
 ##
 ## XIP_ROM_SIZE must be a power of 2.
 ## XIP_ROM_BASE must be a multiple of XIP_ROM_SIZE
 ##
 default XIP_ROM_SIZE=131072
 default XIP_ROM_BASE = ( _ROMBASE + ROM_IMAGE_SIZE - XIP_ROM_SIZE )
 
 ##
 ## Set all of the defaults for an x86 architecture
 ##
 
 arch i386 end
 
 ##
 ## Build the objects we have code for in this directory.
 ##
 
 driver mainboard.o
 if HAVE_MP_TABLE object mptable.o end
 if HAVE_PIRQ_TABLE object irq_tables.o end
 
 ##
 ## Romcc output
 ##
 makerule ./failover.E
-        depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ./romcc"
-        action "./romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
+        depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ../romcc"
+        action "../romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
 end
 
 makerule ./failover.inc
-        depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ./romcc"
-        action "./romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
+        depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ../romcc"
+        action "../romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
 end
 
 makerule ./auto.E
-        depends "$(MAINBOARD)/auto.c ./romcc"
-        action "./romcc -E -mcpu=p4 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+        depends "$(MAINBOARD)/auto.c ../romcc"
+        action "../romcc -E -mcpu=p4 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 makerule ./auto.inc
-        depends "$(MAINBOARD)/auto.c ./romcc"
-        action "./romcc -mcpu=p4 -fno-simplify-phi -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+        depends "$(MAINBOARD)/auto.c ../romcc"
+        action "../romcc -mcpu=p4 -fno-simplify-phi -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 
 ##
 ## Build our 16 bit and 32 bit coreboot entry code
 ##
 mainboardinit cpu/x86/16bit/entry16.inc
 mainboardinit cpu/x86/32bit/entry32.inc
 ldscript /cpu/x86/16bit/entry16.lds
 ldscript /cpu/x86/32bit/entry32.lds
 
 ##
 ## Build our reset vector (This is where coreboot is entered)
 ##
 if USE_FALLBACK_IMAGE
         mainboardinit cpu/x86/16bit/reset16.inc
         ldscript /cpu/x86/16bit/reset16.lds
 else
         mainboardinit cpu/x86/32bit/reset32.inc
         ldscript /cpu/x86/32bit/reset32.lds
 end
 
 ### Should this be in the northbridge code?
 mainboardinit arch/i386/lib/cpu_reset.inc
 
 ##
 ## Include an id string (For safe flashing)
 ##
 mainboardinit arch/i386/lib/id.inc
 ldscript /arch/i386/lib/id.lds
 
 ###
 ### This is the early phase of coreboot startup
 ### Things are delicate and we test to see if we should
 ### failover to another image.
 ###
 if USE_FALLBACK_IMAGE
         ldscript /arch/i386/lib/failover.lds
         mainboardinit ./failover.inc
 end
 
 ###
 ### O.k. We aren't just an intermediary anymore!
 ###
 
 ##
 ## Setup RAM
 ##
 mainboardinit cpu/x86/fpu/enable_fpu.inc
 mainboardinit cpu/x86/mmx/enable_mmx.inc
 mainboardinit cpu/x86/sse/enable_sse.inc
 mainboardinit ./auto.inc
 mainboardinit cpu/x86/sse/disable_sse.inc
 mainboardinit cpu/x86/mmx/disable_mmx.inc
 
 ##
 ## Include the secondary Configuration files
 ##
 dir /pc80
 config chip.h
 
 chip northbridge/intel/i3100
         device pci_domain 0 on
                 device pci 00.0 on end # IMCH
                 device pci 00.1 on end # IMCH error status
                 device pci 01.0 on end # IMCH EDMA engine
                 device pci 02.0 on end # PCIe port A/A0
                 device pci 03.0 on end # PCIe port A1
                 chip southbridge/intel/i3100
                         # PIRQ line -> legacy IRQ mappings
                         register "pirq_a_d" = "0x0b070a05"
                         register "pirq_e_h" = "0x0a808080"
 
                         device pci 1c.0 on end # PCIe port B0
                         device pci 1c.1 on end # PCIe port B1
                         device pci 1c.2 on end # PCIe port B2
                         device pci 1c.3 on end # PCIe port B3
                         device pci 1d.0 on end # USB (UHCI) 1
                         device pci 1d.1 on end # USB (UHCI) 2
                         device pci 1d.7 on end # USB (EHCI)
                         device pci 1e.0 on end # PCI bridge
                         device pci 1e.2 on end # audio
                         device pci 1e.3 on end # modem
                         device pci 1f.0 on     # LPC bridge
                                 chip superio/intel/i3100
                                         device pnp 4e.4 on # Com1
                                                  io 0x60 = 0x3f8
                                                 irq 0x70 = 4
                                         end
                                         device pnp 4e.5 on # Com2
                                                  io 0x60 = 0x2f8
                                                 irq 0x70 = 3
                                         end
                                 end
                         end
                         device pci 1f.2 on end # SATA
                         device pci 1f.3 on end # SMBus
                 end
         end
         device apic_cluster 0 on
                 chip cpu/intel/socket_mPGA479M
                         device apic 0 on end
                 end
         end
 end
diff --git a/src/mainboard/intel/xe7501devkit/Config.lb b/src/mainboard/intel/xe7501devkit/Config.lb
index 52efe0f..eec15cd 100644
--- a/src/mainboard/intel/xe7501devkit/Config.lb
+++ b/src/mainboard/intel/xe7501devkit/Config.lb
@@ -1,224 +1,224 @@
 ##################################################################
 ## BEGIN BOILERPLATE - DO NOT EDIT
 ##
 ## Compute the location and size of where this firmware image
 ## (coreboot plus payload) will live in the boot rom chip.
 ##
 if USE_FALLBACK_IMAGE
 # The fallback image uses FALLBACK_SIZE bytes at the end of the ROM
 
 	default ROM_SECTION_SIZE   = FALLBACK_SIZE
 	default ROM_SECTION_OFFSET = ( ROM_SIZE - FALLBACK_SIZE )
 
 else
 # The normal image goes at the beginning of the coreboot ROM region
 # and uses all the remaining space
 
 	default ROM_SECTION_SIZE   = ( ROM_SIZE - FALLBACK_SIZE )
 	default ROM_SECTION_OFFSET = 0
 end
 
 ##
 ## Compute where this copy of coreboot will start in the boot rom
 ##
 default _ROMBASE      = ( CONFIG_ROM_PAYLOAD_START + PAYLOAD_SIZE )
 
 ##
 ## Compute a range of ROM that can cached to speed up coreboot,
 ## execution speed.
 ##
 ## XIP_ROM_SIZE must be a power of 2.
 ## XIP_ROM_BASE must be a multiple of XIP_ROM_SIZE
 default XIP_ROM_SIZE = 65536
 default XIP_ROM_BASE = ((( _ROMBASE + ROM_IMAGE_SIZE ) / XIP_ROM_SIZE ) * XIP_ROM_SIZE - XIP_ROM_SIZE )
 
 ## END BOILERPLATE
 ##################################################################
 
 arch i386 end 
 
 ##
 ## Build the objects we have code for in this directory.
 ##
 
 driver mainboard.o
 if HAVE_MP_TABLE 		object mptable.o 	 end
 if HAVE_PIRQ_TABLE 		object irq_tables.o	 end
 if HAVE_ACPI_TABLES 	object acpi_tables.o end
 object reset.o
 
 # Include the VGA option ROM, but only if we're compiled to use it
 if CONFIG_PCI_ROM_RUN
 	if CONFIG_CONSOLE_VGA	
 		object vgarom.S
 	else
 		object no_vgarom.S
 	end
 else
 	object no_vgarom.S
 end
 
 ##
 ## Romcc output
 ##
 makerule ./failover.E
-        depends "$(MAINBOARD)/failover.c ./romcc"
-        action "./romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+        depends "$(MAINBOARD)/failover.c ../romcc"
+        action "../romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 end
 
 makerule ./failover.inc
-        depends "$(MAINBOARD)/failover.c ./romcc"
-        action "./romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+        depends "$(MAINBOARD)/failover.c ../romcc"
+        action "../romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 end
 
 makerule ./auto.E
-        depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-        action  "./romcc -E -mcpu=p4 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+        depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+        action  "../romcc -E -mcpu=p4 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 makerule ./auto.inc
-        depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-        action  "./romcc    -mcpu=p4 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+        depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+        action  "../romcc    -mcpu=p4 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 
 ##
 ## Build our 16 bit and 32 bit coreboot entry code
 ##
 mainboardinit cpu/x86/16bit/entry16.inc
 mainboardinit cpu/x86/32bit/entry32.inc
 ldscript /cpu/x86/16bit/entry16.lds
 ldscript /cpu/x86/32bit/entry32.lds
 
 ##
 ## Build our reset vector (This is where coreboot is entered)
 ##
 if HAVE_FALLBACK_BOOT
     if USE_FALLBACK_IMAGE 
 	    mainboardinit cpu/x86/16bit/reset16.inc 
 	    ldscript /cpu/x86/16bit/reset16.lds
     else
 	    mainboardinit cpu/x86/32bit/reset32.inc 
 	    ldscript /cpu/x86/32bit/reset32.lds 
     end
 else
 	mainboardinit cpu/x86/16bit/reset16.inc 
 	ldscript /cpu/x86/16bit/reset16.lds
 end
 
 ### Should this be in the northbridge code?
 mainboardinit arch/i386/lib/cpu_reset.inc
 
 ##
 ## Include an id string (For safe flashing)
 ##
 mainboardinit arch/i386/lib/id.inc
 ldscript /arch/i386/lib/id.lds
 
 ###
 ### This is the early phase of coreboot startup 
 ### Things are delicate and we test to see if we should
 ### failover to another image.
 ###
 if USE_FALLBACK_IMAGE
 	ldscript /arch/i386/lib/failover.lds 
 	mainboardinit ./failover.inc
 end
 
 ###
 ### O.k. We aren't just an intermediary anymore!
 ###
 
 ##
 ## Setup RAM
 ##
 mainboardinit cpu/x86/fpu/enable_fpu.inc
 mainboardinit cpu/x86/mmx/enable_mmx.inc
 mainboardinit cpu/x86/sse/enable_sse.inc
 mainboardinit ./auto.inc
 mainboardinit cpu/x86/sse/disable_sse.inc
 mainboardinit cpu/x86/mmx/disable_mmx.inc
 
 ##
 ## Include the secondary Configuration files 
 ##
 dir /pc80
 
 if CONFIG_CHIP_NAME
 	config chip.h
 end
 
 # based on sample config for tyan/s2735
 chip northbridge/intel/e7501
 	device pci_domain 0 on
 		device pci 0.0 on end # Chipset host controller
 		device pci 0.1 on end # Host RASUM controller
 		device pci 2.0 on # Hub interface B
 			chip southbridge/intel/i82870 # P64H2
 				device pci 1c.0 on end # IOAPIC - bus B
 				device pci 1d.0 on end # Hub to PCI-B bridge
 				device pci 1e.0 on end # IOAPIC - bus A
 				device pci 1f.0 on end # Hub to PCI-A bridge
 			end
 		end
 		device pci 3.0 off end # Hub interface C (82808AA connector - disable for now)
 		device pci 4.0 on # Hub interface D
 			chip southbridge/intel/i82870 # P64H2
 				device pci 1c.0 on end # IOAPIC - bus B
 				device pci 1d.0 on end # Hub to PCI-B bridge
 				device pci 1e.0 on end # IOAPIC - bus A
 				device pci 1f.0 on end # Hub to PCI-A bridge
 			end
 		end
 		device pci 6.0 on end # E7501 Power management registers? (undocumented)
 		chip southbridge/intel/i82801ca
 			device pci 1d.0 off end # USB (might not work, Southbridge code needs looking at)
 			device pci 1d.1 off end # USB (not populated)
 			device pci 1d.2 off end # USB (not populated)
 			device pci 1e.0 on # Hub to PCI bridge
 				chip drivers/pci/onboard # VGA ROM
 					device pci 0.0 on end
 				register "rom_address" = "_vgarom_start"
 				end
 			end
 			device pci 1f.0 on # LPC bridge
 				chip superio/smsc/lpc47b272
 					device pnp 2e.0 off # Floppy
 						io 0x60 = 0x3f0
 						irq 0x70 = 6
 						drq 0x74 = 2
 					end
 					device pnp 2e.3 off # Parallel Port
 						io 0x60 = 0x378
 						irq 0x70 = 7
 					end
 					device pnp 2e.4 on # Com1
 						io 0x60 = 0x3f8
 						irq 0x70 = 4
 					end
 					device pnp 2e.5 off # Com2
 						io 0x60 = 0x2f8
 						irq 0x70 = 3
 					end
 					device pnp 2e.7 on # Keyboard
 						io 0x60 = 0x60
 						io 0x62 = 0x64
 						irq 0x70 = 1 # Keyboard interrupt
 						irq 0x72 = 12 # Mouse interrupt
 					end
 					device pnp 2e.a off end # ACPI
 				end
 			end
 			device pci 1f.1 on end # IDE
 			device pci 1f.3 on end # SMBus
 			device pci 1f.5 off end # AC97 Audio
 			device pci 1f.6 off end # AC97 Modem
 		end # SB
 	end # PCI_DOMAIN
 	device apic_cluster 0 on
 		chip cpu/intel/socket_mPGA604_533Mhz
 			device apic 0 on end
 		end
 		chip cpu/intel/socket_mPGA604_533Mhz
 			device apic 6 on end
 		end
 	end
 end
diff --git a/src/mainboard/iwill/dk8s2/Config.lb b/src/mainboard/iwill/dk8s2/Config.lb
index 31b521d..ad3e22e 100644
--- a/src/mainboard/iwill/dk8s2/Config.lb
+++ b/src/mainboard/iwill/dk8s2/Config.lb
@@ -1,283 +1,283 @@
 ##
 ## Compute the location and size of where this firmware image
 ## (coreboot plus bootloader) will live in the boot rom chip.
 ##
 if USE_FALLBACK_IMAGE
 	default ROM_SECTION_SIZE   = FALLBACK_SIZE
 	default ROM_SECTION_OFFSET = ( ROM_SIZE - FALLBACK_SIZE )
 else
 	default ROM_SECTION_SIZE   = ( ROM_SIZE - FALLBACK_SIZE )
 	default ROM_SECTION_OFFSET = 0
 end
 
 ##
 ## Compute the start location and size size of
 ## The coreboot bootloader.
 ##
 default PAYLOAD_SIZE            = ( ROM_SECTION_SIZE - ROM_IMAGE_SIZE )
 default CONFIG_ROM_PAYLOAD_START = (0xffffffff - ROM_SIZE + ROM_SECTION_OFFSET + 1)
 
 ##
 ## Compute where this copy of coreboot will start in the boot rom
 ##
 default _ROMBASE      = ( CONFIG_ROM_PAYLOAD_START + PAYLOAD_SIZE )
 
 ##
 ## Compute a range of ROM that can cached to speed up coreboot,
 ## execution speed.
 ##
 ## XIP_ROM_SIZE must be a power of 2.
 ## XIP_ROM_BASE must be a multiple of XIP_ROM_SIZE
 ##
 default XIP_ROM_SIZE=65536
 default XIP_ROM_BASE = ( _ROMBASE + ROM_IMAGE_SIZE - XIP_ROM_SIZE )
 
 ##
 ## Set all of the defaults for an x86 architecture
 ##
 
 arch i386 end
 
 ##
 ## Build the objects we have code for in this directory.
 ##
 
 driver mainboard.o
 if HAVE_MP_TABLE object mptable.o end
 if HAVE_PIRQ_TABLE object irq_tables.o end
 #object reset.o
 
 ## ATI Rage XL framebuffering graphics driver
 dir /drivers/ati/ragexl
 
 if USE_DCACHE_RAM
 
 if CONFIG_USE_INIT
 
 makerule ./auto.o
         depends "$(MAINBOARD)/cache_as_ram_auto.c option_table.h"
         action "$(CC) $(DISTRO_CFLAGS) -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/cache_as_ram_auto.c -Os -nostdinc -nostdlib -fno-builtin -Wall -c -o auto.o" 
 end
 
 else    
                 
 makerule ./auto.inc
         depends "$(MAINBOARD)/cache_as_ram_auto.c option_table.h"
         action "$(CC) $(DISTRO_CFLAGS) -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/cache_as_ram_auto.c -Os -nostdinc -nostdlib -fno-builtin -Wall -c -S -o $@"         
         action "perl -e 's/.rodata/.rom.data/g' -pi $@"
         action "perl -e 's/.text/.section .rom.text/g' -pi $@"
 end
 
 end
 else
 ##
 ## Romcc output
 ##
 makerule ./failover.E
-	depends "$(MAINBOARD)/failover.c ./romcc" 
-	action "./romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+	depends "$(MAINBOARD)/failover.c ../romcc" 
+	action "../romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 end
 
 makerule ./failover.inc
-	depends "$(MAINBOARD)/failover.c ./romcc"
-	action "./romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+	depends "$(MAINBOARD)/failover.c ../romcc"
+	action "../romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 end
 
 makerule ./auto.E 
-	depends	"$(MAINBOARD)/auto.c option_table.h ./romcc" 
-	action	"./romcc -E -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	depends	"$(MAINBOARD)/auto.c option_table.h ../romcc" 
+	action	"../romcc -E -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 makerule ./auto.inc 
-	depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-	action	"./romcc    -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+	action	"../romcc    -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 
 end
 
 ##
 ## Build our 16 bit and 32 bit coreboot entry code
 ##
 if USE_FALLBACK_IMAGE
         mainboardinit cpu/x86/16bit/entry16.inc
         ldscript /cpu/x86/16bit/entry16.lds
 end
 
 mainboardinit cpu/x86/32bit/entry32.inc
 
 if USE_DCACHE_RAM
         if CONFIG_USE_INIT
                 ldscript /cpu/x86/32bit/entry32.lds
         end
 
         if CONFIG_USE_INIT
                 ldscript      /cpu/amd/car/cache_as_ram.lds
         end
 end
 
 ##
 ## Build our reset vector (This is where coreboot is entered)
 ##
 if USE_FALLBACK_IMAGE 
 	mainboardinit cpu/x86/16bit/reset16.inc 
 	ldscript /cpu/x86/16bit/reset16.lds 
 else
 	mainboardinit cpu/x86/32bit/reset32.inc 
 	ldscript /cpu/x86/32bit/reset32.lds 
 end
 
 if USE_DCACHE_RAM
 else
 ### Should this be in the northbridge code?
 mainboardinit arch/i386/lib/cpu_reset.inc
 end
 
 ##
 ## Include an id string (For safe flashing)
 ##
 mainboardinit arch/i386/lib/id.inc
 ldscript /arch/i386/lib/id.lds
 
 if USE_DCACHE_RAM
 ##
 ## Setup Cache-As-Ram
 ##
 mainboardinit cpu/amd/car/cache_as_ram.inc
 end
 
 ###
 ### This is the early phase of coreboot startup 
 ### Things are delicate and we test to see if we should
 ### failover to another image.
 ###
 if USE_FALLBACK_IMAGE
 if USE_DCACHE_RAM
        ldscript /arch/i386/lib/failover.lds
 else
        ldscript /arch/i386/lib/failover.lds
         mainboardinit ./failover.inc
 end
 end
 
 ###
 ### O.k. We aren't just an intermediary anymore!
 ###
 
 ##
 ## Setup RAM
 ##
 if USE_DCACHE_RAM
 
 if CONFIG_USE_INIT
 initobject auto.o
 else
 mainboardinit ./auto.inc
 end
 
 else
 
 ##
 ## Setup RAM
 ##
 mainboardinit cpu/x86/fpu/enable_fpu.inc
 mainboardinit cpu/x86/mmx/enable_mmx.inc
 mainboardinit cpu/x86/sse/enable_sse.inc
 mainboardinit ./auto.inc
 mainboardinit cpu/x86/sse/disable_sse.inc
 mainboardinit cpu/x86/mmx/disable_mmx.inc
 end
 
 ##
 ## Include the secondary Configuration files 
 ##
 config chip.h
 
 # config for iwill/dk8s2
 chip northbridge/amd/amdk8/root_complex
 	device pci_domain 0 on
 		chip northbridge/amd/amdk8
 			device pci 18.0 on # LDT 0
 				chip southbridge/amd/amd8131
 					device pci 0.0 on end
 					device pci 0.1 on end
 					device pci 1.0 on end
 					device pci 1.1 on end
 				end
 				chip southbridge/amd/amd8111
 					# this "device pci 0.0" is the parent the next one
 					# PCI bridge
 					device pci 0.0 on
 						device pci 0.0 on end
 						device pci 0.1 on end
 						device pci 0.2 on end
 						device pci 1.0 off end
 					end
 					device pci 1.0 on
 						chip superio/winbond/w83627hf
 							device pnp  2e.0 on      # Floppy
 								 io 0x60 = 0x3f0
 								irq 0x70 = 6
 								drq 0x74 = 2
 							end
 							device pnp  2e.1 off     # Parallel Port
 								 io 0x60 = 0x378
 								irq 0x70 = 7
 							end
 							device pnp  2e.2 on      # Com1
 								 io 0x60 = 0x3f8
 								irq 0x70 = 4
 							end
 							device pnp  2e.3 off     # Com2
 								io 0x60 = 0x2f8
 								irq 0x70 = 3
 							end
 							device pnp  2e.5 on      # Keyboard
 								 io 0x60 = 0x60
 								 io 0x62 = 0x64
 							       irq 0x70 = 1
 								irq 0x72 = 12
 							end
 							device pnp  2e.6 off end # CIR
 							device pnp  2e.7 off end # GAME_MIDI_GIPO1
 							device pnp  2e.8 off end # GPIO2
 							device pnp  2e.9 off end # GPIO3
 							device pnp  2e.a off end # ACPI
 							device pnp  2e.b on      # HW Monitor
 								 io 0x60 = 0x290
 							end
 							register "com1" = "{1}"
 						#	register "com1" = "{1, 0, 0x3f8, 4}"
 						#	register "lpt" = "{1}"
 						end
 					end
 					device pci 1.1 on end
 					device pci 1.2 on end
 					device pci 1.3 on end
 					device pci 1.5 off end
 					device pci 1.6 off end
 				end
 			end # LDT0
 			device pci 18.0 on end # LDT1
 			device pci 18.0 on end # LDT2
 			device pci 18.1 on end
 			device pci 18.2 on end
 			device pci 18.3 on end
 		end
 		chip northbridge/amd/amdk8
 			device pci 19.0 on end
 			device pci 19.0 on end
 			device pci 19.0 on end
 			device pci 19.1 on end
 			device pci 19.2 on end
 			device pci 19.3 on end
 		end
 	end
 	device apic_cluster 0 on
 		chip cpu/amd/socket_940
 			device apic 0 on end
 		end
 		chip cpu/amd/socket_940
 			device apic 1 on end
 		end
 	end
 end
 
diff --git a/src/mainboard/iwill/dk8x/Config.lb b/src/mainboard/iwill/dk8x/Config.lb
index c0cc7eb..bc1c73d 100644
--- a/src/mainboard/iwill/dk8x/Config.lb
+++ b/src/mainboard/iwill/dk8x/Config.lb
@@ -1,258 +1,258 @@
 ##
 ## Compute the location and size of where this firmware image
 ## (coreboot plus bootloader) will live in the boot rom chip.
 ##
 if USE_FALLBACK_IMAGE
 	default ROM_SECTION_SIZE   = FALLBACK_SIZE
 	default ROM_SECTION_OFFSET = ( ROM_SIZE - FALLBACK_SIZE )
 else
 	default ROM_SECTION_SIZE   = ( ROM_SIZE - FALLBACK_SIZE )
 	default ROM_SECTION_OFFSET = 0
 end
 
 ##
 ## Compute the start location and size size of
 ## The coreboot bootloader.
 ##
 default PAYLOAD_SIZE            = ( ROM_SECTION_SIZE - ROM_IMAGE_SIZE )
 default CONFIG_ROM_PAYLOAD_START = (0xffffffff - ROM_SIZE + ROM_SECTION_OFFSET + 1)
 
 ##
 ## Compute where this copy of coreboot will start in the boot rom
 ##
 default _ROMBASE      = ( CONFIG_ROM_PAYLOAD_START + PAYLOAD_SIZE )
 
 ##
 ## Compute a range of ROM that can cached to speed up coreboot,
 ## execution speed.
 ##
 ## XIP_ROM_SIZE must be a power of 2.
 ## XIP_ROM_BASE must be a multiple of XIP_ROM_SIZE
 ##
 default XIP_ROM_SIZE=65536
 default XIP_ROM_BASE = ( _ROMBASE + ROM_IMAGE_SIZE - XIP_ROM_SIZE )
 
 ##
 ## Set all of the defaults for an x86 architecture
 ##
 
 arch i386 end
 
 ##
 ## Build the objects we have code for in this directory.
 ##
 
 driver mainboard.o
 if HAVE_MP_TABLE object mptable.o end
 if HAVE_PIRQ_TABLE object irq_tables.o end
 #object reset.o
 
 if USE_DCACHE_RAM
 
 if CONFIG_USE_INIT
 
 makerule ./auto.o
         depends "$(MAINBOARD)/cache_as_ram_auto.c option_table.h"
         action "$(CC) $(DISTRO_CFLAGS) -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/cache_as_ram_auto.c -Os -nostdinc -nostdlib -fno-builtin -Wall -c -o auto.o" 
 end
 
 else    
                 
 makerule ./auto.inc
         depends "$(MAINBOARD)/cache_as_ram_auto.c option_table.h"
         action "$(CC) $(DISTRO_CFLAGS) -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/cache_as_ram_auto.c -Os -nostdinc -nostdlib -fno-builtin -Wall -c -S -o $@"         
         action "perl -e 's/.rodata/.rom.data/g' -pi $@"
         action "perl -e 's/.text/.section .rom.text/g' -pi $@"
 end
 
 end
 else
 ##
 ## Romcc output
 ##
 makerule ./failover.E
-	depends "$(MAINBOARD)/failover.c ./romcc" 
-	action "./romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+	depends "$(MAINBOARD)/failover.c ../romcc" 
+	action "../romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 end
 
 makerule ./failover.inc
-	depends "$(MAINBOARD)/failover.c ./romcc"
-	action "./romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+	depends "$(MAINBOARD)/failover.c ../romcc"
+	action "../romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 end
 
 makerule ./auto.E 
-	depends	"$(MAINBOARD)/auto.c option_table.h ./romcc" 
-	action	"./romcc -E -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	depends	"$(MAINBOARD)/auto.c option_table.h ../romcc" 
+	action	"../romcc -E -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 makerule ./auto.inc 
-	depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-	action	"./romcc    -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+	action	"../romcc    -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 
 end
 
 ##
 ## Build our 16 bit and 32 bit coreboot entry code
 ##
 if USE_FALLBACK_IMAGE
         mainboardinit cpu/x86/16bit/entry16.inc
         ldscript /cpu/x86/16bit/entry16.lds
 end
 
 mainboardinit cpu/x86/32bit/entry32.inc
 
 if USE_DCACHE_RAM
         if CONFIG_USE_INIT
                 ldscript /cpu/x86/32bit/entry32.lds
         end
 
         if CONFIG_USE_INIT
                 ldscript      /cpu/amd/car/cache_as_ram.lds
         end
 end
 
 ##
 ## Build our reset vector (This is where coreboot is entered)
 ##
 if USE_FALLBACK_IMAGE 
 	mainboardinit cpu/x86/16bit/reset16.inc 
 	ldscript /cpu/x86/16bit/reset16.lds 
 else
 	mainboardinit cpu/x86/32bit/reset32.inc 
 	ldscript /cpu/x86/32bit/reset32.lds 
 end
 
 if USE_DCACHE_RAM
 else
 ### Should this be in the northbridge code?
 mainboardinit arch/i386/lib/cpu_reset.inc
 end
 
 ##
 ## Include an id string (For safe flashing)
 ##
 mainboardinit arch/i386/lib/id.inc
 ldscript /arch/i386/lib/id.lds
 
 if USE_DCACHE_RAM
 ##
 ## Setup Cache-As-Ram
 ##
 mainboardinit cpu/amd/car/cache_as_ram.inc
 end
 
 ###
 ### This is the early phase of coreboot startup 
 ### Things are delicate and we test to see if we should
 ### failover to another image.
 ###
 if USE_FALLBACK_IMAGE
 if USE_DCACHE_RAM
        ldscript /arch/i386/lib/failover.lds
 else
        ldscript /arch/i386/lib/failover.lds
         mainboardinit ./failover.inc
 end
 end
 
 ###
 ### O.k. We aren't just an intermediary anymore!
 ###
 
 ##
 ## Setup RAM
 ##
 if USE_DCACHE_RAM
 
 if CONFIG_USE_INIT
 initobject auto.o
 else
 mainboardinit ./auto.inc
 end
 
 else
 
 ##
 ## Setup RAM
 ##
 mainboardinit cpu/x86/fpu/enable_fpu.inc
 mainboardinit cpu/x86/mmx/enable_mmx.inc
 mainboardinit cpu/x86/sse/enable_sse.inc
 mainboardinit ./auto.inc
 mainboardinit cpu/x86/sse/disable_sse.inc
 mainboardinit cpu/x86/mmx/disable_mmx.inc
 end
 
 ##
 ## Include the secondary Configuration files 
 ##
 config chip.h
 
 chip northbridge/amd/amdk8/root_complex
 	device pci_domain 0 on
 		chip northbridge/amd/amdk8
 			device pci 18.0 on #  northbridge 
 				#  devices on link 0, link 0 == LDT 0 
 				chip southbridge/amd/amd8131
 					# the on/off keyword is mandatory
 					device pci 0.0 on end
 					device pci 0.1 on end
 					device pci 1.0 on end
 					device pci 1.1 on end
 				end
 				chip southbridge/amd/amd8111
 					# this "device pci 0.0" is the parent the next one
 					# PCI bridge
 					device pci 0.0 on
 						device pci 0.0 on end
 						device pci 0.1 on end
 						device pci 0.2 on end
 						device pci 1.0 off end
 					end
 					device pci 1.0 on
 						chip superio/winbond/w83627thf
 							device pnp 2e.0 on end
 							device pnp 2e.1 on end
 							device pnp 2e.2 on end
 							device pnp 2e.3 on end
 							device pnp 2e.4 on end
 							device pnp 2e.5 on end
 							device pnp 2e.6 on end
 							device pnp 2e.7 on end 
 							device pnp 2e.8 on end 
 							device pnp 2e.9 on end 
 							device pnp 2e.a on end 
 						end
 					end
 					device pci 1.1 on end
 					device pci 1.2 on end
 					device pci 1.3 on end 
 					device pci 1.5 off end
 					device pci 1.6 off end
 				end
 			end # LDT0
 			device pci 18.0 on end # LDT1
 			device pci 18.0 on end # LDT2
 			device pci 18.1 on end
 			device pci 18.2 on end
 			device pci 18.3 on end
 		end
 		chip northbridge/amd/amdk8
 			device pci 19.0 on end
 			device pci 19.0 on end
 			device pci 19.0 on end
 			device pci 19.1 on end
 			device pci 19.2 on end
 			device pci 19.3 on end
 		end
 	end 
 	device apic_cluster 0 on
 		chip cpu/amd/socket_940
 			device apic 0 on end
 		end
 		chip cpu/amd/socket_940
 			device apic 1 on end
 		end
 	end
 end
 
diff --git a/src/mainboard/lippert/frontrunner/Config.lb b/src/mainboard/lippert/frontrunner/Config.lb
index fc1f601..6ef7bb4 100644
--- a/src/mainboard/lippert/frontrunner/Config.lb
+++ b/src/mainboard/lippert/frontrunner/Config.lb
@@ -1,143 +1,143 @@
 ##
 ## Compute the location and size of where this firmware image
 ## (coreboot plus bootloader) will live in the boot rom chip.
 ##
 if USE_FALLBACK_IMAGE
 	default ROM_SECTION_SIZE   = FALLBACK_SIZE
 	default ROM_SECTION_OFFSET = ( ROM_SIZE - FALLBACK_SIZE )
 else
 	default ROM_SECTION_SIZE   = ( ROM_SIZE - FALLBACK_SIZE )
 	default ROM_SECTION_OFFSET = 0
 end
 
 ##
 ## Compute the start location and size size of
 ## The coreboot bootloader.
 ##
 default CONFIG_ROM_PAYLOAD_START = (0xffffffff - ROM_SIZE + ROM_SECTION_OFFSET + 1)
 default PAYLOAD_SIZE            = ( ROM_SECTION_SIZE - ROM_IMAGE_SIZE )
 
 ##
 ## Compute where this copy of coreboot will start in the boot rom
 ##
 default _ROMBASE      = ( CONFIG_ROM_PAYLOAD_START + PAYLOAD_SIZE )
 
 ##
 ## Compute a range of ROM that can cached to speed up coreboot,
 ## execution speed.
 ##
 ## XIP_ROM_SIZE must be a power of 2.
 ## XIP_ROM_BASE must be a multiple of XIP_ROM_SIZE
 ##
 default XIP_ROM_SIZE=65536
 default XIP_ROM_BASE = ( _ROMBASE + ROM_IMAGE_SIZE - XIP_ROM_SIZE )
 
 ##
 ## Set all of the defaults for an x86 architecture
 ##
 
 arch i386 end
 
 ##
 ## Build the objects we have code for in this directory.
 ##
 
 driver mainboard.o
 
 if HAVE_PIRQ_TABLE object irq_tables.o end
 #object reset.o
 
 ##
 ## Romcc output
 ##
 makerule ./failover.E
-	depends "$(MAINBOARD)/failover.c ./romcc" 
-	action "./romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+	depends "$(MAINBOARD)/failover.c ../romcc" 
+	action "../romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 end
 
 makerule ./failover.inc
-	depends "$(MAINBOARD)/failover.c ./romcc"
-	action "./romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+	depends "$(MAINBOARD)/failover.c ../romcc"
+	action "../romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 end
 
 makerule ./auto.E 
-	depends	"$(MAINBOARD)/auto.c option_table.h ./romcc" 
-	action	"./romcc -E -mcpu=i386 -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	depends	"$(MAINBOARD)/auto.c option_table.h ../romcc" 
+	action	"../romcc -E -mcpu=i386 -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 makerule ./auto.inc 
-	depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-	action	"./romcc    -mcpu=i386 -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+	action	"../romcc    -mcpu=i386 -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 
 ##
 ## Build our 16 bit and 32 bit coreboot entry code
 ##
 mainboardinit cpu/x86/16bit/entry16.inc
 mainboardinit cpu/x86/32bit/entry32.inc
 ldscript /cpu/x86/16bit/entry16.lds
 ldscript /cpu/x86/32bit/entry32.lds
 
 ##
 ## Build our reset vector (This is where coreboot is entered)
 ##
 if USE_FALLBACK_IMAGE 
 	mainboardinit cpu/x86/16bit/reset16.inc 
 	ldscript /cpu/x86/16bit/reset16.lds 
 else
 	mainboardinit cpu/x86/32bit/reset32.inc 
 	ldscript /cpu/x86/32bit/reset32.lds 
 end
 
 ### Should this be in the northbridge code?
 mainboardinit arch/i386/lib/cpu_reset.inc
 
 ##
 ## Include an id string (For safe flashing)
 ##
 mainboardinit arch/i386/lib/id.inc
 ldscript /arch/i386/lib/id.lds
 
 ###
 ### This is the early phase of coreboot startup 
 ### Things are delicate and we test to see if we should
 ### failover to another image.
 ###
 if USE_FALLBACK_IMAGE
 	ldscript /arch/i386/lib/failover.lds 
 	mainboardinit ./failover.inc
 end
 
 ###
 ### O.k. We aren't just an intermediary anymore!
 ###
 
 ##
 ## Setup RAM
 ##
 mainboardinit cpu/x86/fpu/enable_fpu.inc
 mainboardinit ./auto.inc
 
 ##
 ## Include the secondary Configuration files 
 ##
 dir /pc80
 config chip.h
 
 chip northbridge/amd/gx2
   device pci_domain 0 on 
     device pci 0.0 on end
       chip southbridge/amd/cs5535
         device pci 12.0 on
         device pci 12.1 off end		# SMI
         device pci 12.2 on  end		# IDE
         device pci 12.3 off end 	# Audio
         device pci 12.4 off end		# VGA
       end
     end
   end
 
   chip cpu/amd/model_gx2
   end
 
 end
 
diff --git a/src/mainboard/msi/ms6119/Config.lb b/src/mainboard/msi/ms6119/Config.lb
index 04fdc8d..635c9ac 100644
--- a/src/mainboard/msi/ms6119/Config.lb
+++ b/src/mainboard/msi/ms6119/Config.lb
@@ -1,142 +1,142 @@
 ##
 ## This file is part of the coreboot project.
 ##
 ## Copyright (C) 2008 Uwe Hermann <uwe@hermann-uwe.de>
 ##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2 of the License, or
 ## (at your option) any later version.
 ##
 ## This program is distributed in the hope that it will be useful,
 ## but WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ## GNU General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this program; if not, write to the Free Software
 ## Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 ##
 
 if USE_FALLBACK_IMAGE
 	default ROM_SECTION_SIZE = FALLBACK_SIZE
 	default ROM_SECTION_OFFSET = (ROM_SIZE - FALLBACK_SIZE)
 else
 	default ROM_SECTION_SIZE = (ROM_SIZE - FALLBACK_SIZE)
 	default ROM_SECTION_OFFSET = 0
 end
 default CONFIG_ROM_PAYLOAD_START = (0xffffffff - ROM_SIZE
 				    + ROM_SECTION_OFFSET + 1)
 default PAYLOAD_SIZE = (ROM_SECTION_SIZE - ROM_IMAGE_SIZE)
 default _ROMBASE = (CONFIG_ROM_PAYLOAD_START + PAYLOAD_SIZE)
 default XIP_ROM_SIZE = 64 * 1024
 default XIP_ROM_BASE = (_ROMBASE + ROM_IMAGE_SIZE - XIP_ROM_SIZE)
 arch i386 end
 driver mainboard.o
 if HAVE_PIRQ_TABLE
 	object irq_tables.o
 end
 makerule ./failover.E
-	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ./romcc"
-	action "./romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
+	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ../romcc"
+	action "../romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
 end
 makerule ./failover.inc
-	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ./romcc"
-	action "./romcc -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
+	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ../romcc"
+	action "../romcc -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
 end
 makerule ./auto.E
-	# depends	"$(MAINBOARD)/auto.c option_table.h ./romcc"
-	depends	"$(MAINBOARD)/auto.c ./romcc"
-	action	"./romcc -E -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	# depends	"$(MAINBOARD)/auto.c option_table.h ../romcc"
+	depends	"$(MAINBOARD)/auto.c ../romcc"
+	action	"../romcc -E -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 makerule ./auto.inc
-	# depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-	depends "$(MAINBOARD)/auto.c ./romcc"
-	action	"./romcc -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	# depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+	depends "$(MAINBOARD)/auto.c ../romcc"
+	action	"../romcc -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 mainboardinit cpu/x86/16bit/entry16.inc
 mainboardinit cpu/x86/32bit/entry32.inc
 ldscript /cpu/x86/16bit/entry16.lds
 ldscript /cpu/x86/32bit/entry32.lds
 if USE_FALLBACK_IMAGE
 	mainboardinit cpu/x86/16bit/reset16.inc
 	ldscript /cpu/x86/16bit/reset16.lds
 else
 	mainboardinit cpu/x86/32bit/reset32.inc
 	ldscript /cpu/x86/32bit/reset32.lds
 end
 mainboardinit arch/i386/lib/cpu_reset.inc
 mainboardinit arch/i386/lib/id.inc
 ldscript /arch/i386/lib/id.lds
 if USE_FALLBACK_IMAGE
 	ldscript /arch/i386/lib/failover.lds
 	mainboardinit ./failover.inc
 end
 mainboardinit cpu/x86/fpu/enable_fpu.inc
 mainboardinit cpu/x86/mmx/enable_mmx.inc
 mainboardinit ./auto.inc
 mainboardinit cpu/x86/mmx/disable_mmx.inc
 
 dir /pc80
 config chip.h
 
 chip northbridge/intel/i440bx		# Northbridge
   device apic_cluster 0 on		# APIC cluster
     chip cpu/intel/slot_2		# CPU (FIXME: It's slot 1, actually)
       device apic 0 on end		# APIC
     end
   end
   device pci_domain 0 on		# PCI domain
     device pci 0.0 on end		# Host bridge
     device pci 1.0 on end		# PCI/AGP bridge
     chip southbridge/intel/i82371eb	# Southbridge
       device pci 7.0 on			# ISA bridge
         chip superio/winbond/w83977tf	# Super I/O
           device pnp 3f0.0 on		# Floppy
             io 0x60 = 0x3f0
             irq 0x70 = 6
             drq 0x74 = 2
           end
           device pnp 3f0.1 on		# Parallel port
             io 0x60 = 0x378
             irq 0x70 = 7
             drq 0x74 = 3
           end
           device pnp 3f0.2 on		# COM1
             io 0x60 = 0x3f8
             irq 0x70 = 4
           end
           device pnp 3f0.3 on		# COM2 / IR
             io 0x60 = 0x2f8
             irq 0x70 = 3
           end
           device pnp 3f0.5 on		# PS/2 keyboard
             io 0x60 = 0x60
             io 0x62 = 0x64
             irq 0x70 = 1		# PS/2 keyboard interrupt
             irq 0x72 = 12		# PS/2 mouse interrupt
           end
           device pnp 3f0.7 on		# GPIO 1
           end
           device pnp 3f0.8 on		# GPIO 2
           end
           device pnp 3f0.9 on		# GPIO 3
           end
           device pnp 3f0.a on		# ACPI
           end
         end
       end
       device pci 7.1 on	end		# IDE
       device pci 7.2 on	end		# USB
       device pci 7.3 on end		# ACPI
       register "ide0_enable" = "1"
       register "ide1_enable" = "1"
       register "ide_legacy_enable" = "1"
       # Enable UDMA/33 for higher speed if your IDE device(s) support it.
       register "ide0_drive0_udma33_enable" = "0"
       register "ide0_drive1_udma33_enable" = "0"
       register "ide1_drive0_udma33_enable" = "0"
       register "ide1_drive1_udma33_enable" = "0"
     end
   end
 end
diff --git a/src/mainboard/msi/ms6178/Config.lb b/src/mainboard/msi/ms6178/Config.lb
index 8576e85..ec9509b 100644
--- a/src/mainboard/msi/ms6178/Config.lb
+++ b/src/mainboard/msi/ms6178/Config.lb
@@ -1,145 +1,145 @@
 ##
 ## This file is part of the coreboot project.
 ##
 ## Copyright (C) 2007 Uwe Hermann <uwe@hermann-uwe.de>
 ##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2 of the License, or
 ## (at your option) any later version.
 ##
 ## This program is distributed in the hope that it will be useful,
 ## but WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ## GNU General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this program; if not, write to the Free Software
 ## Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 ##
 
 if USE_FALLBACK_IMAGE
 	default ROM_SECTION_SIZE   = FALLBACK_SIZE
 	default ROM_SECTION_OFFSET = (ROM_SIZE - FALLBACK_SIZE)
 else
 	default ROM_SECTION_SIZE   = (ROM_SIZE - FALLBACK_SIZE)
 	default ROM_SECTION_OFFSET = 0
 end
 default CONFIG_ROM_PAYLOAD_START = (0xffffffff - ROM_SIZE + ROM_SECTION_OFFSET + 1)
 default PAYLOAD_SIZE = (ROM_SECTION_SIZE - ROM_IMAGE_SIZE)
 default _ROMBASE = (CONFIG_ROM_PAYLOAD_START + PAYLOAD_SIZE)
 default XIP_ROM_SIZE = 64 * 1024
 default XIP_ROM_BASE = (_ROMBASE + ROM_IMAGE_SIZE - XIP_ROM_SIZE)
 arch i386 end
 driver mainboard.o
 if HAVE_PIRQ_TABLE object irq_tables.o end
 # object reset.o
 makerule ./failover.E
-	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ./romcc"
-	action "./romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
+	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ../romcc"
+	action "../romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
 end
 makerule ./failover.inc
-	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ./romcc"
-	action "./romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
+	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ../romcc"
+	action "../romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
 end
 makerule ./auto.E
-	# depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-	depends	"$(MAINBOARD)/auto.c ./romcc"
-	action	"./romcc -E -mcpu=p2 -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	# depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+	depends	"$(MAINBOARD)/auto.c ../romcc"
+	action	"../romcc -E -mcpu=p2 -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 makerule ./auto.inc
-	# depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-	depends "$(MAINBOARD)/auto.c ./romcc"
-	action	"./romcc    -mcpu=p2 -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	# depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+	depends "$(MAINBOARD)/auto.c ../romcc"
+	action	"../romcc    -mcpu=p2 -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 mainboardinit cpu/x86/16bit/entry16.inc
 mainboardinit cpu/x86/32bit/entry32.inc
 ldscript /cpu/x86/16bit/entry16.lds
 ldscript /cpu/x86/32bit/entry32.lds
 if USE_FALLBACK_IMAGE
 	mainboardinit cpu/x86/16bit/reset16.inc
 	ldscript /cpu/x86/16bit/reset16.lds
 else
 	mainboardinit cpu/x86/32bit/reset32.inc
 	ldscript /cpu/x86/32bit/reset32.lds
 end
 mainboardinit arch/i386/lib/cpu_reset.inc
 mainboardinit arch/i386/lib/id.inc
 ldscript /arch/i386/lib/id.lds
 if USE_FALLBACK_IMAGE
 	ldscript /arch/i386/lib/failover.lds
 	mainboardinit ./failover.inc
 end
 mainboardinit cpu/x86/fpu/enable_fpu.inc
 mainboardinit cpu/x86/mmx/enable_mmx.inc
 mainboardinit ./auto.inc
 mainboardinit cpu/x86/mmx/disable_mmx.inc
 dir /pc80
 config chip.h
 
 chip northbridge/intel/i82810			# Northbridge
   device apic_cluster 0 on			# APIC cluster
     chip cpu/intel/socket_PGA370		# CPU
       device apic 0 on end			# APIC
     end
   end
   device pci_domain 0 on
     device pci 0.0 on end			# Host bridge
     device pci 1.0 off				# Onboard video
       # chip drivers/pci/onboard
       #   device pci 1.0 on end
       #   register "rom_address" = "0xfff80000"
       # end
     end
     chip southbridge/intel/i82801xx		# Southbridge
       device pci 1e.0 on end			# PCI bridge
       device pci 1f.0 on			# ISA/LPC bridge
         chip superio/winbond/w83627hf		# Super I/O
           device pnp 2e.0 on			# Floppy
             io 0x60 = 0x3f0
             irq 0x70 = 6
             drq 0x74 = 2
           end
           device pnp 2e.1 on			# Parallel port
             io 0x60 = 0x378
             irq 0x70 = 7
             drq 0x74 = 3
           end
           device pnp 2e.2 on			# Com1
             io 0x60 = 0x3f8
             irq 0x70 = 4
           end
           device pnp 2e.3 on			# Com2 (only header on board)
             io 0x60 = 0x2f8
             irq 0x70 = 3
           end
           device pnp 2e.5 on			# PS/2 keyboard/mouse
             io 0x60 = 0x60
             io 0x62 = 0x64
             irq 0x70 = 1			# Keyboard interrupt
             irq 0x72 = 12			# Mouse interrupt
           end
           device pnp 2e.6 on end		# Consumer IR (TODO)
           device pnp 2e.7 on			# Game port / MIDI / GPIO 1
             io 0x60 = 0x201
             io 0x62 = 0x330
             irq 0x70 = 9
           end
           device pnp 2e.8 on end		# GPIO 2
           device pnp 2e.9 on end		# GPIO 3
           device pnp 2e.a on end		# ACPI
           device pnp 2e.b on			# Hardware monitor
             io 0x60 = 0x290
             irq 0x70 = 5
           end
         end
       end
       device pci 1f.1 on end			# IDE
       device pci 1f.2 on end			# USB
       device pci 1f.3 on end			# SMBus
       device pci 1f.5 on end			# AC'97 audio
       device pci 1f.6 on end			# AC'97 modem
     end
   end
 end
 
diff --git a/src/mainboard/msi/ms9282/Config.lb b/src/mainboard/msi/ms9282/Config.lb
index e8cb678..b8e330c 100644
--- a/src/mainboard/msi/ms9282/Config.lb
+++ b/src/mainboard/msi/ms9282/Config.lb
@@ -1,418 +1,418 @@
 ##
 ## This file is part of the coreboot project.
 ##
 ## Copyright (C) 2006 AMD
 ## Written by Yinghai Lu <yinghailu@gmail.com> for AMD.
 ##
 ## Copyright (C) 2006 MSI
 ## Written by Bingxun Shi <bingxunshi@gmail.com> for MSI.
 ##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2 of the License, or
 ## (at your option) any later version.
 ##
 ## This program is distributed in the hope that it will be useful,
 ## but WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ## GNU General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this program; if not, write to the Free Software
 ## Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 ##
 
 ##
 ## Compute the location and size of where this firmware image
 ## (coreboot plus bootloader) will live in the boot rom chip.
 ##
 if USE_FALLBACK_IMAGE
        default ROM_SECTION_SIZE   = FALLBACK_SIZE
        default ROM_SECTION_OFFSET = ( ROM_SIZE - FALLBACK_SIZE )
 else
        default ROM_SECTION_SIZE   = ( ROM_SIZE - FALLBACK_SIZE )
        default ROM_SECTION_OFFSET = 0
 end
 
 ##
 ## Compute the start location and size size of
 ## The coreboot bootloader.
 ##
 default PAYLOAD_SIZE            = ( ROM_SECTION_SIZE - ROM_IMAGE_SIZE )
 default CONFIG_ROM_PAYLOAD_START = (0xffffffff - ROM_SIZE + ROM_SECTION_OFFSET + 1)
 default CONFIG_ROM_PAYLOAD     = 1
 
 ##
 ## Compute where this copy of coreboot will start in the boot rom
 ##
 default _ROMBASE      = ( CONFIG_ROM_PAYLOAD_START + PAYLOAD_SIZE )
 
 ##
 ## Compute a range of ROM that can cached to speed up coreboot,
 ## execution speed.
 ##
 ## XIP_ROM_SIZE must be a power of 2.
 ## XIP_ROM_BASE must be a multiple of XIP_ROM_SIZE
 ##
 default XIP_ROM_SIZE=65536
 default XIP_ROM_BASE = ( _ROMBASE + ROM_IMAGE_SIZE - XIP_ROM_SIZE )
 
 arch i386 end
 
 
 ##
 ## Build the objects we have code for in this directory.
 ##
 
 driver mainboard.o
 
 #dir /drivers/ati/ragexl
 #needed by irq_tables and mptable and acpi_tables
 object get_bus_conf.o
 
 
 if HAVE_MP_TABLE object mptable.o end
 if HAVE_PIRQ_TABLE object irq_tables.o end
 #object reset.o
 
 if USE_DCACHE_RAM
 
 if CONFIG_USE_INIT
 
 makerule ./auto.o
         depends "$(MAINBOARD)/cache_as_ram_auto.c option_table.h"
         action "$(CC) $(DISTRO_CFLAGS) -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/cache_as_ram_auto.c -Os -nostdinc -nostdlib -fno-builtin -Wall -c -o auto.o"
 end
 
 else
 
 makerule ./auto.inc
         depends "$(MAINBOARD)/cache_as_ram_auto.c option_table.h"
         action "$(CC) $(DISTRO_CFLAGS) -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/cache_as_ram_auto.c -Os -nostdinc -nostdlib -fno-builtin -Wall -c -S -o $@"
        action "perl -e 's/.rodata/.rom.data/g' -pi $@"
        action "perl -e 's/.text/.section .rom.text/g' -pi $@"
 end
 
 end
 else
 
 ##
 ## Romcc output
 ##
 makerule ./failover.E
-        depends "$(MAINBOARD)/failover.c ./romcc"
-        action "./romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+        depends "$(MAINBOARD)/failover.c ../romcc"
+        action "../romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 end
 
 makerule ./failover.inc
-        depends "$(MAINBOARD)/failover.c ./romcc"
-        action "./romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+        depends "$(MAINBOARD)/failover.c ../romcc"
+        action "../romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 end
 
 makerule ./auto.E
-        depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-        action  "./romcc -E -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+        depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+        action  "../romcc -E -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 makerule ./auto.inc
-        depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-        action  "./romcc    -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+        depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+        action  "../romcc    -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 
 
 end
 
 ##
 ## Build our 16 bit and 32 bit coreboot entry code
 ##
 if USE_FALLBACK_IMAGE
         mainboardinit cpu/x86/16bit/entry16.inc
         ldscript /cpu/x86/16bit/entry16.lds
 end
 
 mainboardinit cpu/x86/32bit/entry32.inc
 
 if USE_DCACHE_RAM
        if CONFIG_USE_INIT
                ldscript /cpu/x86/32bit/entry32.lds
        end
 
        if CONFIG_USE_INIT
                ldscript      /cpu/amd/car/cache_as_ram.lds
        end
 end
 
 ##
 ## Build our reset vector (This is where coreboot is entered)
 ##
 if USE_FALLBACK_IMAGE
        mainboardinit cpu/x86/16bit/reset16.inc
        ldscript /cpu/x86/16bit/reset16.lds
 else
        mainboardinit cpu/x86/32bit/reset32.inc
        ldscript /cpu/x86/32bit/reset32.lds
 end
 
 if USE_DCACHE_RAM
 else
 ### Should this be in the northbridge code?
 mainboardinit arch/i386/lib/cpu_reset.inc
 end
 
 ##
 ## Include an id string (For safe flashing)
 ##
 mainboardinit southbridge/nvidia/mcp55/id.inc
 ldscript /southbridge/nvidia/mcp55/id.lds
 
 ##
 ## ROMSTRAP table for MCP55
 ##
 if USE_FALLBACK_IMAGE
        mainboardinit southbridge/nvidia/mcp55/romstrap.inc
        ldscript /southbridge/nvidia/mcp55/romstrap.lds
 end
 
 if USE_DCACHE_RAM
 ##
 ## Setup Cache-As-Ram
 ##
 mainboardinit cpu/amd/car/cache_as_ram.inc
 end
 
 ###
 ### This is the early phase of coreboot startup
 ### Things are delicate and we test to see if we should
 ### failover to another image.
 ###
 if USE_FALLBACK_IMAGE
 if USE_DCACHE_RAM
        ldscript /arch/i386/lib/failover.lds
 else
        ldscript /arch/i386/lib/failover.lds
        mainboardinit ./failover.inc
 end
 end
 
 ###
 ### O.k. We aren't just an intermediary anymore!
 ###
 
 ##
 ## Setup RAM
 ##
 if USE_DCACHE_RAM
 
 if CONFIG_USE_INIT
 initobject auto.o
 else
 mainboardinit ./auto.inc
 end
 
 else
 # ROMCC
 mainboardinit cpu/x86/fpu/enable_fpu.inc
 mainboardinit cpu/x86/mmx/enable_mmx.inc
 mainboardinit cpu/x86/sse/enable_sse.inc
 mainboardinit ./auto.inc
 mainboardinit cpu/x86/sse/disable_sse.inc
 mainboardinit cpu/x86/mmx/disable_mmx.inc
 
 end
 
 ##
 ## Include the secondary Configuration files
 ##
 if CONFIG_CHIP_NAME
         config chip.h
 end
 
 
 # sample config for msi/ms9282
 chip northbridge/amd/amdk8/root_complex
         device apic_cluster 0 on
                 chip cpu/amd/socket_F
                         device apic 0 on end
                 end
         end
 
        device pci_domain 0 on
                chip northbridge/amd/amdk8 #mc0
                        device pci 18.0 on #  northbridge
                                #  devices on link 0, link 0 == LDT 0
                                chip southbridge/nvidia/mcp55
                                        device pci 0.0 on end   # HT
                                        device pci 1.0 on # LPC
                                                chip superio/winbond/w83627ehg
                                                        device pnp 2e.0 on #  Floppy
                                                                io 0x60 = 0x3f0
                                                                irq 0x70 = 6
                                                                drq 0x74 = 2
                                                        end
                                                        device pnp 2e.1 off #  Parallel Port
                                                                io 0x60 = 0x378
                                                                irq 0x70 = 7
                                                        end
                                                        device pnp 2e.2 on #  Com1
                                                                io 0x60 = 0x3f8
                                                                irq 0x70 = 4
                                                        end
                                                        device pnp 2e.3 off #  Com2
                                                                io 0x60 = 0x2f8
                                                                irq 0x70 = 3
                                                        end
                                                        device pnp 2e.5 on #  Keyboard
                                                                io 0x60 = 0x60
                                                                io 0x62 = 0x64
                                                                irq 0x70 = 1
                                                                irq 0x72 = 12
                                                        end
                                                        device pnp 2e.6 off #  SERIAL_FALSH
                                                                io 0x60 = 0x100
                                                        end
                                                        device pnp 2e.7 off #  GAME_MIDI_GIPO1
                                                                io 0x60 = 0x220
                                                                io 0x62 = 0x300
                                                                irq 0x70 = 9
                                                        end
                                                        device pnp 2e.8 off end #  WDTO_PLED
                                                        device pnp 2e.9 off end #  GPIO2_GPIO3_GPIO4_GPIO5
                                                        device pnp 2e.a off end #  ACPI
                                                        device pnp 2e.b on #  HW Monitor
                                                                io 0x60 = 0x290
                                                                irq 0x70 = 5
                                                        end
                                                end
                                        end
                                         device pci 1.1 on # SM 0
                                                chip drivers/i2c/i2cmux2 # pca9554 smbus mux
                                                        device i2c 70 on  #0 pca9554 1
                                                                chip drivers/generic/generic #dimm 0-0-0
                                                                         device i2c 50 on end
                                                                 end
                                                                 chip drivers/generic/generic #dimm 0-0-1
                                                                         device i2c 51 on end
                                                                 end
                                                                 chip drivers/generic/generic #dimm 0-1-0
                                                                         device i2c 52 on end
                                                                 end
                                                                 chip drivers/generic/generic #dimm 0-1-1
                                                                         device i2c 53 on end
                                                                 end
                                                                chip drivers/generic/generic #dimm 0-0-0
                                                                         device i2c 54 on end
                                                                 end
                                                                 chip drivers/generic/generic #dimm 0-0-1
                                                                         device i2c 55 on end
                                                                 end
                                                                 chip drivers/generic/generic #dimm 0-1-0
                                                                         device i2c 56 on end
                                                                 end
                                                                 chip drivers/generic/generic #dimm 0-1-1
                                                                         device i2c 57 on end
                                                                 end
                                                        end
                                                        device i2c 70 on  #0 pca9554 2
                                                                chip drivers/generic/generic #dimm 0-0-0
                                                                         device i2c 50 on end
                                                                 end
                                                                 chip drivers/generic/generic #dimm 0-0-1
                                                                         device i2c 51 on end
                                                                 end
                                                                 chip drivers/generic/generic #dimm 0-1-0
                                                                         device i2c 52 on end
                                                                 end
                                                                 chip drivers/generic/generic #dimm 0-1-1
                                                                         device i2c 53 on end
                                                                 end
                                                                chip drivers/generic/generic #dimm 0-0-0
                                                                         device i2c 54 on end
                                                                 end
                                                                 chip drivers/generic/generic #dimm 0-0-1
                                                                         device i2c 55 on end
                                                                 end
                                                                 chip drivers/generic/generic #dimm 0-1-0
                                                                         device i2c 56 on end
                                                                 end
                                                                 chip drivers/generic/generic #dimm 0-1-1
                                                                         device i2c 57 on end
                                                                 end
                                                        end
                                                end
                                        end
                                        device pci 1.1 on # SM 1
                                                chip drivers/i2c/i2cmux2 # pca9554 smbus mux
                                                        device i2c 72 on     #pca9554 channle1
                                                                chip drivers/i2c/adm1027   #HWM ADT7476 1
                                                                        device i2c 2e on end
                                                                end
                                                        end
                                                        device i2c 72 on     #pca9545 channel 2
                                                                chip drivers/i2c/adm1027   #HWM ADT7463
                                                                        device i2c 2e on end
                                                                end
                                                        end
                                                        device i2c 72 on end  #pca9545 channel 3
                                                        device i2c 72 on      #pca9545 channel 4
                                                                chip drivers/i2c/adm1027   #HWM ADT7476 2
                                                                        device i2c 2e on end
                                                                end
                                                        end
                                                end
                                        end
 
                                        device pci 2.0 on end # USB 1.1
                                        device pci 2.1 on end # USB 2
                                        device pci 4.0 on  end # IDE
                                                device pci 5.0 on  end # SATA 0
                                        device pci 5.1 on  end # SATA 1
                                        device pci 5.2 on  end # SATA 2
                                        device pci 6.0 on  #P2P
                                                chip drivers/pci/onboard
                                                        device pci 4.0 on end
                                                        register "rom_address" = "0xfff80000"
                                                end
                                        end # P2P
                                        device pci 7.0 on end # reserve
                                        device pci 8.0 on end # MAC0
                                        device pci 9.0 on end # MAC1
                                        device pci a.0 on
                                                device pci 0.0 on
                                                        chip drivers/pci/onboard
                                                                device pci 4.0 on end  #pci_E lan1
                                                                device pci 4.1 on end  #pci_E lan2
                                                        end
                                                end
                                        end # 0x376
                                                device pci b.0 on  end # PCI E 0x374
                                        device pci c.0 on  end
                                        device pci d.0 on   #SAS
                                                chip drivers/pci/onboard
                                                        device pci 0.0 on end
                                                end
                                        end # PCI E 1 0x378
                                        device pci e.0 on end # PCI E 0 0x375
                                        device pci f.0 on end   #PCI E 0x377  pci_E slot
                                        register "ide0_enable" = "1"
                                        register "ide1_enable" = "1"
                                        register "sata0_enable" = "1"
                                        register "sata1_enable" = "1"
                                end
                        end #  device pci 18.0
                        device pci 18.0 on end # Link 1
                        device pci 18.0 on end
                        device pci 18.1 on end
                        device pci 18.2 on end
                        device pci 18.3 on end
                end #mc0
 
        end # pci_domain
 
 #        chip drivers/generic/debug
 #                device pnp 0.0 off end
 #                device pnp 0.1 off end
 #                device pnp 0.2 off end
 #                device pnp 0.3 off end
 #                device pnp 0.4 off end
 #              device pnp 0.5 on end
 #        end
 end # root_complex
diff --git a/src/mainboard/newisys/khepri/Config.lb b/src/mainboard/newisys/khepri/Config.lb
index ac30d91..9f8e29f 100644
--- a/src/mainboard/newisys/khepri/Config.lb
+++ b/src/mainboard/newisys/khepri/Config.lb
@@ -1,283 +1,283 @@
 ##
 ## Compute the location and size of where this firmware image
 ## (coreboot plus bootloader) will live in the boot rom chip.
 ##
 if USE_FALLBACK_IMAGE
 	default ROM_SECTION_SIZE   = FALLBACK_SIZE
 	default ROM_SECTION_OFFSET = ( ROM_SIZE - FALLBACK_SIZE )
 else
 	default ROM_SECTION_SIZE   = ( ROM_SIZE - FALLBACK_SIZE )
 	default ROM_SECTION_OFFSET = 0
 end
 
 ##
 ## Compute the start location and size size of
 ## The coreboot bootloader.
 ##
 default PAYLOAD_SIZE            = ( ROM_SECTION_SIZE - ROM_IMAGE_SIZE )
 default CONFIG_ROM_PAYLOAD_START = (0xffffffff - ROM_SIZE + ROM_SECTION_OFFSET + 1)
 
 ##
 ## Compute where this copy of coreboot will start in the boot rom
 ##
 default _ROMBASE      = ( CONFIG_ROM_PAYLOAD_START + PAYLOAD_SIZE )
 
 ##
 ## Compute a range of ROM that can cached to speed up coreboot,
 ## execution speed.
 ##
 ## XIP_ROM_SIZE must be a power of 2.
 ## XIP_ROM_BASE must be a multiple of XIP_ROM_SIZE
 ##
 default XIP_ROM_SIZE=65536
 default XIP_ROM_BASE = ( _ROMBASE + ROM_IMAGE_SIZE - XIP_ROM_SIZE )
 
 ##
 ## Set all of the defaults for an x86 architecture
 ##
 
 arch i386 end
 
 ##
 ## Build the objects we have code for in this directory.
 ##
 
 driver mainboard.o
 if HAVE_MP_TABLE object mptable.o end
 if HAVE_PIRQ_TABLE object irq_tables.o end
 #object reset.o
 
 if USE_DCACHE_RAM
 
 if CONFIG_USE_INIT
 
 makerule ./auto.o
         depends "$(MAINBOARD)/cache_as_ram_auto.c option_table.h"
         action "$(CC) $(DISTRO_CFLAGS) -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/cache_as_ram_auto.c -Os -nostdinc -nostdlib -fno-builtin -Wall -c -o auto.o" 
 end
 
 else    
                 
 makerule ./auto.inc
         depends "$(MAINBOARD)/cache_as_ram_auto.c option_table.h"
         action "$(CC) $(DISTRO_CFLAGS) -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/cache_as_ram_auto.c -Os -nostdinc -nostdlib -fno-builtin -Wall -c -S -o $@"         
         action "perl -e 's/.rodata/.rom.data/g' -pi $@"
         action "perl -e 's/.text/.section .rom.text/g' -pi $@"
 end
 
 end
 else
  
 ##
 ## Romcc output
 ##
 makerule ./failover.E
-	depends "$(MAINBOARD)/failover.c ./romcc" 
-	action "./romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+	depends "$(MAINBOARD)/failover.c ../romcc" 
+	action "../romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 end
 
 makerule ./failover.inc
-	depends "$(MAINBOARD)/failover.c ./romcc"
-	action "./romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+	depends "$(MAINBOARD)/failover.c ../romcc"
+	action "../romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 end
 
 makerule ./auto.E 
-	depends	"$(MAINBOARD)/auto.c option_table.h ./romcc" 
-	action	"./romcc -E -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	depends	"$(MAINBOARD)/auto.c option_table.h ../romcc" 
+	action	"../romcc -E -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 makerule ./auto.inc 
-	depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-	action	"./romcc    -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+	action	"../romcc    -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 
 end
 
 ##
 ## Build our 16 bit and 32 bit coreboot entry code
 ##
 if USE_FALLBACK_IMAGE
         mainboardinit cpu/x86/16bit/entry16.inc
         ldscript /cpu/x86/16bit/entry16.lds
 end
 
 mainboardinit cpu/x86/32bit/entry32.inc
 
 if USE_DCACHE_RAM
         if CONFIG_USE_INIT
                 ldscript /cpu/x86/32bit/entry32.lds
         end
 
         if CONFIG_USE_INIT
                 ldscript      /cpu/amd/car/cache_as_ram.lds
         end
 end
 
 ##
 ## Build our reset vector (This is where coreboot is entered)
 ##
 if USE_FALLBACK_IMAGE 
 	mainboardinit cpu/x86/16bit/reset16.inc 
 	ldscript /cpu/x86/16bit/reset16.lds 
 else
 	mainboardinit cpu/x86/32bit/reset32.inc 
 	ldscript /cpu/x86/32bit/reset32.lds 
 end
 
 ### Should this be in the northbridge code?
 if USE_DCACHE_RAM
 else
 mainboardinit arch/i386/lib/cpu_reset.inc
 end
 ##
 ## Include an id string (For safe flashing)
 ##
 mainboardinit arch/i386/lib/id.inc
 ldscript /arch/i386/lib/id.lds
 
 if USE_DCACHE_RAM
 ##
 ## Setup Cache-As-Ram
 ##
 mainboardinit cpu/amd/car/cache_as_ram.inc
 end
 
 ###
 ### This is the early phase of coreboot startup 
 ### Things are delicate and we test to see if we should
 ### failover to another image.
 ###
 if USE_FALLBACK_IMAGE
 if USE_DCACHE_RAM
 	ldscript /arch/i386/lib/failover.lds
 else
 	ldscript /arch/i386/lib/failover.lds
 	mainboardinit ./failover.inc
 end
 end
 
 ###
 ### O.k. We aren't just an intermediary anymore!
 ###
 
 ##
 ## Setup RAM
 ##
 if USE_DCACHE_RAM
 
 if CONFIG_USE_INIT
 initobject auto.o
 else
 mainboardinit ./auto.inc
 end
 
 else
 
 ##
 ## Setup RAM
 ##
 
 mainboardinit cpu/x86/fpu/enable_fpu.inc
 mainboardinit cpu/x86/mmx/enable_mmx.inc
 mainboardinit cpu/x86/sse/enable_sse.inc
 mainboardinit ./auto.inc
 mainboardinit cpu/x86/sse/disable_sse.inc
 mainboardinit cpu/x86/mmx/disable_mmx.inc
 
 end
 
 config chip.h
 
 # FIXME: ROM for onboard VGA
 
 chip northbridge/amd/amdk8/root_complex
 	device apic_cluster 0 on
 		chip cpu/amd/socket_940
 			device apic 0 on end
 		end
 		chip cpu/amd/socket_940
 			device apic 1 on end
 		end
 	end
 
 	device pci_domain 0 on
 		chip northbridge/amd/amdk8
 			device pci 18.0 on end # LDT 0 
 			device pci 18.0 on     # LDT 1
 				chip southbridge/amd/amd8131
 					device pci 0.0 on end
 					device pci 0.1 on end
 					device pci 1.0 on end
 					device pci 1.1 on end
 				end
 				chip southbridge/amd/amd8111
 					device pci 0.0 on
 						device pci 0.0 on end
 						device pci 0.1 on end
 						device pci 0.2 on end
 						device pci 1.0 on end
 					end
 					device pci 1.0 on
 						chip superio/winbond/w83627hf
 							device pnp 2e.0 on #  Floppy
                 	                 			io 0x60 = 0x3f0
                 	                			irq 0x70 = 6
                 	                			drq 0x74 = 2
 							end
                 	        			device pnp 2e.1 off #  Parallel Port
                 	                 			io 0x60 = 0x378
                 	                			irq 0x70 = 7
 							end
                 	        			device pnp 2e.2 on #  Com1
                 	                 			io 0x60 = 0x3f8
                 	                			irq 0x70 = 4
 							end
                 	        			device pnp 2e.3 on #  Com2
                 	                 			io 0x60 = 0x2f8
                 	                			irq 0x70 = 3
 							end
                 	        			device pnp 2e.5 on #  Keyboard
                 	                 			io 0x60 = 0x60
                 	                 			io 0x62 = 0x64
                 	                			irq 0x70 = 1
 								irq 0x72 = 12
 							end
                 	        			device pnp 2e.6 off #  CIR
 								io 0x60 = 0x100
 							end
                 	        			device pnp 2e.7 off #  GAME_MIDI_GIPO1
 								io 0x60 = 0x220
 								io 0x62 = 0x300
 								irq 0x70 = 9
 							end						
                 	        			device pnp 2e.8 off end #  GPIO2
                 	        			device pnp 2e.9 off end #  GPIO3
                 	        			device pnp 2e.a off end #  ACPI
                 	        			device pnp 2e.b on #  HW Monitor
  					 			io 0x60 = 0x290
 								irq 0x70 = 5
                 					end
 						end
 					end
 					device pci 1.1 on end
 					device pci 1.2 on end
 					device pci 1.3 on end 
 					device pci 1.5 on end
 					device pci 1.6 on end
 				end
 			end # LDT1
 			device pci 18.0 on end # LDT2
 			device pci 18.1 on end
 			device pci 18.2 on end
 			device pci 18.3 on end
 		end
 		chip northbridge/amd/amdk8
 			device pci 19.0 on end
 			device pci 19.0 on end
 			device pci 19.0 on end
 			device pci 19.1 on end
 			device pci 19.2 on end
 			device pci 19.3 on end
 		end
 	end 
 end
 
diff --git a/src/mainboard/olpc/btest/Config.lb b/src/mainboard/olpc/btest/Config.lb
index 889bee5..f4c24cc 100644
--- a/src/mainboard/olpc/btest/Config.lb
+++ b/src/mainboard/olpc/btest/Config.lb
@@ -1,170 +1,170 @@
 ##
 ## Compute the location and size of where this firmware image
 ## (coreboot plus bootloader) will live in the boot rom chip.
 ##
 if USE_FALLBACK_IMAGE
 	default ROM_SECTION_SIZE   = FALLBACK_SIZE
 	default ROM_SECTION_OFFSET = ( ROM_SIZE - FALLBACK_SIZE )
 else
 	default ROM_SECTION_SIZE   = ( ROM_SIZE - FALLBACK_SIZE )
 	default ROM_SECTION_OFFSET = 0
 end
 
 ##
 ## Compute the start location and size size of
 ## The coreboot bootloader.
 ##
 default CONFIG_ROM_PAYLOAD_START = (0xffffffff - ROM_SIZE + ROM_SECTION_OFFSET + 1)
 default PAYLOAD_SIZE            = ( ROM_SECTION_SIZE - ROM_IMAGE_SIZE )
 
 ##
 ## Compute where this copy of coreboot will start in the boot rom
 ##
 default _ROMBASE      = ( CONFIG_ROM_PAYLOAD_START + PAYLOAD_SIZE )
 
 ##
 ## Compute a range of ROM that can cached to speed up coreboot,
 ## execution speed.
 ##
 ## XIP_ROM_SIZE must be a power of 2.
 ## XIP_ROM_BASE must be a multiple of XIP_ROM_SIZE
 ##
 default XIP_ROM_SIZE=65536
 default XIP_ROM_BASE = ( _ROMBASE + ROM_IMAGE_SIZE - XIP_ROM_SIZE )
 
 ##
 ## Set all of the defaults for an x86 architecture
 ##
 
 arch i386 end
 
 ##
 ## Build the objects we have code for in this directory.
 ##
 
 driver mainboard.o
 
 if HAVE_PIRQ_TABLE object irq_tables.o end
 #object reset.o
 
 ##
 ## Romcc output
 ##
 makerule ./failover.E
-	depends "$(MAINBOARD)/failover.c ./romcc" 
-	action "./romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+	depends "$(MAINBOARD)/failover.c ../romcc" 
+	action "../romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 end
 
 makerule ./failover.inc
-	depends "$(MAINBOARD)/failover.c ./romcc"
-	action "./romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+	depends "$(MAINBOARD)/failover.c ../romcc"
+	action "../romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 end
 
 makerule ./auto.E 
-	depends	"$(MAINBOARD)/auto.c option_table.h ./romcc" 
-	action	"./romcc -E -mcpu=p2 -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	depends	"$(MAINBOARD)/auto.c option_table.h ../romcc" 
+	action	"../romcc -E -mcpu=p2 -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 makerule ./auto.inc 
-	depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-	action	"./romcc    -mcpu=p2 -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+	action	"../romcc    -mcpu=p2 -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 
 ##
 ## Build our 16 bit and 32 bit coreboot entry code
 ##
 mainboardinit cpu/x86/16bit/entry16.inc
 mainboardinit cpu/x86/32bit/entry32.inc
 ldscript /cpu/x86/16bit/entry16.lds
 ldscript /cpu/x86/32bit/entry32.lds
 
 ##
 ## Build our reset vector (This is where coreboot is entered)
 ##
 if USE_FALLBACK_IMAGE 
 	mainboardinit cpu/x86/16bit/reset16.inc 
 	ldscript /cpu/x86/16bit/reset16.lds 
 else
 	mainboardinit cpu/x86/32bit/reset32.inc 
 	ldscript /cpu/x86/32bit/reset32.lds 
 end
 
 ### Should this be in the northbridge code?
 mainboardinit arch/i386/lib/cpu_reset.inc
 
 ##
 ## Include an id string (For safe flashing)
 ##
 mainboardinit arch/i386/lib/id.inc
 ldscript /arch/i386/lib/id.lds
 
 ###
 ### This is the early phase of coreboot startup 
 ### Things are delicate and we test to see if we should
 ### failover to another image.
 ###
 if USE_FALLBACK_IMAGE
 	ldscript /arch/i386/lib/failover.lds 
 	mainboardinit ./failover.inc
 end
 
 ###
 ### O.k. We aren't just an intermediary anymore!
 ###
 
 ##
 ## Setup RAM
 ##
 mainboardinit cpu/x86/fpu/enable_fpu.inc
 mainboardinit ./auto.inc
 
 ##
 ## Include the secondary Configuration files 
 ##
 dir /pc80
 config chip.h
 
 chip northbridge/amd/gx2
 	register "irqmap" = "0xaa5b"
 	register "setupflash" = "0"
 	device apic_cluster 0 on
 		chip cpu/amd/model_gx2
 			device apic 0 on end
 		end
 	end
   	device pci_domain 0 on 
     		device pci 1.0 on end
 		device pci 1.1 on end
       		chip southbridge/amd/cs5536
 		# 0x51400025 (IRQ Mapper LPC Mask)= 0x00001002
 		# IRQ 12 and 1 unmasked,  Keyboard and Mouse IRQs. OK
 		# 0x5140004E (LPC Serial IRQ Control) = 0xEFFD0080.
 		# Frame Pulse Width = 4clocks
 		# IRQ Data Frames = 17Frames
 		# SIRQ Mode = continous , It would be better if the EC could operate in
 		# Active(Quiet) mode. Save power....
 		# SIRQ Enable = Enabled
 		# Invert mask = IRQ 12 and 1 are active high. Keyboard and Mouse IRQs. OK 
 			#register "lpc_irq" = "0x00001002"
 			#register "lpc_serirq_enable" = "0xEFFD0080"
 			#register "enable_gpio0_inta" = "1"
 			#register "enable_ide_nand_flash" = "1"
 			#register "enable_uarta" = "1"
 			#register "enable_USBP4_host" = "1"
 			#register "audio_irq" = "5"
 			#register "usbf4_irq" = "10"
 			#register "usbf5_irq" = "10"
 			#register "usbf6_irq" = "0"
 			#register "usbf7_irq" = "0"
         		device pci d.0 on end	# Realtek 8139 LAN
         		device pci f.0 on end	# ISA Bridge
         		device pci f.2 on end	# IDE Controller
         		device pci f.3 on end 	# Audio
         		device pci f.4 on end	# OHCI
 			device pci f.5 on end	# EHCI
 			register "unwanted_vpci[0]" = "0x80007E00"	# USB/UDC
 			register "unwanted_vpci[1]" = "0x80007F00"	# USB/OTG
 			register "unwanted_vpci[2]" = "0"	# End of list has a zero
       		end
     	end
 end
 
diff --git a/src/mainboard/olpc/rev_a/Config.lb b/src/mainboard/olpc/rev_a/Config.lb
index 889bee5..f4c24cc 100644
--- a/src/mainboard/olpc/rev_a/Config.lb
+++ b/src/mainboard/olpc/rev_a/Config.lb
@@ -1,170 +1,170 @@
 ##
 ## Compute the location and size of where this firmware image
 ## (coreboot plus bootloader) will live in the boot rom chip.
 ##
 if USE_FALLBACK_IMAGE
 	default ROM_SECTION_SIZE   = FALLBACK_SIZE
 	default ROM_SECTION_OFFSET = ( ROM_SIZE - FALLBACK_SIZE )
 else
 	default ROM_SECTION_SIZE   = ( ROM_SIZE - FALLBACK_SIZE )
 	default ROM_SECTION_OFFSET = 0
 end
 
 ##
 ## Compute the start location and size size of
 ## The coreboot bootloader.
 ##
 default CONFIG_ROM_PAYLOAD_START = (0xffffffff - ROM_SIZE + ROM_SECTION_OFFSET + 1)
 default PAYLOAD_SIZE            = ( ROM_SECTION_SIZE - ROM_IMAGE_SIZE )
 
 ##
 ## Compute where this copy of coreboot will start in the boot rom
 ##
 default _ROMBASE      = ( CONFIG_ROM_PAYLOAD_START + PAYLOAD_SIZE )
 
 ##
 ## Compute a range of ROM that can cached to speed up coreboot,
 ## execution speed.
 ##
 ## XIP_ROM_SIZE must be a power of 2.
 ## XIP_ROM_BASE must be a multiple of XIP_ROM_SIZE
 ##
 default XIP_ROM_SIZE=65536
 default XIP_ROM_BASE = ( _ROMBASE + ROM_IMAGE_SIZE - XIP_ROM_SIZE )
 
 ##
 ## Set all of the defaults for an x86 architecture
 ##
 
 arch i386 end
 
 ##
 ## Build the objects we have code for in this directory.
 ##
 
 driver mainboard.o
 
 if HAVE_PIRQ_TABLE object irq_tables.o end
 #object reset.o
 
 ##
 ## Romcc output
 ##
 makerule ./failover.E
-	depends "$(MAINBOARD)/failover.c ./romcc" 
-	action "./romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+	depends "$(MAINBOARD)/failover.c ../romcc" 
+	action "../romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 end
 
 makerule ./failover.inc
-	depends "$(MAINBOARD)/failover.c ./romcc"
-	action "./romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+	depends "$(MAINBOARD)/failover.c ../romcc"
+	action "../romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 end
 
 makerule ./auto.E 
-	depends	"$(MAINBOARD)/auto.c option_table.h ./romcc" 
-	action	"./romcc -E -mcpu=p2 -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	depends	"$(MAINBOARD)/auto.c option_table.h ../romcc" 
+	action	"../romcc -E -mcpu=p2 -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 makerule ./auto.inc 
-	depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-	action	"./romcc    -mcpu=p2 -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+	action	"../romcc    -mcpu=p2 -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 
 ##
 ## Build our 16 bit and 32 bit coreboot entry code
 ##
 mainboardinit cpu/x86/16bit/entry16.inc
 mainboardinit cpu/x86/32bit/entry32.inc
 ldscript /cpu/x86/16bit/entry16.lds
 ldscript /cpu/x86/32bit/entry32.lds
 
 ##
 ## Build our reset vector (This is where coreboot is entered)
 ##
 if USE_FALLBACK_IMAGE 
 	mainboardinit cpu/x86/16bit/reset16.inc 
 	ldscript /cpu/x86/16bit/reset16.lds 
 else
 	mainboardinit cpu/x86/32bit/reset32.inc 
 	ldscript /cpu/x86/32bit/reset32.lds 
 end
 
 ### Should this be in the northbridge code?
 mainboardinit arch/i386/lib/cpu_reset.inc
 
 ##
 ## Include an id string (For safe flashing)
 ##
 mainboardinit arch/i386/lib/id.inc
 ldscript /arch/i386/lib/id.lds
 
 ###
 ### This is the early phase of coreboot startup 
 ### Things are delicate and we test to see if we should
 ### failover to another image.
 ###
 if USE_FALLBACK_IMAGE
 	ldscript /arch/i386/lib/failover.lds 
 	mainboardinit ./failover.inc
 end
 
 ###
 ### O.k. We aren't just an intermediary anymore!
 ###
 
 ##
 ## Setup RAM
 ##
 mainboardinit cpu/x86/fpu/enable_fpu.inc
 mainboardinit ./auto.inc
 
 ##
 ## Include the secondary Configuration files 
 ##
 dir /pc80
 config chip.h
 
 chip northbridge/amd/gx2
 	register "irqmap" = "0xaa5b"
 	register "setupflash" = "0"
 	device apic_cluster 0 on
 		chip cpu/amd/model_gx2
 			device apic 0 on end
 		end
 	end
   	device pci_domain 0 on 
     		device pci 1.0 on end
 		device pci 1.1 on end
       		chip southbridge/amd/cs5536
 		# 0x51400025 (IRQ Mapper LPC Mask)= 0x00001002
 		# IRQ 12 and 1 unmasked,  Keyboard and Mouse IRQs. OK
 		# 0x5140004E (LPC Serial IRQ Control) = 0xEFFD0080.
 		# Frame Pulse Width = 4clocks
 		# IRQ Data Frames = 17Frames
 		# SIRQ Mode = continous , It would be better if the EC could operate in
 		# Active(Quiet) mode. Save power....
 		# SIRQ Enable = Enabled
 		# Invert mask = IRQ 12 and 1 are active high. Keyboard and Mouse IRQs. OK 
 			#register "lpc_irq" = "0x00001002"
 			#register "lpc_serirq_enable" = "0xEFFD0080"
 			#register "enable_gpio0_inta" = "1"
 			#register "enable_ide_nand_flash" = "1"
 			#register "enable_uarta" = "1"
 			#register "enable_USBP4_host" = "1"
 			#register "audio_irq" = "5"
 			#register "usbf4_irq" = "10"
 			#register "usbf5_irq" = "10"
 			#register "usbf6_irq" = "0"
 			#register "usbf7_irq" = "0"
         		device pci d.0 on end	# Realtek 8139 LAN
         		device pci f.0 on end	# ISA Bridge
         		device pci f.2 on end	# IDE Controller
         		device pci f.3 on end 	# Audio
         		device pci f.4 on end	# OHCI
 			device pci f.5 on end	# EHCI
 			register "unwanted_vpci[0]" = "0x80007E00"	# USB/UDC
 			register "unwanted_vpci[1]" = "0x80007F00"	# USB/OTG
 			register "unwanted_vpci[2]" = "0"	# End of list has a zero
       		end
     	end
 end
 
diff --git a/src/mainboard/rca/rm4100/Config.lb b/src/mainboard/rca/rm4100/Config.lb
index ffe1730..a1eb016 100644
--- a/src/mainboard/rca/rm4100/Config.lb
+++ b/src/mainboard/rca/rm4100/Config.lb
@@ -1,145 +1,145 @@
 ##
 ## This file is part of the coreboot project.
 ##
 ## Copyright (C) 2008 Joseph Smith <joe@smittys.pointclark.net>
 ##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2 of the License, or
 ## (at your option) any later version.
 ##
 ## This program is distributed in the hope that it will be useful,
 ## but WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ## GNU General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this program; if not, write to the Free Software
 ## Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 ##
 
 if USE_FALLBACK_IMAGE
 	default ROM_SECTION_SIZE = FALLBACK_SIZE
 	default ROM_SECTION_OFFSET = (ROM_SIZE - FALLBACK_SIZE)
 else
 	default ROM_SECTION_SIZE = (ROM_SIZE - FALLBACK_SIZE)
 	default ROM_SECTION_OFFSET = 0
 end
 default CONFIG_ROM_PAYLOAD_START = (0xffffffff - ROM_SIZE + ROM_SECTION_OFFSET + 1)
 default PAYLOAD_SIZE = (ROM_SECTION_SIZE - ROM_IMAGE_SIZE)
 default _ROMBASE = (CONFIG_ROM_PAYLOAD_START + PAYLOAD_SIZE)
 default XIP_ROM_SIZE = 65536
 default XIP_ROM_BASE = (_ROMBASE + ROM_IMAGE_SIZE - XIP_ROM_SIZE)
 arch i386 end
 driver mainboard.o
 if HAVE_PIRQ_TABLE object irq_tables.o end
 # object reset.o
 if HAVE_ACPI_TABLES
 	object fadt.o
 	object dsdt.o
 	object acpi_tables.o
 end
 makerule ./failover.E
-	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ./romcc"
-	action "./romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
+	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ../romcc"
+	action "../romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
 end
 makerule ./failover.inc
-	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ./romcc"
-	action "./romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
+	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ../romcc"
+	action "../romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
 end
 makerule ./auto.E
-	# depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-	depends	"$(MAINBOARD)/auto.c ./romcc"
-	action	"./romcc -E -mcpu=p3 -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	# depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+	depends	"$(MAINBOARD)/auto.c ../romcc"
+	action	"../romcc -E -mcpu=p3 -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 makerule ./auto.inc 
-	# depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-	depends	"$(MAINBOARD)/auto.c ./romcc"
-	action	"./romcc    -mcpu=p3 -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	# depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+	depends	"$(MAINBOARD)/auto.c ../romcc"
+	action	"../romcc    -mcpu=p3 -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 mainboardinit cpu/x86/16bit/entry16.inc
 mainboardinit cpu/x86/32bit/entry32.inc
 ldscript /cpu/x86/16bit/entry16.lds
 ldscript /cpu/x86/32bit/entry32.lds
 if USE_FALLBACK_IMAGE
 	mainboardinit cpu/x86/16bit/reset16.inc
 	ldscript /cpu/x86/16bit/reset16.lds
 else
 	mainboardinit cpu/x86/32bit/reset32.inc
 	ldscript /cpu/x86/32bit/reset32.lds
 end
 mainboardinit arch/i386/lib/cpu_reset.inc
 mainboardinit arch/i386/lib/id.inc
 ldscript /arch/i386/lib/id.lds
 if USE_FALLBACK_IMAGE
 	ldscript /arch/i386/lib/failover.lds
 	mainboardinit ./failover.inc
 end
 mainboardinit cpu/x86/fpu/enable_fpu.inc
 mainboardinit cpu/x86/mmx/enable_mmx.inc
 mainboardinit ./auto.inc
 mainboardinit cpu/x86/mmx/disable_mmx.inc
 dir /pc80
 config chip.h
 
 chip northbridge/intel/i82830		# Northbridge
   device pci_domain 0 on		# PCI domain
     device pci 0.0 on end		# Host bridge
     chip drivers/pci/onboard		# Onboard VGA
       device pci 2.0 on end		# VGA (Intel 82830 CGC)
       register "rom_address" = "0xfff00000"
     end
     chip southbridge/intel/i82801xx	# Southbridge
       device pci 1d.0 on end		# USB UHCI Controller #1
       device pci 1d.1 on end		# USB UHCI Controller #2
       device pci 1d.2 on end		# USB UHCI Controller #3
       device pci 1d.7 on end		# USB2 EHCI Controller
       device pci 1e.0 on		# PCI bridge
         device pci 08.0 on end		# Intel 82801DB PRO/100 VE Ethernet
       end
       device pci 1f.0 on		# ISA/LPC bridge
         chip superio/smsc/smscsuperio	# Super I/O
           device pnp 2e.0 off		# Floppy
             io 0x60 = 0x3f0
             irq 0x70 = 6
             drq 0x74 = 2
           end
           device pnp 2e.3 on		# Parallel port
             io 0x60 = 0x378
             irq 0x70 = 7
             drq 0x74 = 4
           end
           device pnp 2e.4 on		# Com1
             io 0x60 = 0x3f8
             irq 0x70 = 4
           end
           device pnp 2e.5 on		# Com2 / IR
             io 0x60 = 0x2f8
             irq 0x70 = 3
           end
           device pnp 2e.7 on		# PS/2 keyboard/mouse
             io 0x60 = 0x60
             io 0x62 = 0x64
             irq 0x70 = 1		# Keyboard interrupt
             irq 0x72 = 12		# Mouse interrupt
           end
           device pnp 2e.9 off end	# Game port
           device pnp 2e.a on		# PME
             io 0x60 = 0x800
           end
           device pnp 2e.b off end	# MPU-401
         end
       end
       device pci 1f.1 on end		# IDE
       device pci 1f.3 on end		# SMBus
       device pci 1f.5 on end		# AC'97 audio
       device pci 1f.6 on end		# AC'97 modem
     end
   end
   device apic_cluster 0 on		# APIC cluster
     chip cpu/intel/socket_PGA370	# Mobile Celeron Micro-FCBGA Socket 479
       device apic 0 on end		# APIC
     end
   end
 end
 
diff --git a/src/mainboard/sunw/ultra40/Config.lb b/src/mainboard/sunw/ultra40/Config.lb
index 712a684..59d6a5c 100644
--- a/src/mainboard/sunw/ultra40/Config.lb
+++ b/src/mainboard/sunw/ultra40/Config.lb
@@ -1,350 +1,350 @@
 ##
 ## Compute the location and size of where this firmware image
 ## (coreboot plus bootloader) will live in the boot rom chip.
 ##
 if USE_FALLBACK_IMAGE
 	default ROM_SECTION_SIZE   = FALLBACK_SIZE
 	default ROM_SECTION_OFFSET = ( ROM_SIZE - FALLBACK_SIZE )
 else
 	default ROM_SECTION_SIZE   = ( ROM_SIZE - FALLBACK_SIZE )
 	default ROM_SECTION_OFFSET = 0
 end
 
 ##
 ## Compute the start location and size size of
 ## The coreboot bootloader.
 ##
 default PAYLOAD_SIZE            = ( ROM_SECTION_SIZE - ROM_IMAGE_SIZE )
 default CONFIG_ROM_PAYLOAD_START = (0xffffffff - ROM_SIZE + ROM_SECTION_OFFSET + 1)
 default CONFIG_ROM_PAYLOAD     = 1
 
 ##
 ## Compute where this copy of coreboot will start in the boot rom
 ##
 default _ROMBASE      = ( CONFIG_ROM_PAYLOAD_START + PAYLOAD_SIZE )
 
 ##
 ## Compute a range of ROM that can cached to speed up coreboot,
 ## execution speed.
 ##
 ## XIP_ROM_SIZE must be a power of 2.
 ## XIP_ROM_BASE must be a multiple of XIP_ROM_SIZE
 ##
 default XIP_ROM_SIZE=65536
 default XIP_ROM_BASE = ( _ROMBASE + ROM_IMAGE_SIZE - XIP_ROM_SIZE )
 
 arch i386 end 
 
 
 ##
 ## Build the objects we have code for in this directory.
 ##
 
 driver mainboard.o
 #needed by irq_tables and mptable and acpi_tables
 object get_bus_conf.o
 
 if HAVE_MP_TABLE object mptable.o end
 if HAVE_PIRQ_TABLE object irq_tables.o end
 #object reset.o
 if USE_DCACHE_RAM
 
 	if CONFIG_USE_INIT	
 		makerule ./auto.o
 		        depends "$(MAINBOARD)/cache_as_ram_auto.c option_table.h"
         		action "$(CC) $(DISTRO_CFLAGS) -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/cache_as_ram_auto.c -Os -nostdinc -nostdlib -fno-builtin -Wall -c -o auto.o"
 		end
 	else
 		makerule ./auto.inc
         		depends "$(MAINBOARD)/cache_as_ram_auto.c option_table.h"
 		        action "$(CC) $(DISTRO_CFLAGS) -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/cache_as_ram_auto.c -Os -nostdinc -nostdlib -fno-builtin -Wall -c -S -o $@"
 		        action "perl -e 's/.rodata/.rom.data/g' -pi $@"
         		action "perl -e 's/.text/.section .rom.text/g' -pi $@"
 		end
 	end
 
 else
 	##
 	## Romcc output
 	##
 	makerule ./failover.E
-        	depends "$(MAINBOARD)/failover.c ./romcc"
-	        action "./romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+        	depends "$(MAINBOARD)/failover.c ../romcc"
+	        action "../romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 	end
 
 	makerule ./failover.inc
-        	depends "$(MAINBOARD)/failover.c ./romcc"
-	        action "./romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+        	depends "$(MAINBOARD)/failover.c ../romcc"
+	        action "../romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 	end
 
 	makerule ./auto.E
-        	depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-	        action  "./romcc -E -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+        	depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+	        action  "../romcc -E -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 	end
 
 	makerule ./auto.inc
-        	depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-	        action  "./romcc    -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+        	depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+	        action  "../romcc    -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 	end
 
 end
 
 ##
 ## Build our 16 bit and 32 bit coreboot entry code
 ##
 if USE_FALLBACK_IMAGE
         mainboardinit cpu/x86/16bit/entry16.inc
         ldscript /cpu/x86/16bit/entry16.lds
 end
 
 mainboardinit cpu/x86/32bit/entry32.inc
 
 if USE_DCACHE_RAM
         if CONFIG_USE_INIT
                 ldscript /cpu/x86/32bit/entry32.lds
         end
 
         if CONFIG_USE_INIT
                 ldscript /cpu/amd/car/cache_as_ram.lds
         end
 end
 
 
 ##
 ## Build our reset vector (This is where coreboot is entered)
 ##
 if USE_FALLBACK_IMAGE 
 	mainboardinit cpu/x86/16bit/reset16.inc 
 	ldscript /cpu/x86/16bit/reset16.lds 
 else
 	mainboardinit cpu/x86/32bit/reset32.inc 
 	ldscript /cpu/x86/32bit/reset32.lds 
 end
 
 if USE_DCACHE_RAM
 else
 	### Should this be in the northbridge code?
 	mainboardinit arch/i386/lib/cpu_reset.inc
 end
 
 ##
 ## Include an id string (For safe flashing)
 ##
 mainboardinit southbridge/nvidia/ck804/id.inc
 ldscript /southbridge/nvidia/ck804/id.lds
 
 ##
 ## ROMSTRAP table for CK804
 ##
 if USE_FALLBACK_IMAGE
 	mainboardinit southbridge/nvidia/ck804/romstrap.inc
 	ldscript /southbridge/nvidia/ck804/romstrap.lds
 end
 
 
 
 if USE_DCACHE_RAM
 	##
 	## Setup Cache-As-Ram
 	##
 	mainboardinit cpu/amd/car/cache_as_ram.inc
 end
 
 ###
 ### This is the early phase of coreboot startup 
 ### Things are delicate and we test to see if we should
 ### failover to another image.
 ###
 if USE_FALLBACK_IMAGE
 	ldscript /arch/i386/lib/failover.lds
 	if USE_DCACHE_RAM
 	else
 	        mainboardinit ./failover.inc
 	end
 end
 
 ##
 ## Setup RAM
 ##
 if USE_DCACHE_RAM
 
 	if CONFIG_USE_INIT
 		initobject auto.o
 	else
 		mainboardinit ./auto.inc
 	end
 
 else
 	# ROMCC
 	mainboardinit cpu/x86/fpu/enable_fpu.inc
 	mainboardinit cpu/x86/mmx/enable_mmx.inc
 	mainboardinit cpu/x86/sse/enable_sse.inc
 	mainboardinit ./auto.inc
 	mainboardinit cpu/x86/sse/disable_sse.inc
 	mainboardinit cpu/x86/mmx/disable_mmx.inc
 
 end
 
 ##
 ## Include the secondary Configuration files 
 ##
 if CONFIG_CHIP_NAME
 	config chip.h
 end
 
 # sample config for tyan/s2895
 chip northbridge/amd/amdk8/root_complex
         device apic_cluster 0 on
                 chip cpu/amd/socket_940
                         device apic 0 on end
                 end
         end
 	device pci_domain 0 on
 		chip northbridge/amd/amdk8 #mc0
 			device pci 18.0 on end # link 0
 			device pci 18.0 on # link1 
 				#  devices on link 0, link 0 == LDT 0 
 			        chip southbridge/nvidia/ck804 
 					device pci 0.0 on end   # HT
                 			device pci 1.0 on # LPC
                 	                        chip superio/smsc/lpc47m10x
                         	                        device pnp 2e.0 off #  Floppy
                                 	                         io 0x60 = 0x3f0
                                         	                irq 0x70 = 6
                                                 	        drq 0x74 = 2
 	                                                end
         	                                        device pnp 2e.3 off #  Parallel Port
                 	                                         io 0x60 = 0x378
                         	                                irq 0x70 = 7
                                 	                end
                                         	        device pnp 2e.4 on #  Com1
                                                 	        io 0x60 = 0x3f8
 	                                                        irq 0x70 = 4
         	                                        end
                 	                                device pnp 2e.5 off #  Com2
                         	                                io 0x60 = 0x2f8
                                 	                        irq 0x70 = 3
                                         	        end
 	                                                device pnp 2e.7 off #  Keyboard
         	                                                io 0x60 = 0x60
                 	                                        io 0x62 = 0x64
                         	                                irq 0x70 = 1
                                 	                        irq 0x72 = 12
                                         	        end
                         	                end
 					end
 			                device pci 1.1 on # SM 0
                                                 chip drivers/generic/generic #dimm 0-0-0
                                                         device i2c 50 on end  
                                                 end              
                                                 chip drivers/generic/generic #dimm 0-0-1
                                                         device i2c 51 on end
                                                 end     
                                                 chip drivers/generic/generic #dimm 0-1-0
                                                         device i2c 52 on end
                                                 end             
                                                 chip drivers/generic/generic #dimm 0-1-1
                                                         device i2c 53 on end
                                                 end              
                                                 chip drivers/generic/generic #dimm 1-0-0
                                                         device i2c 54 on end
                                                 end     
                                                 chip drivers/generic/generic #dimm 1-0-1
                                                         device i2c 55 on end
                                                 end     
                                                 chip drivers/generic/generic #dimm 1-1-0
                                                         device i2c 56 on end
                                                 end     
                                                 chip drivers/generic/generic #dimm 1-1-1
                                                         device i2c 57 on end
                                                 end 
 					end # SM
                                         device pci 1.1 on # SM 1
 #PCI device smbus address will depend on addon pci device, do we need to scan_smbus_bus?
 #                                                chip drivers/generic/generic #PCIXA Slot1
 #                                                        device i2c 50 on end
 #                                                end
 #                                                chip drivers/generic/generic #PCIXB Slot1
 #                                                        device i2c 51 on end
 #                                                end     
 #                                                chip drivers/generic/generic #PCIXB Slot2
 #                                                        device i2c 52 on end
 #                                                end             
 #                                                chip drivers/generic/generic #PCI Slot1
 #                                                        device i2c 53 on end
 #                                                end              
 #                                                chip drivers/generic/generic #Master CK804 PCI-E
 #                                                        device i2c 54 on end
 #                                                end     
 #                                                chip drivers/generic/generic #Slave CK804 PCI-E
 #                                                        device i2c 55 on end
 #                                                end             
                                                 chip drivers/generic/generic #MAC EEPROM
                                                         device i2c 51 on end
                                                 end 
 
                                         end # SM 
 	                		device pci 2.0 on end # USB 1.1
         	        		device pci 2.1 on end # USB 2
 	                		device pci 4.0 on end # ACI
         	        		device pci 4.1 off end # MCI
                 			device pci 6.0 on end # IDE
 	                		device pci 7.0 on end # SATA 1
         	        		device pci 8.0 on end # SATA 0
                 			device pci 9.0 on end # PCI
 	                		device pci a.0 on end # NIC
         	       			device pci b.0 off end # PCI E 3
                 			device pci c.0 off end # PCI E 2
                 			device pci d.0 off end # PCI E 1
                 			device pci e.0 on end # PCI E 0
 	                                register "ide0_enable" = "1"
         	                        register "ide1_enable" = "1"
                 	                register "sata0_enable" = "1"
                         	        register "sata1_enable" = "1"
 #					register "nic_rom_address" = "0xfff80000" # 64k
 #					register "raid_rom_address" = "0xfff90000"
 					register "mac_eeprom_smbus" = "3" # 1: smbus under 2e.8, 2: SM0 3: SM1
 					register "mac_eeprom_addr" = "0x51"
 				end
 			end #  device pci 18.0 
 			device pci 18.0 on end # link 2
 			device pci 18.1 on end
 			device pci 18.2 on end
 			device pci 18.3 on end
 		end # mc0
 		
 		chip northbridge/amd/amdk8
                 	device pci 19.0 on end # link 0
 		device pci 19.0 on   
                         	#  devices on link 1, link 1 == LDT 1
                         	chip southbridge/nvidia/ck804 
                                 	device pci 0.0 on end   # HT
                                 	device pci 1.0 on end   # LPC
                                 	device pci 1.1 off end # SM
                                 	device pci 2.0 off end # USB 1.1
                                 	device pci 2.1 off end # USB 2
                                 	device pci 4.0 off end # ACI
                                 	device pci 4.1 off end # MCI
                                 	device pci 6.0 off end # IDE
                                 	device pci 7.0 off end # SATA 1
                                 	device pci 8.0 off end # SATA 0
                                 	device pci 9.0 off end # PCI
                                 	device pci a.0 on end # NIC
                                 	device pci b.0 off end # PCI E 3
                                 	device pci c.0 off end # PCI E 2
                                 	device pci d.0 off end # PCI E 1
                                 	device pci e.0 on end # PCI E 0
 #					register "nic_rom_address" = "0xfff80000" # 64k
                                         register "mac_eeprom_smbus" = "3"
                                         register "mac_eeprom_addr" = "0x51"
                         	end
                 	end #  device pci 19.0 
 			
 			device pci 19.0 on end
 			device pci 19.1 on end
 			device pci 19.2 on end
 			device pci 19.3 on end
 		end
 	end # PCI domain
 	
 end #root_complex
diff --git a/src/mainboard/supermicro/x6dai_g/Config.lb b/src/mainboard/supermicro/x6dai_g/Config.lb
index 668824f..82f990c 100644
--- a/src/mainboard/supermicro/x6dai_g/Config.lb
+++ b/src/mainboard/supermicro/x6dai_g/Config.lb
@@ -1,198 +1,198 @@
 ##
 ## Only use the option table in a normal image
 ##
 default USE_OPTION_TABLE = !USE_FALLBACK_IMAGE
 
 ##
 ## Compute the location and size of where this firmware image
 ## (coreboot plus bootloader) will live in the boot rom chip.
 ##
 if USE_FALLBACK_IMAGE
 	default ROM_SECTION_SIZE   = FALLBACK_SIZE
 	default ROM_SECTION_OFFSET = ( ROM_SIZE - FALLBACK_SIZE )
 else
 	default ROM_SECTION_SIZE   = ( ROM_SIZE - FALLBACK_SIZE )
 	default ROM_SECTION_OFFSET = 0
 end
 
 ##
 ## Compute the start location and size size of
 ## The coreboot bootloader.
 ##
 default PAYLOAD_SIZE            = ( ROM_SECTION_SIZE - ROM_IMAGE_SIZE )
 default CONFIG_ROM_PAYLOAD_START = (0xffffffff - ROM_SIZE + ROM_SECTION_OFFSET + 1)
 
 ##
 ## Compute where this copy of coreboot will start in the boot rom
 ##
 default _ROMBASE      = ( CONFIG_ROM_PAYLOAD_START + PAYLOAD_SIZE )
 
 ##
 ## Compute a range of ROM that can be cached to speed up coreboot,
 ## execution speed.
 ##
 ## XIP_ROM_SIZE must be a power of 2.
 ## XIP_ROM_BASE must be a multiple of XIP_ROM_SIZE
 ##
 default XIP_ROM_SIZE=131072
 default XIP_ROM_BASE = ( _ROMBASE + ROM_IMAGE_SIZE - XIP_ROM_SIZE )
 
 ##
 ## Set all of the defaults for an x86 architecture
 ##
 
 arch i386 end
 
 ##
 ## Build the objects we have code for in this directory.
 ##
 
 driver mainboard.o
 if HAVE_MP_TABLE object mptable.o end
 if HAVE_PIRQ_TABLE object irq_tables.o end
 object reset.o
 
 ##
 ## Romcc output
 ##
 makerule ./failover.E
-	depends "$(MAINBOARD)/failover.c ./romcc" 
-	action "./romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+	depends "$(MAINBOARD)/failover.c ../romcc" 
+	action "../romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 end
 
 makerule ./failover.inc
-	depends "$(MAINBOARD)/failover.c ./romcc"
-	action "./romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+	depends "$(MAINBOARD)/failover.c ../romcc"
+	action "../romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 end
 
 makerule ./auto.E 
-	depends	"$(MAINBOARD)/auto.c option_table.h ./romcc" 
-	action	"./romcc -E -mcpu=p4 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	depends	"$(MAINBOARD)/auto.c option_table.h ../romcc" 
+	action	"../romcc -E -mcpu=p4 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 makerule ./auto.inc 
-	depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-	action	"./romcc    -mcpu=p4 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+	action	"../romcc    -mcpu=p4 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 
 ##
 ## Build our 16 bit and 32 bit coreboot entry code
 ##
 mainboardinit cpu/x86/16bit/entry16.inc
 mainboardinit cpu/x86/32bit/entry32.inc
 ldscript /cpu/x86/16bit/entry16.lds
 ldscript /cpu/x86/32bit/entry32.lds
 
 ##
 ## Build our reset vector (This is where coreboot is entered)
 ##
 if USE_FALLBACK_IMAGE 
 	mainboardinit cpu/x86/16bit/reset16.inc
 	ldscript /cpu/x86/16bit/reset16.lds
 else
 	mainboardinit cpu/x86/32bit/reset32.inc
 	ldscript /cpu/x86/32bit/reset32.lds
 end
 
 ### Should this be in the northbridge code?
 mainboardinit arch/i386/lib/cpu_reset.inc
 
 ##
 ## Include an id string (For safe flashing)
 ##
 mainboardinit arch/i386/lib/id.inc
 ldscript /arch/i386/lib/id.lds
 
 ###
 ### This is the early phase of coreboot startup 
 ### Things are delicate and we test to see if we should
 ### failover to another image.
 ###
 if USE_FALLBACK_IMAGE
 	ldscript /arch/i386/lib/failover.lds 
 	mainboardinit ./failover.inc
 end
 
 ###
 ### O.k. We aren't just an intermediary anymore!
 ###
 
 ##
 ## Setup RAM
 ##
 mainboardinit cpu/x86/fpu/enable_fpu.inc
 mainboardinit cpu/x86/mmx/enable_mmx.inc
 mainboardinit cpu/x86/sse/enable_sse.inc
 mainboardinit ./auto.inc
 mainboardinit cpu/x86/sse/disable_sse.inc
 mainboardinit cpu/x86/mmx/disable_mmx.inc
 
 ##
 ## Include the secondary Configuration files 
 ##
 dir /pc80
 config chip.h
 
 chip northbridge/intel/e7525 # mch
 	device pci_domain 0 on
 		chip southbridge/intel/esb6300  # esb6300 
 			register "pirq_a_d" = "0x0b0a0a05"
 			register "pirq_e_h" = "0x0a0b0c80"
 		
 			device pci 1c.0 on end
 		
 			device pci 1d.0 on end
 			device pci 1d.1 on end
 			device pci 1d.4 on end
 			device pci 1d.5 on end
 			device pci 1d.7 on end
 		
 			device pci 1e.0 on end
 		
 			device pci 1f.0 on 
 				chip superio/winbond/w83627hf
 					device pnp 2e.0 off end
 					device pnp 2e.1 off end
 					device pnp 2e.2 on
 						 io 0x60 = 0x3f8
 						irq 0x70 = 4
 					end
 					device pnp 2e.3 on
 						 io 0x60 = 0x2f8
 						irq 0x70 = 3
 					end
 					device pnp 2e.4 off end
 					device pnp 2e.5 off end
 					device pnp 2e.6 off end
 					device pnp 2e.7 off end
 					device pnp 2e.9 off end
 					device pnp 2e.a on  end
 					device pnp 2e.b off end
 					device pnp 2e.f off end
 					device pnp 2e.10 off end
 					device pnp 2e.14 off end
 				end
 			end
 			device pci 1f.1 on end
 			device pci 1f.2 on end
 			device pci 1f.3 on end
 			device pci 1f.5 off end
 			device pci 1f.6 on end
 		end
 		device pci 00.0 on end
 		device pci 00.1 on end 
 		device pci 00.2 on end
 		device pci 02.0 on end
 		device pci 03.0 on end
 		device pci 04.0 on end
 		device pci 08.0 on end
 	end
 	device apic_cluster 0 on
 		chip cpu/intel/socket_mPGA604_800Mhz # cpu0
 			device apic 0 on end
 		end
 		chip cpu/intel/socket_mPGA604_800Mhz # cpu1
 			device apic 6 on end
 		end
 	end
 end
 
diff --git a/src/mainboard/supermicro/x6dhe_g/Config.lb b/src/mainboard/supermicro/x6dhe_g/Config.lb
index 366a061..3176f51 100644
--- a/src/mainboard/supermicro/x6dhe_g/Config.lb
+++ b/src/mainboard/supermicro/x6dhe_g/Config.lb
@@ -1,220 +1,220 @@
 ##
 ## Only use the option table in a normal image
 ##
 default USE_OPTION_TABLE = !USE_FALLBACK_IMAGE
 
 ##
 ## Compute the location and size of where this firmware image
 ## (coreboot plus bootloader) will live in the boot rom chip.
 ##
 if USE_FALLBACK_IMAGE
 	default ROM_SECTION_SIZE   = FALLBACK_SIZE
 	default ROM_SECTION_OFFSET = ( ROM_SIZE - FALLBACK_SIZE )
 else
 	default ROM_SECTION_SIZE   = ( ROM_SIZE - FALLBACK_SIZE )
 	default ROM_SECTION_OFFSET = 0
 end
 
 ##
 ## Compute the start location and size size of
 ## The coreboot bootloader.
 ##
 default PAYLOAD_SIZE            = ( ROM_SECTION_SIZE - ROM_IMAGE_SIZE )
 default CONFIG_ROM_PAYLOAD_START = (0xffffffff - ROM_SIZE + ROM_SECTION_OFFSET + 1)
 
 ##
 ## Compute where this copy of coreboot will start in the boot rom
 ##
 default _ROMBASE	=( CONFIG_ROM_PAYLOAD_START + PAYLOAD_SIZE )
 
 ##
 ## Compute a range of ROM that can be cached to speed up coreboot.
 ## execution speed.
 ## XIP_ROM_SIZE must be a power of 2.
 ## XIP_ROM_BASE must be a multiple of XIP_ROM_SIZE
 default XIP_ROM_SIZE=131072
 default XIP_ROM_BASE= ( _ROMBASE + ROM_IMAGE_SIZE - XIP_ROM_SIZE )
 
 ##
 ## Set all of the defaults for an x86 architecture
 ##
 
 arch i386 end
 
 ##
 ## Build the objects we have code for in this directory.
 ##
 
 driver mainboard.o
 if HAVE_MP_TABLE object mptable.o end
 if HAVE_PIRQ_TABLE object irq_tables.o end
 object reset.o
 
 ##
 ## Romcc output
 ##
 makerule ./failover.E
-	depends "$(MAINBOARD)/failover.c ./romcc"
-	action "./romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+	depends "$(MAINBOARD)/failover.c ../romcc"
+	action "../romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 end
 
 makerule ./failover.inc
-	depends "$(MAINBOARD)/failover.c ./romcc"
-	action "./romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+	depends "$(MAINBOARD)/failover.c ../romcc"
+	action "../romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 end
 
 makerule ./auto.E 
-	depends	"$(MAINBOARD)/auto.c option_table.h ./romcc" 
-	action	"./romcc -E -mcpu=p4 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	depends	"$(MAINBOARD)/auto.c option_table.h ../romcc" 
+	action	"../romcc -E -mcpu=p4 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 
 makerule ./auto.inc 
-	depends	"$(MAINBOARD)/auto.c option_table.h ./romcc" 
-	action	"./romcc    -mcpu=p4 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	depends	"$(MAINBOARD)/auto.c option_table.h ../romcc" 
+	action	"../romcc    -mcpu=p4 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 
 ##
 ## Build our 16 bit and 32 bit coreboot entry code
 ##
 mainboardinit cpu/x86/16bit/entry16.inc
 mainboardinit cpu/x86/32bit/entry32.inc
 ldscript /cpu/x86/16bit/entry16.lds
 ldscript /cpu/x86/32bit/entry32.lds
 
 ##
 ## Build our reset vector (This is where coreboot is entered)
 ##
 if USE_FALLBACK_IMAGE 
 	mainboardinit cpu/x86/16bit/reset16.inc 
 	ldscript /cpu/x86/16bit/reset16.lds 
 else
 	mainboardinit cpu/x86/32bit/reset32.inc 
 	ldscript /cpu/x86/32bit/reset32.lds 
 end
 
 ### Should this be in the northbridge code?
 mainboardinit arch/i386/lib/cpu_reset.inc
 
 ##
 ## Include an id string (For safe flashing)
 ##
 mainboardinit arch/i386/lib/id.inc
 ldscript /arch/i386/lib/id.lds
 
 ###
 ### This is the early phase of coreboot startup 
 ### Things are delicate and we test to see if we should
 ### failover to another image.
 ###
 if USE_FALLBACK_IMAGE
 	ldscript /arch/i386/lib/failover.lds 
 	mainboardinit ./failover.inc
 end
 
 ###
 ### O.k. We aren't just an intermediary anymore!
 ###
 
 ##
 ## Setup RAM
 ##
 mainboardinit cpu/x86/fpu/enable_fpu.inc
 mainboardinit cpu/x86/mmx/enable_mmx.inc
 mainboardinit cpu/x86/sse/enable_sse.inc
 mainboardinit ./auto.inc
 mainboardinit cpu/x86/sse/disable_sse.inc
 mainboardinit cpu/x86/mmx/disable_mmx.inc
 
 
 ##
 ## Include the secondary Configuration files 
 ##
 dir /pc80
 config chip.h
 
 chip northbridge/intel/e7520  # MCH
 	chip drivers/generic/debug  # DEBUGGING
 		device pnp 00.0 on end
 		device pnp 00.1 off end
 		device pnp 00.2 off end
 		device pnp 00.3 off end
 	end
 	device pci_domain 0 on
 		chip southbridge/intel/esb6300	# ESB6300
 			register "pirq_a_d" = "0x0b070a05"
 			register "pirq_e_h" = "0x0a808080"
 
 			device pci 1c.0 on 
 				chip drivers/generic/generic 
 					device pci 01.0 on end	# onboard gige1
 					device pci 02.0 on end 	# onboard gige2
 				end
 			end
 
 			# USB ports
 			device pci 1d.0 on end
 			device pci 1d.1 on end
 			device pci 1d.4 on end	# Southbridge Watchdog timer
 			device pci 1d.5 on end	# Southbridge I/O apic1
 			device pci 1d.7 on end
 
 			# VGA / PCI 32-bit
 			device pci 1e.0 on 
 				chip drivers/generic/generic
 					device pci 01.0 on end 
 				end
 			end
 
 
 			device pci 1f.0 on 	# ISA bridge
 				chip superio/winbond/w83627hf
 					device pnp 2e.0 off end
 					device pnp 2e.2 on 
 						 io 0x60 = 0x3f8
 						irq 0x70 = 4
 					end
 					device pnp 2e.3 on
 						 io 0x60 = 0x2f8
 						irq 0x70 = 3
 					end
 					device pnp 2e.4 off end
 					device pnp 2e.5 off end
 					device pnp 2e.6 off end
 					device pnp 2e.7 off end
 					device pnp 2e.9 off end
 					device pnp 2e.a on end
 					device pnp 2e.b off end
 				end
 			end
 			device pci 1f.1 on end
 			device pci 1f.2 off end
 			device pci 1f.3	on end		# SMBus
 			device pci 1f.5 off end
 			device pci 1f.6 off end
 		end
 
 		device pci 00.0	on end	# Northbridge
 		device pci 00.1	on end  # Northbridge Error reporting
 		device pci 01.0 on end
 		device pci 02.0 on 
 			chip southbridge/intel/pxhd	# PXHD 6700 
 				device pci 00.0 on end   # bridge 
 				device pci 00.1 on end   # I/O apic
 				device pci 00.2 on end   # bridge
 				device pci 00.3 on end   # I/O apic
 			end
 		end
 #	 	device register "intrline" = "0x00070105" 
 		device 	pci 04.0 on end	
 		device 	pci 06.0 on end	
 	end
 
 	device apic_cluster 0 on
 		chip cpu/intel/socket_mPGA604_800Mhz  	# CPU 0
 			device apic 0 on end
 		end
 		chip cpu/intel/socket_mPGA604_800Mhz 	# CPU 1
 			device apic 6 on end
 		end
 	end
 end
diff --git a/src/mainboard/supermicro/x6dhe_g2/Config.lb b/src/mainboard/supermicro/x6dhe_g2/Config.lb
index 748cfde..5c69af1 100644
--- a/src/mainboard/supermicro/x6dhe_g2/Config.lb
+++ b/src/mainboard/supermicro/x6dhe_g2/Config.lb
@@ -1,220 +1,220 @@
 ##
 ## Only use the option table in a normal image
 ##
 default USE_OPTION_TABLE = !USE_FALLBACK_IMAGE
 
 ##
 ## Compute the location and size of where this firmware image
 ## (coreboot plus bootloader) will live in the boot rom chip.
 ##
 if USE_FALLBACK_IMAGE
 	default ROM_SECTION_SIZE   = FALLBACK_SIZE
 	default ROM_SECTION_OFFSET = ( ROM_SIZE - FALLBACK_SIZE )
 else
 	default ROM_SECTION_SIZE   = ( ROM_SIZE - FALLBACK_SIZE )
 	default ROM_SECTION_OFFSET = 0
 end
 
 ##
 ## Compute the start location and size size of
 ## The coreboot bootloader.
 ##
 default PAYLOAD_SIZE            = ( ROM_SECTION_SIZE - ROM_IMAGE_SIZE )
 default CONFIG_ROM_PAYLOAD_START = (0xffffffff - ROM_SIZE + ROM_SECTION_OFFSET + 1)
 
 ##
 ## Compute where this copy of coreboot will start in the boot rom
 ##
 default _ROMBASE	=( CONFIG_ROM_PAYLOAD_START + PAYLOAD_SIZE )
 
 ##
 ## Compute a range of ROM that can be cached to speed up coreboot.
 ## execution speed.
 ## XIP_ROM_SIZE must be a power of 2.
 ## XIP_ROM_BASE must be a multiple of XIP_ROM_SIZE
 default XIP_ROM_SIZE=131072
 default XIP_ROM_BASE= ( _ROMBASE + ROM_IMAGE_SIZE - XIP_ROM_SIZE )
 
 ##
 ## Set all of the defaults for an x86 architecture
 ##
 
 arch i386 end
 
 ##
 ## Build the objects we have code for in this directory.
 ##
 
 driver mainboard.o
 if HAVE_MP_TABLE object mptable.o end
 if HAVE_PIRQ_TABLE object irq_tables.o end
 object reset.o
 
 ##
 ## Romcc output
 ##
 makerule ./failover.E
-	depends "$(MAINBOARD)/failover.c ./romcc"
-	action "./romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+	depends "$(MAINBOARD)/failover.c ../romcc"
+	action "../romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 end
 
 makerule ./failover.inc
-	depends "$(MAINBOARD)/failover.c ./romcc"
-	action "./romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+	depends "$(MAINBOARD)/failover.c ../romcc"
+	action "../romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 end
 
 makerule ./auto.E 
-	depends	"$(MAINBOARD)/auto.c option_table.h ./romcc" 
-	action	"./romcc -E -mcpu=p4 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	depends	"$(MAINBOARD)/auto.c option_table.h ../romcc" 
+	action	"../romcc -E -mcpu=p4 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 
 makerule ./auto.inc 
-	depends	"$(MAINBOARD)/auto.c option_table.h ./romcc" 
-	action	"./romcc    -mcpu=p4 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	depends	"$(MAINBOARD)/auto.c option_table.h ../romcc" 
+	action	"../romcc    -mcpu=p4 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 
 ##
 ## Build our 16 bit and 32 bit coreboot entry code
 ##
 mainboardinit cpu/x86/16bit/entry16.inc
 mainboardinit cpu/x86/32bit/entry32.inc
 ldscript /cpu/x86/16bit/entry16.lds
 ldscript /cpu/x86/32bit/entry32.lds
 
 ##
 ## Build our reset vector (This is where coreboot is entered)
 ##
 if USE_FALLBACK_IMAGE 
 	mainboardinit cpu/x86/16bit/reset16.inc 
 	ldscript /cpu/x86/16bit/reset16.lds 
 else
 	mainboardinit cpu/x86/32bit/reset32.inc 
 	ldscript /cpu/x86/32bit/reset32.lds 
 end
 
 ### Should this be in the northbridge code?
 mainboardinit arch/i386/lib/cpu_reset.inc
 
 ##
 ## Include an id string (For safe flashing)
 ##
 mainboardinit arch/i386/lib/id.inc
 ldscript /arch/i386/lib/id.lds
 
 ###
 ### This is the early phase of coreboot startup 
 ### Things are delicate and we test to see if we should
 ### failover to another image.
 ###
 if USE_FALLBACK_IMAGE
 	ldscript /arch/i386/lib/failover.lds 
 	mainboardinit ./failover.inc
 end
 
 ###
 ### O.k. We aren't just an intermediary anymore!
 ###
 
 ##
 ## Setup RAM
 ##
 mainboardinit cpu/x86/fpu/enable_fpu.inc
 mainboardinit cpu/x86/mmx/enable_mmx.inc
 mainboardinit cpu/x86/sse/enable_sse.inc
 mainboardinit ./auto.inc
 mainboardinit cpu/x86/sse/disable_sse.inc
 mainboardinit cpu/x86/mmx/disable_mmx.inc
 
 
 ##
 ## Include the secondary Configuration files 
 ##
 dir /pc80
 config chip.h
 
 chip northbridge/intel/e7520  # MCH
 	chip drivers/generic/debug  # DEBUGGING
 		device pnp 00.0 off end
 		device pnp 00.1 off end
 		device pnp 00.2 off end
 		device pnp 00.3 off end
 	end
 	device pci_domain 0 on
 		chip southbridge/intel/i82801er	# ICH5R 
 			register "pirq_a_d" = "0x0b070a05"
 			register "pirq_e_h" = "0x0a808080"
 
 			device pci 1c.0 on 
 				chip drivers/generic/generic 
 					device pci 01.0 on end	# onboard gige1
 					device pci 02.0 on end 	# onboard gige2
 				end
 			end
 
 			# USB ports
 			device pci 1d.0 on end
 			device pci 1d.1 on end
 			device pci 1d.4 on end	# Southbridge Watchdog timer
 			device pci 1d.5 on end	# Southbridge I/O apic1
 			device pci 1d.7 on end
 
 			# VGA / PCI 32-bit
 			device pci 1e.0 on 
 				chip drivers/generic/generic
 					device pci 01.0 on end 
 				end
 			end
 
 
 			device pci 1f.0 on 	# ISA bridge
 				chip superio/nsc/pc87427
 					device pnp 2e.0 off end
 					device pnp 2e.2 on 
 						 io 0x60 = 0x3f8
 						irq 0x70 = 4
 					end
 					device pnp 2e.3 on
 						 io 0x60 = 0x2f8
 						irq 0x70 = 3
 					end
 					device pnp 2e.4 off end
 					device pnp 2e.5 off end
 					device pnp 2e.6 off end
 					device pnp 2e.7 off end
 					device pnp 2e.9 off end
 					device pnp 2e.a on end
 					device pnp 2e.b off end
 				end
 			end
 			device pci 1f.1 on end
 			device pci 1f.2 on end
 			device pci 1f.3	on end		# SMBus
 			device pci 1f.5 off end
 			device pci 1f.6 off end
 		end
 
 		device pci 00.0	on end	# Northbridge
 		device pci 00.1	on end  # Northbridge Error reporting
 		device pci 01.0 on end
 		device pci 02.0 on 
 			chip southbridge/intel/pxhd	# PXHD 6700 
 				device pci 00.0 on end   # bridge 
 				device pci 00.1 on end   # I/O apic
 				device pci 00.2 on end   # bridge
 				device pci 00.3 on end   # I/O apic
 			end
 		end
 #	 	device register "intrline" = "0x00070105" 
 		device 	pci 04.0 on end	
 		device 	pci 06.0 on end	
 	end
 
 	device apic_cluster 0 on
 		chip cpu/intel/socket_mPGA604_800Mhz  	# CPU 0
 			device apic 0 on end
 		end
 		chip cpu/intel/socket_mPGA604_800Mhz 	# CPU 1
 			device apic 6 on end
 		end
 	end
 end
diff --git a/src/mainboard/supermicro/x6dhr_ig/Config.lb b/src/mainboard/supermicro/x6dhr_ig/Config.lb
index abd07e7..ce9c538 100644
--- a/src/mainboard/supermicro/x6dhr_ig/Config.lb
+++ b/src/mainboard/supermicro/x6dhr_ig/Config.lb
@@ -1,218 +1,218 @@
 ##
 ## Only use the option table in a normal image
 ##
 default USE_OPTION_TABLE = !USE_FALLBACK_IMAGE
 
 ##
 ## Compute the location and size of where this firmware image
 ## (coreboot plus bootloader) will live in the boot rom chip.
 ##
 if USE_FALLBACK_IMAGE
 	default ROM_SECTION_SIZE   = FALLBACK_SIZE
 	default ROM_SECTION_OFFSET = ( ROM_SIZE - FALLBACK_SIZE )
 else
 	default ROM_SECTION_SIZE   = ( ROM_SIZE - FALLBACK_SIZE )
 	default ROM_SECTION_OFFSET = 0
 end
 
 ##
 ## Compute the start location and size size of
 ## The coreboot bootloader.
 ##
 default PAYLOAD_SIZE            = ( ROM_SECTION_SIZE - ROM_IMAGE_SIZE )
 default CONFIG_ROM_PAYLOAD_START = (0xffffffff - ROM_SIZE + ROM_SECTION_OFFSET + 1)
 
 ##
 ## Compute where this copy of coreboot will start in the boot rom
 ##
 default _ROMBASE      = ( CONFIG_ROM_PAYLOAD_START + PAYLOAD_SIZE )
 
 ##
 ## Compute a range of ROM that can cached to speed up coreboot,
 ## execution speed.
 ##
 ## XIP_ROM_SIZE must be a power of 2.
 ## XIP_ROM_BASE must be a multiple of XIP_ROM_SIZE
 ##
 default XIP_ROM_SIZE=131072
 default XIP_ROM_BASE = ( _ROMBASE + ROM_IMAGE_SIZE - XIP_ROM_SIZE )
 
 ##
 ## Set all of the defaults for an x86 architecture
 ##
 
 arch i386 end
 
 ##
 ## Build the objects we have code for in this directory.
 ##
 
 driver mainboard.o
 if HAVE_MP_TABLE object mptable.o end
 if HAVE_PIRQ_TABLE object irq_tables.o end
 object reset.o
 
 ##
 ## Romcc output
 ##
 makerule ./failover.E
-	depends "$(MAINBOARD)/failover.c ./romcc" 
-	action "./romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+	depends "$(MAINBOARD)/failover.c ../romcc" 
+	action "../romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 end
 
 makerule ./failover.inc
-	depends "$(MAINBOARD)/failover.c ./romcc"
-	action "./romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+	depends "$(MAINBOARD)/failover.c ../romcc"
+	action "../romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 end
 
 makerule ./auto.E 
-	depends	"$(MAINBOARD)/auto.c option_table.h ./romcc" 
-	action	"./romcc -E -mcpu=p4 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	depends	"$(MAINBOARD)/auto.c option_table.h ../romcc" 
+	action	"../romcc -E -mcpu=p4 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 makerule ./auto.inc 
-	depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-	action	"./romcc    -mcpu=p4 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+	action	"../romcc    -mcpu=p4 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 
 ##
 ## Build our 16 bit and 32 bit coreboot entry code
 ##
 mainboardinit cpu/x86/16bit/entry16.inc
 mainboardinit cpu/x86/32bit/entry32.inc
 ldscript /cpu/x86/16bit/entry16.lds
 ldscript /cpu/x86/32bit/entry32.lds
 
 ##
 ## Build our reset vector (This is where coreboot is entered)
 ##
 if USE_FALLBACK_IMAGE 
 	mainboardinit cpu/x86/16bit/reset16.inc
 	ldscript /cpu/x86/16bit/reset16.lds
 else
 	mainboardinit cpu/x86/32bit/reset32.inc
 	ldscript /cpu/x86/32bit/reset32.lds
 end
 
 ### Should this be in the northbridge code?
 mainboardinit arch/i386/lib/cpu_reset.inc
 
 ##
 ## Include an id string (For safe flashing)
 ##
 mainboardinit arch/i386/lib/id.inc
 ldscript /arch/i386/lib/id.lds
 
 ###
 ### This is the early phase of coreboot startup 
 ### Things are delicate and we test to see if we should
 ### failover to another image.
 ###
 if USE_FALLBACK_IMAGE
 	ldscript /arch/i386/lib/failover.lds 
 	mainboardinit ./failover.inc
 end
 
 ###
 ### O.k. We aren't just an intermediary anymore!
 ###
 
 ##
 ## Setup RAM
 ##
 mainboardinit cpu/x86/fpu/enable_fpu.inc
 mainboardinit cpu/x86/mmx/enable_mmx.inc
 mainboardinit cpu/x86/sse/enable_sse.inc
 mainboardinit ./auto.inc
 mainboardinit cpu/x86/sse/disable_sse.inc
 mainboardinit cpu/x86/mmx/disable_mmx.inc
 
 ##
 ## Include the secondary Configuration files 
 ##
 dir /pc80
 config chip.h
 
 chip northbridge/intel/e7520 # mch
 	device pci_domain 0 on 
 		chip southbridge/intel/i82801er # i82801er
 			# USB ports
 			device pci 1d.0 on end
 			device pci 1d.1 on end
 			device pci 1d.2 on end 
 			device pci 1d.3 on end
 			device pci 1d.7 on end
 		
 			# -> VGA
 			device pci 1e.0 on end
 		
 			# -> IDE
 			device pci 1f.0 on 
 				chip superio/winbond/w83627hf
 					device pnp 2e.0 off end
 					device pnp 2e.2 on 
 						 io 0x60 = 0x3f8
 						irq 0x70 = 4
 					end
 					device pnp 2e.3 on
 						 io 0x60 = 0x2f8
 						irq 0x70 = 3
 					end
 					device pnp 2e.4 off end
 					device pnp 2e.5 off end
 					device pnp 2e.6 off end
 					device pnp 2e.7 off end
 					device pnp 2e.9 off end
 					device pnp 2e.a on  end
 					device pnp 2e.b off end
 				end
 			end
 			device pci 1f.1 on end
 			device pci 1f.2 on end
 			device pci 1f.3 on end
 
 			register "pirq_a_d" = "0x0b070a05"
 			register "pirq_e_h" = "0x0a808080"
 		end
 		device pci 00.0 on end 
 		device pci 00.1  on end
 		device pci 01.0 on end 
 		device pci 02.0 on end 
 		device pci 03.0 on 
 			chip southbridge/intel/pxhd # pxhd1
 				# Bus bridges and ioapics usually bus 2
 				device pci 0.0 on end
 				device pci 0.1 on end
 				device pci 0.2 on 
 				# On board gig e1000
 					chip drivers/generic/generic 
         		        	        device pci 02.0 on end
         		        	        device pci 02.1 on end
         		        	end
 				end
 				device pci 0.3 on end
 			end
 		end
 		device pci 04.0 on 
 			chip southbridge/intel/pxhd # pxhd2
 				# Bus bridges and ioapics usually bus 5
 				device pci 0.0 on end
 				# Slot 6  is usually 6:2.0
 				device pci 0.1 on end
 				device pci 0.2 on end
 				# Slot 7 is usually 7:2.0
 				device pci 0.3 on end
 			end
 		end
 		device pci 06.0 on end
 	end
 	device apic_cluster 0 on
 		chip cpu/intel/socket_mPGA604_800Mhz # cpu 0
 			device apic 0 on end
 		end
 		chip cpu/intel/socket_mPGA604_800Mhz # cpu 1
 			device apic 6 on end
 		end
 	end
 	register "intrline" = "0x00070105"
 end
 
diff --git a/src/mainboard/supermicro/x6dhr_ig2/Config.lb b/src/mainboard/supermicro/x6dhr_ig2/Config.lb
index ad9b6d0..aa3d456 100644
--- a/src/mainboard/supermicro/x6dhr_ig2/Config.lb
+++ b/src/mainboard/supermicro/x6dhr_ig2/Config.lb
@@ -1,209 +1,209 @@
 ##
 ## Only use the option table in a normal image
 ##
 default USE_OPTION_TABLE = !USE_FALLBACK_IMAGE
 
 ##
 ## Compute the location and size of where this firmware image
 ## (coreboot plus bootloader) will live in the boot rom chip.
 ##
 if USE_FALLBACK_IMAGE
 	default ROM_SECTION_SIZE   = FALLBACK_SIZE
 	default ROM_SECTION_OFFSET = ( ROM_SIZE - FALLBACK_SIZE )
 else
 	default ROM_SECTION_SIZE   = ( ROM_SIZE - FALLBACK_SIZE )
 	default ROM_SECTION_OFFSET = 0
 end
 
 ##
 ## Compute the start location and size size of
 ## The coreboot bootloader.
 ##
 default PAYLOAD_SIZE            = ( ROM_SECTION_SIZE - ROM_IMAGE_SIZE )
 default CONFIG_ROM_PAYLOAD_START = (0xffffffff - ROM_SIZE + ROM_SECTION_OFFSET + 1)
 
 ##
 ## Compute where this copy of coreboot will start in the boot rom
 ##
 default _ROMBASE      = ( CONFIG_ROM_PAYLOAD_START + PAYLOAD_SIZE )
 
 ##
 ## Compute a range of ROM that can cached to speed up coreboot,
 ## execution speed.
 ##
 ## XIP_ROM_SIZE must be a power of 2.
 ## XIP_ROM_BASE must be a multiple of XIP_ROM_SIZE
 ##
 default XIP_ROM_SIZE=131072
 default XIP_ROM_BASE = ( _ROMBASE + ROM_IMAGE_SIZE - XIP_ROM_SIZE )
 
 ##
 ## Set all of the defaults for an x86 architecture
 ##
 
 arch i386 end
 
 ##
 ## Build the objects we have code for in this directory.
 ##
 
 driver mainboard.o
 if HAVE_MP_TABLE object mptable.o end
 if HAVE_PIRQ_TABLE object irq_tables.o end
 object reset.o
 
 ##
 ## Romcc output
 ##
 makerule ./failover.E
-	depends "$(MAINBOARD)/failover.c ./romcc" 
-	action "./romcc -fno-simplify-phi -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+	depends "$(MAINBOARD)/failover.c ../romcc" 
+	action "../romcc -fno-simplify-phi -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 end
 
 makerule ./failover.inc
-	depends "$(MAINBOARD)/failover.c ./romcc"
-	action "./romcc -fno-simplify-phi -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+	depends "$(MAINBOARD)/failover.c ../romcc"
+	action "../romcc -fno-simplify-phi -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 end
 
 makerule ./auto.E 
-	depends	"$(MAINBOARD)/auto.c option_table.h ./romcc" 
-	action	"./romcc -fno-simplify-phi -E -mcpu=p4 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	depends	"$(MAINBOARD)/auto.c option_table.h ../romcc" 
+	action	"../romcc -fno-simplify-phi -E -mcpu=p4 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 makerule ./auto.inc 
-	depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-	action	"./romcc -fno-simplify-phi -mcpu=p4 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+	action	"../romcc -fno-simplify-phi -mcpu=p4 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 
 ##
 ## Build our 16 bit and 32 bit coreboot entry code
 ##
 mainboardinit cpu/x86/16bit/entry16.inc
 mainboardinit cpu/x86/32bit/entry32.inc
 ldscript /cpu/x86/16bit/entry16.lds
 ldscript /cpu/x86/32bit/entry32.lds
 
 ##
 ## Build our reset vector (This is where coreboot is entered)
 ##
 if USE_FALLBACK_IMAGE 
 	mainboardinit cpu/x86/16bit/reset16.inc
 	ldscript /cpu/x86/16bit/reset16.lds
 else
 	mainboardinit cpu/x86/32bit/reset32.inc
 	ldscript /cpu/x86/32bit/reset32.lds
 end
 
 ### Should this be in the northbridge code?
 mainboardinit arch/i386/lib/cpu_reset.inc
 
 ##
 ## Include an id string (For safe flashing)
 ##
 mainboardinit arch/i386/lib/id.inc
 ldscript /arch/i386/lib/id.lds
 
 ###
 ### This is the early phase of coreboot startup 
 ### Things are delicate and we test to see if we should
 ### failover to another image.
 ###
 if USE_FALLBACK_IMAGE
 	ldscript /arch/i386/lib/failover.lds 
 	mainboardinit ./failover.inc
 end
 
 ###
 ### O.k. We aren't just an intermediary anymore!
 ###
 
 ##
 ## Setup RAM
 ##
 mainboardinit cpu/x86/fpu/enable_fpu.inc
 mainboardinit cpu/x86/mmx/enable_mmx.inc
 mainboardinit cpu/x86/sse/enable_sse.inc
 mainboardinit ./auto.inc
 mainboardinit cpu/x86/sse/disable_sse.inc
 mainboardinit cpu/x86/mmx/disable_mmx.inc
 
 ##
 ## Include the secondary Configuration files 
 ##
 dir /pc80
 config chip.h
 
 chip northbridge/intel/e7520 # mch
 	device pci_domain 0 on 
 		chip southbridge/intel/i82801er # i82801er
 			# USB ports
 			device pci 1d.0 on end
 			device pci 1d.1 on end
 			device pci 1d.2 on end 
 			device pci 1d.3 on end
 			device pci 1d.7 on end
 		
 			# -> Bridge
 			device pci 1e.0 on end
 		
 			# -> ISA
 			device pci 1f.0 on 
 				chip superio/winbond/w83627hf
 					device pnp 2e.0 off end
 					device pnp 2e.2 on 
 						 io 0x60 = 0x3f8
 						irq 0x70 = 4
 					end
 					device pnp 2e.3 on
 						 io 0x60 = 0x2f8
 						irq 0x70 = 3
 					end
 					device pnp 2e.4 off end
 					device pnp 2e.5 off end
 					device pnp 2e.6 off end
 					device pnp 2e.7 off end
 					device pnp 2e.9 off end
 					device pnp 2e.a on  end
 					device pnp 2e.b off end
 				end
 			end
 			# -> IDE
 			device pci 1f.1 on end
 			# -> SATA 
 			device pci 1f.2 on end
 			device pci 1f.3 on end
 
 			register "pirq_a_d" = "0x0b070a05"
 			register "pirq_e_h" = "0x0a808080"
 		end
 		device pci 00.0 on end 
 		device pci 00.1 on end
 		device pci 01.0 on end 
 		device pci 02.0 on 
 			chip southbridge/intel/pxhd # pxhd1
 				# Bus bridges and ioapics usually bus 1
 				device pci 0.0 on 
 				# On board gig e1000
 					chip drivers/generic/generic 
         		        	        device pci 03.0 on end
         		        	        device pci 03.1 on end
         		        	end
 				end
 				device pci 0.1 on end
 				device pci 0.2 on end
 				device pci 0.3 on end
 			end
 		end
 		device pci 04.0 on end
 		device pci 06.0 on end
 	end
 	device apic_cluster 0 on
 		chip cpu/intel/socket_mPGA604_800Mhz # cpu 0
 			device apic 0 on end
 		end
 		chip cpu/intel/socket_mPGA604_800Mhz # cpu 1
 			device apic 6 on end
 		end
 	end
 	register "intrline" = "0x00070105"
 end
 
diff --git a/src/mainboard/technologic/ts5300/Config.lb b/src/mainboard/technologic/ts5300/Config.lb
index 95dc254..8643472 100644
--- a/src/mainboard/technologic/ts5300/Config.lb
+++ b/src/mainboard/technologic/ts5300/Config.lb
@@ -1,148 +1,148 @@
 ##
 ## Compute the location and size of where this firmware image
 ## (coreboot plus bootloader) will live in the boot rom chip.
 ##
 default ROM_SIZE = 128 * 1024 
 default FALLBACK_SIZE = 0x10000
 if USE_FALLBACK_IMAGE
 	default ROM_SECTION_SIZE   = FALLBACK_SIZE
 	default ROM_SECTION_OFFSET = ( ROM_SIZE - FALLBACK_SIZE )
 else
 	default ROM_SECTION_SIZE   = ( ROM_SIZE - FALLBACK_SIZE )
 	default ROM_SECTION_OFFSET = 0
 end
 
 ##
 ## Compute the start location and size size of
 ## The coreboot bootloader.
 ##
 default PAYLOAD_SIZE            = ( ROM_SECTION_SIZE - ROM_IMAGE_SIZE )
 default CONFIG_ROM_PAYLOAD_START = (0xffffffff - ROM_SIZE + ROM_SECTION_OFFSET + 1)
 
 ##
 ## Compute where this copy of coreboot will start in the boot rom
 ##
 default _ROMBASE      = ( CONFIG_ROM_PAYLOAD_START + PAYLOAD_SIZE )
 
 ##
 ## Compute a range of ROM that can cached to speed up coreboot,
 ## execution speed.
 ##
 ## XIP_ROM_SIZE must be a power of 2.
 ## XIP_ROM_BASE must be a multiple of XIP_ROM_SIZE
 ##
 default XIP_ROM_SIZE=32*1024
 default XIP_ROM_BASE = ( _ROMBASE + ROM_IMAGE_SIZE - XIP_ROM_SIZE )
 
 ##
 ## Set all of the defaults for an x86 architecture
 ##
 
 arch i386 end
 
 ##
 ## Build the objects we have code for in this directory.
 ##
 
 driver mainboard.o
 if HAVE_PIRQ_TABLE object irq_tables.o end
 object reset.o
 
 ##
 ## Romcc output
 ##
 makerule ./failover.E
-	depends "$(MAINBOARD)/failover.c ./romcc" 
-	action "./romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+	depends "$(MAINBOARD)/failover.c ../romcc" 
+	action "../romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 end
 
 makerule ./failover.inc
-	depends "$(MAINBOARD)/failover.c ./romcc"
-	action "./romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+	depends "$(MAINBOARD)/failover.c ../romcc"
+	action "../romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 end
 
 makerule ./auto.E 
-	depends	"$(MAINBOARD)/auto.c option_table.h ./romcc" 
-	action	"./romcc -E -mcpu=i386 -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	depends	"$(MAINBOARD)/auto.c option_table.h ../romcc" 
+	action	"../romcc -E -mcpu=i386 -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 makerule ./auto.inc 
-	depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-	action	"./romcc    -mcpu=i386 -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+	action	"../romcc    -mcpu=i386 -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 
 ##
 ## Build our 16 bit and 32 bit coreboot entry code
 ##
 mainboardinit cpu/x86/16bit/entry16.inc
 mainboardinit cpu/x86/32bit/entry32.inc
 ldscript /cpu/x86/16bit/entry16.lds
 ldscript /cpu/x86/32bit/entry32.lds
 
 ##
 ## Build our reset vector (This is where coreboot is entered)
 ##
 if USE_FALLBACK_IMAGE 
 	mainboardinit cpu/x86/16bit/reset16.inc 
 	ldscript /cpu/x86/16bit/reset16.lds 
 else
 	mainboardinit cpu/x86/32bit/reset32.inc 
 	ldscript /cpu/x86/32bit/reset32.lds 
 end
 
 ### Should this be in the northbridge code?
 mainboardinit arch/i386/lib/cpu_reset.inc
 
 ##
 ## Include an id string (For safe flashing)
 ##
 mainboardinit arch/i386/lib/id.inc
 ldscript /arch/i386/lib/id.lds
 
 ###
 ### This is the early phase of coreboot startup 
 ### Things are delicate and we test to see if we should
 ### failover to another image.
 ###
 if USE_FALLBACK_IMAGE
 	ldscript /arch/i386/lib/failover.lds 
 	mainboardinit ./failover.inc
 end
 
 
 # VGA console
 #if CONFIG_CONSOLE_VGA
 #	default CONFIG_PCI_ROM_RUN=1
 #end
 ###
 ### O.k. We aren't just an intermediary anymore!
 ###
 
 ##
 ## Setup RAM
 ##
 mainboardinit cpu/x86/fpu/enable_fpu.inc
 mainboardinit ./auto.inc
 
 ##
 ## Include the secondary Configuration files 
 ##
 dir /pc80
 dir /devices
 config chip.h
 
 chip cpu/amd/sc520
 	device pci_domain 0 on 
 		device pci 0.0 on end
 	
 #		chip drivers/pci/onboard
 #			device pci 12.0 on end # enet
 #		end
 #		chip drivers/pci/onboard
 #			device pci 14.0 on end # 69000
 #			register "rom_address" = "0x2000000"
 #		end
 #		register "com1" = "{1}"
 #		register "com1" = "{1, 0, 0x3f8, 4}"
 	end
 
 end
diff --git a/src/mainboard/televideo/tc7020/Config.lb b/src/mainboard/televideo/tc7020/Config.lb
index 6792d43..768aeb1 100644
--- a/src/mainboard/televideo/tc7020/Config.lb
+++ b/src/mainboard/televideo/tc7020/Config.lb
@@ -1,138 +1,138 @@
 ##
 ## This file is part of the coreboot project.
 ##
 ## Copyright (C) 2007 Kenji Noguchi <tokoy246@gmail.com>
 ##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2 of the License, or
 ## (at your option) any later version.
 ##
 ## This program is distributed in the hope that it will be useful,
 ## but WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ## GNU General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this program; if not, write to the Free Software
 ## Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 ##
 
 if USE_FALLBACK_IMAGE
 	default ROM_SECTION_SIZE = FALLBACK_SIZE
 	default ROM_SECTION_OFFSET = (ROM_SIZE - FALLBACK_SIZE)
 else
 	default ROM_SECTION_SIZE = (ROM_SIZE - FALLBACK_SIZE)
 	default ROM_SECTION_OFFSET = 0
 end
 default CONFIG_ROM_PAYLOAD_START = (0xffffffff - ROM_SIZE + ROM_SECTION_OFFSET + 1)
 default PAYLOAD_SIZE = (ROM_SECTION_SIZE - ROM_IMAGE_SIZE)
 default _ROMBASE = (CONFIG_ROM_PAYLOAD_START + PAYLOAD_SIZE)
 default XIP_ROM_SIZE = 64 * 1024
 default XIP_ROM_BASE = (_ROMBASE + ROM_IMAGE_SIZE - XIP_ROM_SIZE)
 arch i386 end
 driver mainboard.o
 if HAVE_PIRQ_TABLE
 	object irq_tables.o
 end
 makerule ./failover.E
-	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ./romcc"
-	action "./romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
+	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ../romcc"
+	action "../romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
 end
 makerule ./failover.inc
-	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ./romcc"
-	action "./romcc -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
+	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ../romcc"
+	action "../romcc -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
 end
 makerule ./auto.E
-	# depends	"$(MAINBOARD)/auto.c option_table.h ./romcc"
-	depends	"$(MAINBOARD)/auto.c ./romcc"
-	action	"./romcc -E -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	# depends	"$(MAINBOARD)/auto.c option_table.h ../romcc"
+	depends	"$(MAINBOARD)/auto.c ../romcc"
+	action	"../romcc -E -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 makerule ./auto.inc
-	# depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-	depends "$(MAINBOARD)/auto.c ./romcc"
-	action	"./romcc -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	# depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+	depends "$(MAINBOARD)/auto.c ../romcc"
+	action	"../romcc -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 mainboardinit cpu/x86/16bit/entry16.inc
 mainboardinit cpu/x86/32bit/entry32.inc
 ldscript /cpu/x86/16bit/entry16.lds
 ldscript /cpu/x86/32bit/entry32.lds
 if USE_FALLBACK_IMAGE
 	mainboardinit cpu/x86/16bit/reset16.inc
 	ldscript /cpu/x86/16bit/reset16.lds
 else
 	mainboardinit cpu/x86/32bit/reset32.inc
 	ldscript /cpu/x86/32bit/reset32.lds
 end
 mainboardinit arch/i386/lib/cpu_reset.inc
 mainboardinit arch/i386/lib/id.inc
 ldscript /arch/i386/lib/id.lds
 if USE_FALLBACK_IMAGE
 	ldscript /arch/i386/lib/failover.lds
 	mainboardinit ./failover.inc
 end
 mainboardinit cpu/x86/fpu/enable_fpu.inc
 mainboardinit cpu/amd/model_gx1/cpu_setup.inc
 mainboardinit cpu/amd/model_gx1/gx_setup.inc
 mainboardinit ./auto.inc
 
 dir /pc80
 config chip.h
 
 chip northbridge/amd/gx1		# Northbridge
   device pci_domain 0 on		# PCI domain
     device pci 0.0 on end		# Host bridge
     chip southbridge/amd/cs5530		# Southbridge
       device pci 12.0 on		# ISA bridge
         chip superio/nsc/pc97317	# Super I/O
           device pnp 2e.0 on		# PS/2 keyboard
             io 0x60 = 0x60
             io 0x62 = 0x64
             irq 0x70 = 1
           end
           device pnp 2e.1 on		# PS/2 mouse
             irq 0x70 = 12
           end
           device pnp 2e.2 on		# RTC, Advanced power control (APC)
             io 0x60 = 0x70
             irq 0x70 = 8
           end
           device pnp 2e.3 off		# Floppy (N/A on this board)
             io 0x60 = 0x3f0
             irq 0x70 = 6
             drq 0x74 = 2
           end
           device pnp 2e.4 on		# Parallel port
             io 0x60 = 0x378
             irq 0x70 = 7
           end
           device pnp 2e.5 on		# COM2
             io 0x60 = 0x2f8
             irq 0x70 = 3
           end
           device pnp 2e.6 on		# COM1
             io 0x60 = 0x3f8
             irq 0x70 = 4
           end
           device pnp 2e.7 on		# GPIO
             io 0x60 = 0xe0
           end
           device pnp 2e.8 on		# Power management
             io 0x60 = 0xe8
           end
         end
       end
       device pci 12.1 off end		# SMI
       device pci 12.2 on end		# IDE
       device pci 12.3 on end		# Audio
       device pci 12.4 on end		# VGA (onboard)
       device pci 13.0 on end		# USB
       device pci 14.0 on end		# MiniPCI slot
       device pci 15.0 on end		# Ethernet (onboard)
       register "ide0_enable" = "1"
       register "ide1_enable" = "0"	# Not available/needed on this board
     end
   end
   chip cpu/amd/model_gx1		# CPU
   end
 end
diff --git a/src/mainboard/thomson/ip1000/Config.lb b/src/mainboard/thomson/ip1000/Config.lb
index 9405695..52e6e1a 100644
--- a/src/mainboard/thomson/ip1000/Config.lb
+++ b/src/mainboard/thomson/ip1000/Config.lb
@@ -1,145 +1,145 @@
 ##
 ## This file is part of the coreboot project.
 ##
 ## Copyright (C) 2008 Joseph Smith <joe@settoplinux.org>
 ##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2 of the License, or
 ## (at your option) any later version.
 ##
 ## This program is distributed in the hope that it will be useful,
 ## but WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ## GNU General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this program; if not, write to the Free Software
 ## Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 ##
 
 if USE_FALLBACK_IMAGE
 	default ROM_SECTION_SIZE = FALLBACK_SIZE
 	default ROM_SECTION_OFFSET = (ROM_SIZE - FALLBACK_SIZE)
 else
 	default ROM_SECTION_SIZE = (ROM_SIZE - FALLBACK_SIZE)
 	default ROM_SECTION_OFFSET = 0
 end
 default CONFIG_ROM_PAYLOAD_START = (0xffffffff - ROM_SIZE + ROM_SECTION_OFFSET + 1)
 default PAYLOAD_SIZE = (ROM_SECTION_SIZE - ROM_IMAGE_SIZE)
 default _ROMBASE = (CONFIG_ROM_PAYLOAD_START + PAYLOAD_SIZE)
 default XIP_ROM_SIZE = 65536
 default XIP_ROM_BASE = (_ROMBASE + ROM_IMAGE_SIZE - XIP_ROM_SIZE)
 arch i386 end
 driver mainboard.o
 if HAVE_PIRQ_TABLE object irq_tables.o end
 # object reset.o
 if HAVE_ACPI_TABLES
 	object fadt.o
 	object dsdt.o
 	object acpi_tables.o
 end
 makerule ./failover.E
-	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ./romcc"
-	action "./romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
+	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ../romcc"
+	action "../romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
 end
 makerule ./failover.inc
-	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ./romcc"
-	action "./romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
+	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ../romcc"
+	action "../romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
 end
 makerule ./auto.E
-	# depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-	depends	"$(MAINBOARD)/auto.c ./romcc"
-	action	"./romcc -E -mcpu=p3 -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	# depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+	depends	"$(MAINBOARD)/auto.c ../romcc"
+	action	"../romcc -E -mcpu=p3 -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 makerule ./auto.inc 
-	# depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-	depends	"$(MAINBOARD)/auto.c ./romcc"
-	action	"./romcc    -mcpu=p3 -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	# depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+	depends	"$(MAINBOARD)/auto.c ../romcc"
+	action	"../romcc    -mcpu=p3 -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 mainboardinit cpu/x86/16bit/entry16.inc
 mainboardinit cpu/x86/32bit/entry32.inc
 ldscript /cpu/x86/16bit/entry16.lds
 ldscript /cpu/x86/32bit/entry32.lds
 if USE_FALLBACK_IMAGE
 	mainboardinit cpu/x86/16bit/reset16.inc
 	ldscript /cpu/x86/16bit/reset16.lds
 else
 	mainboardinit cpu/x86/32bit/reset32.inc
 	ldscript /cpu/x86/32bit/reset32.lds
 end
 mainboardinit arch/i386/lib/cpu_reset.inc
 mainboardinit arch/i386/lib/id.inc
 ldscript /arch/i386/lib/id.lds
 if USE_FALLBACK_IMAGE
 	ldscript /arch/i386/lib/failover.lds
 	mainboardinit ./failover.inc
 end
 mainboardinit cpu/x86/fpu/enable_fpu.inc
 mainboardinit cpu/x86/mmx/enable_mmx.inc
 mainboardinit ./auto.inc
 mainboardinit cpu/x86/mmx/disable_mmx.inc
 dir /pc80
 config chip.h
 
 chip northbridge/intel/i82830		# Northbridge
   device pci_domain 0 on		# PCI domain
     device pci 0.0 on end		# Host bridge
     chip drivers/pci/onboard		# Onboard VGA
       device pci 2.0 on end		# VGA (Intel 82830 CGC)
       register "rom_address" = "0xfff00000"
     end
     chip southbridge/intel/i82801xx	# Southbridge
       device pci 1d.0 on end		# USB UHCI Controller #1
       device pci 1d.1 on end		# USB UHCI Controller #2
       device pci 1d.2 on end		# USB UHCI Controller #3
       device pci 1d.7 on end		# USB2 EHCI Controller
       device pci 1e.0 on		# PCI bridge
         device pci 08.0 on end		# Intel 82801DB PRO/100 VE Ethernet
       end
       device pci 1f.0 on		# ISA/LPC bridge
         chip superio/smsc/smscsuperio	# Super I/O
           device pnp 2e.0 off		# Floppy
             io 0x60 = 0x3f0
             irq 0x70 = 6
             drq 0x74 = 2
           end
           device pnp 2e.3 on		# Parallel port
             io 0x60 = 0x378
             irq 0x70 = 7
             drq 0x74 = 4
           end
           device pnp 2e.4 on		# Com1
             io 0x60 = 0x3f8
             irq 0x70 = 4
           end
           device pnp 2e.5 on		# Com2 / IR
             io 0x60 = 0x2f8
             irq 0x70 = 3
           end
           device pnp 2e.7 on		# PS/2 keyboard/mouse
             io 0x60 = 0x60
             io 0x62 = 0x64
             irq 0x70 = 1		# Keyboard interrupt
             irq 0x72 = 12		# Mouse interrupt
           end
           device pnp 2e.9 off end	# Game port
           device pnp 2e.a on		# PME
             io 0x60 = 0x800
           end
           device pnp 2e.b off end	# MPU-401
         end
       end
       device pci 1f.1 on end		# IDE
       device pci 1f.3 on end		# SMBus
       device pci 1f.5 on end		# AC'97 audio
       device pci 1f.6 off end		# AC'97 modem
     end
   end
   device apic_cluster 0 on		# APIC cluster
     chip cpu/intel/socket_PGA370	# Low Voltage PIII Micro-FCBGA Socket 479
       device apic 0 on end		# APIC
     end
   end
 end
 
diff --git a/src/mainboard/tyan/s1846/Config.lb b/src/mainboard/tyan/s1846/Config.lb
index fe7813e..47e54cd 100644
--- a/src/mainboard/tyan/s1846/Config.lb
+++ b/src/mainboard/tyan/s1846/Config.lb
@@ -1,137 +1,137 @@
 ##
 ## This file is part of the coreboot project.
 ##
 ## Copyright (C) 2007 Uwe Hermann <uwe@hermann-uwe.de>
 ##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2 of the License, or
 ## (at your option) any later version.
 ##
 ## This program is distributed in the hope that it will be useful,
 ## but WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ## GNU General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this program; if not, write to the Free Software
 ## Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 ##
 
 if USE_FALLBACK_IMAGE
 	default ROM_SECTION_SIZE = FALLBACK_SIZE
 	default ROM_SECTION_OFFSET = (ROM_SIZE - FALLBACK_SIZE)
 else
 	default ROM_SECTION_SIZE = (ROM_SIZE - FALLBACK_SIZE)
 	default ROM_SECTION_OFFSET = 0
 end
 default CONFIG_ROM_PAYLOAD_START = (0xffffffff - ROM_SIZE
 				    + ROM_SECTION_OFFSET + 1)
 default PAYLOAD_SIZE = (ROM_SECTION_SIZE - ROM_IMAGE_SIZE)
 default _ROMBASE = (CONFIG_ROM_PAYLOAD_START + PAYLOAD_SIZE)
 default XIP_ROM_SIZE = 64 * 1024
 default XIP_ROM_BASE = (_ROMBASE + ROM_IMAGE_SIZE - XIP_ROM_SIZE)
 arch i386 end
 driver mainboard.o
 if HAVE_PIRQ_TABLE
 	object irq_tables.o
 end
 makerule ./failover.E
-	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ./romcc"
-	action "./romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
+	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ../romcc"
+	action "../romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
 end
 makerule ./failover.inc
-	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ./romcc"
-	action "./romcc -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
+	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ../romcc"
+	action "../romcc -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
 end
 makerule ./auto.E
-	# depends	"$(MAINBOARD)/auto.c option_table.h ./romcc"
-	depends	"$(MAINBOARD)/auto.c ./romcc"
-	action	"./romcc -E -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	# depends	"$(MAINBOARD)/auto.c option_table.h ../romcc"
+	depends	"$(MAINBOARD)/auto.c ../romcc"
+	action	"../romcc -E -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 makerule ./auto.inc
-	# depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-	depends "$(MAINBOARD)/auto.c ./romcc"
-	action	"./romcc -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	# depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+	depends "$(MAINBOARD)/auto.c ../romcc"
+	action	"../romcc -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 mainboardinit cpu/x86/16bit/entry16.inc
 mainboardinit cpu/x86/32bit/entry32.inc
 ldscript /cpu/x86/16bit/entry16.lds
 ldscript /cpu/x86/32bit/entry32.lds
 if USE_FALLBACK_IMAGE
 	mainboardinit cpu/x86/16bit/reset16.inc
 	ldscript /cpu/x86/16bit/reset16.lds
 else
 	mainboardinit cpu/x86/32bit/reset32.inc
 	ldscript /cpu/x86/32bit/reset32.lds
 end
 mainboardinit arch/i386/lib/cpu_reset.inc
 mainboardinit arch/i386/lib/id.inc
 ldscript /arch/i386/lib/id.lds
 if USE_FALLBACK_IMAGE
 	ldscript /arch/i386/lib/failover.lds
 	mainboardinit ./failover.inc
 end
 mainboardinit cpu/x86/fpu/enable_fpu.inc
 mainboardinit cpu/x86/mmx/enable_mmx.inc
 mainboardinit ./auto.inc
 mainboardinit cpu/x86/mmx/disable_mmx.inc
 
 dir /pc80
 config chip.h
 
 chip northbridge/intel/i440bx		# Northbridge
   device apic_cluster 0 on		# APIC cluster
     chip cpu/intel/slot_2		# CPU (FIXME: It's slot 1, actually)
       device apic 0 on end		# APIC
     end
   end
   device pci_domain 0 on		# PCI domain
     device pci 0.0 on end		# Host bridge
     device pci 1.0 on end		# PCI/AGP bridge
     chip southbridge/intel/i82371eb	# Southbridge
       device pci 7.0 on			# ISA bridge
         chip superio/nsc/pc87309	# Super I/O
           device pnp 2e.0 on		# Floppy
             io 0x60 = 0x3f0
             irq 0x70 = 6
             drq 0x74 = 2
           end
           device pnp 2e.1 on		# Parallel port
             io 0x60 = 0x378
             irq 0x70 = 7
           end
           device pnp 2e.2 on		# COM2 / IR
             io 0x60 = 0x2f8
             irq 0x70 = 3
           end
           device pnp 2e.3 on		# COM1
             io 0x60 = 0x3f8
             irq 0x70 = 4
           end
           device pnp 2e.4 on		# Power management
           end
           device pnp 2e.5 on		# PS/2 mouse
             irq 0x70 = 12
           end
           device pnp 2e.6 on		# PS/2 keyboard
             io 0x60 = 0x60
             io 0x62 = 0x64
             irq 0x70 = 1
           end
         end
       end
       device pci 7.1 on	end		# IDE
       device pci 7.2 on	end		# USB
       device pci 7.3 on end		# ACPI
       register "ide0_enable" = "1"
       register "ide1_enable" = "1"
       register "ide_legacy_enable" = "1"
       # Enable UDMA/33 for higher speed if your IDE device(s) support it.
       register "ide0_drive0_udma33_enable" = "0"
       register "ide0_drive1_udma33_enable" = "0"
       register "ide1_drive0_udma33_enable" = "0"
       register "ide1_drive1_udma33_enable" = "0"
     end
   end
 end
diff --git a/src/mainboard/tyan/s2735/Config.lb b/src/mainboard/tyan/s2735/Config.lb
index 4606fce..8a9d466 100644
--- a/src/mainboard/tyan/s2735/Config.lb
+++ b/src/mainboard/tyan/s2735/Config.lb
@@ -1,274 +1,274 @@
 ##
 ## Compute the location and size of where this firmware image
 ## (coreboot plus bootloader) will live in the boot rom chip.
 ##
 if USE_FALLBACK_IMAGE
 	default ROM_SECTION_SIZE   = FALLBACK_SIZE
 	default ROM_SECTION_OFFSET = ( ROM_SIZE - FALLBACK_SIZE )
 else
 	default ROM_SECTION_SIZE   = ( ROM_SIZE - FALLBACK_SIZE )
 	default ROM_SECTION_OFFSET = 0
 end
 
 ##
 ## Compute the start location and size size of
 ## The coreboot bootloader.
 ##
 default PAYLOAD_SIZE            = ( ROM_SECTION_SIZE - ROM_IMAGE_SIZE )
 default CONFIG_ROM_PAYLOAD_START = (0xffffffff - ROM_SIZE + ROM_SECTION_OFFSET + 1)
 default CONFIG_ROM_PAYLOAD     = 1
 
 ##
 ## Compute where this copy of coreboot will start in the boot rom
 ##
 default _ROMBASE      = ( CONFIG_ROM_PAYLOAD_START + PAYLOAD_SIZE )
 
 ##
 ## Compute a range of ROM that can cached to speed up coreboot,
 ## execution speed.
 ##
 ## XIP_ROM_SIZE must be a power of 2.
 ## XIP_ROM_BASE must be a multiple of XIP_ROM_SIZE
 ##
 default XIP_ROM_SIZE=65536
 default XIP_ROM_BASE = ( _ROMBASE + ROM_IMAGE_SIZE - XIP_ROM_SIZE )
 
 arch i386 end 
 
 
 ##
 ## Build the objects we have code for in this directory.
 ##
 
 driver mainboard.o
 if HAVE_MP_TABLE object mptable.o end
 if HAVE_PIRQ_TABLE object irq_tables.o end
 object reset.o
 if USE_DCACHE_RAM
 
 if CONFIG_USE_INIT
 
 makerule ./auto.o
         depends "$(MAINBOARD)/cache_as_ram_auto.c option_table.h"
         action "$(CC) $(DISTRO_CFLAGS) -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/cache_as_ram_auto.c -Os -nostdinc -nostdlib -fno-builtin -Wall -c -o auto.o"
 end
 
 else
 
 makerule ./auto.inc
         depends "$(MAINBOARD)/cache_as_ram_auto.c option_table.h"
         action "$(CC) $(DISTRO_CFLAGS) -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/cache_as_ram_auto.c -Os -nostdinc -nostdlib -fno-builtin -Wall -c -S -o $@"
         action "perl -e 's/.rodata/.rom.data/g' -pi $@"
         action "perl -e 's/.text/.section .rom.text/g' -pi $@"
 end
 
 end
 else
 
 ##
 ## Romcc output
 ##
 makerule ./failover.E
-        depends "$(MAINBOARD)/failover.c ./romcc"
-        action "./romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+        depends "$(MAINBOARD)/failover.c ../romcc"
+        action "../romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 end
 
 makerule ./failover.inc
-        depends "$(MAINBOARD)/failover.c ./romcc"
-        action "./romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+        depends "$(MAINBOARD)/failover.c ../romcc"
+        action "../romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 end
 
 makerule ./auto.E
-        depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-        action  "./romcc -E -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+        depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+        action  "../romcc -E -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 makerule ./auto.inc
-        depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-        action  "./romcc    -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+        depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+        action  "../romcc    -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 
 end
 
 ##
 ## Build our 16 bit and 32 bit coreboot entry code
 ##
 mainboardinit cpu/x86/16bit/entry16.inc
 mainboardinit cpu/x86/32bit/entry32.inc
 ldscript /cpu/x86/16bit/entry16.lds
 if USE_DCACHE_RAM
         if CONFIG_USE_INIT
                 ldscript /cpu/x86/32bit/entry32.lds
         end
 
         if CONFIG_USE_INIT
                 ldscript      /cpu/x86/car/cache_as_ram.lds
         end
 end
 
 
 ##
 ## Build our reset vector (This is where coreboot is entered)
 ##
 if USE_FALLBACK_IMAGE 
 	mainboardinit cpu/x86/16bit/reset16.inc 
 	ldscript /cpu/x86/16bit/reset16.lds 
 else
 	mainboardinit cpu/x86/32bit/reset32.inc 
 	ldscript /cpu/x86/32bit/reset32.lds 
 end
 
 if USE_DCACHE_RAM
 else
 ### Should this be in the northbridge code?
 mainboardinit arch/i386/lib/cpu_reset.inc
 end
 
 ##
 ## Include an id string (For safe flashing)
 ##
 mainboardinit arch/i386/lib/id.inc
 ldscript /arch/i386/lib/id.lds
 
 if USE_DCACHE_RAM
 ##
 ## Setup Cache-As-Ram
 ##
 mainboardinit cpu/x86/car/cache_as_ram.inc
 end
 
 ###
 ### This is the early phase of coreboot startup 
 ### Things are delicate and we test to see if we should
 ### failover to another image.
 ###
 if USE_FALLBACK_IMAGE
 if USE_DCACHE_RAM
        ldscript /arch/i386/lib/failover.lds
 else
        ldscript /arch/i386/lib/failover.lds
         mainboardinit ./failover.inc
 end
 end
 
 ##
 ## Setup RAM
 ##
 if USE_DCACHE_RAM
 
 if CONFIG_USE_INIT
 initobject auto.o
 else
 mainboardinit ./auto.inc
 end
 
 else
 # ROMCC
 mainboardinit cpu/x86/fpu/enable_fpu.inc
 mainboardinit cpu/x86/mmx/enable_mmx.inc
 mainboardinit cpu/x86/sse/enable_sse.inc
 mainboardinit ./auto.inc
 mainboardinit cpu/x86/sse/disable_sse.inc
 mainboardinit cpu/x86/mmx/disable_mmx.inc
 
 end
 
 ##
 ## Include the secondary Configuration files 
 ##
 if CONFIG_CHIP_NAME
 	config chip.h
 end
 
 
 # sample config for tyan/s2735
 chip northbridge/intel/e7501
         device pci_domain 0 on
 		device pci 0.0 on end
         	device pci 0.1 on end
         	device pci 2.0 on
         		chip southbridge/intel/i82870
         	        	device pci 1c.0 on end
 		                device pci 1d.0 on 
 					chip drivers/pci/onboard
                                         	device pci 1.0 on end # intel lan
                                                 device pci 1.1 on end
                                         end
 				end
         	                device pci 1e.0 on end
         	                device pci 1f.0 on end
         		end
 		end
         	device pci 6.0 on end
         	chip southbridge/intel/i82801er
         		device pci 1d.0 on end
 		        device pci 1d.1 on end
         	        device pci 1d.2 on end
         	        device pci 1d.3 on end
 		        device pci 1d.7 on end
 		        device pci 1e.0 on 
                         	chip drivers/pci/onboard
                                 	device pci 1.0 on end # intel lan 10/100
                                 end
                                 chip drivers/pci/onboard
                                         device pci 2.0 on end # ati 
                                 end
 			end
 		        device pci 1f.0 on
 				chip superio/winbond/w83627hf
                                 	device pnp 2e.0 on #  Floppy
                                         	io 0x60 = 0x3f0
                                                 irq 0x70 = 6
                                                 drq 0x74 = 2
                                         end
 	                                device pnp 2e.1 off #  Parallel Port
                                                 io 0x60 = 0x378
                                                 irq 0x70 = 7
                                         end
                                         device pnp 2e.2 on #  Com1
         	                                io 0x60 = 0x3f8
                                                 irq 0x70 = 4
                                         end
                                         device pnp 2e.3 on #  Com2
                                                 io 0x60 = 0x2f8
                                                 irq 0x70 = 3
                                         end
                                         device pnp 2e.5 on #  Keyboard
                                                 io 0x60 = 0x60
                                                 io 0x62 = 0x64
                                                 irq 0x70 = 1
                                                 irq 0x72 = 12
                                         end
                                         device pnp 2e.6 off #  CIR
                                                 io 0x60 = 0x100
                                         end
                                         device pnp 2e.7 off #  GAME_MIDI_GIPO1
                                                 io 0x60 = 0x220
                                                 io 0x62 = 0x300
                                                 irq 0x70 = 9
                                         end                               
                                         device pnp 2e.8 off end #  GPIO2
                                         device pnp 2e.9 off end #  GPIO3
                                         device pnp 2e.a off end #  ACPI
                                         device pnp 2e.b on #  HW Monitor
                                                 io 0x60 = 0x290
                                                 irq 0x70 = 5
                                         end
 				end
 		        end
 		        device pci 1f.1 off end
         	        device pci 1f.2 on end
         	        device pci 1f.3 on end
         		device pci 1f.5 off end
 		        device pci 1f.6 off end
 		end # SB
         end # PCI_DOMAIN
         device apic_cluster 0 on
                 chip cpu/intel/socket_mPGA604_533Mhz
                         device apic 0 on end
                 end
                 chip cpu/intel/socket_mPGA604_533Mhz
                         device apic 6 on end
                 end
         end
 end
 
diff --git a/src/mainboard/tyan/s2850/Config.lb b/src/mainboard/tyan/s2850/Config.lb
index 7eabbcf..2256274 100644
--- a/src/mainboard/tyan/s2850/Config.lb
+++ b/src/mainboard/tyan/s2850/Config.lb
@@ -1,290 +1,290 @@
 ##
 ## Compute the location and size of where this firmware image
 ## (coreboot plus bootloader) will live in the boot rom chip.
 ##
 if USE_FALLBACK_IMAGE
 	default ROM_SECTION_SIZE   = FALLBACK_SIZE
 	default ROM_SECTION_OFFSET = ( ROM_SIZE - FALLBACK_SIZE )
 else
 	default ROM_SECTION_SIZE   = ( ROM_SIZE - FALLBACK_SIZE )
 	default ROM_SECTION_OFFSET = 0
 end
 
 ##
 ## Compute the start location and size size of
 ## The coreboot bootloader.
 ##
 default PAYLOAD_SIZE            = ( ROM_SECTION_SIZE - ROM_IMAGE_SIZE )
 default CONFIG_ROM_PAYLOAD_START = (0xffffffff - ROM_SIZE + ROM_SECTION_OFFSET + 1)
 
 ##
 ## Compute where this copy of coreboot will start in the boot rom
 ##
 default _ROMBASE      = ( CONFIG_ROM_PAYLOAD_START + PAYLOAD_SIZE )
 
 ##
 ## Compute a range of ROM that can cached to speed up coreboot,
 ## execution speed.
 ##
 ## XIP_ROM_SIZE must be a power of 2.
 ## XIP_ROM_BASE must be a multiple of XIP_ROM_SIZE
 ##
 default XIP_ROM_SIZE=65536
 default XIP_ROM_BASE = ( _ROMBASE + ROM_IMAGE_SIZE - XIP_ROM_SIZE )
 
 arch i386 end 
 
 ##
 ## Build the objects we have code for in this directory.
 ##
 
 driver mainboard.o
 
 #dir /drivers/si/3114
 
 if HAVE_MP_TABLE object mptable.o end
 if HAVE_PIRQ_TABLE object irq_tables.o end
 
 if USE_DCACHE_RAM
 
 if CONFIG_USE_INIT
 
 makerule ./auto.o
         depends "$(MAINBOARD)/cache_as_ram_auto.c option_table.h"
         action "$(CC) $(DISTRO_CFLAGS) -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/cache_as_ram_auto.c -Os -nostdinc -nostdlib -fno-builtin -Wall -c -o auto.o" 
 end
 
 else    
                 
 makerule ./auto.inc
         depends "$(MAINBOARD)/cache_as_ram_auto.c option_table.h"
         action "$(CC) $(DISTRO_CFLAGS) -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/cache_as_ram_auto.c -Os -nostdinc -nostdlib -fno-builtin -Wall -c -S -o $@"         
         action "perl -e 's/.rodata/.rom.data/g' -pi $@"
         action "perl -e 's/.text/.section .rom.text/g' -pi $@"
 end
 
 end
 else
 
 ##
 ## Romcc output
 ##
 makerule ./failover.E
-        depends "$(MAINBOARD)/failover.c ./romcc"
-        action "./romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+        depends "$(MAINBOARD)/failover.c ../romcc"
+        action "../romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 end
 
 makerule ./failover.inc
-        depends "$(MAINBOARD)/failover.c ./romcc"
-        action "./romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+        depends "$(MAINBOARD)/failover.c ../romcc"
+        action "../romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 end
 
 makerule ./auto.E
-        depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-        action  "./romcc -E -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+        depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+        action  "../romcc -E -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 makerule ./auto.inc
-        depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-        action  "./romcc    -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+        depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+        action  "../romcc    -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 
 end
 ##
 ## Build our 16 bit and 32 bit coreboot entry code
 ##
 if USE_FALLBACK_IMAGE
         mainboardinit cpu/x86/16bit/entry16.inc
         ldscript /cpu/x86/16bit/entry16.lds
 end
 
 mainboardinit cpu/x86/32bit/entry32.inc
 
 if USE_DCACHE_RAM
         if CONFIG_USE_INIT
                 ldscript /cpu/x86/32bit/entry32.lds
         end
 
         if CONFIG_USE_INIT
                 ldscript      /cpu/amd/car/cache_as_ram.lds
         end
 end
 
 ##
 ## Build our reset vector (This is where coreboot is entered)
 ##
 if USE_FALLBACK_IMAGE 
 	mainboardinit cpu/x86/16bit/reset16.inc 
 	ldscript /cpu/x86/16bit/reset16.lds 
 else
 	mainboardinit cpu/x86/32bit/reset32.inc 
 	ldscript /cpu/x86/32bit/reset32.lds 
 end
 
 if USE_DCACHE_RAM
 else
 ### Should this be in the northbridge code?
 mainboardinit arch/i386/lib/cpu_reset.inc
 end
 
 ##
 ## Include an id string (For safe flashing)
 ##
 mainboardinit arch/i386/lib/id.inc
 ldscript /arch/i386/lib/id.lds
 
 if USE_DCACHE_RAM
 ##
 ## Setup Cache-As-Ram
 ##
 mainboardinit cpu/amd/car/cache_as_ram.inc
 end
 
 ###
 ### This is the early phase of coreboot startup 
 ### Things are delicate and we test to see if we should
 ### failover to another image.
 ###
 if USE_FALLBACK_IMAGE
 if USE_DCACHE_RAM
        ldscript /arch/i386/lib/failover.lds
 else
        ldscript /arch/i386/lib/failover.lds
         mainboardinit ./failover.inc
 end
 end
 
 ###
 ### O.k. We aren't just an intermediary anymore!
 ###
 
 ##
 ## Setup RAM
 ##
 if USE_DCACHE_RAM
 
 if CONFIG_USE_INIT
 initobject auto.o
 else
 mainboardinit ./auto.inc
 end
 
 else
 
 ##
 ## Setup RAM
 ##
 mainboardinit cpu/x86/fpu/enable_fpu.inc
 mainboardinit cpu/x86/mmx/enable_mmx.inc
 mainboardinit cpu/x86/sse/enable_sse.inc
 mainboardinit ./auto.inc
 mainboardinit cpu/x86/sse/disable_sse.inc
 mainboardinit cpu/x86/mmx/disable_mmx.inc
 
 end
 
 ##
 ## Include the secondary Configuration files 
 ##
 if CONFIG_CHIP_NAME
 	config chip.h
 end
 
 # sample config for tyan/s2850
 chip northbridge/amd/amdk8/root_complex
         device apic_cluster 0 on                        
                 chip cpu/amd/socket_940                
                         device apic 0 on end                    
                 end                                     
         end 
 	device pci_domain 0 on
 		chip northbridge/amd/amdk8
 			device pci 18.0 on # LDT0
 				#  devices on link 2, link 2 == LDT 2
 				chip southbridge/amd/amd8111
 					# this "device pci 0.0" is the parent the next one
 					# PCI bridge
 					device pci 0.0 on
 						device pci 0.0 on end
 						device pci 0.1 on end
 						device pci 0.2 off end
 						device pci 1.0 off end
                                                 #chip drivers/ati/ragexl
 						chip drivers/pci/onboard
                                                         device pci b.0 on end
 							register "rom_address" = "0xfff80000"
                                                 end
 					end
 					device pci 1.0 on
 						chip superio/winbond/w83627hf
 							device pnp 2e.0 on #  Floppy
                 	                 			io 0x60 = 0x3f0
                 	                			irq 0x70 = 6
                 	                			drq 0x74 = 2
 							end
                 	        			device pnp 2e.1 off #  Parallel Port
                 	                 			io 0x60 = 0x378
                 	                			irq 0x70 = 7
 							end
                 	        			device pnp 2e.2 on #  Com1
                 	                 			io 0x60 = 0x3f8
                 	                			irq 0x70 = 4
 							end
                 	        			device pnp 2e.3 off #  Com2
                 	                 			io 0x60 = 0x2f8
                 	                			irq 0x70 = 3
 							end
                 	        			device pnp 2e.5 on #  Keyboard
                 	                 			io 0x60 = 0x60
                 	                 			io 0x62 = 0x64
                 	                			irq 0x70 = 1
 								irq 0x72 = 12
 							end
                 	                               device pnp 2e.6 off #  CIR
                 	                                        io 0x60 = 0x100
                 	                                end
                 	                                device pnp 2e.7 off #  GAME_MIDI_GIPO1
                 	                                        io 0x60 = 0x220
                 	                                        io 0x62 = 0x300
                 	                                        irq 0x70 = 9
                 	                                end  
                 	                                device pnp 2e.8 off end #  GPIO2
                 	                                device pnp 2e.9 off end #  GPIO3
                 	                                device pnp 2e.a off end #  ACPI
                 	                                device pnp 2e.b on #  HW Monitor
                 	                                        io 0x60 = 0x290
                 	                                        irq 0x70 = 5
                 	                                end
 						end
 					end
 					device pci 1.1 on end
 					device pci 1.2 on end
 					device pci 1.3 on 
                                                 chip drivers/generic/generic #dimm 0-0-0
                                                         device i2c 50 on end
                                                 end
                                                 chip drivers/generic/generic #dimm 0-0-1
                                                         device i2c 51 on end
                                                 end
                                                 chip drivers/generic/generic #dimm 0-1-0
                                                         device i2c 52 on end
                                                 end
                                                 chip drivers/generic/generic #dimm 0-1-1
                                                         device i2c 53 on end
                                                 end
 					end
 					device pci 1.5 on end
 					device pci 1.6 off end
                                         register "ide0_enable" = "1"
                                         register "ide1_enable" = "1"
 				end
 			end #  device pci 18.0 
                 	device pci 18.0 on end
                 	device pci 18.0 on end
 			
 			device pci 18.1 on end
 			device pci 18.2 on end
 			device pci 18.3 on end
 		end
 	end 
 end
 
diff --git a/src/mainboard/tyan/s2875/Config.lb b/src/mainboard/tyan/s2875/Config.lb
index 14b2dee..3803cfa 100644
--- a/src/mainboard/tyan/s2875/Config.lb
+++ b/src/mainboard/tyan/s2875/Config.lb
@@ -1,282 +1,282 @@
 ##
 ## Compute the location and size of where this firmware image
 ## (coreboot plus bootloader) will live in the boot rom chip.
 ##
 if USE_FALLBACK_IMAGE
 	default ROM_SECTION_SIZE   = FALLBACK_SIZE
 	default ROM_SECTION_OFFSET = ( ROM_SIZE - FALLBACK_SIZE )
 else
 	default ROM_SECTION_SIZE   = ( ROM_SIZE - FALLBACK_SIZE )
 	default ROM_SECTION_OFFSET = 0
 end
 
 ##
 ## Compute the start location and size size of
 ## The coreboot bootloader.
 ##
 default PAYLOAD_SIZE            = ( ROM_SECTION_SIZE - ROM_IMAGE_SIZE )
 default CONFIG_ROM_PAYLOAD_START = (0xffffffff - ROM_SIZE + ROM_SECTION_OFFSET + 1)
 
 ##
 ## Compute where this copy of coreboot will start in the boot rom
 ##
 default _ROMBASE      = ( CONFIG_ROM_PAYLOAD_START + PAYLOAD_SIZE )
 
 ##
 ## Compute a range of ROM that can cached to speed up coreboot,
 ## execution speed.
 ##
 ## XIP_ROM_SIZE must be a power of 2.
 ## XIP_ROM_BASE must be a multiple of XIP_ROM_SIZE
 ##
 default XIP_ROM_SIZE=65536
 default XIP_ROM_BASE = ( _ROMBASE + ROM_IMAGE_SIZE - XIP_ROM_SIZE )
 
 arch i386 end 
 
 ##
 ## Build the objects we have code for in this directory.
 ##
 
 driver mainboard.o
 
 #dir /drivers/si/3114
 
 if HAVE_MP_TABLE object mptable.o end
 if HAVE_PIRQ_TABLE object irq_tables.o end
 
 if USE_DCACHE_RAM
 
 if CONFIG_USE_INIT
 
 makerule ./auto.o
         depends "$(MAINBOARD)/cache_as_ram_auto.c option_table.h"
         action "$(CC) $(DISTRO_CFLAGS) -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/cache_as_ram_auto.c -Os -nostdinc -nostdlib -fno-builtin -Wall -c -o auto.o" 
 end
 
 else    
                 
 makerule ./auto.inc
         depends "$(MAINBOARD)/cache_as_ram_auto.c option_table.h"
         action "$(CC) $(DISTRO_CFLAGS) -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/cache_as_ram_auto.c -Os -nostdinc -nostdlib -fno-builtin -Wall -c -S -o $@"         
         action "perl -e 's/.rodata/.rom.data/g' -pi $@"
         action "perl -e 's/.text/.section .rom.text/g' -pi $@"
 end
 
 end
 else
   
 ##
 ## Romcc output
 ##
 makerule ./failover.E
-        depends "$(MAINBOARD)/failover.c ./romcc"
-        action "./romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+        depends "$(MAINBOARD)/failover.c ../romcc"
+        action "../romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 end
 
 makerule ./failover.inc
-        depends "$(MAINBOARD)/failover.c ./romcc"
-        action "./romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+        depends "$(MAINBOARD)/failover.c ../romcc"
+        action "../romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 end
 
 makerule ./auto.E
-        depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-        action  "./romcc -E -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+        depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+        action  "../romcc -E -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 makerule ./auto.inc
-        depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-        action  "./romcc    -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+        depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+        action  "../romcc    -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 
 end
 ##
 ## Build our 16 bit and 32 bit coreboot entry code
 ##
 if USE_FALLBACK_IMAGE
         mainboardinit cpu/x86/16bit/entry16.inc
         ldscript /cpu/x86/16bit/entry16.lds
 end
 
 mainboardinit cpu/x86/32bit/entry32.inc
 
 if USE_DCACHE_RAM
         if CONFIG_USE_INIT
                 ldscript /cpu/x86/32bit/entry32.lds
         end
 
         if CONFIG_USE_INIT
                 ldscript      /cpu/amd/car/cache_as_ram.lds
         end
 end
 
 ##
 ## Build our reset vector (This is where coreboot is entered)
 ##
 if USE_FALLBACK_IMAGE 
 	mainboardinit cpu/x86/16bit/reset16.inc 
 	ldscript /cpu/x86/16bit/reset16.lds 
 else
 	mainboardinit cpu/x86/32bit/reset32.inc 
 	ldscript /cpu/x86/32bit/reset32.lds 
 end
 
 if USE_DCACHE_RAM
 else
 ### Should this be in the northbridge code?
 mainboardinit arch/i386/lib/cpu_reset.inc
 end
 
 ##
 ## Include an id string (For safe flashing)
 ##
 mainboardinit arch/i386/lib/id.inc
 ldscript /arch/i386/lib/id.lds
 
 if USE_DCACHE_RAM
 ##
 ## Setup Cache-As-Ram
 ##
 mainboardinit cpu/amd/car/cache_as_ram.inc
 end
 
 ###
 ### This is the early phase of coreboot startup 
 ### Things are delicate and we test to see if we should
 ### failover to another image.
 ###
 if USE_FALLBACK_IMAGE
 if USE_DCACHE_RAM
        ldscript /arch/i386/lib/failover.lds
 else
        ldscript /arch/i386/lib/failover.lds
         mainboardinit ./failover.inc
 end
 end
 
 ###
 ### O.k. We aren't just an intermediary anymore!
 ###
 
 ##
 ## Setup RAM
 ##
 if USE_DCACHE_RAM
 
 if CONFIG_USE_INIT
 initobject auto.o
 else
 mainboardinit ./auto.inc
 end
 
 else
 
 ##
 ## Setup RAM
 ##
 mainboardinit cpu/x86/fpu/enable_fpu.inc
 mainboardinit cpu/x86/mmx/enable_mmx.inc
 mainboardinit cpu/x86/sse/enable_sse.inc
 mainboardinit ./auto.inc
 mainboardinit cpu/x86/sse/disable_sse.inc
 mainboardinit cpu/x86/mmx/disable_mmx.inc
 
 end
 
 ##
 ## Include the secondary Configuration files 
 ##
 if CONFIG_CHIP_NAME
 	config chip.h
 end
 
 # sample config for tyan/s2875
 chip northbridge/amd/amdk8/root_complex
         device apic_cluster 0 on
                 chip cpu/amd/socket_940
                         device apic 0 on end
                 end
         end
 	device pci_domain 0 on
 		chip northbridge/amd/amdk8
 			device pci 18.0 on #  northbridge 
 				#  devices on link 0, link 0 == LDT 0
 				chip southbridge/amd/amd8151
 					# the on/off keyword is mandatory
 					device pci 0.0 on end
 					device pci 1.0 on end
 				end
 				chip southbridge/amd/amd8111
 					# this "device pci 0.0" is the parent the next one
 					# PCI bridge
 					device pci 0.0 on
 						device pci 0.0 on end
 						device pci 0.1 on end
 						device pci 0.2 off end
 						device pci 1.0 off end
                                                 chip drivers/pci/onboard
                                                         device pci 5.0 on end
                                                         register "rom_address" = "0xfff80000"
                                                 end
 					end
 					device pci 1.0 on
 						chip superio/winbond/w83627hf
 							device pnp 2e.0 on #  Floppy
 								io 0x60 = 0x3f0
 								irq 0x70 = 6
 								drq 0x74 = 2
 							end
 							device pnp 2e.1 off #  Parallel Port
 								io 0x60 = 0x378
 								irq 0x70 = 7
 							end
 							device pnp 2e.2 on #  Com1
 								io 0x60 = 0x3f8
 								irq 0x70 = 4
 							end
 							device pnp 2e.3 off #  Com2
 								io 0x60 = 0x2f8
 								irq 0x70 = 3
 							end
 							device pnp 2e.5 on #  Keyboard
 								io 0x60 = 0x60
 								io 0x62 = 0x64
 								irq 0x70 = 1
 								irq 0x72 = 12
 							end
 							device pnp 2e.6 off #  CIR
 								io 0x60 = 0x100
 							end
 							device pnp 2e.7 off #  GAME_MIDI_GIPO1
 								io 0x60 = 0x220
 								io 0x62 = 0x300
 								irq 0x70 = 9
 							end  
 							device pnp 2e.8 off end #  GPIO2
 							device pnp 2e.9 off end #  GPIO3
 							device pnp 2e.a off end #  ACPI
 							device pnp 2e.b on #  HW Monitor
 								io 0x60 = 0x290
 								irq 0x70 = 5
 							end
 						end
 					end
 					device pci 1.1 on end
 					device pci 1.2 on end
 					device pci 1.3 on end
 					device pci 1.5 on end
 					device pci 1.6 off end
                                         register "ide0_enable" = "1"
                                         register "ide1_enable" = "1"
 				end
 			end #  device pci 18.0 
 			
 			device pci 18.0 on end
 			device pci 18.0 on end
 			
 			device pci 18.1 on end
 			device pci 18.2 on end
 			device pci 18.3 on end
 		end
 	end 
 end
 
diff --git a/src/mainboard/tyan/s2880/Config.lb b/src/mainboard/tyan/s2880/Config.lb
index cde3c90..ed20ed9 100644
--- a/src/mainboard/tyan/s2880/Config.lb
+++ b/src/mainboard/tyan/s2880/Config.lb
@@ -1,297 +1,297 @@
 ##
 ## Compute the location and size of where this firmware image
 ## (coreboot plus bootloader) will live in the boot rom chip.
 ##
 if USE_FALLBACK_IMAGE
 	default ROM_SECTION_SIZE   = FALLBACK_SIZE
 	default ROM_SECTION_OFFSET = ( ROM_SIZE - FALLBACK_SIZE )
 else
 	default ROM_SECTION_SIZE   = ( ROM_SIZE - FALLBACK_SIZE )
 	default ROM_SECTION_OFFSET = 0
 end
 
 ##
 ## Compute the start location and size size of
 ## The coreboot bootloader.
 ##
 default PAYLOAD_SIZE            = ( ROM_SECTION_SIZE - ROM_IMAGE_SIZE )
 default CONFIG_ROM_PAYLOAD_START = (0xffffffff - ROM_SIZE + ROM_SECTION_OFFSET + 1)
 
 ##
 ## Compute where this copy of coreboot will start in the boot rom
 ##
 default _ROMBASE      = ( CONFIG_ROM_PAYLOAD_START + PAYLOAD_SIZE )
 
 ##
 ## Compute a range of ROM that can cached to speed up coreboot,
 ## execution speed.
 ##
 ## XIP_ROM_SIZE must be a power of 2.
 ## XIP_ROM_BASE must be a multiple of XIP_ROM_SIZE
 ##
 default XIP_ROM_SIZE=65536
 default XIP_ROM_BASE = ( _ROMBASE + ROM_IMAGE_SIZE - XIP_ROM_SIZE )
 
 arch i386 end 
 
 ##
 ## Build the objects we have code for in this directory.
 ##
 
 driver mainboard.o
 
 #dir /drivers/si/3114
 
 if HAVE_MP_TABLE object mptable.o end
 if HAVE_PIRQ_TABLE object irq_tables.o end
 
 if USE_DCACHE_RAM
 
 if CONFIG_USE_INIT
 
 makerule ./auto.o
         depends "$(MAINBOARD)/cache_as_ram_auto.c option_table.h"
         action "$(CC) $(DISTRO_CFLAGS) -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/cache_as_ram_auto.c -Os -nostdinc -nostdlib -fno-builtin -Wall -c -o auto.o" 
 end
 
 else    
                 
 makerule ./auto.inc
         depends "$(MAINBOARD)/cache_as_ram_auto.c option_table.h"
         action "$(CC) $(DISTRO_CFLAGS) -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/cache_as_ram_auto.c -Os -nostdinc -nostdlib -fno-builtin -Wall -c -S -o $@"         
         action "perl -e 's/.rodata/.rom.data/g' -pi $@"
         action "perl -e 's/.text/.section .rom.text/g' -pi $@"
 end
 
 end
 else
 
 ##
 ## Romcc output
 ##
 makerule ./failover.E
-        depends "$(MAINBOARD)/failover.c ./romcc"
-        action "./romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+        depends "$(MAINBOARD)/failover.c ../romcc"
+        action "../romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 end
 
 makerule ./failover.inc
-        depends "$(MAINBOARD)/failover.c ./romcc"
-        action "./romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+        depends "$(MAINBOARD)/failover.c ../romcc"
+        action "../romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 end
 
 makerule ./auto.E
-        depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-        action  "./romcc -E -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+        depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+        action  "../romcc -E -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 makerule ./auto.inc
-        depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-        action  "./romcc    -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+        depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+        action  "../romcc    -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 
 end
 ##
 ## Build our 16 bit and 32 bit coreboot entry code
 ##
 if USE_FALLBACK_IMAGE
         mainboardinit cpu/x86/16bit/entry16.inc
         ldscript /cpu/x86/16bit/entry16.lds
 end
 
 mainboardinit cpu/x86/32bit/entry32.inc
 
 if USE_DCACHE_RAM
         if CONFIG_USE_INIT
                 ldscript /cpu/x86/32bit/entry32.lds
         end
 
         if CONFIG_USE_INIT
                 ldscript      /cpu/amd/car/cache_as_ram.lds
         end
 end
 
 ##
 ## Build our reset vector (This is where coreboot is entered)
 ##
 if USE_FALLBACK_IMAGE 
 	mainboardinit cpu/x86/16bit/reset16.inc 
 	ldscript /cpu/x86/16bit/reset16.lds 
 else
 	mainboardinit cpu/x86/32bit/reset32.inc 
 	ldscript /cpu/x86/32bit/reset32.lds 
 end
 
 if USE_DCACHE_RAM
 else
 ### Should this be in the northbridge code?
 mainboardinit arch/i386/lib/cpu_reset.inc
 end
 
 ##
 ## Include an id string (For safe flashing)
 ##
 mainboardinit arch/i386/lib/id.inc
 ldscript /arch/i386/lib/id.lds
 
 if USE_DCACHE_RAM
 ##
 ## Setup Cache-As-Ram
 ##
 mainboardinit cpu/amd/car/cache_as_ram.inc
 end
 
 ###
 ### This is the early phase of coreboot startup 
 ### Things are delicate and we test to see if we should
 ### failover to another image.
 ###
 if USE_FALLBACK_IMAGE
 if USE_DCACHE_RAM
        ldscript /arch/i386/lib/failover.lds
 else
        ldscript /arch/i386/lib/failover.lds
         mainboardinit ./failover.inc
 end
 end
 
 ###
 ### O.k. We aren't just an intermediary anymore!
 ###
 
 ##
 ## Setup RAM
 ##
 if USE_DCACHE_RAM
 
 if CONFIG_USE_INIT
 initobject auto.o
 else
 mainboardinit ./auto.inc
 end
 
 else
 
 ##
 ## Setup RAM
 ##
 mainboardinit cpu/x86/fpu/enable_fpu.inc
 mainboardinit cpu/x86/mmx/enable_mmx.inc
 mainboardinit cpu/x86/sse/enable_sse.inc
 mainboardinit ./auto.inc
 mainboardinit cpu/x86/sse/disable_sse.inc
 mainboardinit cpu/x86/mmx/disable_mmx.inc
 
 end
 
 ##
 ## Include the secondary Configuration files 
 ##
 if CONFIG_CHIP_NAME
 	config chip.h
 end
 
 # sample config for tyan/s2880
 chip northbridge/amd/amdk8/root_complex
         device apic_cluster 0 on
                 chip cpu/amd/socket_940
                         device apic 0 on end
                 end
         end
 	device pci_domain 0 on
 		chip northbridge/amd/amdk8
 			device pci 18.0 on #  northbridge 
 				#  devices on link 0, link 0 == LDT 0
 				chip southbridge/amd/amd8131
 					# the on/off keyword is mandatory
 					device pci 0.0 on
                                                 chip drivers/pci/onboard
                                                         device pci 9.0 on end #broadcom
 							device pci 9.1 on end 
                                                 end
 #                                                chip drivers/lsi/53c1030
 #                                                        device pci a.0 on end
 #                                                        device pci a.1 on end
 #                                                        register "fw_address" = "0xfff8c000"
 #                                                end
 					end
 					device pci 0.1 on end
 					device pci 1.0 on end
 					device pci 1.1 on end
 				end
 				chip southbridge/amd/amd8111
 					# this "device pci 0.0" is the parent the next one
 					# PCI bridge
 					device pci 0.0 on
 						device pci 0.0 on end
 						device pci 0.1 on end
 						device pci 0.2 off end
 						device pci 1.0 off end
                                                 chip drivers/pci/onboard
                                                         device pci 5.0 on end #some sata
                                                 end
                                                 chip drivers/pci/onboard
                                                         device pci 6.0 on end #adti
                                                         register "rom_address" = "0xfff80000"
                                                 end
 					end
 					device pci 1.0 on
 						chip superio/winbond/w83627hf
 							device pnp 2e.0 on #  Floppy
                 	                 			io 0x60 = 0x3f0
                 	                			irq 0x70 = 6
                 	                			drq 0x74 = 2
 							end
                 	        			device pnp 2e.1 off #  Parallel Port
                 	                 			io 0x60 = 0x378
                 	                			irq 0x70 = 7
 							end
                 	        			device pnp 2e.2 on #  Com1
                 	                 			io 0x60 = 0x3f8
                 	                			irq 0x70 = 4
 							end
                 	        			device pnp 2e.3 off #  Com2
                 	                 			io 0x60 = 0x2f8
                 	                			irq 0x70 = 3
 							end
                 	        			device pnp 2e.5 on #  Keyboard
                 	                 			io 0x60 = 0x60
                 	                 			io 0x62 = 0x64
                 	                			irq 0x70 = 1
 								irq 0x72 = 12
 							end
                 	                                device pnp 2e.6 off #  CIR
                 	                                        io 0x60 = 0x100
                 	                                end
                 	                                device pnp 2e.7 off #  GAME_MIDI_GIPO1
                 	                                        io 0x60 = 0x220
                 	                                        io 0x62 = 0x300
                 	                                        irq 0x70 = 9
                 	                                end  
                 	                                device pnp 2e.8 off end #  GPIO2
                 	                                device pnp 2e.9 off end #  GPIO3
                 	                                device pnp 2e.a off end #  ACPI
                 	                                device pnp 2e.b on #  HW Monitor
                 	                                        io 0x60 = 0x290
                 	                                        irq 0x70 = 5
                 	                                end
 						end
 					end
 					device pci 1.1 on end
 					device pci 1.2 on end
 					device pci 1.3 on end
 					device pci 1.5 off end
 					device pci 1.6 off end
                                         register "ide0_enable" = "1"
                                         register "ide1_enable" = "1"
 				end
 			end #  device pci 18.0 
 			
                 	device pci 18.0 on end
                 	device pci 18.0 on end
 			
 			device pci 18.1 on end
 			device pci 18.2 on end
 			device pci 18.3 on end
 		end
 	end 
 end
 
diff --git a/src/mainboard/tyan/s2881/Config.lb b/src/mainboard/tyan/s2881/Config.lb
index fedae9c..a7227c2 100644
--- a/src/mainboard/tyan/s2881/Config.lb
+++ b/src/mainboard/tyan/s2881/Config.lb
@@ -1,332 +1,332 @@
 ##
 ## Compute the location and size of where this firmware image
 ## (coreboot plus bootloader) will live in the boot rom chip.
 ##
 if USE_FALLBACK_IMAGE
 	default ROM_SECTION_SIZE   = FALLBACK_SIZE
 	default ROM_SECTION_OFFSET = ( ROM_SIZE - FALLBACK_SIZE )
 else
 	default ROM_SECTION_SIZE   = ( ROM_SIZE - FALLBACK_SIZE )
 	default ROM_SECTION_OFFSET = 0
 end
 
 ##
 ## Compute the start location and size size of
 ## The coreboot bootloader.
 ##
 default PAYLOAD_SIZE            = ( ROM_SECTION_SIZE - ROM_IMAGE_SIZE )
 default CONFIG_ROM_PAYLOAD_START = (0xffffffff - ROM_SIZE + ROM_SECTION_OFFSET + 1)
 
 ##
 ## Compute where this copy of coreboot will start in the boot rom
 ##
 default _ROMBASE      = ( CONFIG_ROM_PAYLOAD_START + PAYLOAD_SIZE )
 
 ##
 ## Compute a range of ROM that can cached to speed up coreboot,
 ## execution speed.
 ##
 ## XIP_ROM_SIZE must be a power of 2.
 ## XIP_ROM_BASE must be a multiple of XIP_ROM_SIZE
 ##
 default XIP_ROM_SIZE=65536
 default XIP_ROM_BASE = ( _ROMBASE + ROM_IMAGE_SIZE - XIP_ROM_SIZE )
 
 arch i386 end 
 
 ##
 ## Build the objects we have code for in this directory.
 ##
 
 driver mainboard.o
 
 #dir /drivers/si/3114
 object get_bus_conf.o
 if HAVE_MP_TABLE object mptable.o end
 if HAVE_PIRQ_TABLE object irq_tables.o end
 if USE_DCACHE_RAM
 
 if CONFIG_USE_INIT
 
 makerule ./auto.o
         depends "$(MAINBOARD)/cache_as_ram_auto.c option_table.h"
         action "$(CC) $(DISTRO_CFLAGS) -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/cache_as_ram_auto.c -Os -nostdinc -nostdlib -fno-builtin -Wall -c -o auto.o" 
 end
 
 else    
                 
 makerule ./auto.inc
         depends "$(MAINBOARD)/cache_as_ram_auto.c option_table.h"
         action "$(CC) $(DISTRO_CFLAGS) -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/cache_as_ram_auto.c -Os -nostdinc -nostdlib -fno-builtin -Wall -c -S -o $@"         
         action "perl -e 's/.rodata/.rom.data/g' -pi $@"
         action "perl -e 's/.text/.section .rom.text/g' -pi $@"
 end
 
 end
 else
 
 
 ##
 ## Romcc output
 ##
 makerule ./failover.E
-        depends "$(MAINBOARD)/failover.c ./romcc"
-        action "./romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+        depends "$(MAINBOARD)/failover.c ../romcc"
+        action "../romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 end
 
 makerule ./failover.inc
-        depends "$(MAINBOARD)/failover.c ./romcc"
-        action "./romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+        depends "$(MAINBOARD)/failover.c ../romcc"
+        action "../romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 end
 
 makerule ./auto.E
-        depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-        action  "./romcc -E -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+        depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+        action  "../romcc -E -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 makerule ./auto.inc
-        depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-        action  "./romcc    -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+        depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+        action  "../romcc    -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 
 end
 ##
 ## Build our 16 bit and 32 bit coreboot entry code
 ##
 if USE_FALLBACK_IMAGE
         mainboardinit cpu/x86/16bit/entry16.inc
         ldscript /cpu/x86/16bit/entry16.lds
 end
 
 mainboardinit cpu/x86/32bit/entry32.inc
 
 if USE_DCACHE_RAM
         if CONFIG_USE_INIT
                 ldscript /cpu/x86/32bit/entry32.lds
         end
 
         if CONFIG_USE_INIT
                 ldscript      /cpu/amd/car/cache_as_ram.lds
         end
 end
 
 ##
 ## Build our reset vector (This is where coreboot is entered)
 ##
 if USE_FALLBACK_IMAGE 
 	mainboardinit cpu/x86/16bit/reset16.inc 
 	ldscript /cpu/x86/16bit/reset16.lds 
 else
 	mainboardinit cpu/x86/32bit/reset32.inc 
 	ldscript /cpu/x86/32bit/reset32.lds 
 end
 
 if USE_DCACHE_RAM
 else
 ### Should this be in the northbridge code?
 mainboardinit arch/i386/lib/cpu_reset.inc
 end
 
 ##
 ## Include an id string (For safe flashing)
 ##
 mainboardinit arch/i386/lib/id.inc
 ldscript /arch/i386/lib/id.lds
 
 if USE_DCACHE_RAM
 ##
 ## Setup Cache-As-Ram
 ##
 mainboardinit cpu/amd/car/cache_as_ram.inc
 end
 
 ###
 ### This is the early phase of coreboot startup 
 ### Things are delicate and we test to see if we should
 ### failover to another image.
 ###
 if USE_FALLBACK_IMAGE
 if USE_DCACHE_RAM
        ldscript /arch/i386/lib/failover.lds
 else
        ldscript /arch/i386/lib/failover.lds
         mainboardinit ./failover.inc
 end
 end
 
 ###
 ### O.k. We aren't just an intermediary anymore!
 ###
 
 ##
 ## Setup RAM
 ##
 if USE_DCACHE_RAM
 
 if CONFIG_USE_INIT
 initobject auto.o
 else
 mainboardinit ./auto.inc
 end
 
 else
 
 ##
 ## Setup RAM
 ##
 mainboardinit cpu/x86/fpu/enable_fpu.inc
 mainboardinit cpu/x86/mmx/enable_mmx.inc
 mainboardinit cpu/x86/sse/enable_sse.inc
 mainboardinit ./auto.inc
 mainboardinit cpu/x86/sse/disable_sse.inc
 mainboardinit cpu/x86/mmx/disable_mmx.inc
 
 end
 
 ##
 ## Include the secondary Configuration files 
 ##
 if CONFIG_CHIP_NAME
 	config chip.h
 end
 
 # sample config for tyan/s2881
 chip northbridge/amd/amdk8/root_complex
         device apic_cluster 0 on
                 chip cpu/amd/socket_940
                         device apic 0 on end
                 end
         end
 	device pci_domain 0 on
 		chip northbridge/amd/amdk8
 			device pci 18.0 on end # LDT0
 			device pci 18.0 on end # LDT1
 			device pci 18.0 on #  northbridge 
 				#  devices on link 2, link 2 == LDT 2
 				chip southbridge/amd/amd8131
 					# the on/off keyword is mandatory
 					device pci 0.0 on 
                                                 chip drivers/pci/onboard
                                                         device pci 9.0 on end # Broadcom 5704
                                                         device pci 9.1 on end
                                                 end
                                                 chip drivers/pci/onboard
                                                         device pci a.0 on end # Adaptic
                                                         device pci a.1 on end
                                                 end
 					end
 					device pci 0.1 on end
 					device pci 1.0 on end
 					device pci 1.1 on end
 				end
 				chip southbridge/amd/amd8111
 					# this "device pci 0.0" is the parent the next one
 					# PCI bridge
 					device pci 0.0 on
 						device pci 0.0 on end
 						device pci 0.1 on end
 						device pci 0.2 off end
 						device pci 1.0 off end
                                                 chip drivers/pci/onboard
                                                         device pci 5.0 on end # SiI
                                                 end
                                                 chip drivers/pci/onboard
                                                         device pci 6.0 on end
 							register "rom_address" = "0xfff80000"
                                                 end
 					end
 					device pci 1.0 on
 						chip superio/winbond/w83627hf
 							device pnp 2e.0 on #  Floppy
                 	                 			io 0x60 = 0x3f0
                 	                			irq 0x70 = 6
                 	                			drq 0x74 = 2
 							end
                 	        			device pnp 2e.1 off #  Parallel Port
                 	                 			io 0x60 = 0x378
                 	                			irq 0x70 = 7
 							end
                 	        			device pnp 2e.2 on #  Com1
                 	                 			io 0x60 = 0x3f8
                 	                			irq 0x70 = 4
 							end
                 	        			device pnp 2e.3 off #  Com2
                 	                 			io 0x60 = 0x2f8
                 	                			irq 0x70 = 3
 							end
                 	        			device pnp 2e.5 on #  Keyboard
                 	                 			io 0x60 = 0x60
                 	                 			io 0x62 = 0x64
                 	                			irq 0x70 = 1
 								irq 0x72 = 12
 							end
                 	                                device pnp 2e.6 off #  CIR
                 	                                        io 0x60 = 0x100
                 	                                end
                 	                                device pnp 2e.7 off #  GAME_MIDI_GIPO1
                 	                                        io 0x60 = 0x220
                 	                                        io 0x62 = 0x300
                 	                                        irq 0x70 = 9
                 	                                end  
                 	                                device pnp 2e.8 off end #  GPIO2
                 	                                device pnp 2e.9 off end #  GPIO3
                 	                                device pnp 2e.a off end #  ACPI
                 	                                device pnp 2e.b on #  HW Monitor
                 	                                        io 0x60 = 0x290
                 	                                        irq 0x70 = 5
                 	                                end
 						end
 					end
 					device pci 1.1 on end
 					device pci 1.2 on end
                                         device pci 1.3 on 
                                                 chip drivers/generic/generic #dimm 0-0-0
                                                         device i2c 50 on end
                                                 end
                                                 chip drivers/generic/generic #dimm 0-0-1
                                                         device i2c 51 on end
                                                 end     
                                                 chip drivers/generic/generic #dimm 0-1-0
                                                         device i2c 52 on end
                                                 end
                                                 chip drivers/generic/generic #dimm 0-1-1
                                                         device i2c 53 on end
                                                 end
                                                 chip drivers/generic/generic #dimm 1-0-0
                                                         device i2c 54 on end
                                                 end
                                                 chip drivers/generic/generic #dimm 1-0-1
                                                         device i2c 55 on end
                                                 end
                                                 chip drivers/generic/generic #dimm 1-1-0
                                                         device i2c 56 on end
                                                 end
                                                 chip drivers/generic/generic #dimm 1-1-1
                                                         device i2c 57 on end
                                                 end
                                                 chip drivers/i2c/adm1027 # ADT7463A CPU0/1 temp, CPU1 vid, SYS FAN 1/2/3
                                                         device i2c 2d on end
                                                 end
                                                 chip drivers/generic/generic # Winbond HWM 0x54 CPU0/1 VRM temp, SYSFAN 4,CPU0 vid, CPU0/1 FAN
                                                         device i2c 2a on end
                                                 end
                                                 chip drivers/generic/generic # Winbond HWM 0x92
                                                         device i2c 49 on end
                                                 end
                                                 chip drivers/generic/generic # Winbond HWM 0x94
                                                         device i2c 4a on end
                                                 end
                                         end # acpi
 					device pci 1.5 off end
 					device pci 1.6 off end
                                         register "ide0_enable" = "1"
                                         register "ide1_enable" = "1"
 				end
 			end #  device pci 18.0 
 			
 			device pci 18.1 on end
 			device pci 18.2 on end
 			device pci 18.3 on end
 		end
 	end 
 end
 
diff --git a/src/mainboard/tyan/s2882/Config.lb b/src/mainboard/tyan/s2882/Config.lb
index 704fdf8..7c9d3f6 100644
--- a/src/mainboard/tyan/s2882/Config.lb
+++ b/src/mainboard/tyan/s2882/Config.lb
@@ -1,327 +1,327 @@
 ##
 ## Compute the location and size of where this firmware image
 ## (coreboot plus bootloader) will live in the boot rom chip.
 ##
 if USE_FALLBACK_IMAGE
 	default ROM_SECTION_SIZE   = FALLBACK_SIZE
 	default ROM_SECTION_OFFSET = ( ROM_SIZE - FALLBACK_SIZE )
 else
 	default ROM_SECTION_SIZE   = ( ROM_SIZE - FALLBACK_SIZE )
 	default ROM_SECTION_OFFSET = 0
 end
 
 ##
 ## Compute the start location and size size of
 ## The coreboot bootloader.
 ##
 default PAYLOAD_SIZE            = ( ROM_SECTION_SIZE - ROM_IMAGE_SIZE )
 default CONFIG_ROM_PAYLOAD_START = (0xffffffff - ROM_SIZE + ROM_SECTION_OFFSET + 1)
 
 ##
 ## Compute where this copy of coreboot will start in the boot rom
 ##
 default _ROMBASE      = ( CONFIG_ROM_PAYLOAD_START + PAYLOAD_SIZE )
 
 ##
 ## Compute a range of ROM that can cached to speed up coreboot,
 ## execution speed.
 ##
 ## XIP_ROM_SIZE must be a power of 2.
 ## XIP_ROM_BASE must be a multiple of XIP_ROM_SIZE
 ##
 default XIP_ROM_SIZE=65536
 default XIP_ROM_BASE = ( _ROMBASE + ROM_IMAGE_SIZE - XIP_ROM_SIZE )
 
 arch i386 end 
 
 ##
 ## Build the objects we have code for in this directory.
 ##
 
 driver mainboard.o
 
 #dir /drivers/si/3114
 
 if HAVE_MP_TABLE object mptable.o end
 if HAVE_PIRQ_TABLE object irq_tables.o end
 
 if USE_DCACHE_RAM
 
 if CONFIG_USE_INIT
 
 makerule ./auto.o
         depends "$(MAINBOARD)/cache_as_ram_auto.c option_table.h"
         action "$(CC) $(DISTRO_CFLAGS) -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/cache_as_ram_auto.c -Os -nostdinc -nostdlib -fno-builtin -Wall -c -o auto.o" 
 end
 
 else    
                 
 makerule ./auto.inc
         depends "$(MAINBOARD)/cache_as_ram_auto.c option_table.h"
         action "$(CC) $(DISTRO_CFLAGS) -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/cache_as_ram_auto.c -Os -nostdinc -nostdlib -fno-builtin -Wall -c -S -o $@"         
         action "perl -e 's/.rodata/.rom.data/g' -pi $@"
         action "perl -e 's/.text/.section .rom.text/g' -pi $@"
 end
 
 end
 else
 
 ##
 ## Romcc output
 ##
 makerule ./failover.E
-        depends "$(MAINBOARD)/failover.c ./romcc"
-        action "./romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+        depends "$(MAINBOARD)/failover.c ../romcc"
+        action "../romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 end
 
 makerule ./failover.inc
-        depends "$(MAINBOARD)/failover.c ./romcc"
-        action "./romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+        depends "$(MAINBOARD)/failover.c ../romcc"
+        action "../romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 end
 
 makerule ./auto.E
-        depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-        action  "./romcc -E -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+        depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+        action  "../romcc -E -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 makerule ./auto.inc
-        depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-        action  "./romcc    -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+        depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+        action  "../romcc    -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 
 end
 ##
 ## Build our 16 bit and 32 bit coreboot entry code
 ##
 if USE_FALLBACK_IMAGE
         mainboardinit cpu/x86/16bit/entry16.inc
         ldscript /cpu/x86/16bit/entry16.lds
 end
 
 mainboardinit cpu/x86/32bit/entry32.inc
 
 if USE_DCACHE_RAM
         if CONFIG_USE_INIT
                 ldscript /cpu/x86/32bit/entry32.lds
         end
 
         if CONFIG_USE_INIT
                 ldscript      /cpu/amd/car/cache_as_ram.lds
         end
 end
 
 ##
 ## Build our reset vector (This is where coreboot is entered)
 ##
 if USE_FALLBACK_IMAGE 
 	mainboardinit cpu/x86/16bit/reset16.inc 
 	ldscript /cpu/x86/16bit/reset16.lds 
 else
 	mainboardinit cpu/x86/32bit/reset32.inc 
 	ldscript /cpu/x86/32bit/reset32.lds 
 end
 
 if USE_DCACHE_RAM
 else
 ### Should this be in the northbridge code?
 mainboardinit arch/i386/lib/cpu_reset.inc
 end
 
 ##
 ## Include an id string (For safe flashing)
 ##
 mainboardinit arch/i386/lib/id.inc
 ldscript /arch/i386/lib/id.lds
 
 if USE_DCACHE_RAM
 ##
 ## Setup Cache-As-Ram
 ##
 mainboardinit cpu/amd/car/cache_as_ram.inc
 end
 
 ###
 ### This is the early phase of coreboot startup 
 ### Things are delicate and we test to see if we should
 ### failover to another image.
 ###
 if USE_FALLBACK_IMAGE
 if USE_DCACHE_RAM
        ldscript /arch/i386/lib/failover.lds
 else
        ldscript /arch/i386/lib/failover.lds
         mainboardinit ./failover.inc
 end
 end
 
 ###
 ### O.k. We aren't just an intermediary anymore!
 ###
 
 ##
 ## Setup RAM
 ##
 if USE_DCACHE_RAM
 
 if CONFIG_USE_INIT
 initobject auto.o
 else
 mainboardinit ./auto.inc
 end
 
 else
 
 ##
 ## Setup RAM
 ##
 mainboardinit cpu/x86/fpu/enable_fpu.inc
 mainboardinit cpu/x86/mmx/enable_mmx.inc
 mainboardinit cpu/x86/sse/enable_sse.inc
 mainboardinit ./auto.inc
 mainboardinit cpu/x86/sse/disable_sse.inc
 mainboardinit cpu/x86/mmx/disable_mmx.inc
 
 end
 
 ##
 ## Include the secondary Configuration files 
 ##
 if CONFIG_CHIP_NAME
 	config chip.h
 end
 
 # sample config for tyan/s2882
 chip northbridge/amd/amdk8/root_complex
         device apic_cluster 0 on
                 chip cpu/amd/socket_940
                         device apic 0 on end
                 end
         end
 
 	device pci_domain 0 on
 		chip northbridge/amd/amdk8
 			device pci 18.0 on #  northbridge 
 				#  devices on link 0, link 0 == LDT 0
 				chip southbridge/amd/amd8131
 					# the on/off keyword is mandatory
 					device pci 0.0 on
                                                 chip drivers/pci/onboard 
                                                         device pci 6.0 on end # adaptec
                                                         device pci 6.1 on end
                                                 end 
                                                 chip drivers/pci/onboard
                                                         device pci 9.0 on end # broadcom 5704
                                                         device pci 9.1 on end
                                                 end
 					end
 					device pci 0.1 on end
 					device pci 1.0 on end
 					device pci 1.1 on end
 				end
 				chip southbridge/amd/amd8111
 					# this "device pci 0.0" is the parent the next one
 					# PCI bridge
 					device pci 0.0 on
 						device pci 0.0 on end
 						device pci 0.1 on end
 						device pci 0.2 off end
 						device pci 1.0 off end
                                                 chip drivers/pci/onboard  
                                                         device pci 5.0 on end
                                                 end
                                         #       chip drivers/ati/ragexl
                                                 chip drivers/pci/onboard
                                                         device pci 6.0 on end
                                                         register "rom_address" = "0xfff00000"
                                                 end
                                                 chip drivers/pci/onboard 
                                                         device pci 8.0 on end #intel 10/100
                                                 end
 					end
 					device pci 1.0 on
 						chip superio/winbond/w83627hf
 							device pnp 2e.0 on #  Floppy
                 	                 			io 0x60 = 0x3f0
                 	                			irq 0x70 = 6
                 	                			drq 0x74 = 2
 							end
                 	        			device pnp 2e.1 off #  Parallel Port
                 	                 			io 0x60 = 0x378
                 	                			irq 0x70 = 7
 							end
                 	        			device pnp 2e.2 on #  Com1
                 	                 			io 0x60 = 0x3f8
                 	                			irq 0x70 = 4
 							end
                 	        			device pnp 2e.3 off #  Com2
                 	                 			io 0x60 = 0x2f8
                 	                			irq 0x70 = 3
 							end
                 	        			device pnp 2e.5 on #  Keyboard
                 	                 			io 0x60 = 0x60
                 	                 			io 0x62 = 0x64
                 	                			irq 0x70 = 1
 								irq 0x72 = 12
 							end
                 	                                device pnp 2e.6 off #  CIR
                 	                                        io 0x60 = 0x100
                 	                                end
                 	                                device pnp 2e.7 off #  GAME_MIDI_GIPO1
                 	                                        io 0x60 = 0x220
                 	                                        io 0x62 = 0x300
                 	                                        irq 0x70 = 9
                 	                                end  
                 	                                device pnp 2e.8 off end #  GPIO2
                 	                                device pnp 2e.9 off end #  GPIO3
                 	                                device pnp 2e.a off end #  ACPI
                 	                                device pnp 2e.b on #  HW Monitor
                 	                                        io 0x60 = 0x290
                 	                                        irq 0x70 = 5
                 	                                end
 						end
 					end
 					device pci 1.1 on end
 					device pci 1.2 on end
 					device pci 1.3 on end
 					device pci 1.3 on 
 #						 chip drivers/generic/generic #dimm 0-0-0
 #							 device i2c 50 on end
 #						 end
 #						 chip drivers/generic/generic #dimm 0-0-1
 #							 device i2c 51 on end
 #						 end	 
 #						 chip drivers/generic/generic #dimm 0-1-0
 #							 device i2c 52 on end
 #						 end
 #						 chip drivers/generic/generic #dimm 0-1-1
 #							 device i2c 53 on end
 #						 end
 #						 chip drivers/generic/generic #dimm 1-0-0
 #							 device i2c 54 on end
 #						 end
 #						 chip drivers/generic/generic #dimm 1-0-1
 #							 device i2c 55 on end
 #						 end
 #						 chip drivers/generic/generic #dimm 1-1-0
 #							 device i2c 56 on end
 #						 end
 #						 chip drivers/generic/generic #dimm 1-1-1
 #							 device i2c 57 on end
 #						 end
                                         end # acpi
 					device pci 1.5 off end
 					device pci 1.6 off end
 					register "ide0_enable" = "1"
 					register "ide1_enable" = "1"
 				end
 			end #  device pci 18.0 
 			
                 	device pci 18.0 on end
                 	device pci 18.0 on end
 			
 			device pci 18.1 on end
 			device pci 18.2 on end
 			device pci 18.3 on end
 		end # NB
 	end #pci_domain
 end
 
diff --git a/src/mainboard/tyan/s2885/Config.lb b/src/mainboard/tyan/s2885/Config.lb
index d0d8415..9eff1ce 100644
--- a/src/mainboard/tyan/s2885/Config.lb
+++ b/src/mainboard/tyan/s2885/Config.lb
@@ -1,327 +1,327 @@
 ##
 ## Compute the location and size of where this firmware image
 ## (coreboot plus bootloader) will live in the boot rom chip.
 ##
 if USE_FALLBACK_IMAGE
 	default ROM_SECTION_SIZE   = FALLBACK_SIZE
 	default ROM_SECTION_OFFSET = ( ROM_SIZE - FALLBACK_SIZE )
 else
 	default ROM_SECTION_SIZE   = ( ROM_SIZE - FALLBACK_SIZE )
 	default ROM_SECTION_OFFSET = 0
 end
 
 ##
 ## Compute the start location and size size of
 ## The coreboot bootloader.
 ##
 default PAYLOAD_SIZE            = ( ROM_SECTION_SIZE - ROM_IMAGE_SIZE )
 default CONFIG_ROM_PAYLOAD_START = (0xffffffff - ROM_SIZE + ROM_SECTION_OFFSET + 1)
 
 ##
 ## Compute where this copy of coreboot will start in the boot rom
 ##
 default _ROMBASE      = ( CONFIG_ROM_PAYLOAD_START + PAYLOAD_SIZE )
 
 ##
 ## Compute a range of ROM that can cached to speed up coreboot,
 ## execution speed.
 ##
 ## XIP_ROM_SIZE must be a power of 2.
 ## XIP_ROM_BASE must be a multiple of XIP_ROM_SIZE
 ##
 default XIP_ROM_SIZE=65536
 default XIP_ROM_BASE = ( _ROMBASE + ROM_IMAGE_SIZE - XIP_ROM_SIZE )
 
 arch i386 end 
 
 ##
 ## Build the objects we have code for in this directory.
 ##
 
 driver mainboard.o
 
 #dir /drivers/si/3114
 object get_bus_conf.o
 if HAVE_MP_TABLE object mptable.o end
 if HAVE_PIRQ_TABLE object irq_tables.o end
 
 if USE_DCACHE_RAM
 
 if CONFIG_USE_INIT
 
 makerule ./auto.o
         depends "$(MAINBOARD)/cache_as_ram_auto.c option_table.h"
         action "$(CC) $(DISTRO_CFLAGS) -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/cache_as_ram_auto.c -Os -nostdinc -nostdlib -fno-builtin -Wall -c -o auto.o" 
 end
 
 else    
                 
 makerule ./auto.inc
         depends "$(MAINBOARD)/cache_as_ram_auto.c option_table.h"
         action "$(CC) $(DISTRO_CFLAGS) -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/cache_as_ram_auto.c -Os -nostdinc -nostdlib -fno-builtin -Wall -c -S -o $@"         
         action "perl -e 's/.rodata/.rom.data/g' -pi $@"
         action "perl -e 's/.text/.section .rom.text/g' -pi $@"
 end
 
 end
 else
   
 ##
 ## Romcc output
 ##
 makerule ./failover.E
-        depends "$(MAINBOARD)/failover.c ./romcc"
-        action "./romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+        depends "$(MAINBOARD)/failover.c ../romcc"
+        action "../romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 end
 
 makerule ./failover.inc
-        depends "$(MAINBOARD)/failover.c ./romcc"
-        action "./romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+        depends "$(MAINBOARD)/failover.c ../romcc"
+        action "../romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 end
 
 makerule ./auto.E
-        depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-        action  "./romcc -E -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+        depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+        action  "../romcc -E -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 makerule ./auto.inc
-        depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-        action  "./romcc    -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+        depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+        action  "../romcc    -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 
 end
 ##
 ## Build our 16 bit and 32 bit coreboot entry code
 ##
 if USE_FALLBACK_IMAGE
         mainboardinit cpu/x86/16bit/entry16.inc
         ldscript /cpu/x86/16bit/entry16.lds
 end
 
 mainboardinit cpu/x86/32bit/entry32.inc
 
 if USE_DCACHE_RAM
         if CONFIG_USE_INIT
                 ldscript /cpu/x86/32bit/entry32.lds
         end
 
         if CONFIG_USE_INIT
                 ldscript      /cpu/amd/car/cache_as_ram.lds
         end
 end
 
 ##
 ## Build our reset vector (This is where coreboot is entered)
 ##
 if USE_FALLBACK_IMAGE 
 	mainboardinit cpu/x86/16bit/reset16.inc 
 	ldscript /cpu/x86/16bit/reset16.lds 
 else
 	mainboardinit cpu/x86/32bit/reset32.inc 
 	ldscript /cpu/x86/32bit/reset32.lds 
 end
 
 if USE_DCACHE_RAM
 else
 ### Should this be in the northbridge code?
 mainboardinit arch/i386/lib/cpu_reset.inc
 end
 
 ##
 ## Include an id string (For safe flashing)
 ##
 mainboardinit arch/i386/lib/id.inc
 ldscript /arch/i386/lib/id.lds
 
 if USE_DCACHE_RAM
 ##
 ## Setup Cache-As-Ram
 ##
 mainboardinit cpu/amd/car/cache_as_ram.inc
 end
 
 ###
 ### This is the early phase of coreboot startup 
 ### Things are delicate and we test to see if we should
 ### failover to another image.
 ###
 if USE_FALLBACK_IMAGE
 if USE_DCACHE_RAM
        ldscript /arch/i386/lib/failover.lds
 else
        ldscript /arch/i386/lib/failover.lds
         mainboardinit ./failover.inc
 end
 end
 
 ###
 ### O.k. We aren't just an intermediary anymore!
 ###
 
 ##
 ## Setup RAM
 ##
 if USE_DCACHE_RAM
 
 if CONFIG_USE_INIT
 initobject auto.o
 else
 mainboardinit ./auto.inc
 end
 
 else
 
 ##
 ## Setup RAM
 ##
 mainboardinit cpu/x86/fpu/enable_fpu.inc
 mainboardinit cpu/x86/mmx/enable_mmx.inc
 mainboardinit cpu/x86/sse/enable_sse.inc
 mainboardinit ./auto.inc
 mainboardinit cpu/x86/sse/disable_sse.inc
 mainboardinit cpu/x86/mmx/disable_mmx.inc
 
 end
 
 ##
 ## Include the secondary Configuration files 
 ##
 if CONFIG_CHIP_NAME
 	config chip.h
 end
 
 # sample config for tyan/s2885
 chip northbridge/amd/amdk8/root_complex
         device apic_cluster 0 on
                 chip cpu/amd/socket_940
                         device apic 0 on end
                 end
         end
 	device pci_domain 0 on
 		chip northbridge/amd/amdk8
 			device pci 18.0 on # LDT0
 				chip southbridge/amd/amd8151
 					# the on/off keyword is mandatory
 					device pci 0.0 on end
 					device pci 1.0 on end
 				end
 			end
 			device pci 18.0 on end # LDT1
 			device pci 18.0 on #  northbridge 
 				#  devices on link 2, link 2 == LDT 2
 				chip southbridge/amd/amd8131
 					# the on/off keyword is mandatory
 					device pci 0.0 on 
                                                 chip drivers/pci/onboard
                                                         device pci 9.0 on end # broadcom 5703
                                                 end
 					end
 					device pci 0.1 on end
 					device pci 1.0 on end
 					device pci 1.1 on end
 				end
 				chip southbridge/amd/amd8111
 					# this "device pci 0.0" is the parent the next one
 					# PCI bridge
 					device pci 0.0 on
 						device pci 0.0 on end
 						device pci 0.1 on end
 						device pci 0.2 off end
 						device pci 1.0 off end
                                                 chip drivers/pci/onboard
                                                         device pci b.0 on end # SiI 3114
                                                 end
 					end
 					device pci 1.0 on
 						chip superio/winbond/w83627hf
 							device pnp 2e.0 on #  Floppy
                 	                 			io 0x60 = 0x3f0
                 	                			irq 0x70 = 6
                 	                			drq 0x74 = 2
 							end
                 	        			device pnp 2e.1 off #  Parallel Port
                 	                 			io 0x60 = 0x378
                 	                			irq 0x70 = 7
 							end
                 	        			device pnp 2e.2 on #  Com1
                 	                 			io 0x60 = 0x3f8
                 	                			irq 0x70 = 4
 							end
                 	        			device pnp 2e.3 on #  Com2
                 	                 			io 0x60 = 0x2f8
                 	                			irq 0x70 = 3
 							end
                 	        			device pnp 2e.5 on #  Keyboard
                 	                 			io 0x60 = 0x60
                 	                 			io 0x62 = 0x64
                 	                			irq 0x70 = 1
 								irq 0x72 = 12
 							end
                 	        			device pnp 2e.6 off #  CIR
 								io 0x60 = 0x100
 							end
                 	        			device pnp 2e.7 off #  GAME_MIDI_GIPO1
 								io 0x60 = 0x220
 								io 0x62 = 0x300
 								irq 0x70 = 9
 							end						
                 	        			device pnp 2e.8 off end #  GPIO2
                 	        			device pnp 2e.9 off end #  GPIO3
                 	        			device pnp 2e.a off end #  ACPI
                 	        			device pnp 2e.b on #  HW Monitor
  					 			io 0x60 = 0x290
 								irq 0x70 = 5
                 					end
 						end
 					end
 					device pci 1.1 on end
 					device pci 1.2 on end
 					device pci 1.3 on
                                                 chip drivers/generic/generic #dimm 0-0-0
                                                         device i2c 50 on end
                                                 end              
                                                 chip drivers/generic/generic #dimm 0-0-1
                                                         device i2c 51 on end
                                                 end     
                                                 chip drivers/generic/generic #dimm 0-1-0
                                                         device i2c 52 on end
                                                 end             
                                                 chip drivers/generic/generic #dimm 0-1-1
                                                         device i2c 53 on end
                                                 end              
                                                 chip drivers/generic/generic #dimm 1-0-0
                                                         device i2c 54 on end
                                                 end     
                                                 chip drivers/generic/generic #dimm 1-0-1
                                                         device i2c 55 on end
                                                 end
                                                 chip drivers/generic/generic #dimm 1-1-0
                                                         device i2c 56 on end
                                                 end     
                                                 chip drivers/generic/generic #dimm 1-1-1
                                                         device i2c 57 on end
                                                 end 
 					end # acpi
 					device pci 1.5 on end
 					device pci 1.6 off end
                 	                register "ide0_enable" = "1"
                 	                register "ide1_enable" = "1"
 				end
 			end #  device pci 18.0 
 			
 			device pci 18.1 on end
 			device pci 18.2 on end
 			device pci 18.3 on end
 		end
 
 	end #pci_domain
 
 #        chip drivers/generic/debug 
 #                device pnp 0.0 off end
 #                device pnp 0.1 off end 
 #                device pnp 0.2 off end
 #                device pnp 0.3 off end
 #		device pnp 0.4 off end
 #		device pnp 0.5 on end
 #        end
 end
 
diff --git a/src/mainboard/tyan/s2891/Config.lb b/src/mainboard/tyan/s2891/Config.lb
index 0a28891..90164c7 100644
--- a/src/mainboard/tyan/s2891/Config.lb
+++ b/src/mainboard/tyan/s2891/Config.lb
@@ -1,365 +1,365 @@
 ##
 ## Compute the location and size of where this firmware image
 ## (coreboot plus bootloader) will live in the boot rom chip.
 ##
 if USE_FALLBACK_IMAGE
 	default ROM_SECTION_SIZE   = FALLBACK_SIZE
 	default ROM_SECTION_OFFSET = ( ROM_SIZE - FALLBACK_SIZE )
 else
 	default ROM_SECTION_SIZE   = ( ROM_SIZE - FALLBACK_SIZE )
 	default ROM_SECTION_OFFSET = 0
 end
 
 ##
 ## Compute the start location and size size of
 ## The coreboot bootloader.
 ##
 default PAYLOAD_SIZE            = ( ROM_SECTION_SIZE - ROM_IMAGE_SIZE )
 default CONFIG_ROM_PAYLOAD_START = (0xffffffff - ROM_SIZE + ROM_SECTION_OFFSET + 1)
 default CONFIG_ROM_PAYLOAD     = 1
 
 ##
 ## Compute where this copy of coreboot will start in the boot rom
 ##
 default _ROMBASE      = ( CONFIG_ROM_PAYLOAD_START + PAYLOAD_SIZE )
 
 ##
 ## Compute a range of ROM that can cached to speed up coreboot,
 ## execution speed.
 ##
 ## XIP_ROM_SIZE must be a power of 2.
 ## XIP_ROM_BASE must be a multiple of XIP_ROM_SIZE
 ##
 default XIP_ROM_SIZE=65536
 default XIP_ROM_BASE = ( _ROMBASE + ROM_IMAGE_SIZE - XIP_ROM_SIZE )
 
 arch i386 end 
 
 
 ##
 ## Build the objects we have code for in this directory.
 ##
 
 driver mainboard.o
 
 #dir /drivers/ati/ragexl
 
 #needed by irq_tables and mptable and acpi_tables
 object get_bus_conf.o
 
 if HAVE_MP_TABLE object mptable.o end
 if HAVE_PIRQ_TABLE object irq_tables.o end
 #object reset.o
 
 if USE_DCACHE_RAM
 
 	if CONFIG_USE_INIT
 
 		makerule ./auto.o
         		depends "$(MAINBOARD)/cache_as_ram_auto.c option_table.h"
 		        action "$(CC) $(DISTRO_CFLAGS) -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/cache_as_ram_auto.c -Os -nostdinc -nostdlib -fno-builtin -Wall -c -o auto.o"
 		end
 
 	else
 
 		makerule ./auto.inc
 		        depends "$(MAINBOARD)/cache_as_ram_auto.c option_table.h"
 		        action "$(CC) $(DISTRO_CFLAGS) -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/cache_as_ram_auto.c -Os -nostdinc -nostdlib -fno-builtin -Wall -c -S -o $@"
 			action "perl -e 's/.rodata/.rom.data/g' -pi $@"
 			action "perl -e 's/.text/.section .rom.text/g' -pi $@"
 		end
 
 	end
 else
 
 	##
 	## Romcc output
 	##
 	makerule ./failover.E
-        	depends "$(MAINBOARD)/failover.c ./romcc"
-	        action "./romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+        	depends "$(MAINBOARD)/failover.c ../romcc"
+	        action "../romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 	end
 
 	makerule ./failover.inc
-        	depends "$(MAINBOARD)/failover.c ./romcc"
-	        action "./romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+        	depends "$(MAINBOARD)/failover.c ../romcc"
+	        action "../romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 	end
 
 	makerule ./auto.E
-        	depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-	        action  "./romcc -E -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+        	depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+	        action  "../romcc -E -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 	end
 
 	makerule ./auto.inc
-        	depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-	        action  "./romcc    -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+        	depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+	        action  "../romcc    -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 	end
 
 end
 
 ##
 ## Build our 16 bit and 32 bit coreboot entry code
 ##
 if USE_FALLBACK_IMAGE
         mainboardinit cpu/x86/16bit/entry16.inc
         ldscript /cpu/x86/16bit/entry16.lds
 end
 
 mainboardinit cpu/x86/32bit/entry32.inc
 
 
 if USE_DCACHE_RAM
 	if CONFIG_USE_INIT
 		ldscript /cpu/x86/32bit/entry32.lds
 	end
 
 	if CONFIG_USE_INIT
 		ldscript /cpu/amd/car/cache_as_ram.lds
 	end
 end
 
 ##
 ## Build our reset vector (This is where coreboot is entered)
 ##
 if USE_FALLBACK_IMAGE 
 	mainboardinit cpu/x86/16bit/reset16.inc 
 	ldscript /cpu/x86/16bit/reset16.lds 
 else
 	mainboardinit cpu/x86/32bit/reset32.inc 
 	ldscript /cpu/x86/32bit/reset32.lds 
 end
 
 if USE_DCACHE_RAM
 else
 	### Should this be in the northbridge code?
 	mainboardinit arch/i386/lib/cpu_reset.inc
 end
 
 ##
 ## Include an id string (For safe flashing)
 ##
 mainboardinit southbridge/nvidia/ck804/id.inc
 ldscript /southbridge/nvidia/ck804/id.lds
 
 ##
 ## ROMSTRAP table for CK804
 ##
 if USE_FALLBACK_IMAGE
 	mainboardinit southbridge/nvidia/ck804/romstrap.inc
 	ldscript /southbridge/nvidia/ck804/romstrap.lds
 end
 
 if USE_DCACHE_RAM
 	##
 	## Setup Cache-As-Ram
 	##
 	mainboardinit cpu/amd/car/cache_as_ram.inc
 end
 
 ###
 ### This is the early phase of coreboot startup 
 ### Things are delicate and we test to see if we should
 ### failover to another image.
 ###
 if USE_FALLBACK_IMAGE
 	ldscript /arch/i386/lib/failover.lds
 	if USE_DCACHE_RAM
 	else
 		mainboardinit ./failover.inc
 	end
 end
 
 ###
 ### O.k. We aren't just an intermediary anymore!
 ###
 
 ##
 ## Setup RAM
 ##
 if USE_DCACHE_RAM
 
 	if CONFIG_USE_INIT
 		initobject auto.o
 	else
 		mainboardinit ./auto.inc
 	end
 
 else
 	# ROMCC
 	mainboardinit cpu/x86/fpu/enable_fpu.inc
 	mainboardinit cpu/x86/mmx/enable_mmx.inc
 	mainboardinit cpu/x86/sse/enable_sse.inc
 	mainboardinit ./auto.inc
 	mainboardinit cpu/x86/sse/disable_sse.inc
 	mainboardinit cpu/x86/mmx/disable_mmx.inc
 
 end
 
 
 ##
 ## Include the secondary Configuration files 
 ##
 if CONFIG_CHIP_NAME
         config chip.h
 end
 
 
 # sample config for tyan/s2891
 chip northbridge/amd/amdk8/root_complex
         device apic_cluster 0 on        
                 chip cpu/amd/socket_940 
                         device apic 0 on end
                 end                     
         end  
 
 	device pci_domain 0 on
 		chip northbridge/amd/amdk8 #mc0
 			device pci 18.0 on #  northbridge 
 				#  devices on link 0, link 0 == LDT 0 
 			        chip southbridge/nvidia/ck804 
 					device pci 0.0 on end   # HT
                 			device pci 1.0 on # LPC
                                         	chip superio/winbond/w83627hf
                                                 	device pnp 2e.0 off #  Floppy
                                                         	io 0x60 = 0x3f0
 	                                                        irq 0x70 = 6
         	                                                drq 0x74 = 2
                 	                                end
                         	                        device pnp 2e.1 off #  Parallel Port
                                 	                        io 0x60 = 0x378
                                         	                irq 0x70 = 7
                                                 	end
 	                                                device pnp 2e.2 on #  Com1
         	                                                io 0x60 = 0x3f8
                 	                                        irq 0x70 = 4
                         	                        end
                                 	                device pnp 2e.3 off #  Com2
                                         	                io 0x60 = 0x2f8
                                                 	        irq 0x70 = 3
 	                                                end
         	                                        device pnp 2e.5 on #  Keyboard
                 	                                        io 0x60 = 0x60
                         	                                io 0x62 = 0x64
                                 	                        irq 0x70 = 1
                                         	                irq 0x72 = 12
                                                 	end
 	                                                device pnp 2e.6 off #  CIR
         	                                                io 0x60 = 0x100
                 	                                end
                         	                        device pnp 2e.7 off #  GAME_MIDI_GIPO1
                                 	                        io 0x60 = 0x220
                                         	                io 0x62 = 0x300
                                                 	        irq 0x70 = 9
 	                                                end
         	                                        device pnp 2e.8 off end #  GPIO2
                 	                                device pnp 2e.9 off end #  GPIO3
                         	                        device pnp 2e.a off end #  ACPI
                                 	                device pnp 2e.b off #  HW Monitor
                                         	                io 0x60 = 0x290
                                                 	        irq 0x70 = 5
 	                                                end
         	                                end
 					end
                                         device pci 1.1 on # SM 0
 #                                                chip drivers/generic/generic #dimm 0-0-0
 #                                                        device i2c 50 on end
 #                                                end
 #                                                chip drivers/generic/generic #dimm 0-0-1
 #                                                        device i2c 51 on end
 #                                                end
 #                                                chip drivers/generic/generic #dimm 0-1-0
 #                                                        device i2c 52 on end
 #                                                end
 #                                                chip drivers/generic/generic #dimm 0-1-1
 #                                                        device i2c 53 on end
 #                                                end
 #                                                chip drivers/generic/generic #dimm 1-0-0
 #                                                        device i2c 54 on end
 #                                                end
 #                                                chip drivers/generic/generic #dimm 1-0-1
 #                                                        device i2c 55 on end
 #                                                end
 #                                                chip drivers/generic/generic #dimm 1-1-0
 #                                                        device i2c 56 on end
 #                                                end
 #                                                chip drivers/generic/generic #dimm 1-1-1
 #                                                        device i2c 57 on end
 #                                                end
                                         end # SM
 #		        	        device pci 1.1 on # SM 1
 #						chip drivers/i2c/adm1027 # ADT7463A CPU0 temp, SYS FAN 2/3/4
 #                                                	device i2c 2d on end
 #                                                end
 #                                                chip drivers/i2c/adm1027 # ADT7463A CPU1 temp, CPU0/1 FAN , SYS FAN 1/5 
 #		                                        device i2c 2e on end
 #                                                end
 #                                                chip drivers/generic/generic # Winbond HWM 0x54 CPU0/1 VRM temp, SYSFAN 6/7, SB FAN
 #                                                        device i2c 2a on end
 #                                                end
 #                                                chip drivers/generic/generic # Winbond HWM 0x92
 #                                                        device i2c 49 on end
 #                                                end
 #                                                chip drivers/generic/generic # Winbond HWM 0x94
 #                                                        device i2c 4a on end
 #                                                end
 #					end #SM
                 			device pci 2.0 on end # USB 1.1
 	                		device pci 2.1 on end # USB 2
         	        		device pci 4.0 off end # ACI
                 			device pci 4.1 off end # MCI
                 			device pci 6.0 on end # IDE
                 			device pci 7.0 on end # SATA 1
 	                		device pci 8.0 on end # SATA 0
         	        		device pci 9.0 on  # PCI
 					#	chip drivers/ati/ragexl
                                                 chip drivers/pci/onboard
                                                         device pci 7.0 on end
                                                         #register "rom_address" = "0xfff80000" #for 512K
                                                         register "rom_address" = "0xfff00000" #for 1M
                                                 end
 					end
                 			device pci a.0 off end # NIC
                				device pci b.0 off end # PCI E 3
                 			device pci c.0 off end # PCI E 2
 	                		device pci d.0 on end # PCI E 1
         	        		device pci e.0 on end # PCI E 0
                 	                register "ide0_enable" = "1"
                         	        register "ide1_enable" = "1"
 	                                register "sata0_enable" = "1"
         	                        register "sata1_enable" = "1"
 				end
 			end #  device pci 18.0 
 			device pci 18.0 on end # Link 1
 			device pci 18.0 on
 	                        #  devices on link 2, link 2 == LDT 2
         	                chip southbridge/amd/amd8131
                 	                # the on/off keyword is mandatory
                         	        device pci 0.0 on end
 	                                device pci 0.1 on end
         	                        device pci 1.0 on
                                                 chip drivers/pci/onboard
                                                         device pci 9.0 on end
 							device pci 9.1 on end
                                                 end
 					end
                 	                device pci 1.1 on end
                         	end
 			end # device pci 18.0
 			device pci 18.1 on end
 			device pci 18.2 on end
 			device pci 18.3 on end
 		end #mc0
 		
 	end # pci_domain
 #       chip drivers/generic/debug                      
 #                device pnp 0.0 off end # chip name      
 #                device pnp 0.1 off end # pci_regs_all
 #                device pnp 0.2 off end # mem
 #                device pnp 0.3 off end # cpuid
 #                device pnp 0.4 off end # smbus_regs_all
 #                device pnp 0.5 off end # dual core msr
 #                device pnp 0.6 off end # cache size
 #                device pnp 0.7 off end # tsc
 #		device pnp 0.8 on  end # hard_reset
 #       end 
 end # root_complex
diff --git a/src/mainboard/tyan/s2892/Config.lb b/src/mainboard/tyan/s2892/Config.lb
index c40068a..90a6e02 100644
--- a/src/mainboard/tyan/s2892/Config.lb
+++ b/src/mainboard/tyan/s2892/Config.lb
@@ -1,364 +1,364 @@
 ##
 ## Compute the location and size of where this firmware image
 ## (coreboot plus bootloader) will live in the boot rom chip.
 ##
 if USE_FALLBACK_IMAGE
 	default ROM_SECTION_SIZE   = FALLBACK_SIZE
 	default ROM_SECTION_OFFSET = ( ROM_SIZE - FALLBACK_SIZE )
 else
 	default ROM_SECTION_SIZE   = ( ROM_SIZE - FALLBACK_SIZE )
 	default ROM_SECTION_OFFSET = 0
 end
 
 ##
 ## Compute the start location and size size of
 ## The coreboot bootloader.
 ##
 default PAYLOAD_SIZE            = ( ROM_SECTION_SIZE - ROM_IMAGE_SIZE )
 default CONFIG_ROM_PAYLOAD_START = (0xffffffff - ROM_SIZE + ROM_SECTION_OFFSET + 1)
 default CONFIG_ROM_PAYLOAD     = 1
 
 ##
 ## Compute where this copy of coreboot will start in the boot rom
 ##
 default _ROMBASE      = ( CONFIG_ROM_PAYLOAD_START + PAYLOAD_SIZE )
 
 ##
 ## Compute a range of ROM that can cached to speed up coreboot,
 ## execution speed.
 ##
 ## XIP_ROM_SIZE must be a power of 2.
 ## XIP_ROM_BASE must be a multiple of XIP_ROM_SIZE
 ##
 default XIP_ROM_SIZE=65536
 default XIP_ROM_BASE = ( _ROMBASE + ROM_IMAGE_SIZE - XIP_ROM_SIZE )
 
 arch i386 end 
 
 
 ##
 ## Build the objects we have code for in this directory.
 ##
 
 driver mainboard.o
 
 #dir /drivers/ati/ragexl
 #needed by irq_tables and mptable and acpi_tables
 object get_bus_conf.o
 
 
 if HAVE_MP_TABLE object mptable.o end
 if HAVE_PIRQ_TABLE object irq_tables.o end
 #object reset.o
 
 if USE_DCACHE_RAM
 
 if CONFIG_USE_INIT
 
 makerule ./auto.o
         depends "$(MAINBOARD)/cache_as_ram_auto.c option_table.h"
         action "$(CC) $(DISTRO_CFLAGS) -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/cache_as_ram_auto.c -Os -nostdinc -nostdlib -fno-builtin -Wall -c -o auto.o"
 end
 
 else
 
 makerule ./auto.inc
         depends "$(MAINBOARD)/cache_as_ram_auto.c option_table.h"
         action "$(CC) $(DISTRO_CFLAGS) -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/cache_as_ram_auto.c -Os -nostdinc -nostdlib -fno-builtin -Wall -c -S -o $@"
 	action "perl -e 's/.rodata/.rom.data/g' -pi $@"
 	action "perl -e 's/.text/.section .rom.text/g' -pi $@"
 end
 
 end
 else
 
 ##
 ## Romcc output
 ##
 makerule ./failover.E
-        depends "$(MAINBOARD)/failover.c ./romcc"
-        action "./romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+        depends "$(MAINBOARD)/failover.c ../romcc"
+        action "../romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 end
 
 makerule ./failover.inc
-        depends "$(MAINBOARD)/failover.c ./romcc"
-        action "./romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+        depends "$(MAINBOARD)/failover.c ../romcc"
+        action "../romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 end
 
 makerule ./auto.E
-        depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-        action  "./romcc -E -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+        depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+        action  "../romcc -E -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 makerule ./auto.inc
-        depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-        action  "./romcc    -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+        depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+        action  "../romcc    -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 
 
 end
 
 ##
 ## Build our 16 bit and 32 bit coreboot entry code
 ##
 if USE_FALLBACK_IMAGE
         mainboardinit cpu/x86/16bit/entry16.inc
         ldscript /cpu/x86/16bit/entry16.lds
 end
 
 mainboardinit cpu/x86/32bit/entry32.inc
 
 if USE_DCACHE_RAM
 	if CONFIG_USE_INIT
 		ldscript /cpu/x86/32bit/entry32.lds
 	end
 
 	if CONFIG_USE_INIT
 		ldscript      /cpu/amd/car/cache_as_ram.lds
 	end
 end
 
 ##
 ## Build our reset vector (This is where coreboot is entered)
 ##
 if USE_FALLBACK_IMAGE 
 	mainboardinit cpu/x86/16bit/reset16.inc 
 	ldscript /cpu/x86/16bit/reset16.lds 
 else
 	mainboardinit cpu/x86/32bit/reset32.inc 
 	ldscript /cpu/x86/32bit/reset32.lds 
 end
 
 if USE_DCACHE_RAM
 else
 ### Should this be in the northbridge code?
 mainboardinit arch/i386/lib/cpu_reset.inc
 end
 
 ##
 ## Include an id string (For safe flashing)
 ##
 mainboardinit southbridge/nvidia/ck804/id.inc
 ldscript /southbridge/nvidia/ck804/id.lds
 
 ##
 ## ROMSTRAP table for CK804
 ##
 if USE_FALLBACK_IMAGE
 	mainboardinit southbridge/nvidia/ck804/romstrap.inc
 	ldscript /southbridge/nvidia/ck804/romstrap.lds
 end
 
 if USE_DCACHE_RAM
 ##
 ## Setup Cache-As-Ram
 ##
 mainboardinit cpu/amd/car/cache_as_ram.inc
 end
 
 ###
 ### This is the early phase of coreboot startup 
 ### Things are delicate and we test to see if we should
 ### failover to another image.
 ###
 if USE_FALLBACK_IMAGE
 if USE_DCACHE_RAM
        ldscript /arch/i386/lib/failover.lds 
 else
        ldscript /arch/i386/lib/failover.lds 
 	mainboardinit ./failover.inc
 end
 end
 
 ###
 ### O.k. We aren't just an intermediary anymore!
 ###
 
 ##
 ## Setup RAM
 ##
 if USE_DCACHE_RAM
 
 if CONFIG_USE_INIT
 initobject auto.o
 else
 mainboardinit ./auto.inc
 end
 
 else
 # ROMCC
 mainboardinit cpu/x86/fpu/enable_fpu.inc
 mainboardinit cpu/x86/mmx/enable_mmx.inc
 mainboardinit cpu/x86/sse/enable_sse.inc
 mainboardinit ./auto.inc
 mainboardinit cpu/x86/sse/disable_sse.inc
 mainboardinit cpu/x86/mmx/disable_mmx.inc
 
 end
 
 ##
 ## Include the secondary Configuration files 
 ##
 if CONFIG_CHIP_NAME
         config chip.h
 end
 
 
 # sample config for tyan/s2892
 chip northbridge/amd/amdk8/root_complex
         device apic_cluster 0 on                
                 chip cpu/amd/socket_940                 
                         device apic 0 on end    
                 end                     
         end  
 
 	device pci_domain 0 on
 		chip northbridge/amd/amdk8 #mc0
 			device pci 18.0 on #  northbridge 
 				#  devices on link 0, link 0 == LDT 0 
 			        chip southbridge/nvidia/ck804 
 					device pci 0.0 on end   # HT
                 			device pci 1.0 on # LPC
                                         	chip superio/winbond/w83627hf
                                                 	device pnp 2e.0 on #  Floppy
                                                         	io 0x60 = 0x3f0
 	                                                        irq 0x70 = 6
         	                                                drq 0x74 = 2
                 	                                end
                         	                        device pnp 2e.1 off #  Parallel Port
                                 	                        io 0x60 = 0x378
                                         	                irq 0x70 = 7
                                                 	end
 	                                                device pnp 2e.2 on #  Com1
         	                                                io 0x60 = 0x3f8
                 	                                        irq 0x70 = 4
                         	                        end
                                 	                device pnp 2e.3 off #  Com2
                                         	                io 0x60 = 0x2f8
                                                 	        irq 0x70 = 3
 	                                                end
         	                                        device pnp 2e.5 on #  Keyboard
                 	                                        io 0x60 = 0x60
                         	                                io 0x62 = 0x64
                                 	                        irq 0x70 = 1
                                         	                irq 0x72 = 12
                                                 	end
 	                                                device pnp 2e.6 off #  CIR
         	                                                io 0x60 = 0x100
                 	                                end
                         	                        device pnp 2e.7 off #  GAME_MIDI_GIPO1
                                 	                        io 0x60 = 0x220
                                         	                io 0x62 = 0x300
                                                 	        irq 0x70 = 9
 	                                                end
         	                                        device pnp 2e.8 off end #  GPIO2
                 	                                device pnp 2e.9 off end #  GPIO3
                         	                        device pnp 2e.a off end #  ACPI
                                 	                device pnp 2e.b on #  HW Monitor
                                         	                io 0x60 = 0x290
                                                 	        irq 0x70 = 5
 	                                                end
         	                                end
 					end
                                         device pci 1.1 on # SM 0
                                                 chip drivers/generic/generic #dimm 0-0-0
                                                         device i2c 50 on end
                                                 end
                                                 chip drivers/generic/generic #dimm 0-0-1
                                                         device i2c 51 on end
                                                 end
                                                 chip drivers/generic/generic #dimm 0-1-0
                                                         device i2c 52 on end
                                                 end
                                                 chip drivers/generic/generic #dimm 0-1-1
                                                         device i2c 53 on end
                                                 end
                                                 chip drivers/generic/generic #dimm 1-0-0
                                                         device i2c 54 on end
                                                 end
                                                 chip drivers/generic/generic #dimm 1-0-1
                                                         device i2c 55 on end
                                                 end
                                                 chip drivers/generic/generic #dimm 1-1-0
                                                         device i2c 56 on end
                                                 end
                                                 chip drivers/generic/generic #dimm 1-1-1
                                                         device i2c 57 on end
                                                 end
                                         end # SM
 		        	        device pci 1.1 on # SM 1
 						chip drivers/i2c/adm1027 # ADT7463A CPU0 temp, SYS FAN 2/3/4
                                                 	device i2c 2d on end
                                                 end
                                                 chip drivers/i2c/adm1027 # ADT7463A CPU1 temp, CPU0/1 FAN , SYS FAN 1/5 
 		                                        device i2c 2e on end
                                                 end
                                                 chip drivers/generic/generic # Winbond HWM 0x54 CPU0/1 VRM temp, SYSFAN 6/7, SB FAN
                                                         device i2c 2a on end
                                                 end
                                                 chip drivers/generic/generic # Winbond HWM 0x92
                                                         device i2c 49 on end
                                                 end
                                                 chip drivers/generic/generic # Winbond HWM 0x94
                                                         device i2c 4a on end
                                                 end
 					end #SM
                 			device pci 2.0 on end # USB 1.1
 	                		device pci 2.1 on end # USB 2
         	        		device pci 4.0 off end # ACI
                 			device pci 4.1 off end # MCI
                 			device pci 6.0 on end # IDE
                 			device pci 7.0 on end # SATA 1
 	                		device pci 8.0 on end # SATA 0
         	        		device pci 9.0 on  # PCI
 					#	chip drivers/ati/ragexl
 						chip drivers/pci/onboard
 							device pci 6.0 on end
 							register "rom_address" = "0xfff80000"
 						end
                                                 chip drivers/pci/onboard
                                                         device pci 8.0 on end
                                                 end
 					end
                 			device pci a.0 off end # NIC
                				device pci b.0 off end # PCI E 3
                 			device pci c.0 off end # PCI E 2
 	                		device pci d.0 on end # PCI E 1
         	        		device pci e.0 on end # PCI E 0
                 	                register "ide0_enable" = "1"
                         	        register "ide1_enable" = "1"
 	                                register "sata0_enable" = "1"
         	                        register "sata1_enable" = "1"
 				end
 			end #  device pci 18.0 
 			device pci 18.0 on end # Link 1
 			device pci 18.0 on
 	                        #  devices on link 2, link 2 == LDT 2
         	                chip southbridge/amd/amd8131
                 	                # the on/off keyword is mandatory
                         	        device pci 0.0 on end
 	                                device pci 0.1 on end
         	                        device pci 1.0 on
                                                 chip drivers/pci/onboard
                                                         device pci 9.0 on end # broadcom 5704
 							device pci 9.1 on end
                                                 end
 					end
                 	                device pci 1.1 on end
                         	end
 			end # device pci 18.0
 			device pci 18.1 on end
 			device pci 18.2 on end
 			device pci 18.3 on end
 		end #mc0
 		
 	end # pci_domain
 	
 #        chip drivers/generic/debug 
 #                device pnp 0.0 off end
 #                device pnp 0.1 off end
 #                device pnp 0.2 off end
 #                device pnp 0.3 off end
 #                device pnp 0.4 off end
 #		device pnp 0.5 on end
 #        end  
 end # root_complex
diff --git a/src/mainboard/tyan/s2895/Config.lb b/src/mainboard/tyan/s2895/Config.lb
index 02518a0..980c257 100644
--- a/src/mainboard/tyan/s2895/Config.lb
+++ b/src/mainboard/tyan/s2895/Config.lb
@@ -1,428 +1,428 @@
 ##
 ## Compute the location and size of where this firmware image
 ## (coreboot plus bootloader) will live in the boot rom chip.
 ##
 if USE_FAILOVER_IMAGE
 	default ROM_SECTION_SIZE   = FAILOVER_SIZE
 	default ROM_SECTION_OFFSET = ( ROM_SIZE - FAILOVER_SIZE )
 else
     if USE_FALLBACK_IMAGE
 	default ROM_SECTION_SIZE   = FALLBACK_SIZE
 	default ROM_SECTION_OFFSET = ( ROM_SIZE - FALLBACK_SIZE - FAILOVER_SIZE )
     else
 	default ROM_SECTION_SIZE   = ( ROM_SIZE - FALLBACK_SIZE - FAILOVER_SIZE )
 	default ROM_SECTION_OFFSET = 0
     end
 end
 
 ##
 ## Compute the start location and size size of
 ## The coreboot bootloader.
 ##
 default PAYLOAD_SIZE            = ( ROM_SECTION_SIZE - ROM_IMAGE_SIZE )
 default CONFIG_ROM_PAYLOAD_START = (0xffffffff - ROM_SIZE + ROM_SECTION_OFFSET + 1)
 
 ##
 ## Compute where this copy of coreboot will start in the boot rom
 ##
 default _ROMBASE      = ( CONFIG_ROM_PAYLOAD_START + PAYLOAD_SIZE )
 
 ##
 ## Compute a range of ROM that can cached to speed up coreboot,
 ## execution speed.
 ##
 ## XIP_ROM_SIZE must be a power of 2.
 ## XIP_ROM_BASE must be a multiple of XIP_ROM_SIZE
 ##
 default XIP_ROM_SIZE=65536
 
 if USE_FAILOVER_IMAGE
 	default XIP_ROM_BASE = ( _ROMBASE - XIP_ROM_SIZE + ROM_IMAGE_SIZE)
 else
     if USE_FALLBACK_IMAGE
 	default XIP_ROM_BASE = ( _ROMBASE - XIP_ROM_SIZE + ROM_IMAGE_SIZE + FAILOVER_SIZE)
     else
 	default XIP_ROM_BASE = ( _ROMBASE - XIP_ROM_SIZE + ROM_IMAGE_SIZE)
     end
 end
 
 arch i386 end 
 
 ##
 ## Build the objects we have code for in this directory.
 ##
 
 driver mainboard.o
 #needed by irq_tables and mptable and acpi_tables
 object get_bus_conf.o
 
 if HAVE_MP_TABLE object mptable.o end
 if HAVE_PIRQ_TABLE object irq_tables.o end
 #object reset.o
 if USE_DCACHE_RAM
 
 	if CONFIG_USE_INIT	
 		makerule ./auto.o
 		        depends "$(MAINBOARD)/cache_as_ram_auto.c option_table.h"
         		action "$(CC) $(DISTRO_CFLAGS) -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/cache_as_ram_auto.c -Os -nostdinc -nostdlib -fno-builtin -Wall -c -o auto.o"
 		end
 	else
 		makerule ./auto.inc
         		depends "$(MAINBOARD)/cache_as_ram_auto.c option_table.h"
 		        action "$(CC) $(DISTRO_CFLAGS) -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/cache_as_ram_auto.c -Os -nostdinc -nostdlib -fno-builtin -Wall -c -S -o $@"
 		        action "perl -e 's/.rodata/.rom.data/g' -pi $@"
         		action "perl -e 's/.text/.section .rom.text/g' -pi $@"
 		end
 	end
 
 else
 	##
 	## Romcc output
 	##
 	makerule ./failover.E
-        	depends "$(MAINBOARD)/failover.c ./romcc"
-	        action "./romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+        	depends "$(MAINBOARD)/failover.c ../romcc"
+	        action "../romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 	end
 
 	makerule ./failover.inc
-        	depends "$(MAINBOARD)/failover.c ./romcc"
-	        action "./romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+        	depends "$(MAINBOARD)/failover.c ../romcc"
+	        action "../romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 	end
 
 	makerule ./auto.E
-        	depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-	        action  "./romcc -E -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+        	depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+	        action  "../romcc -E -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 	end
 
 	makerule ./auto.inc
-        	depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-	        action  "./romcc    -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+        	depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+	        action  "../romcc    -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 	end
 
 end
 
 ##
 ## Build our 16 bit and 32 bit coreboot entry code
 ##
 if HAVE_FAILOVER_BOOT
     if USE_FAILOVER_IMAGE
 	mainboardinit cpu/x86/16bit/entry16.inc
 	ldscript /cpu/x86/16bit/entry16.lds
     end
 else
     if USE_FALLBACK_IMAGE
 	mainboardinit cpu/x86/16bit/entry16.inc
 	ldscript /cpu/x86/16bit/entry16.lds
     end
 end
 
 mainboardinit cpu/x86/32bit/entry32.inc
 
 if USE_DCACHE_RAM
         if CONFIG_USE_INIT
                 ldscript /cpu/x86/32bit/entry32.lds
         end
 
         if CONFIG_USE_INIT
                 ldscript /cpu/amd/car/cache_as_ram.lds
         end
 end
 
 
 ##
 ## Build our reset vector (This is where coreboot is entered)
 ##
 if HAVE_FAILOVER_BOOT
     if USE_FAILOVER_IMAGE 
 	mainboardinit cpu/x86/16bit/reset16.inc 
 	ldscript /cpu/x86/16bit/reset16.lds 
     else
 	mainboardinit cpu/x86/32bit/reset32.inc 
 	ldscript /cpu/x86/32bit/reset32.lds 
     end
 else
     if USE_FALLBACK_IMAGE 
 	mainboardinit cpu/x86/16bit/reset16.inc 
 	ldscript /cpu/x86/16bit/reset16.lds 
     else
 	mainboardinit cpu/x86/32bit/reset32.inc 
 	ldscript /cpu/x86/32bit/reset32.lds 
     end
 end
 
 if USE_DCACHE_RAM
 else
 	### Should this be in the northbridge code?
 	mainboardinit arch/i386/lib/cpu_reset.inc
 end
 
 ##
 ## Include an id string (For safe flashing)
 ##
 mainboardinit southbridge/nvidia/ck804/id.inc
 ldscript /southbridge/nvidia/ck804/id.lds
 
 ##
 ## ROMSTRAP table for CK804
 ##
 if HAVE_FAILOVER_BOOT
     if USE_FAILOVER_IMAGE 
 	mainboardinit southbridge/nvidia/ck804/romstrap.inc
 	ldscript /southbridge/nvidia/ck804/romstrap.lds
     end
 else
     if USE_FALLBACK_IMAGE 
 	mainboardinit southbridge/nvidia/ck804/romstrap.inc
 	ldscript /southbridge/nvidia/ck804/romstrap.lds
     end
 end
 
 if USE_DCACHE_RAM
 	##
 	## Setup Cache-As-Ram
 	##
 	mainboardinit cpu/amd/car/cache_as_ram.inc
 end
 
 ###
 ### This is the early phase of coreboot startup 
 ### Things are delicate and we test to see if we should
 ### failover to another image.
 ###
 if HAVE_FAILOVER_BOOT
     if USE_FAILOVER_IMAGE
 	if USE_DCACHE_RAM
 		ldscript /arch/i386/lib/failover_failover.lds
 	end
     end
 else
     if USE_FALLBACK_IMAGE
 	if USE_DCACHE_RAM
 		ldscript /arch/i386/lib/failover.lds
 	else
 		mainboardinit ./failover.inc
 	end
     end
 end
 
 ##
 ## Setup RAM
 ##
 if USE_DCACHE_RAM
 
 	if CONFIG_USE_INIT
 		initobject auto.o
 	else
 		mainboardinit ./auto.inc
 	end
 
 else
 	# ROMCC
 	mainboardinit cpu/x86/fpu/enable_fpu.inc
 	mainboardinit cpu/x86/mmx/enable_mmx.inc
 	mainboardinit cpu/x86/sse/enable_sse.inc
 	mainboardinit ./auto.inc
 	mainboardinit cpu/x86/sse/disable_sse.inc
 	mainboardinit cpu/x86/mmx/disable_mmx.inc
 
 end
 
 ##
 ## Include the secondary Configuration files 
 ##
 if CONFIG_CHIP_NAME
 	config chip.h
 end
 
 # sample config for tyan/s2895
 chip northbridge/amd/amdk8/root_complex
         device apic_cluster 0 on
                 chip cpu/amd/socket_940
                         device apic 0 on end
                 end
         end
 	device pci_domain 0 on
 		chip northbridge/amd/amdk8 #mc0
 			device pci 18.0 on 
 				#  devices on link 0, link 0 == LDT 0 
 			        chip southbridge/nvidia/ck804 
 					device pci 0.0 on end   # HT
                 			device pci 1.0 on # LPC
                 	                        chip superio/smsc/lpc47b397
                         	                        device pnp 2e.0 on #  Floppy
                                 	                         io 0x60 = 0x3f0
                                         	                irq 0x70 = 6
                                                 	        drq 0x74 = 2
 	                                                end
         	                                        device pnp 2e.3 off #  Parallel Port
                 	                                         io 0x60 = 0x378
                         	                                irq 0x70 = 7
                                 	                end
                                         	        device pnp 2e.4 on #  Com1
                                                 	        io 0x60 = 0x3f8
 	                                                        irq 0x70 = 4
         	                                        end
                 	                                device pnp 2e.5 off #  Com2
                         	                                io 0x60 = 0x2f8
                                 	                        irq 0x70 = 3
                                         	        end
 	                                                device pnp 2e.7 on #  Keyboard
         	                                                io 0x60 = 0x60
                 	                                        io 0x62 = 0x64
                         	                                irq 0x70 = 1
                                 	                        irq 0x72 = 12
                                         	        end
 	                                                device pnp 2e.8 on # HW Monitor
         	                                                io 0x60 = 0x290
                                                                 chip drivers/generic/generic # LM95221 CPU temp
                                                                         device i2c 2b on end
                                                                 end
                                                                 chip drivers/generic/generic # EMCT03
                                                                         device i2c 54 on end
                                                                 end
 							end
 	                                                device	pnp 2e.a on #  RT
         	                                                io 0x60 = 0x400
 							end
                         	                end
 					end
 			                device pci 1.1 on # SM 0
                                                 chip drivers/generic/generic #dimm 0-0-0
                                                         device i2c 50 on end  
                                                 end              
                                                 chip drivers/generic/generic #dimm 0-0-1
                                                         device i2c 51 on end
                                                 end     
                                                 chip drivers/generic/generic #dimm 0-1-0
                                                         device i2c 52 on end
                                                 end             
                                                 chip drivers/generic/generic #dimm 0-1-1
                                                         device i2c 53 on end
                                                 end              
                                                 chip drivers/generic/generic #dimm 1-0-0
                                                         device i2c 54 on end
                                                 end     
                                                 chip drivers/generic/generic #dimm 1-0-1
                                                         device i2c 55 on end
                                                 end     
                                                 chip drivers/generic/generic #dimm 1-1-0
                                                         device i2c 56 on end
                                                 end     
                                                 chip drivers/generic/generic #dimm 1-1-1
                                                         device i2c 57 on end
                                                 end 
 					end # SM
                                         device pci 1.1 on # SM 1
 #PCI device smbus address will depend on addon pci device, do we need to scan_smbus_bus?
 #                                                chip drivers/generic/generic #PCIXA Slot1
 #                                                        device i2c 50 on end
 #                                                end
 #                                                chip drivers/generic/generic #PCIXB Slot1
 #                                                        device i2c 51 on end
 #                                                end     
 #                                                chip drivers/generic/generic #PCIXB Slot2
 #                                                        device i2c 52 on end
 #                                                end             
 #                                                chip drivers/generic/generic #PCI Slot1
 #                                                        device i2c 53 on end
 #                                                end              
 #                                                chip drivers/generic/generic #Master CK804 PCI-E
 #                                                        device i2c 54 on end
 #                                                end     
 #                                                chip drivers/generic/generic #Slave CK804 PCI-E
 #                                                        device i2c 55 on end
 #                                                end             
                                                 chip drivers/generic/generic #MAC EEPROM
                                                         device i2c 51 on end
                                                 end 
 
                                         end # SM 
 	                		device pci 2.0 on end # USB 1.1
         	        		device pci 2.1 on end # USB 2
 	                		device pci 4.0 on end # ACI
         	        		device pci 4.1 off end # MCI
                 			device pci 6.0 on end # IDE
 	                		device pci 7.0 on end # SATA 1
         	        		device pci 8.0 on end # SATA 0
                 			device pci 9.0 on end # PCI
 	                		device pci a.0 on end # NIC
         	       			device pci b.0 off end # PCI E 3
                 			device pci c.0 off end # PCI E 2
                 			device pci d.0 off end # PCI E 1
                 			device pci e.0 on end # PCI E 0
 	                                register "ide0_enable" = "1"
         	                        register "ide1_enable" = "1"
                 	                register "sata0_enable" = "1"
                         	        register "sata1_enable" = "1"
 #					register "nic_rom_address" = "0xfff80000" # 64k
 #					register "raid_rom_address" = "0xfff90000"
 					register "mac_eeprom_smbus" = "3" # 1: smbus under 2e.8, 2: SM0 3: SM1
 					register "mac_eeprom_addr" = "0x51"
 				end
 			end #  device pci 18.0 
 			device pci 18.0 on end # Link 1
 			device pci 18.0 on
                         #  devices on link 2, link 2 == LDT 2
 	                        chip southbridge/amd/amd8131
         	                        # the on/off keyword is mandatory
                 	                device pci 0.0 on end
                         	        device pci 0.1 on end
 					device pci 1.0 on 
                                                 chip drivers/pci/onboard
                                                         device pci 6.0 on end # lsi scsi
                                                         device pci 6.1 on end
                                                 end
 					end
 					device pci 1.1 on end
                 	        end
 			end # device pci 18.0
 			device pci 18.1 on end
 			device pci 18.2 on end
 			device pci 18.3 on end
 		end # mc0
 		
 		chip northbridge/amd/amdk8
                 	device pci 19.0 on #  northbridge 
                         	#  devices on link 0, link 0 == LDT 0 
                         	chip southbridge/nvidia/ck804 
                                 	device pci 0.0 on end   # HT
                                 	device pci 1.0 on end   # LPC
                                 	device pci 1.1 off end # SM
                                 	device pci 2.0 off end # USB 1.1
                                 	device pci 2.1 off end # USB 2
                                 	device pci 4.0 off end # ACI
                                 	device pci 4.1 off end # MCI
                                 	device pci 6.0 off end # IDE
                                 	device pci 7.0 off end # SATA 1
                                 	device pci 8.0 off end # SATA 0
                                 	device pci 9.0 off end # PCI
                                 	device pci a.0 on end # NIC
                                 	device pci b.0 off end # PCI E 3
                                 	device pci c.0 off end # PCI E 2
                                 	device pci d.0 off end # PCI E 1
                                 	device pci e.0 on end # PCI E 0
 #					register "nic_rom_address" = "0xfff80000" # 64k
                                         register "mac_eeprom_smbus" = "3"
                                         register "mac_eeprom_addr" = "0x51"
                         	end
                 	end #  device pci 19.0 
 			
 			device pci 19.0 on end
 			device pci 19.0 on end
 			device pci 19.1 on end
 			device pci 19.2 on end
 			device pci 19.3 on end
 		end
 	end # PCI domain
 	
 #       chip drivers/generic/debug 
 #               device pnp 0.0 off end # chip name
 #                device pnp 0.1 off end # pci_regs_all
 #                device pnp 0.2 off end # mem
 #                device pnp 0.3 off end # cpuid
 #                device pnp 0.4 on end # smbus_regs_all
 #                device pnp 0.5 off end # dual core msr
 #                device pnp 0.6 off end # cache size
 #                device pnp 0.7 off end # tsc
 #       end  
 end #root_complex
diff --git a/src/mainboard/tyan/s4880/Config.lb b/src/mainboard/tyan/s4880/Config.lb
index 9d5e860..020e596 100644
--- a/src/mainboard/tyan/s4880/Config.lb
+++ b/src/mainboard/tyan/s4880/Config.lb
@@ -1,296 +1,296 @@
 ##
 ## Compute the location and size of where this firmware image
 ## (coreboot plus bootloader) will live in the boot rom chip.
 ##
 if USE_FALLBACK_IMAGE
 	default ROM_SECTION_SIZE   = FALLBACK_SIZE
 	default ROM_SECTION_OFFSET = ( ROM_SIZE - FALLBACK_SIZE )
 else
 	default ROM_SECTION_SIZE   = ( ROM_SIZE - FALLBACK_SIZE )
 	default ROM_SECTION_OFFSET = 0
 end
 
 ##
 ## Compute the start location and size size of
 ## The coreboot bootloader.
 ##
 default PAYLOAD_SIZE            = ( ROM_SECTION_SIZE - ROM_IMAGE_SIZE )
 default CONFIG_ROM_PAYLOAD_START = (0xffffffff - ROM_SIZE + ROM_SECTION_OFFSET + 1)
 default CONFIG_ROM_PAYLOAD     = 1
 
 ##
 ## Compute where this copy of coreboot will start in the boot rom
 ##
 default _ROMBASE      = ( CONFIG_ROM_PAYLOAD_START + PAYLOAD_SIZE )
 
 ##
 ## Compute a range of ROM that can cached to speed up coreboot,
 ## execution speed.
 ##
 ## XIP_ROM_SIZE must be a power of 2.
 ## XIP_ROM_BASE must be a multiple of XIP_ROM_SIZE
 ##
 default XIP_ROM_SIZE=65536
 default XIP_ROM_BASE = ( _ROMBASE + ROM_IMAGE_SIZE - XIP_ROM_SIZE )
 
 arch i386 end 
 
 
 ##
 ## Build the objects we have code for in this directory.
 ##
 
 driver mainboard.o
 if HAVE_MP_TABLE object mptable.o end
 if HAVE_PIRQ_TABLE object irq_tables.o end
 if USE_DCACHE_RAM
 
 	if CONFIG_USE_INIT
 
 		makerule ./auto.o
         		depends "$(MAINBOARD)/cache_as_ram_auto.c option_table.h"
 	        	action "$(CC) $(DISTRO_CFLAGS) -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/cache_as_ram_auto.c -Os -nostdinc -nostdlib -fno-builtin -Wall -c -o auto.o"
 		end
 
 	else
 
 		makerule ./auto.inc
         		depends "$(MAINBOARD)/cache_as_ram_auto.c option_table.h"
 		        action "$(CC) $(DISTRO_CFLAGS) -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/cache_as_ram_auto.c -Os -nostdinc -nostdlib -fno-builtin -Wall -c -S -o $@"
         		action "perl -e 's/.rodata/.rom.data/g' -pi $@"
 		        action "perl -e 's/.text/.section .rom.text/g' -pi $@"
 			end
 	end
 else
 
 	##
 	## Romcc output
 	##
 	makerule ./failover.E
-        	depends "$(MAINBOARD)/failover.c ./romcc"
-	        action "./romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+        	depends "$(MAINBOARD)/failover.c ../romcc"
+	        action "../romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 	end
 
 	makerule ./failover.inc
-	        depends "$(MAINBOARD)/failover.c ./romcc"
-        	action "./romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+	        depends "$(MAINBOARD)/failover.c ../romcc"
+        	action "../romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 	end
 
 	makerule ./auto.E
-        	depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-	        action  "./romcc -E -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+        	depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+	        action  "../romcc -E -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 	end
 
 	makerule ./auto.inc
-        	depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-	        action  "./romcc    -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+        	depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+	        action  "../romcc    -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 	end
 
 	##
 	## Setup RAM
 	##
 	mainboardinit cpu/x86/fpu/enable_fpu.inc
 	mainboardinit cpu/x86/mmx/enable_mmx.inc
 	mainboardinit cpu/x86/sse/enable_sse.inc
 	mainboardinit ./auto.inc
 	mainboardinit cpu/x86/sse/disable_sse.inc
 	mainboardinit cpu/x86/mmx/disable_mmx.inc
 	mainboardinit arch/i386/lib/jmp_auto_out.inc
 
 end
 
 ##
 ## Build our 16 bit and 32 bit coreboot entry code
 ##
 if USE_FALLBACK_IMAGE
         mainboardinit cpu/x86/16bit/entry16.inc
         ldscript /cpu/x86/16bit/entry16.lds
 end
 
 mainboardinit cpu/x86/32bit/entry32.inc
 
 if USE_DCACHE_RAM
         if CONFIG_USE_INIT
                 ldscript /cpu/x86/32bit/entry32.lds
         end
 
         if CONFIG_USE_INIT
                 ldscript /cpu/amd/car/cache_as_ram.lds
         end
 end
 
 
 ##
 ## Build our reset vector (This is where coreboot is entered)
 ##
 if USE_FALLBACK_IMAGE 
 	mainboardinit cpu/x86/16bit/reset16.inc 
 	ldscript /cpu/x86/16bit/reset16.lds 
 else
 	mainboardinit cpu/x86/32bit/reset32.inc 
 	ldscript /cpu/x86/32bit/reset32.lds 
 end
 
 if USE_DCACHE_RAM
 else
 	### Should this be in the northbridge code?
 	mainboardinit arch/i386/lib/cpu_reset.inc
 end
 
 ##
 ## Include an id string (For safe flashing)
 ##
 mainboardinit arch/i386/lib/id.inc
 ldscript /arch/i386/lib/id.lds
 
 
 if USE_DCACHE_RAM
 	##
 	## Setup Cache-As-Ram
 	##
 	mainboardinit cpu/amd/car/cache_as_ram.inc
 end
 
 ###
 ### This is the early phase of coreboot startup 
 ### Things are delicate and we test to see if we should
 ### failover to another image.
 ###
 if USE_FALLBACK_IMAGE
 	if USE_DCACHE_RAM
 		ldscript /arch/i386/lib/failover.lds
 	else
        		ldscript /arch/i386/lib/failover.lds
 	        mainboardinit ./failover.inc
 	end
 end
 
 ##
 ## Setup RAM
 ##
 if USE_DCACHE_RAM
 
 	if CONFIG_USE_INIT
 		initobject auto.o
 	else
 		mainboardinit ./auto.inc
 	end
 
 else
 
 	# ROMCC
 	mainboardinit arch/i386/lib/jmp_auto.inc
 
 end
 
 ##
 ## Include the secondary Configuration files 
 ##
 if CONFIG_CHIP_NAME
 	config chip.h
 end
 
 # sample config for tyan/s4880
 chip northbridge/amd/amdk8/root_complex
         device apic_cluster 0 on
                 chip cpu/amd/socket_940
                         device apic 0 on end
                 end
         end
 
 	device pci_domain 0 on
 		chip northbridge/amd/amdk8
 			device pci 18.0 on end # LDT0
 			device pci 18.0 on end # LDT1
 			device pci 18.0 on #  northbridge 
 				#  devices on link 2, link 2 == LDT 2
 				chip southbridge/amd/amd8131
 					# the on/off keyword is mandatory
                                         device pci 0.0 on
 #                                                chip drivers/lsi/53c1030
 #                                                        device pci 4.0 on end
 #                                                        device pci 4.1 on end
 #                                                        register "fw_address" = "0xfff8c000"
 #                                                end
                                                 chip drivers/pci/onboard
                                                         device pci 9.0 on end
                                                         device pci 9.1 on end
                                                 end
 					end
 					device pci 0.1 on end
 					device pci 1.0 on end
 					device pci 1.1 on end
 				end
 				chip southbridge/amd/amd8111
 					# this "device pci 0.0" is the parent the next one
 					# PCI bridge
 					device pci 0.0 on
 						device pci 0.0 on end
 						device pci 0.1 on end
 						device pci 0.2 off end
 						device pci 1.0 off end
                                                 chip drivers/pci/onboard
                                                         device pci 6.0 on end
                                                         register "rom_address" = "0xfff80000"
                                                 end
 					end
 					device pci 1.0 on
 						chip superio/winbond/w83627hf
 							device pnp 2e.0 on #  Floppy
                 	                 			io 0x60 = 0x3f0
                 	                			irq 0x70 = 6
                 	                			drq 0x74 = 2
 							end
                 	        			device pnp 2e.1 off #  Parallel Port
                 	                 			io 0x60 = 0x378
                 	                			irq 0x70 = 7
 							end
                 	        			device pnp 2e.2 on #  Com1
                 	                 			io 0x60 = 0x3f8
                 	                			irq 0x70 = 4
 							end
                 	        			device pnp 2e.3 off #  Com2
                 	                 			io 0x60 = 0x2f8
                 	                			irq 0x70 = 3
 							end
                 	        			device pnp 2e.5 on #  Keyboard
                 	                 			io 0x60 = 0x60
                 	                 			io 0x62 = 0x64
                 	                			irq 0x70 = 1
 								irq 0x72 = 12
 							end
                 	                                device pnp 2e.6 off #  CIR
                 	                                        io 0x60 = 0x100
                 	                                end
                 	                                device pnp 2e.7 off #  GAME_MIDI_GIPO1
                 	                                        io 0x60 = 0x220
                 	                                        io 0x62 = 0x300
                 	                                        irq 0x70 = 9
                 	                                end  
                 	                                device pnp 2e.8 off end #  GPIO2
                 	                                device pnp 2e.9 off end #  GPIO3
                 	                                device pnp 2e.a off end #  ACPI
                 	                                device pnp 2e.b on #  HW Monitor
                 	                                        io 0x60 = 0x290
                 	                                        irq 0x70 = 5
                 	                                end
 						end
 					end
 					device pci 1.1 on end
 					device pci 1.2 on end
 					device pci 1.3 on end
 					device pci 1.5 off end
 					device pci 1.6 off end
                                         register "ide0_enable" = "1"
                                         register "ide1_enable" = "1"
 				end
 			end #  device pci 18.0 
 			
 			device pci 18.1 on end
 			device pci 18.2 on end
 			device pci 18.3 on end
 		end
 
 	end #pci_domain
 end
 
diff --git a/src/mainboard/tyan/s4882/Config.lb b/src/mainboard/tyan/s4882/Config.lb
index 6affa24..e81e1c9 100644
--- a/src/mainboard/tyan/s4882/Config.lb
+++ b/src/mainboard/tyan/s4882/Config.lb
@@ -1,404 +1,404 @@
 ##
 ## Compute the location and size of where this firmware image
 ## (coreboot plus bootloader) will live in the boot rom chip.
 ##
 if USE_FALLBACK_IMAGE
 	default ROM_SECTION_SIZE   = FALLBACK_SIZE
 	default ROM_SECTION_OFFSET = ( ROM_SIZE - FALLBACK_SIZE )
 else
 	default ROM_SECTION_SIZE   = ( ROM_SIZE - FALLBACK_SIZE )
 	default ROM_SECTION_OFFSET = 0
 end
 
 ##
 ## Compute the start location and size size of
 ## The coreboot bootloader.
 ##
 default PAYLOAD_SIZE            = ( ROM_SECTION_SIZE - ROM_IMAGE_SIZE )
 default CONFIG_ROM_PAYLOAD_START = (0xffffffff - ROM_SIZE + ROM_SECTION_OFFSET + 1)
 default CONFIG_ROM_PAYLOAD     = 1
 
 ##
 ## Compute where this copy of coreboot will start in the boot rom
 ##
 default _ROMBASE      = ( CONFIG_ROM_PAYLOAD_START + PAYLOAD_SIZE )
 
 ##
 ## Compute a range of ROM that can cached to speed up coreboot,
 ## execution speed.
 ##
 ## XIP_ROM_SIZE must be a power of 2.
 ## XIP_ROM_BASE must be a multiple of XIP_ROM_SIZE
 ##
 default XIP_ROM_SIZE=65536
 default XIP_ROM_BASE = ( _ROMBASE + ROM_IMAGE_SIZE - XIP_ROM_SIZE )
 
 arch i386 end 
 
 
 ##
 ## Build the objects we have code for in this directory.
 ##
 
 driver mainboard.o
 if HAVE_MP_TABLE object mptable.o end
 if HAVE_PIRQ_TABLE object irq_tables.o end
 if USE_DCACHE_RAM
 
 	if CONFIG_USE_INIT
 
 		makerule ./auto.o
         		depends "$(MAINBOARD)/cache_as_ram_auto.c option_table.h"
 	        	action "$(CC) $(DISTRO_CFLAGS) -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/cache_as_ram_auto.c -Os -nostdinc -nostdlib -fno-builtin -Wall -c -o auto.o"
 		end
 
 	else
 
 		makerule ./auto.inc
         		depends "$(MAINBOARD)/cache_as_ram_auto.c option_table.h"
 		        action "$(CC) $(DISTRO_CFLAGS) -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/cache_as_ram_auto.c -Os -nostdinc -nostdlib -fno-builtin -Wall -c -S -o $@"
         		action "perl -e 's/.rodata/.rom.data/g' -pi $@"
 		        action "perl -e 's/.text/.section .rom.text/g' -pi $@"
 			end
 	end
 else
 
 	##
 	## Romcc output
 	##
 	makerule ./failover.E
-        	depends "$(MAINBOARD)/failover.c ./romcc"
-	        action "./romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+        	depends "$(MAINBOARD)/failover.c ../romcc"
+	        action "../romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 	end
 
 	makerule ./failover.inc
-	        depends "$(MAINBOARD)/failover.c ./romcc"
-        	action "./romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+	        depends "$(MAINBOARD)/failover.c ../romcc"
+        	action "../romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 	end
 
 	makerule ./auto.E
-        	depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-	        action  "./romcc -E -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+        	depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+	        action  "../romcc -E -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 	end
 
 	makerule ./auto.inc
-        	depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-	        action  "./romcc    -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+        	depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+	        action  "../romcc    -mcpu=k8 -O2 -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 	end
 
 	##
 	## Setup RAM
 	##
 	mainboardinit cpu/x86/fpu/enable_fpu.inc
 	mainboardinit cpu/x86/mmx/enable_mmx.inc
 	mainboardinit cpu/x86/sse/enable_sse.inc
 	mainboardinit ./auto.inc
 	mainboardinit cpu/x86/sse/disable_sse.inc
 	mainboardinit cpu/x86/mmx/disable_mmx.inc
 	mainboardinit arch/i386/lib/jmp_auto_out.inc
 
 end
 
 ##
 ## Build our 16 bit and 32 bit coreboot entry code
 ##
 if USE_FALLBACK_IMAGE
         mainboardinit cpu/x86/16bit/entry16.inc
         ldscript /cpu/x86/16bit/entry16.lds
 end
 
 mainboardinit cpu/x86/32bit/entry32.inc
 
 if USE_DCACHE_RAM
         if CONFIG_USE_INIT
                 ldscript /cpu/x86/32bit/entry32.lds
         end
 
         if CONFIG_USE_INIT
                 ldscript /cpu/amd/car/cache_as_ram.lds
         end
 end
 
 
 ##
 ## Build our reset vector (This is where coreboot is entered)
 ##
 if USE_FALLBACK_IMAGE 
 	mainboardinit cpu/x86/16bit/reset16.inc 
 	ldscript /cpu/x86/16bit/reset16.lds 
 else
 	mainboardinit cpu/x86/32bit/reset32.inc 
 	ldscript /cpu/x86/32bit/reset32.lds 
 end
 
 if USE_DCACHE_RAM
 else
 	### Should this be in the northbridge code?
 	mainboardinit arch/i386/lib/cpu_reset.inc
 end
 
 ##
 ## Include an id string (For safe flashing)
 ##
 mainboardinit arch/i386/lib/id.inc
 ldscript /arch/i386/lib/id.lds
 
 
 if USE_DCACHE_RAM
 	##
 	## Setup Cache-As-Ram
 	##
 	mainboardinit cpu/amd/car/cache_as_ram.inc
 end
 
 ###
 ### This is the early phase of coreboot startup 
 ### Things are delicate and we test to see if we should
 ### failover to another image.
 ###
 if USE_FALLBACK_IMAGE
 	if USE_DCACHE_RAM
 		ldscript /arch/i386/lib/failover.lds
 	else
        		ldscript /arch/i386/lib/failover.lds
 	        mainboardinit ./failover.inc
 	end
 end
 
 ##
 ## Setup RAM
 ##
 if USE_DCACHE_RAM
 
 	if CONFIG_USE_INIT
 		initobject auto.o
 	else
 		mainboardinit ./auto.inc
 	end
 
 else
 
 	# ROMCC
 	mainboardinit arch/i386/lib/jmp_auto.inc
 
 end
 
 ##
 ## Include the secondary Configuration files 
 ##
 if CONFIG_CHIP_NAME
 	config chip.h
 end
 
 # sample config for tyan/s4882
 chip northbridge/amd/amdk8/root_complex
         device apic_cluster 0 on
                 chip cpu/amd/socket_940
                         device apic 0 on end
                 end
         end
 	device pci_domain 0 on
 		chip northbridge/amd/amdk8
 			device pci 18.0 on end # LDT0
 			device pci 18.0 on #  northbridge 
 				#  devices on link 1, link 1 == LDT 1
 				chip southbridge/amd/amd8131
 					# the on/off keyword is mandatory
 					device pci 0.0 on 
 #						chip drivers/lsi/53c1030
 #							device pci 4.0 on end
 #							device pci 4.1 on end
 #							register "fw_address" = "0xfff8c000"
 #						end
                                                 chip drivers/pci/onboard
                                                         device pci 9.0 on end #Broadcom
                                                         device pci 9.1 on end
                                                 end 
 					end
 					device pci 0.1 on end
 					device pci 1.0 on end
 					device pci 1.1 on end
 				end
 				chip southbridge/amd/amd8111
 					# this "device pci 0.0" is the parent the next one
 					# PCI bridge
 					device pci 0.0 on
 						device pci 0.0 on end
 						device pci 0.1 on end
 						device pci 0.2 off end
 						device pci 1.0 off end
                                                 #chip drivers/ati/ragexl
                                                 chip drivers/pci/onboard
                                                         device pci 6.0 on end
                                                         register "rom_address" = "0xfff80000"
                                                 end
                                                 chip drivers/pci/onboard
                                                         device pci 5.0 on end #SiI
                                                 end
 					end
 					device pci 1.0 on
 						chip superio/winbond/w83627hf
 							device pnp 2e.0 on #  Floppy
                 	                 			io 0x60 = 0x3f0
                 	                			irq 0x70 = 6
                 	                			drq 0x74 = 2
 							end
                 	        			device pnp 2e.1 off #  Parallel Port
                 	                 			io 0x60 = 0x378
                 	                			irq 0x70 = 7
 							end
                 	        			device pnp 2e.2 on #  Com1
                 	                 			io 0x60 = 0x3f8
                 	                			irq 0x70 = 4
 							end
                 	        			device pnp 2e.3 on #  Com2
                 	                 			io 0x60 = 0x2f8
                 	                			irq 0x70 = 3
 							end
                 	        			device pnp 2e.5 on #  Keyboard
                 	                 			io 0x60 = 0x60
                 	                 			io 0x62 = 0x64
                 	                			irq 0x70 = 1
 								irq 0x72 = 12
 							end
                 	                                device pnp 2e.6 off #  CIR
                 	                                        io 0x60 = 0x100
                 	                                end
                 	                                device pnp 2e.7 off #  GAME_MIDI_GIPO1
                 	                                        io 0x60 = 0x220
                 	                                        io 0x62 = 0x300
                 	                                        irq 0x70 = 9
                 	                                end  
                 	                                device pnp 2e.8 off end #  GPIO2
                 	                                device pnp 2e.9 off end #  GPIO3
                 	                                device pnp 2e.a off end #  ACPI
                 	                                device pnp 2e.b on #  HW Monitor
                 	                                        io 0x60 = 0x290
                 	                                        irq 0x70 = 5
                 	                                end
 						end
 					end
 					device pci 1.1 on end
 					device pci 1.2 on end
                                         device pci 1.3 on 
 #                                                chip drivers/i2c/i2cmux # pca9556 smbus mux
 #                                                        device i2c 18 on #0 pca9516 2, 1
 #	  					                chip drivers/i2c/lm63 #cpu0 temp
 #                                                                        device i2c 4c on end
 #                                                                end 
 #							end
 #                                                        device i2c 18 on #1 pca9516 1, 1
 #                                                                chip drivers/generic/generic #dimm 1-0-0
 #                                                                        device i2c 50 on end
 #                                                                end
 #                                                                chip drivers/generic/generic #dimm 1-0-1
 #                                                                        device i2c 51 on end
 #                                                                end
 #                                                                chip drivers/generic/generic #dimm 1-1-0
 #                                                                        device i2c 52 on end
 #                                                                end
 #                                                                chip drivers/generic/generic #dimm 1-1-1
 #	                                                                device i2c 53 on end
 #								end
 #                                                        end
 #                                                        device i2c 18 on #2 pca9516 1, 2
 #                                                                chip drivers/generic/generic #dimm 0-0-0
 #                                                                        device i2c 50 on end
 #                                                                end
 #                                                                chip drivers/generic/generic #dimm 0-0-1
 #                                                                        device i2c 51 on end
 #                                                                end
 #                                                                chip drivers/generic/generic #dimm 0-1-0
 #                                                                        device i2c 52 on end
 #                                                                end
 #                                                                chip drivers/generic/generic #dimm 0-1-1
 #                                                                	device i2c 53 on end
 #								end
 #                                                        end
 #                                                        device i2c 18 on #3 pca9516 1, 3
 #                                                                chip drivers/generic/generic #dimm 3-0-0
 #                                                                        device i2c 50 on end
 #                                                                end
 #                                                                chip drivers/generic/generic #dimm 3-0-1
 #                                                                        device i2c 51 on end
 #                                                                end
 #                                                                chip drivers/generic/generic #dimm 3-1-0
 #                                                                        device i2c 52 on end
 #                                                                end
 #                                                                chip drivers/generic/generic #dimm 3-1-1
 #                                                                	device i2c 53 on end
 #								end
 #                                                        end
 #                                                        device i2c 18 on #4 pca9516 1, 4
 #                                                                chip drivers/generic/generic #dimm 2-0-0
 #                                                                        device i2c 50 on end
 #                                                                end
 #                                                                chip drivers/generic/generic #dimm 2-0-1
 #                                                                        device i2c 51 on end
 #                                                                end
 #                                                                chip drivers/generic/generic #dimm 2-1-0
 #                                                                        device i2c 52 on end
 #                                                                end
 #                                                                chip drivers/generic/generic #dimm 2-1-1
 #                                                                	device i2c 53 on end
 #								end
 #                                                        end
 #                                                        device i2c 18 on #5 pca9516 2, 2
 #                                                                chip drivers/i2c/lm63 #cpu1 temp
 #                                                                       device i2c 4c on end
 #                                                                end
 #                                                        end
 #                                                        device i2c 18 on #6 pca9516 2, 3
 #                                                                chip drivers/i2c/lm63 #cpu2 temp
 #                                                                        device i2c 4c on end
 #                                                                end
 #                                                        end
 #                                                        device i2c 18 on #7 pca9516 2, 4
 #                                                                chip drivers/i2c/lm63 #cpu3 temp
 #                                                                        device i2c 4c on end
 #                                                                end
 #                                                        end
 #                                                end # i2cmux
 #                                                chip drivers/i2c/adm1027 # ADM1027 CPU1 vid and System FAN...
 #                                                        device i2c 2e on end
 #                                                end
 #                                                chip drivers/generic/generic # Winbond HWM 0x54 CPU0 vid 
 #                                                        device i2c 2a on end
 #                                                end
 #                                                chip drivers/generic/generic # Winbond HWM 0x92
 #                                                        device i2c 49 on end
 #                                                end
 #                                                chip drivers/generic/generic # Winbond HWM 0x94
 #                                                        device i2c 4a on end
 #                                                end
 #                                                chip drivers/generic/generic # ??
 #                                                        device i2c 69 on end
 #                                                end
                                         end # acpi
 					device pci 1.5 off end
 					device pci 1.6 off end
 					register "ide0_enable" = "1"
                                         register "ide1_enable" = "1"
 				end
 			end #  device pci 18.0 
 			
                 	device pci 18.0 on end
 			
 			device pci 18.1 on end
 			device pci 18.2 on end
 			device pci 18.3 on end
 		end
 
 	end 
 #        chip drivers/generic/debug
 #                device pnp 0.0 off end # chip name
 #                device pnp 0.1 off end # pci_regs_all
 #                device pnp 0.2 off end # mem
 #                device pnp 0.3 on end # cpuid
 #                device pnp 0.4 off end # smbus_regs_all
 #		device pnp 0.5 on end # dual core msr
 #		device pnp 0.6 on end # cache size
 #		device pnp 0.7 on end # tsc
 #        end
 end
 
diff --git a/src/mainboard/via/epia-cn/Config.lb b/src/mainboard/via/epia-cn/Config.lb
index 6e48b2b..7f1e59a 100644
--- a/src/mainboard/via/epia-cn/Config.lb
+++ b/src/mainboard/via/epia-cn/Config.lb
@@ -1,144 +1,144 @@
 ##
 ## This file is part of the coreboot project.
 ##
 ## Copyright (C) 2008 VIA Technologies, Inc.
 ## (Written by Aaron Lwe <aaron.lwe@gmail.com> for VIA)
 ##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2 of the License, or
 ## (at your option) any later version.
 ##
 ## This program is distributed in the hope that it will be useful,
 ## but WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ## GNU General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with this program; if not, write to the Free Software
 ## Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 ##
 
 if USE_FALLBACK_IMAGE
 	default ROM_SECTION_SIZE   = FALLBACK_SIZE
 	default ROM_SECTION_OFFSET = (ROM_SIZE - FALLBACK_SIZE)
 else
 	default ROM_SECTION_SIZE   = (ROM_SIZE - FALLBACK_SIZE)
 	default ROM_SECTION_OFFSET = 0
 end
 default PAYLOAD_SIZE = (ROM_SECTION_SIZE - ROM_IMAGE_SIZE)
 default CONFIG_ROM_PAYLOAD_START = (0xffffffff - ROM_SIZE + ROM_SECTION_OFFSET + 1)
 default _ROMBASE = (CONFIG_ROM_PAYLOAD_START + PAYLOAD_SIZE)
 default XIP_ROM_SIZE = 64 * 1024
 default XIP_ROM_BASE = (_ROMBASE + ROM_IMAGE_SIZE - XIP_ROM_SIZE)
 arch i386 end
 driver mainboard.o
 if HAVE_PIRQ_TABLE object irq_tables.o end
 if HAVE_MP_TABLE object mptable.o end
 if HAVE_ACPI_TABLES
 	object fadt.o
 	object dsdt.o
 	object acpi_tables.o
 end
 makerule ./failover.E
-	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ./romcc"
-	action "./romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
+	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ../romcc"
+	action "../romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
 end
 makerule ./failover.inc
-	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ./romcc"
-	action "./romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
+	depends "$(MAINBOARD)/../../../arch/i386/lib/failover.c ../romcc"
+	action "../romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/../../../arch/i386/lib/failover.c -o $@"
 end
 makerule ./auto.E
-	depends	"$(MAINBOARD)/auto.c option_table.h ./romcc"
-	action	"./romcc -E -mcpu=c3 -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	depends	"$(MAINBOARD)/auto.c option_table.h ../romcc"
+	action	"../romcc -E -mcpu=c3 -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 makerule ./auto.inc
-	depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-	action	"./romcc    -mcpu=c3 -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+	action	"../romcc    -mcpu=c3 -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 mainboardinit cpu/x86/16bit/entry16.inc
 mainboardinit cpu/x86/32bit/entry32.inc
 ldscript /cpu/x86/16bit/entry16.lds
 ldscript /cpu/x86/32bit/entry32.lds
 if USE_FALLBACK_IMAGE
 	mainboardinit cpu/x86/16bit/reset16.inc
 	ldscript /cpu/x86/16bit/reset16.lds
 else
 	mainboardinit cpu/x86/32bit/reset32.inc
 	ldscript /cpu/x86/32bit/reset32.lds
 end
 mainboardinit arch/i386/lib/cpu_reset.inc
 mainboardinit arch/i386/lib/id.inc
 ldscript /arch/i386/lib/id.lds
 if USE_FALLBACK_IMAGE
 	ldscript /arch/i386/lib/failover.lds
 	mainboardinit ./failover.inc
 end
 mainboardinit cpu/x86/fpu/enable_fpu.inc
 mainboardinit cpu/x86/mmx/enable_mmx.inc
 mainboardinit ./auto.inc
 mainboardinit cpu/x86/mmx/disable_mmx.inc
 dir /pc80
 config chip.h
 
 chip northbridge/via/cn700			# Northbridge
   device pci_domain 0 on			# PCI domain
     device pci 0.0 on end			# AGP Bridge
     device pci 0.1 on end			# Error Reporting
     device pci 0.2 on end			# Host Bus Control
     device pci 0.3 on end			# Memory Controller
     device pci 0.4 on end			# Power Management
     device pci 0.7 on end			# V-Link Controller
     device pci 1.0 on end			# PCI Bridge
     chip southbridge/via/vt8237r		# Southbridge
       # Enable both IDE channels.
       register "ide0_enable" = "1"
       register "ide1_enable" = "1"
       # Both cables are 40pin.
       register "ide0_80pin_cable" = "0"
       register "ide1_80pin_cable" = "0"
       device pci f.0 on end			# IDE
       register "fn_ctrl_lo" = "0x80"
       register "fn_ctrl_hi" = "0x1d"
       device pci 10.0 on end			# OHCI
       device pci 10.1 on end			# OHCI
       device pci 10.2 on end			# OHCI
       device pci 10.3 on end			# OHCI
       device pci 10.4 on end			# EHCI
       device pci 10.5 on end			# UDCI
       device pci 11.0 on			# Southbridge LPC
         chip superio/via/vt1211			# Super I/O
           device pnp 2e.0 off			# Floppy
             io 0x60 = 0x3f0
             irq 0x70 = 6
             drq 0x74 = 2
           end
           device pnp 2e.1 on			# Parallel Port
             io 0x60 = 0x378
             irq 0x70 = 7
             drq 0x74 = 3
           end
           device pnp 2e.2 on			# COM1
             io 0x60 = 0x3f8
             irq 0x70 = 4
           end
           device pnp 2e.3 on			# COM2
             io 0x60 = 0x2f8
             irq 0x70 = 3
           end
           device pnp 2e.b on			# HWM
             io 0x60 = 0xec00
           end
         end
       end
       device pci 11.5 on end			# AC'97 audio
       # device pci 11.6 off end			# AC'97 Modem
       device pci 12.0 on end			# Ethernet
     end
   end
   device apic_cluster 0 on			# APIC cluster
     chip cpu/via/model_c7			# VIA C7
       device apic 0 on end			# APIC
     end
   end
 end
diff --git a/src/mainboard/via/epia-m/Config.lb b/src/mainboard/via/epia-m/Config.lb
index 295cecb..2ebd209 100644
--- a/src/mainboard/via/epia-m/Config.lb
+++ b/src/mainboard/via/epia-m/Config.lb
@@ -1,190 +1,190 @@
 ##
 ## Compute the location and size of where this firmware image
 ## (coreboot plus bootloader) will live in the boot rom chip.
 ##
 if USE_FALLBACK_IMAGE
 	default ROM_SECTION_SIZE   = FALLBACK_SIZE
 	default ROM_SECTION_OFFSET = ( ROM_SIZE - FALLBACK_SIZE )
 else
 	default ROM_SECTION_SIZE   = ( ROM_SIZE - FALLBACK_SIZE )
 	default ROM_SECTION_OFFSET = 0
 end
 
 ##
 ## Compute the start location and size size of
 ## The coreboot bootloader.
 ##
 default PAYLOAD_SIZE            = ( ROM_SECTION_SIZE - ROM_IMAGE_SIZE )
 default CONFIG_ROM_PAYLOAD_START = (0xffffffff - ROM_SIZE + ROM_SECTION_OFFSET + 1)
 
 ##
 ## Compute where this copy of coreboot will start in the boot rom
 ##
 default _ROMBASE      = ( CONFIG_ROM_PAYLOAD_START + PAYLOAD_SIZE )
 
 ##
 ## Compute a range of ROM that can cached to speed up coreboot,
 ## execution speed.
 ##
 ## XIP_ROM_SIZE must be a power of 2.
 ## XIP_ROM_BASE must be a multiple of XIP_ROM_SIZE
 ##
 default XIP_ROM_SIZE=65536
 default XIP_ROM_BASE = ( _ROMBASE + ROM_IMAGE_SIZE - XIP_ROM_SIZE )
 
 ##
 ## Set all of the defaults for an x86 architecture
 ##
 
 arch i386 end
 
 ##
 ## Build the objects we have code for in this directory.
 ##
 
 driver mainboard.o
 if HAVE_PIRQ_TABLE object irq_tables.o end
 #object reset.o
 object vgabios.o
 
 if HAVE_ACPI_TABLES
 	object fadt.o
 	object dsdt.o
 	object acpi_tables.o
 end
 
 ##
 ## Romcc output
 ##
 makerule ./failover.E
-	depends "$(MAINBOARD)/failover.c ./romcc" 
-	action "./romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+	depends "$(MAINBOARD)/failover.c ../romcc" 
+	action "../romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 end
 
 makerule ./failover.inc
-	depends "$(MAINBOARD)/failover.c ./romcc"
-	action "./romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+	depends "$(MAINBOARD)/failover.c ../romcc"
+	action "../romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 end
 
 makerule ./auto.E 
-	depends	"$(MAINBOARD)/auto.c option_table.h ./romcc" 
-	action	"./romcc -E -mcpu=c3 -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	depends	"$(MAINBOARD)/auto.c option_table.h ../romcc" 
+	action	"../romcc -E -mcpu=c3 -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 makerule ./auto.inc 
-	depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-	action	"./romcc    -mcpu=c3 -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+	action	"../romcc    -mcpu=c3 -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 
 ##
 ## Build our 16 bit and 32 bit coreboot entry code
 ##
 mainboardinit cpu/x86/16bit/entry16.inc
 mainboardinit cpu/x86/32bit/entry32.inc
 ldscript /cpu/x86/16bit/entry16.lds
 ldscript /cpu/x86/32bit/entry32.lds
 
 ##
 ## Build our reset vector (This is where coreboot is entered)
 ##
 if USE_FALLBACK_IMAGE 
 	mainboardinit cpu/x86/16bit/reset16.inc 
 	ldscript /cpu/x86/16bit/reset16.lds 
 else
 	mainboardinit cpu/x86/32bit/reset32.inc 
 	ldscript /cpu/x86/32bit/reset32.lds 
 end
 
 ### Should this be in the northbridge code?
 mainboardinit arch/i386/lib/cpu_reset.inc
 
 ##
 ## Include an id string (For safe flashing)
 ##
 mainboardinit arch/i386/lib/id.inc
 ldscript /arch/i386/lib/id.lds
 
 ###
 ### This is the early phase of coreboot startup 
 ### Things are delicate and we test to see if we should
 ### failover to another image.
 ###
 if USE_FALLBACK_IMAGE
 	ldscript /arch/i386/lib/failover.lds 
 	mainboardinit ./failover.inc
 end
 
 ###
 ### O.k. We aren't just an intermediary anymore!
 ###
 
 ##
 ## Setup RAM
 ##
 mainboardinit cpu/x86/fpu/enable_fpu.inc
 mainboardinit cpu/x86/mmx/enable_mmx.inc
 mainboardinit ./auto.inc
 mainboardinit cpu/x86/mmx/disable_mmx.inc
 
 ##
 ## Include the secondary Configuration files 
 ##
 dir /pc80
 config chip.h
 
 chip northbridge/via/vt8623
 
 	device apic_cluster 0 on
 		chip cpu/via/model_c3
 			device apic 0 on  end 
 		end
 	end
 
 	device pci_domain 0 on
 		chip southbridge/via/vt8235
 
 			device pci 10.0 on end # USB 1.1
 			device pci 10.1 on end # USB 1.1
 			device pci 10.2 on end # USB 1.1
 			device pci 10.3 on end # USB 2
 
 			device pci 11.0 on      # Southbridge
 				chip superio/via/vt1211
 					device pnp 2e.0 on	# Floppy
 						io 0x60 = 0x3f0
 						irq 0x70 = 6
 						drq 0x74 = 2
 					end
 					device pnp 2e.1 on	# Parallel Port
 						io 0x60 = 0x378
 						irq 0x70 = 7
 						drq 0x74 = 3
 					end
 					device pnp 2e.2 on	# COM1
 						io 0x60 = 0x3f8
 						irq 0x70 = 4
 					end
 					device pnp 2e.3 on	# COM2
 						io 0x60 = 0x2f8
 						irq 0x70 = 3
 					end
 					device pnp 2e.b on	# HWM
 						io 0x60 = 0xec00
 					end
 
 				end
 			end
 			
 			device pci 11.1 on  end # IDE
 			# 2-4 non existant?
 			device pci 11.5 on  end # AC97 Audio
 			device pci 11.6 off end # AC97 Modem
 			device pci 12.0 on end  # Ethernet
 		end
 #		This is on the EPIA MII, not the M.
 		chip southbridge/ricoh/rl5c476
 			register "enable_cf" = "1"
 			device pci 0a.0 on end
 			device pci 0a.1 on end	
 		end
 	end
 end
diff --git a/src/mainboard/via/epia/Config.lb b/src/mainboard/via/epia/Config.lb
index 1daff5b..516255d 100644
--- a/src/mainboard/via/epia/Config.lb
+++ b/src/mainboard/via/epia/Config.lb
@@ -1,191 +1,191 @@
 ##
 ## Compute the location and size of where this firmware image
 ## (coreboot plus bootloader) will live in the boot rom chip.
 ##
 if USE_FALLBACK_IMAGE
 	default ROM_SECTION_SIZE   = FALLBACK_SIZE
 	default ROM_SECTION_OFFSET = ( ROM_SIZE - FALLBACK_SIZE )
 else
 	default ROM_SECTION_SIZE   = ( ROM_SIZE - FALLBACK_SIZE )
 	default ROM_SECTION_OFFSET = 0
 end
 
 ##
 ## Compute the start location and size size of
 ## The coreboot bootloader.
 ##
 default CONFIG_ROM_PAYLOAD_START = (0xffffffff - ROM_SIZE + ROM_SECTION_OFFSET + 1)
 default PAYLOAD_SIZE            = ( ROM_SECTION_SIZE - ROM_IMAGE_SIZE )
 
 ##
 ## Compute where this copy of coreboot will start in the boot rom
 ##
 default _ROMBASE      = ( CONFIG_ROM_PAYLOAD_START + PAYLOAD_SIZE )
 
 ##
 ## Compute a range of ROM that can cached to speed up coreboot,
 ## execution speed.
 ##
 ## XIP_ROM_SIZE must be a power of 2.
 ## XIP_ROM_BASE must be a multiple of XIP_ROM_SIZE
 ##
 default XIP_ROM_SIZE=65536
 default XIP_ROM_BASE = ( _ROMBASE + ROM_IMAGE_SIZE - XIP_ROM_SIZE )
 
 ##
 ## Set all of the defaults for an x86 architecture
 ##
 
 arch i386 end
 
 ##
 ## Build the objects we have code for in this directory.
 ##
 
 driver mainboard.o
 if HAVE_PIRQ_TABLE object irq_tables.o end
 #object reset.o
 
 ##
 ## Romcc output
 ##
 makerule ./failover.E
-	depends "$(MAINBOARD)/failover.c ./romcc" 
-	action "./romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+	depends "$(MAINBOARD)/failover.c ../romcc" 
+	action "../romcc -E -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 end
 
 makerule ./failover.inc
-	depends "$(MAINBOARD)/failover.c ./romcc"
-	action "./romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
+	depends "$(MAINBOARD)/failover.c ../romcc"
+	action "../romcc    -O --label-prefix=failover -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/failover.c -o $@"
 end
 
 makerule ./auto.E 
-	depends	"$(MAINBOARD)/auto.c option_table.h ./romcc" 
-	action	"./romcc -E -mcpu=c3 -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	depends	"$(MAINBOARD)/auto.c option_table.h ../romcc" 
+	action	"../romcc -E -mcpu=c3 -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 makerule ./auto.inc 
-	depends "$(MAINBOARD)/auto.c option_table.h ./romcc"
-	action	"./romcc    -mcpu=c3 -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
+	depends "$(MAINBOARD)/auto.c option_table.h ../romcc"
+	action	"../romcc    -mcpu=c3 -O -I$(TOP)/src -I. $(CPPFLAGS) $(MAINBOARD)/auto.c -o $@"
 end
 
 ##
 ## Build our 16 bit and 32 bit coreboot entry code
 ##
 mainboardinit cpu/x86/16bit/entry16.inc
 mainboardinit cpu/x86/32bit/entry32.inc
 ldscript /cpu/x86/16bit/entry16.lds
 ldscript /cpu/x86/32bit/entry32.lds
 
 ##
 ## Build our reset vector (This is where coreboot is entered)
 ##
 if USE_FALLBACK_IMAGE 
 	mainboardinit cpu/x86/16bit/reset16.inc 
 	ldscript /cpu/x86/16bit/reset16.lds 
 else
 	mainboardinit cpu/x86/32bit/reset32.inc 
 	ldscript /cpu/x86/32bit/reset32.lds 
 end
 
 ### Should this be in the northbridge code?
 mainboardinit arch/i386/lib/cpu_reset.inc
 
 ##
 ## Include an id string (For safe flashing)
 ##
 mainboardinit arch/i386/lib/id.inc
 ldscript /arch/i386/lib/id.lds
 
 ###
 ### This is the early phase of coreboot startup 
 ### Things are delicate and we test to see if we should
 ### failover to another image.
 ###
 if USE_FALLBACK_IMAGE
 	ldscript /arch/i386/lib/failover.lds 
 	mainboardinit ./failover.inc
 end
 
 ###
 ### O.k. We aren't just an intermediary anymore!
 ###
 
 ##
 ## Setup RAM
 ##
 mainboardinit cpu/x86/fpu/enable_fpu.inc
 mainboardinit cpu/x86/mmx/enable_mmx.inc
 mainboardinit ./auto.inc
 mainboardinit cpu/x86/mmx/disable_mmx.inc
 
 ##
 ## Include the secondary Configuration files 
 ##
 dir /pc80
 config chip.h
 
 chip northbridge/via/vt8601
 	device pci_domain 0 on
     		device pci 0.0 on end			# Northbridge
 #		device pci 0.1 on			# AGP bridge
 		#	chip drivers/pci/onboard	# Integrated VGA
 		#		device pci 0.0 on end
 		#		register "rom_adress" = "0xfff80000"
 		#	end
 #		end
 		chip southbridge/via/vt8231
 			register "enable_native_ide" = "0"
 			register "enable_com_ports" = "1"
 			register "enable_keyboard" = "0"
 			device pci 11.0 on              # Southbrdge
 				chip superio/winbond/w83627hf
 					device pnp 2e.0 on      #  Floppy
 					   io 0x60 = 0x3f0
 					  irq 0x70 = 6
 					  drq 0x74 = 2
 					end
 					device pnp 2e.1 off     #  Parallel Port
 					   io 0x60 = 0x378
 					  irq 0x70 = 7
 					end
 					device pnp 2e.2 on      #  Com1
 					   io 0x60 = 0x3f8
 					  irq 0x70 = 4
 					end
 					device pnp 2e.3 off     #  Com2
 					   io 0x60 = 0x2f8
 					  irq 0x70 = 3
 					end
 					device pnp 2e.5 on      #  Keyboard
 					   io 0x60 = 0x60
 					   io 0x62 = 0x64
 					  irq 0x70 = 1
 					  irq 0x72 = 12
 	      				end
 				register "com1" = "{TTYS0_BAUD}"
 				end
 				device pnp 2e.6 off end 	#  CIR
 				device pnp 2e.7 off end 	#  GAME_MIDI_GIPO1
 				device pnp 2e.8 off end		#  GPIO2
 				device pnp 2e.9 off end 	#  GPIO3
 				device pnp 2e.a off end		#  ACPI
 				device pnp 2e.b on		#  HW Monitor
 					io 0x60 = 0x290
 				end
 			end
 			device pci 11.1 on  end		# Ide
 			device pci 11.2 off end		# Usb port 0-1
 			device pci 11.3 off end		# Usb port 2-3
 			device pci 11.4 off end		# ACPI
 			device pci 11.5 off end		# AC97 Audio
 			device pci 11.6 on  end		# AC97 Modem
           		device pci 12.0 on  end		# Ethernet
         	end
 	end
 
         device apic_cluster 0 on
                 chip cpu/via/model_c3
                         device apic 0 on end
                 end
         end
 end
diff --git a/util/newconfig/config.g b/util/newconfig/config.g
index 73136ba..26cee43 100644
--- a/util/newconfig/config.g
+++ b/util/newconfig/config.g
@@ -1,2350 +1,2353 @@
 # -*- python -*-
 import sys
 import os
 import re
 import string
 import types
 
 import traceback
 
 warnings = 0
 errors = 0
 
 target_dir = ''
 target_name = ''
 treetop = ''
 full_mainboard_path = ''
 mainboard_path = ''
 global_options = {}
 global_options_by_order = []
 global_option_values = {}
 global_uses_options = {}
 global_exported_options = []
 romimages = {}
 buildroms = []
 curimage = 0
 alloptions = 0 # override uses at top level
 
 local_path = re.compile(r'^\.')
 include_pattern = re.compile(r'%%([^%]+)%%')
 
 # the cpu type for this mainboard
 cpu_type = 0
 
 # -----------------------------------------------------------------------------
 #                    Utility Classes
 # -----------------------------------------------------------------------------
 
 class stack:
 	"""Used to keep track of the current part or dir"""
 	class __stack_iter:
 		def __init__ (self, stack):
 			self.index = 0
 			self.len = len(stack)
 			self.stack = stack
 
 		def __iter__ (self):
 			return self
 
 		def next (self):
 			if (self.index < self.len):
 				s = self.stack[self.index]
 				self.index = self.index + 1
 				return s
 			raise StopIteration
 
 	def __init__ (self):
 		self.stack = []
 
 	def __len__ (self):
 		return len(self.stack)
 
 	def __getitem__ (self, i):
 		return self.stack[i]
 
 	def __iter__ (self):
 		return self.__stack_iter(self.stack)
 
 	def push(self, part):
 		self.stack.append(part)
 
 	def pop(self):
 		try:
 			return self.stack.pop()
 		except IndexError:
 			return 0
 
 	def tos(self):
 		try:
 			return self.stack[-1]
 		except IndexError:
 			return 0
 
 	def empty(self):
 		return (len(self.stack) == 0)
 partstack = stack()
 dirstack = stack()
 
 class debug_info:
 	none = 0
 	gencode = 1
 	dumptree = 2
 	object = 3
 	dict = 4
 	statement = 5
 	dump = 6
 
 	def __init__(self, *level):
 		self.__level = level
 
 	def setdebug(self, *level):
 		self.__level = level
 
 	def level(self, level):
 		return level in self.__level
 
 	def info(self, level, str):
 		if level in self.__level:
 			print str
 
 global debug
 debug = debug_info(debug_info.none)
 
 # -----------------------------------------------------------------------------
 #                    Error Handling
 # -----------------------------------------------------------------------------
 
 class location:
 	"""Used to keep track of our current location while parsing
 	configuration files"""
 	class __place:
                 def __init__(self, file, line, command):
                         self.file = file
                         self.line = line
                         self.command = command
                 def next_line(self, command):
                         self.line = self.line + 1
                         self.command = command
                 def at(self):
                         return "%s:%d" % (self.file, self.line)
         
         def __init__ (self):
                 self.stack = stack()
 
 	def __str__ (self):
 		s = ''
 		for p in self.stack:
 			if (s == ''):
 				s = p.at()
 			else:
 				s = s + '\n' + p.at()
 		return s
 
         def file(self):
                 return self.stack.tos().file
 
         def line(self):
                 return self.stack.tos().line
 
         def command(self):
                 return self.stack.tos().command
 
         def push(self, file):
                 self.stack.push(self.__place(os.path.normpath(file), 0, ""))
 
         def pop(self):
                 self.stack.pop()
 
         def next_line(self, command):
                 self.stack.tos().next_line(command)
 
         def at(self):
                 return self.stack.tos().at()
 loc = location()
 
 def error(string):      
 	"""Print error message"""
         global errors, loc
 	errors = errors + 1
         print "===> ERROR: %s" % string
         print "%s" % loc
 
 def fatal(string):      
 	"""Print error message and exit"""
 	error(string)
         exitiferrors()
 
 def warning(string):
 	"""Print warning message"""
         global warnings, loc
 	warnings = warnings + 1
         print "===> WARNING: %s" % string
 
 def notice(string):
 	"""Print notice message"""
 	#print "===> NOTE: %s" % string
 
 def exitiferrors():
 	"""Exit parser if an error has been encountered"""
 	if (errors != 0):
 		sys.exit(1)
 
 def safe_open(file, mode):
 	try:
 		return open(file, mode)
 	except IOError:
 		fatal("Could not open file \"%s\"" % file)
 
 # -----------------------------------------------------------------------------
 #                    Main classes
 # -----------------------------------------------------------------------------
 
 class romimage:
 	"""A rom image is the ultimate goal of coreboot"""
 	def __init__ (self, name):
 		# name of this rom image
 		self.name = name
 
 		# set by 'arch' directive
 		self.arch = ''
 
 		# set by 'payload' directive
 		self.payload = ''
 
 		# set by 'init' directive
 		self.initfile = ''
 
 		# make rules added by 'makerule' directive
 		self.makebaserules = {}
 
 		# object files added by 'object' directive
 		self.objectrules = {}
 
 		# init object files added by 'initobject' directive
 		self.initobjectrules = {}
 
 		# driver files added by 'driver' directive
 		self.driverrules = {}
 
 		# loader scripts added by 'ldscript' directive
 		self.ldscripts = []
 
 		# user defines added by 'makedefine' directive
 		self.userdefines = []
 
 		# files to be included in crt0.S
 		self.initincludes = {}
 
 		# as above, but order is preserved
 		self.initincludesorder = []
 
 		# transitional flag to support old crtinclude format
 		self.useinitincludes = 0
 
 		# instance counter for parts
 		self.partinstance = 0
 
 		# chip config files included by the 'config' directive
 		self.configincludes = {}
 
 		# root of part tree
 		self.root = 0
 
 		# name of target directory specified by 'target' directive
 		self.target_dir = ''
 
 		# option values used in rom image
 		self.values = {}
 
 		# exported options
 		self.exported_options = []
 
 		# Last device built
 		self.last_device = 0
 
 	def getname(self):
 		return self.name
 
 	def getvalues(self):
 		return self.values
 
 	def setarch(self, arch):
 		self.arch = arch
 
 	def setpayload(self, payload):
 		self.payload = payload
 
 	def setinitfile(self, initfile):
 		self.initfile = initfile
 
 	def getinitfile(self):
 		return self.initfile
 
 	def addmakerule(self, id):
 		o = getdict(self.makebaserules, id)
 		if (o):
 			warning("rule %s previously defined" % id)
 		o = makerule(id)
 		setdict(self.makebaserules, id, o)
 
 	def getmakerules(self):
 		return self.makebaserules
 
 	def getmakerule(self, id):
 		o = getdict(self.makebaserules, id)
 		if (o):
 			return o
 		fatal("No such make rule \"%s\"" % id)
 
 	def addmakeaction(self, id, str):
 		o = getdict(self.makebaserules, id)
 		if (o):
 			a = dequote(str)
 			o.addaction(a)
 			return
 		fatal("No such rule \"%s\" for addmakeaction" % id)
 
 	def addmakedepend(self, id, str):
 		o = getdict(self.makebaserules, id)
 		if (o):
 			a = dequote(str)
 			o.adddependency(a)
 			return
 		fatal("No such rule \"%s\" for addmakedepend" % id)
 
 	# this is called with an an object name. 
 	# the easiest thing to do is add this object to the current 
 	# component.
 	# such kludgery. If the name starts with '.' then make the 
 	# dependency be on ./thing.x gag me.
 	def addobjectdriver(self, dict, object_name):
 		global dirstack
 		suffix = object_name[-2:]
 		if (suffix == '.o'):
 			suffix = '.c'
 		base = object_name[:-2]
 		type = object_name[-1:]
 		if (object_name[0] == '.'):
 			source = base + suffix
 		else:
 			source = os.path.join(dirstack.tos(), base + suffix)
 		object = base + '.o'
 		debug.info(debug.object, "add object %s source %s" % (object_name, source))
 		l = getdict(dict, base)
 		if (l):
 			warning("object/driver %s previously defined" % base)
 		setdict(dict, base, [object, source, type, base])
 
 	def addinitobjectrule(self, name):
 		self.addobjectdriver(self.initobjectrules, name)
 
 	def addobjectrule(self, name):
 		self.addobjectdriver(self.objectrules, name)
 
 	def adddriverrule(self, name):
 		self.addobjectdriver(self.driverrules, name)
 
 	def getinitobjectrules(self):
 		return self.initobjectrules
 
 	def getinitobjectrule(self, name):
 		o = getdict(self.initobjectrules, name)
 		if (o):
 			return o
 		fatal("No such init object rule \"%s\"" % name)
 
 	def getobjectrules(self):
 		return self.objectrules
 
 	def getobjectrule(self, name):
 		o = getdict(self.objectrules, name)
 		if (o):
 			return o
 		fatal("No such object rule \"%s\"" % name)
 
 	def getdriverrules(self):
 		return self.driverrules
 
 	def getdriverrule(self, name):
 		o = getdict(self.driverrules, name)
 		if (o):
 			return o
 		fatal("No such driver rule \"%s\"" % name)
 
 	def addldscript(self, path):
 		self.ldscripts.append(path)
 
 	def getldscripts(self):
 		return self.ldscripts
 
 	def adduserdefine(self, str):
 		self.userdefines.append(str)
 
 	def getuserdefines(self):
 		return self.userdefines
 
 	def addinitinclude(self, str, path):
 		if (str != 0):
 			self.useinitincludes = 1
 
 		debug.info(debug.object, "ADDCRT0: %s -> %s" % (str, path))
 		o = getdict(self.initincludes, path)
 		if (o):
 			warning("init include for %s previously defined" % path)
 		o = initinclude(str, path)
 		setdict(self.initincludes, path, o)
 		self.initincludesorder.append(path)
 
 	def getinitincludes(self):
 		return self.initincludesorder
 
 	def getinitinclude(self, path):
 		o = getdict(self.initincludes, path)
 		if (o):
 			return o
 		fatal("No such init include \"%s\"" % path)
 
 	def addconfiginclude(self, part, path):
 		setdict(self.configincludes, part, path)
 
 	def getconfigincludes(self):
 		return self.configincludes
 
 	def getincludefilename(self):
 		if (self.useinitincludes):
 			return "crt0.S"
 		else:
 			return "crt0_includes.h"
 	
 	def newformat(self):
 		return self.useinitincludes
 
 	def numparts(self):
 		return self.partinstance
 
 	def newpartinstance(self):
 		i = self.partinstance
 		self.partinstance = self.partinstance + 1
 		return i
 
 	def setroot(self, part):
 		self.root = part
 
 	def getroot(self):
 		return self.root
 
 	def settargetdir(self, path):
 		self.targetdir = path
 
 	def gettargetdir(self):
 		return self.targetdir
 
 class buildrom:
 	"""A buildrom statement"""
 	def __init__ (self, filename, size, roms):
 		self.name = filename
 		self.size = size
 		self.roms = roms
 	
 	def __len__ (self):
 		return len(self.roms)
 
 	def __getitem__(self,i):
 		return self.roms[i]
 
 class initinclude:
 	"""include file for initialization code"""
 	def __init__ (self, str, path):
 		self.string = str
 		self.path = path
 
 	def getstring(self):
 		return self.string
 
 	def getpath(self):
 		return self.path
 
 class makerule:
 	"""Rule to be included in Makefile"""
 	def __init__ (self, target):
 		self.target = target
 		self.dependency = []
 		self.actions = []
 
 	def addaction(self, action):
 		self.actions.append(action)
 
 	def adddependency(self, dependency):
 		self.dependency.append(dependency)
 
 	def gtarget(self):
 		return self.target
 
 	def gdependency(self):
 		return self.dependency
 
 	def gaction(self):
 		return self.actions
 
 class option:
 	"""Configuration option"""
 	def __init__ (self, name):
 		self.name = name	# name of option
 		self.loc = 0		# current location
 		self.used = 0		# option has been used
 					# it is undefined)
 		self.comment = ''	# description of option
 		self.exportable = 0	# option is able to be exported
 		self.format = '%s'	# option print format
 		self.write = []		# parts that can set this option
 
 	def where(self):
 		return self.loc
 
 	def setcomment(self, comment, loc):
 		if (self.comment != ''):
 			print "%s: " % self.name
 			print "Attempt to modify comment at %s" % loc 
 			return
 		self.comment = comment
 
 	def setexportable(self):
 		self.exportable = 1
 
 	def setnoexport(self):
 		self.exportable = 0
 
 	def setformat(self, fmt):
 		self.format = fmt
 
 	def getformat(self):
 		return self.format
 
 	def setused(self):
 		if (self.exportable):
 			self.exported = 1
 		self.used = 1
 
 	def setwrite(self, part):
 		self.write.append(part)
 
 	def isexportable(self):
 		return self.exportable
 
 	def iswritable(self, part):
 		return (part in self.write)
 
 class option_value:
 	"""Value of a configuration option. The option has a default
         value which can be changed at any time. Once an option has been
 	set the default value is no longer used."""
 	def __init__(self, name, prev):
 		self.name = name
 		self.value = ''
 		self.set = 0
 		if (prev):
 			self.value   = prev.value
 			self.set     = prev.set
 		
 
 	def setvalue(self, value):
 		if ((self.set & 2) == 2):
 			warning("Changing option %s" % self.name)
 		else:
 			self.set |= 2
 		self.value = value
 
 	def setdefault(self, value):
 		if ((self.set & 1) == 1):
 			notice("Changing default value of %s" % self.name)
 		
 		if ((self.set & 2) == 0):
 			self.value = value
 			self.set |= 1
 
 	def contents(self):
 		return self.value
 
 	def isset(self):
 		return (self.set & 2) == 2
 
 
 class partobj:
 	"""A configuration part"""
 	def __init__ (self, image, dir, parent, part, type_name, instance_name, chip_or_device):
 		debug.info(debug.object, "partobj dir %s parent %s part %s" \
 				% (dir, parent, part))
 
 		# romimage that is configuring this part
 		self.image = image
 
 		# links for static device tree
 		self.children = 0
 		self.prev_sibling = 0
 		self.next_sibling = 0
 		self.prev_device = 0
 		self.next_device = 0
 		self.chip_or_device = chip_or_device
 
 		# list of init code files
 		self.initcode = []
 
 		# initializers for static device tree
 		self.registercode = {}
 
 		# part name
 		self.part = part
 
 		# type name of this part
 		self.type_name = type_name
 
 		# object files needed to build this part
 		self.objects = []
 
 		# directory containg part files
 		self.dir = dir
 
 		# instance number, used to distinguish anonymous
 		# instances of this part
 		self.instance = image.newpartinstance()
 		debug.info(debug.object, "INSTANCE %d" % self.instance)
 
 		# Options used by this part
 		self.uses_options = {}
 
 		# Name of chip config file (0 if not needed)
 		self.chipconfig = 0
 
 		# Flag to indicate that we have generated type
 		# definitions for this part (only want to do it once)
 		self.done_types = 0
 
 		# Path to the device
 		self.path = ""
 
 		# Resources of the device
 		self.resoruce = ""
 		self.resources = 0
 
 		# Enabled state of the device
 		self.enabled = 1
 
 		# Flag if I am a dumplicate device
 		self.dup = 0
 
 		# If no instance name is supplied then generate
 		# a unique name
 		if (instance_name == 0):
 			self.instance_name = self.type_name + \
 					"_dev%d" % self.instance
 			self.chipinfo_name = "%s_info_%d" \
 					% (self.type_name, self.instance)
 		else:
 			self.instance_name = instance_name
 			self.chipinfo_name = "%s_info_%d" % (self.instance_name, self.instance)
 
 		# Link this part into the device list
 		if (self.chip_or_device == 'device'):
 			if (image.last_device):
 				image.last_device.next_device = self
 			self.prev_device = image.last_device
 			image.last_device = self
 
 		# Link this part into the tree
 		if (parent and (part != 'arch')):
 			debug.info(debug.gencode, "add to parent")
 			self.parent   = parent
 			# add current child as my sibling, 
 			# me as the child.
 			if (parent.children):
 				debug.info(debug.gencode, "add %s (%d) as sibling" % (parent.children.dir, parent.children.instance))
 				youngest = parent.children
 				while(youngest.next_sibling):
 					youngest = youngest.next_sibling
 				youngest.next_sibling = self
 				self.prev_sibling = youngest
 			else:
 				parent.children = self
 		else:
 			self.parent = self
 
 
 	def info(self):
 		return "%s: %s" % (self.part, self.type)
 	def type(self):
 		return self.chip_or_device
 
 	def readable_name(self):
 		name = ""
 		name = "%s_%d" % (self.type_name, self.instance)
 		if (self.chip_or_device == 'chip'):
 			name = "%s %s %s" % (name, self.part, self.dir)
 		else:
 			name = "%s %s" % (name, self.path)
 		return name
 			
 	def dumpme(self, lvl):
 		"""Dump information about this part for debugging"""
 		print "%d: %s" % (lvl, self.readable_name())
 		print "%d: part %s" % (lvl, self.part)
 		print "%d: instance %d" % (lvl, self.instance)
 		print "%d: chip_or_device %s"  %  (lvl, self.chip_or_device)
 		print "%d: dir %s" % (lvl,self.dir)
 		print "%d: type_name %s" % (lvl,self.type_name)
 		print "%d: parent: %s" % (lvl, self.parent.readable_name())
 		if (self.children):
 			print "%d: child %s" % (lvl, self.children.readable_name())
 		if (self.next_sibling):
 			print "%d: siblings %s" % (lvl, self.next_sibling.readable_name())
 		print "%d: initcode " % lvl
 		for i in self.initcode:
 			print "\t%s" % i
 		print "%d: registercode " % lvl
 		for f, v in self.registercode.items():
 			print "\t%s = %s" % (f, v)
 		print "\n"
 
 	def firstchilddevice(self):
 		"""Find the first device in the children link."""
 		kid = self.children
 		while (kid):
 			if (kid.chip_or_device == 'device'):
 				return kid
 			else:
 				kid = kid.children
 		return 0
 
 	def firstparentdevice(self):
 		"""Find the first device in the parent link."""
 		parent = self.parent
 		while (parent and (parent.parent != parent) and (parent.chip_or_device != 'device')):
 			parent = parent.parent
 		if ((parent.parent != parent) and (parent.chip_or_device != 'device')):
 			parent = 0
 		while(parent and (parent.dup == 1)):
 			parent = parent.prev_sibling
 		if (not parent):
 			fatal("Device %s has no device parent; this is a config file error" % self.readable_name())
 		return parent
 
 	def firstparentdevicelink(self):
 		"""Find the first device in the parent link and record which link it is."""
 		link = 0
 		parent = self.parent
 		while (parent and (parent.parent != parent) and (parent.chip_or_device != 'device')):
 			parent = parent.parent
 		if ((parent.parent != parent) and (parent.chip_or_device != 'device')):
 			parent = 0
 		while(parent and (parent.dup == 1)):
 			parent = parent.prev_sibling
 			link = link + 1
 		if (not parent):
 			fatal("Device %s has no device parent; this is a config file error" % self.readable_name())
 		return link
 
 
 	def firstparentchip(self):
 		"""Find the first chip in the parent link."""
 		parent = self.parent
 		while (parent):
 			if ((parent.parent == parent) or (parent.chip_or_device == 'chip')):
 				return parent
 			else:
 				parent = parent.parent
 		fatal("Device %s has no chip parent; this is a config file error" % self.readable_name())
 
 	def firstsiblingdevice(self):
 		"""Find the first device in the sibling link."""
 		sibling = self.next_sibling
 		while(sibling and (sibling.path == self.path)):
 			sibling = sibling.next_sibling
 		if ((not sibling) and (self.parent.chip_or_device == 'chip')):
 			sibling = self.parent.next_sibling
 		while(sibling):
 			if (sibling.chip_or_device == 'device'):
 				return sibling
 			else:
 				sibling = sibling.children
 		return 0
 
 	def gencode(self, file, pass_num):
 		"""Generate static initalizer code for this part. Two passes
 		are used - the first generates type information, and the second
 		generates instance information"""
 		if (pass_num == 0):
 			if (self.chip_or_device == 'chip'):
 				return;
 			else:
 				if (self.instance):
 					file.write("struct device %s;\n" \
 						% self.instance_name)
 				else:
 					file.write("struct device dev_root;\n")
 			return
 		# This is pass the second, which is pass number 1
 		# this is really just a case statement ...
 
 		if (self.chip_or_device == 'chip'):
 			if (self.chipconfig):
 				debug.info(debug.gencode, "gencode: chipconfig(%d)" % \
 					self.instance)
 				file.write("struct %s_config %s" % (self.type_name ,\
 					self.chipinfo_name))
 				if (self.registercode):
 					file.write("\t= {\n")
 					for f, v in self.registercode.items():
 						file.write( "\t.%s = %s,\n" % (f, v))
 					file.write("};\n")
 				else:
 					file.write(";")
 				file.write("\n")
 
 			if (self.instance == 0):
 				self.instance_name = "dev_root"
 				file.write("struct device **last_dev_p = &%s.next;\n" % (self.image.last_device.instance_name))
 				file.write("struct device dev_root = {\n")
 				file.write("\t.ops = &default_dev_ops_root,\n")
 				file.write("\t.bus = &dev_root.link[0],\n")
 				file.write("\t.path = { .type = DEVICE_PATH_ROOT },\n")
 				file.write("\t.enabled = 1,\n\t.links = 1,\n")
 				file.write("\t.on_mainboard = 1,\n")
 				file.write("\t.link = {\n\t\t[0] = {\n")
 				file.write("\t\t\t.dev=&dev_root,\n\t\t\t.link = 0,\n")
 				file.write("\t\t\t.children = &%s,\n" % self.firstchilddevice().instance_name)
 				file.write("\t\t},\n")
 				file.write("\t},\n")
 				if (self.chipconfig):
 					file.write("\t.chip_ops = &%s_ops,\n" % self.type_name)
 					file.write("\t.chip_info = &%s_info_%s,\n" % (self.type_name, self.instance))
 				file.write("\t.next = &%s,\n" % self.firstchilddevice().instance_name)
 				file.write("};\n")
 			return
 
 		# Don't print duplicate devices, just print their children
 		if (self.dup):
 			return
 
 		file.write("struct device %s = {\n" % self.instance_name)
 		file.write("\t.ops = 0,\n")
 		file.write("\t.bus = &%s.link[%d],\n" % \
 			(self.firstparentdevice().instance_name, \
 			self.firstparentdevicelink()))
 		file.write("\t.path = {%s},\n" % self.path)
 		file.write("\t.enabled = %d,\n" % self.enabled)
 		file.write("\t.on_mainboard = 1,\n")
 		if (self.resources):
 			file.write("\t.resources = %d,\n" % self.resources)
 			file.write("\t.resource = {%s\n\t },\n" % self.resource)
 		file.write("\t.link = {\n");	
 		links = 0
 		bus = self
 		while(bus and (bus.path == self.path)):
 			child = bus.firstchilddevice()
 			if (child or (bus != self) or (bus.next_sibling and (bus.next_sibling.path == self.path))):
 				file.write("\t\t[%d] = {\n" % links)
 				file.write("\t\t\t.link = %d,\n" % links)
 				file.write("\t\t\t.dev = &%s,\n" % self.instance_name)
 				if (child):
 					file.write("\t\t\t.children = &%s,\n" %child.instance_name)
 				file.write("\t\t},\n")
 				links = links + 1
 			if (1):	
 				bus = bus.next_sibling
 			else:
 				bus = 0
 		file.write("\t},\n")
 		file.write("\t.links = %d,\n" % (links))
 		sibling = self.firstsiblingdevice(); 
 		if (sibling):
 			file.write("\t.sibling = &%s,\n" % sibling.instance_name)
 		chip = self.firstparentchip()
 		if (chip and chip.chipconfig):
 			file.write("\t.chip_ops = &%s_ops,\n" % chip.type_name)
 			file.write("\t.chip_info = &%s_info_%s,\n" % (chip.type_name, chip.instance))
 		if (self.next_device):	
 			file.write("\t.next=&%s\n" % self.next_device.instance_name)
 		file.write("};\n")
 		return
 
     	def addinit(self, code):
 		"""Add init file to this part"""
         	self.initcode.append(code)
 		
     	def addconfig(self, path):
 		"""Add chip config file to this part"""
         	self.chipconfig = os.path.join(self.dir, path)
 		self.image.addconfiginclude(self.type_name, self.chipconfig)
 
     	def addregister(self, field, value):
 		"""Register static initialization information"""
 		if (self.chip_or_device != 'chip'):
 			fatal("Only chips can have register values")
 		field = dequote(field)
 		value = dequote(value)
         	setdict(self.registercode, field, value)
 
 	def set_enabled(self, enabled):
 		self.enabled = enabled
 
 	def start_resources(self):
 		self.resource = ""
 		self.resources = 0
 
 	def end_resources(self):
 		self.resource = "%s" % (self.resource)
 
 	def add_resource(self, type, index, value):
 		""" Add a resource to a device """
 		self.resource = "%s\n\t\t{ .flags=%s, .index=0x%x, .base=0x%x}," % (self.resource, type, index, value)
 		self.resources = self.resources + 1
 
 	def set_path(self, path):
 		self.path = path
 		if (self.prev_sibling and (self.prev_sibling.path == self.path)):
 			self.dup = 1
 			if (self.prev_device):
 				self.prev_device.next_device = self.next_device
 			if (self.next_device):	
 				self.next_device.prev_device = self.prev_device
 			if (self.image.last_device == self):
 				self.image.last_device = self.prev_device
 			self.prev_device = 0
 			self.next_device = 0
 		
 	def addpcipath(self, slot, function):
 		""" Add a relative pci style path from our parent to this device """
 		if ((slot < 0) or (slot > 0x1f)):
 			fatal("Invalid device id")
 		if ((function < 0) or (function > 7)):
 			fatal("Invalid pci function %s" % function )
 		self.set_path(".type=DEVICE_PATH_PCI,.u={.pci={ .devfn = PCI_DEVFN(0x%x,%d)}}" % (slot, function))
 
 	def addpnppath(self, port, device):
 		""" Add a relative path to a pnp device hanging off our parent """
 		if ((port < 0) or (port > 65536)):
 			fatal("Invalid port")
 		if ((device < 0) or (device > 0xffff)):
 			fatal("Invalid device")
 		self.set_path(".type=DEVICE_PATH_PNP,.u={.pnp={ .port = 0x%x, .device = 0x%x }}" % (port, device))
 		
 	def addi2cpath(self, device):
 		""" Add a relative path to a i2c device hanging off our parent """
 		if ((device < 0) or (device > 0x7f)):
 			fatal("Invalid device")
 		self.set_path(".type=DEVICE_PATH_I2C,.u={.i2c={ .device = 0x%x }}" % (device))
 
 	def addapicpath(self, apic_id):
 		""" Add a relative path to a cpu device hanging off our parent """
 		if ((apic_id < 0) or (apic_id > 255)):
 			fatal("Invalid device")
 		self.set_path(".type=DEVICE_PATH_APIC,.u={.apic={ .apic_id = 0x%x }}" % (apic_id))
     
 	def addpci_domainpath(self, pci_domain):
 		""" Add a pci_domain number to a chip """
 		if ((pci_domain < 0) or (pci_domain > 0xffff)):
 			fatal("Invalid pci_domain: 0x%x is out of the range 0 to 0xffff" % pci_domain)
 		self.set_path(".type=DEVICE_PATH_PCI_DOMAIN,.u={.pci_domain={ .domain = 0x%x }}" % (pci_domain))
     
 	def addapic_clusterpath(self, cluster):
 		""" Add an apic cluster to a chip """
 		if ((cluster < 0) or (cluster > 15)):
 			fatal("Invalid apic cluster: %d is out of the range 0 to ff" % cluster)
 		self.set_path(".type=DEVICE_PATH_APIC_CLUSTER,.u={.apic_cluster={ .cluster = 0x%x }}" % (cluster))
     
 	def addcpupath(self, cpu_id):
 		""" Add a relative path to a cpu device hanging off our parent """
 		if ((cpu_id < 0) or (cpu_id > 255)):
 			fatal("Invalid device")
 		self.set_path(".type=DEVICE_PATH_CPU,.u={.cpu={ .id = 0x%x }}" % (cpu_id))
     
 
 	def addcpu_buspath(self, id):
 		""" Add a cpu_bus to a chip """
 		if ((id < 0) or (id > 255)):
 			fatal("Invalid device")
 		self.set_path(".type=DEVICE_PATH_CPU_BUS,.u={.cpu_bus={ .id = 0x%x }}" % (id))
     
 	def usesoption(self, name):
 		"""Declare option that can be used by this part"""
 		global global_options
 		o = getdict(global_options, name)
 		if (o == 0):
 			fatal("can't use undefined option %s" % name)
 		o1 = getdict(self.uses_options, name)
 		if (o1):
 			return
 		setdict(self.uses_options, name, o)
 		exportoption(o, self.image.exported_options)
 
 # -----------------------------------------------------------------------------
 #                    statements 
 # -----------------------------------------------------------------------------
 
 def getdict(dict, name):
 	if name not in dict.keys(): 
 		debug.info(debug.dict, "Undefined: %s" % name)
 		return 0
 	v = dict.get(name, 0)
 	debug.info(debug.dict, "getdict %s returning %s" % (name, v))
 	return v
 
 def setdict(dict, name, value):
 	debug.info(debug.dict, "setdict sets %s to %s" % (name, value))
 	dict[name] = value
 
 # options. 
 # to create an option, it has to not exist. 
 # When an option value is fetched, the fact that it was used is 
 # remembered. 
 # Legal things to do:
 # set a default value, then set a real value before the option is used.
 # set a value, try to set a default, default silently fails.
 # Illegal:
 # use the value, then try to set the value
 
 def newoption(name):
 	global global_options, global_options_by_order
 	o = getdict(global_options, name)
 	if (o):
 		fatal("option %s already defined" % name)
 	o = option(name)
 	setdict(global_options, name, o)
 	global_options_by_order.append(name)
 
 def newoptionvalue(name, image):
 	g = getdict(global_option_values, name)
 	v = option_value(name, g)
 	if (image):
 		setdict(image.getvalues(), name, v)
 	else:
 		setdict(global_option_values, name, v)
 	return v
 
 def getoptionvalue(name, op, image):
 	global global_option_values
 	#print "getoptionvalue name %s op %s image %s\n" % (name, op,image)
 	if (op == 0):
 		# we want to debug config files, not the config tool, so no:
 		# print_stack() 
 		fatal("Option %s undefined (missing use command?)" % name)
 	if (image):
 		v = getdict(image.getvalues(), name)
 	else:
 		v = getdict(global_option_values, name)
 	return v
 
 def getoption(name, image):
 	"""option must be declared before being used in a part
 	if we're not processing a part, then we must
 	be at the top level where all options are available"""
 
 	global global_uses_options, alloptions, curimage
 
 	#print "getoption: name %s image %s alloptions %s curimage %s\n\n" % (name, image, alloptions, curimage)
 	curpart = partstack.tos()
 	if (alloptions):
 		o = getdict(global_options, name)
 	elif (curpart):
 		o = getdict(curpart.uses_options, name)
 		if (o == 0):
 			print "curpart.uses_options is %s\n" % curpart.uses_options
 	else:
 		o = getdict(global_uses_options, name)
 	v = getoptionvalue(name, o, image)
 	if (v == 0):
 		v = getoptionvalue(name, o, 0)
 	if (v == 0):
 		fatal("No value for option %s" % name)
 	val = v.contents()
 	if (not (type(val) is types.StringType)):
 		return v.contents()
 	if (val == '' or val[0] != '{'):
 		return v.contents()
 	s = curimage
 	curimage = image
 	val = parse('delexpr', val)
 	curimage = s
 	exitiferrors()
 	return val
 
 def setoption(name, value, imp):
 	"""Set an option from within a configuration file. Normally this
 	is only permitted in the target (top level) configuration file.
 	If 'imp' is true, then set an option implicitly (e.g. 'arch' 
 	and 'mainboard' statements). Implicit options can be set anywhere 
 	the statements are legal, but also performs an implicit 'uses' 
 	for the option"""
 
 	global loc, global_options, global_option_values, curimage
 
 	curpart = partstack.tos()
 	if (not imp and curpart):
 		fatal("Options may only be set in target configuration file")
 	if (imp):
 		usesoption(name)
 	if (curpart):
 		o = getdict(curpart.uses_options, name)
 	else:
 		o = getdict(global_uses_options, name)
 	if (not o):
 		fatal("Attempt to set nonexistent option %s (missing USES?)" % name)
 	v = getoptionvalue(name, o, curimage)
 	if (v == 0):
 		v = newoptionvalue(name, curimage)
 	v.setvalue(value)
 
 def exportoption(op, exported_options):
 	if (not op.isexportable()):
 		return
 	if (not op in exported_options):
 		exported_options.append(op)
 
 def setdefault(name, value, isdef):
 	"""Set the default value of an option from within a configuration 
 	file. This is permitted from any configuration file, but will
 	result in a warning if the default is set more than once.
 	If 'isdef' is set, we're defining the option in Options.lb so
 	there is no need for 'uses'."""
 
 	global loc, global_options, curimage
 
 	if (isdef):
 		o = getdict(global_options, name)
 		if (not o):
 			return
 		image = 0
 	else:
 		curpart = partstack.tos()
 		if (curpart):
 			o = getdict(curpart.uses_options, name)
 		else:
 			o = getdict(global_uses_options, name)
 		if (not o):
 			fatal("Attempt to set default for nonexistent option %s (missing USES?)" % name)
 		image = curimage
 
 	v = getoptionvalue(name, o, image)
 	if (v == 0):
 		v = newoptionvalue(name, image)
 	v.setdefault(value)
 
 def setnodefault(name):
 	global loc, global_options
 	o = getdict(global_options, name)
 	if (not o):
 		return
 	v = getdict(global_option_values, name)
 	if (v != 0):
 		warning("removing default for %s" % name)
 		del global_option_values[name]
 
 def setcomment(name, value):
 	global loc, global_options
 	o = getdict(global_options, name)
 	if (not o):
 		fatal("setcomment: %s not here" % name)
 	o.setcomment(value, loc)
 
 def setexported(name):
 	global global_options
 	o = getdict(global_options, name)
 	if (not o):
 		fatal("setexported: %s not here" % name)
 	o.setexportable()
 	global_exported_options.append(o)
 
 def setnoexport(name):
 	global global_options
 	o = getdict(global_options, name)
 	if (not o):
 		fatal("setnoexport: %s not here" % name)
 	o.setnoexport()
 	if (o in global_exported_options):
 		global_exported_options.remove(o)
 
 def setexportable(name):
 	global global_options
 	o = getdict(global_options, name)
 	if (not o):
 		fatal("setexportable: %s not here" % name)
 	o.setexportable()
 
 def setformat(name, fmt):
 	global global_options
 	o = getdict(global_options, name)
 	if (not o):
 		fatal("setformat: %s not here" % name)
 	o.setformat(fmt)
 
 def getformated(name, image):
 	global global_options, global_option_values
 	o = getdict(global_options, name)
 	v = getoption(name, image)
 	f = o.getformat()
 	return (f % v)
 
 def setwrite(name, part):
 	global global_options
 	o = getdict(global_options, name)
 	if (not o):
 		fatal("setwrite: %s not here" % name)
 	o.setwrite(part)
 
 def hasvalue(name, image):
 	global global_options
 	o = getdict(global_options, name)
 	if (o == 0):
 		return 0
 	v = 0
 	if (image):
 		v = getdict(image.getvalues(), name)
 	if (v == 0):
 		v = getdict(global_option_values, name)
 	return (v != 0)
 
 def isset(name, part):
 	global global_uses_options, global_option_values, curimage
 	if (part):
 		o = getdict(part.uses_options, name)
 	else:
 		o = getdict(global_uses_options, name)
 	if (o == 0):
 		return 0
 	v = 0
 	if (curimage):
 		v = getdict(curimage.getvalues(), name)
 	if (v == 0):
 		v = getdict(global_option_values, name)
 	return (v != 0 and v.isset())
 
 def usesoption(name):
 	global global_options, global_uses_options
 	curpart = partstack.tos()
 	if (curpart):
 		curpart.usesoption(name)
 		return
 	o = getdict(global_options, name)
 	if (o == 0):
 		fatal("Can't use undefined option %s" % name)
 	o1 = getdict(global_uses_options, name)
 	if (o1):
 		return
 	setdict(global_uses_options, name, o)
 	exportoption(o, global_exported_options)
 
 def validdef(name, defval):
 	global global_options
 	o = getdict(global_options, name)
 	if (not o):
 		fatal("validdef: %s not here" % name)
 	if ((defval & 1) != 1):
 	    fatal("Must specify default value for option %s" % name)
 	if ((defval & 2) != 2):
 	    fatal("Must specify export for option %s" % name)
 	if ((defval & 4) != 4):
 	    fatal("Must specify comment for option %s" % name)
 
 def loadoptions(path, file, rule):
 	file = os.path.join('src', path, file)
 	optionsfile = os.path.join(treetop, file)
 	fp = safe_open(optionsfile, 'r')
 	loc.push(file)
 	if (not parse(rule, fp.read())):
 		fatal("Could not parse file")
 	loc.pop()
 
 def addinit(path):
 	global curimage, dirstack
 	if (path[0] == '/'):
 		curimage.setinitfile(treetop + '/src/' + path)
 	else:
 		curimage.setinitfile(dirstack.tos() + '/' + path)
 	print "Adding init file: %s" % path
 
 def addconfig(path):
 	global partstack
 	curpart = partstack.tos()
 	curpart.addconfig(path)
 
 def addregister(field, value):
 	global partstack
 	curpart = partstack.tos()
 	curpart.addregister(field, value)
 
 def addcrt0include(path):
 	"""we do the crt0include as a dictionary, so that if needed we
 	can trace who added what when. Also it makes the keys
 	nice and unique."""
 	global curimage
 	curimage.addinitinclude(0, path)
 
 def addinitinclude(str, path):
 	global curimage
 	curimage.addinitinclude(dequote(str), path)
 
 def addldscript(path):
 	global curimage, dirstack
 	curdir = dirstack.tos()
 	if (path[0] == '/'):
 		fullpath =  treetop + '/src/' + path
 	else:
 		fullpath = curdir + '/' + path
 	debug.info(debug.statement, "fullpath :%s: curdir :%s: path :%s:" % (fullpath, curdir, path))
 	curimage.addldscript(fullpath)
 
 def payload(path):
 	global curimage
 	curimage.setpayload(path)
 	adduserdefine("PAYLOAD:=%s"%path)
 
 def startromimage(name):
 	global romimages, curimage, target_dir, target_name
 	curpart = partstack.tos()
 	print "Configuring ROMIMAGE %s Curimage %s" % (name, curimage)
 	print "Curpart is %s\n" % curpart
 	o = getdict(romimages, name)
 	if (o):
 		fatal("romimage %s previously defined" % name)
 	curimage = romimage(name)
 	curimage.settargetdir(os.path.join(target_dir, name))
 	#o = partobj(curimage, target_dir, 0, 'board', target_name)
 	#curimage.setroot(o)
 	setdict(romimages, name, curimage)
 	dodir('/config', 'Config.lb')
 
 def endromimage():
 	global curimage
 	mainboard()
 	print "End ROMIMAGE"
 	curimage = 0
 	#curpart = 0
 
 def mainboardsetup(path):
 	global full_mainboard_path, mainboard_path
 	mainboard_path = os.path.join('mainboard', path)
 	loadoptions(mainboard_path, 'Options.lb', 'mainboardvariables')
 	full_mainboard_path = os.path.join(treetop, 'src', 'mainboard', path)
 	vendor = re.sub("/.*", "", path)
         part_number = re.sub("[^/]*/", "", path)
 	setdefault('MAINBOARD', full_mainboard_path, 0)
 	setdefault('MAINBOARD_VENDOR', vendor, 0)
 	setdefault('MAINBOARD_PART_NUMBER', part_number, 0)
 
 def mainboard():
 	global curimage, dirstack, partstack
 	file = 'Config.lb'
 	partdir = mainboard_path
 	srcdir = os.path.join(treetop, 'src')
 	fulldir = os.path.join(srcdir, partdir)
 	type_name = flatten_name(partdir)
 	newpart = partobj(curimage, fulldir, partstack.tos(), 'mainboard', \
 		type_name, 0, 'chip')
 	#print "Configuring PART %s" % (type)
 	partstack.push(newpart)
 	#print "  new PART tos is now %s\n" %partstack.tos().info()
 	dirstack.push(fulldir)
 	loadoptions(mainboard_path, 'Options.lb', 'mainboardvariables')
 	# special case for 'cpu' parts.
 	# we could add a new function too, but this is rather trivial.
 	# if the part is a cpu, and we haven't seen it before,
 	# arrange to source the directory /cpu/'type'
 	doconfigfile(srcdir, partdir, file, 'cfgfile')
 	curimage.setroot(partstack.tos())
 	partpop()
 
 def addbuildrom(filename, size, roms):
 	global buildroms
 	print "Build ROM size %d" % size
 	b = buildrom(filename, size, roms)
 	buildroms.append(b)
 
 def addinitobject(object_name):
 	global curimage
 	curimage.addinitobjectrule(object_name)
 
 def addobject(object_name):
 	global curimage
 	curimage.addobjectrule(object_name)
 
 def adddriver(driver_name):
 	global curimage
 	curimage.adddriverrule(driver_name)
 
 def target(name):
         global target_dir, target_name
 	print "Configuring TARGET %s" % name
 	target_name = name
 	target_dir = os.path.join(os.path.dirname(loc.file()), name)
 	if not os.path.isdir(target_dir):
 		print "Creating directory %s" % target_dir
 		os.makedirs(target_dir)
 	print "Will place Makefile, crt0.S, etc. in %s" % target_dir
 
 
 def cpudir(path):
 	global cpu_type
 	if (cpu_type and (cpu_type != path)):
 		fatal("Two different CPU types: %s and %s" % (cpu_type, path))
 	srcdir = "/cpu/%s" % path
 	dodir(srcdir, "Config.lb")
 	cpu_type = path
 	
 def devicepart(type):
 	global curimage, dirstack, partstack
 	newpart = partobj(curimage, 0, partstack.tos(), type, \
 			'', 0, 'device')
 	#print "Configuring PART %s" % (type)
 	partstack.push(newpart)
 	#print "  new PART tos is now %s\n" %partstack.tos().info()
 	# just push TOS, so that we can pop later. 
 	dirstack.push(dirstack.tos())
 	
 def part(type, path, file, name):
 	global curimage, dirstack, partstack
         partdir = os.path.join(type, path)
 	srcdir = os.path.join(treetop, 'src')
 	fulldir = os.path.join(srcdir, partdir)
 	type_name = flatten_name(partdir)
 	newpart = partobj(curimage, fulldir, partstack.tos(), type, \
 			type_name, name, 'chip')
 	#print "Configuring PART %s, path %s" % (type, path)
 	partstack.push(newpart)
 	#print "  new PART tos is now %s\n" %partstack.tos().info()
 	dirstack.push(fulldir)
 	# special case for 'cpu' parts. 
 	# we could add a new function too, but this is rather trivial.
 	# if the part is a cpu, and we haven't seen it before, 
 	# arrange to source the directory /cpu/'type'
 	if (type == 'cpu'):
 		cpudir(path)
 	else:
 		doconfigfile(srcdir, partdir, file, 'cfgfile')
 
 def partpop():
 	global dirstack, partstack
 	curpart = partstack.tos()
 	if (curpart == 0):
 		fatal("Trying to pop non-existent part")
 	#print "End PART %s" % curpart.part
 	# Warn if options are used without being set in this part
 	for op in curpart.uses_options.keys():
 		if (not isset(op, curpart)):
 			notice("Option %s using default value %s" % (op, getformated(op, curpart.image)))
 	oldpart = partstack.pop()
 	dirstack.pop()
 	#print "partstack.pop, TOS is now %s\n" % oldpart.info()
 
 def dodir(path, file):
 	"""dodir is like part but there is no new part"""
 	global dirstack
 	# if the first char is '/', it is relative to treetop, 
 	# else relative to curdir
 	# os.path.join screws up if the name starts with '/', sigh.
 	print "Configuring DIR %s" % os.path.join(path, file)
 	if (path[0] == '/'):
 		fullpath = os.path.join(treetop, 'src')
 		path = re.sub('^/*', '', path)
 	else:
 		fullpath = dirstack.tos()
 	debug.info(debug.statement, "DODIR: path %s, fullpath %s" % (path, fullpath))
 	dirstack.push(os.path.join(fullpath, path))
 	doconfigfile(fullpath, path, file, 'cfgfile')
 	dirstack.pop()
 
 def lookup(name):
 	global curimage
 	return getoption(name, curimage)
 
 def addrule(id):
 	global curimage
 	curimage.addmakerule(id)
 	
 def adduserdefine(str):
 	global curimage
 	curimage.adduserdefine(str)
 
 def addaction(id, str):
 	global curimage
 	curimage.addmakeaction(id, str)
 
 def adddep(id, str):
 	global curimage
 	curimage.addmakedepend(id, str)
 
 def setarch(my_arch):
 	"""arch is 'different' ... darn it."""
 	global curimage
 	print "SETTING ARCH %s\n" % my_arch
 	curimage.setarch(my_arch)
 	setdefault('ARCH', my_arch, 1)
 	part('arch', my_arch, 'Config.lb', 0)
 
 def doconfigfile(path, confdir, file, rule):
 	rname = os.path.join(confdir, file)
 	loc.push(rname)
 	fullpath = os.path.join(path, rname)
 	fp = safe_open(fullpath, 'r')
 	if (not parse(rule, fp.read())):
 		fatal("Could not parse file")
 	exitiferrors()
 	loc.pop()
 
 #=============================================================================
 #		MISC FUNCTIONS
 #=============================================================================
 def ternary(val, yes, no):
 	debug.info(debug.statement, "ternary %s" % expr)
 	debug.info(debug.statement, "expr %s a %d yes %d no %d"% (expr, a, yes, no))
         if (val == 0):
 		debug.info(debug.statement, "Ternary returns %d" % yes)
 		return yes
         else:
 		debug.info(debug.statement, "Ternary returns %d" % no)
 		return no
 
 def tohex(name):
 	"""atoi is in the python library, but not strtol? Weird!"""
 	return eval('int(%s)' % name)
 
 def IsInt(str):
 	""" Is the given string an integer?"""
 	try:
 		num = long(str)
 		return 1
 	except ValueError:
 		return 0
 
 def dequote(str):
 	a = re.sub("^\"", "", str)
 	a = re.sub("\"$", "", a)
 	# highly un-intuitive, need four \!
 	a = re.sub("\\\\\"", "\"", a)
 	return a
 
 def flatten_name(str):
 	a = re.sub("[/-]", "_", str)
 	return a
 
 def topify(path):
 	"""If the first part of <path> matches treetop, replace 
 	that part with $(TOP)"""
 	if path[0:len(treetop)] == treetop:
 		path = path[len(treetop):len(path)]
 		if (path[0:1] == "/"):
 			path = path[1:len(path)]
 		path = "$(TOP)/" + path
 	return path
 
 %%
 # to make if work without 2 passses, we use an old hack from SIMD, the 
 # context bit. If the bit is 1, then ops get done, otherwise
 # ops don't get done. From the top level, context is always
 # 1. In an if, context depends on eval of the if condition
 
 parser Config:
     ignore:			r'\s+'
     ignore:			"#.*?\r?\n"
 
     # less general tokens should come first, otherwise they get matched
     # by the re's
     token ACTION:		'action'
     token ADDACTION:		'addaction'
     token ALWAYS:		'always'
     token ARCH:			'arch'
     token BUILDROM:		'buildrom'
     token COMMENT:		'comment'
     token CONFIG:		'config'
     token CPU:			'cpu'
     token CPU_BUS:		'cpu_bus'
     token CHIP:			'chip'
     token DEFAULT:		'default'
     token DEFINE:		'define'
     token DEPENDS:		'depends'
     token DEVICE:		'device'
     token DIR:			'dir'
     token DRIVER:		'driver'
     token DRQ:			'drq'
     token ELSE:			'else'
     token END:			'end'
     token EOF:			'$'
     token EQ:			'='
     token EXPORT:		'export'
     token FORMAT:		'format'
     token IF:			'if'
     token INIT:			'init'
     token INITOBJECT:		'initobject'
     token INITINCLUDE:		'initinclude'
     token IO:			'io'
     token IRQ:			'irq'
     token LDSCRIPT:		'ldscript'
     token LOADOPTIONS:		'loadoptions'
     token MAINBOARD:		'mainboard'
     token MAINBOARDINIT:	'mainboardinit'
     token MAKEDEFINE:		'makedefine'
     token MAKERULE:		'makerule'
     token MEM:			'mem'
     token NEVER:		'never'
     token NONE:			'none'
     token NORTHBRIDGE:		'northbridge'
     token OBJECT:		'object'
     token OPTION:		'option'
     token PAYLOAD:		'payload'
     token PMC:			'pmc'
     token PRINT:		'print'
     token REGISTER:		'register'
     token ROMIMAGE:		'romimage'
     token SOUTHBRIDGE:		'southbridge'
     token SUPERIO:		'superio'
     token TARGET:		'target'
     token USED:			'used'
     token USES:			'uses'
     token WRITE:		'write'
     token NUM:			'[0-9]+'
     token HEX_NUM:		'[0-9a-fA-F]+'
     token HEX_PREFIX:		'0x'
     # Why is path separate? Because paths to resources have to at least
     # have a slash, we thinks
     token PATH:			r'[-a-zA-Z0-9_.][-a-zA-Z0-9/_.]+[-a-zA-Z0-9_.]+'
     # Dir's on the other hand are abitrary
     # this may all be stupid.
     token DIRPATH:		r'[-a-zA-Z0-9_$()./]+'
     token ID:			r'[a-zA-Z_.]+[a-zA-Z0-9_.]*'
     token DELEXPR:		r'{([^}]+|\\.)*}'
     token STR:			r'"([^\\"]+|\\.)*"'
     token RAWTEXT:		r'.*'
     token ON:			'on'
     token OFF:			'off'
     token PCI:			'pci'
     token PNP:			'pnp'
     token I2C:			'i2c'
     token APIC:			'apic'
     token APIC_CLUSTER:		'apic_cluster'
     token CPU:			'cpu'
     token CPU_BUS:		'cpu_bus'
     token PCI_DOMAIN:		'pci_domain'
 
 
     rule expr:		logical			{{ l = logical }}
 			( "&&" logical		{{ l = l and logical }}
 			| "||"  logical		{{ l = l or logical }}
 			)*			{{ return l }}
 
     rule logical:	factor			{{ n = factor }}
 			( "[+]" factor		{{ n = n+factor }}
 			| "-"  factor		{{ n = n-factor }}
 			)*			{{ return n }}
 
     rule factor:	term			{{ v = term }}
 			( "[*]" term		{{ v = v*term }}
 			| "/"  term		{{ v = v/term }}
 			| "<<"  term		{{ v = v << term }}
 			| ">=" term		{{ v = (v < term)}}
 			)*			{{ return v }}
 
     # A term is a number, variable, or an expression surrounded by parentheses
     rule term:		NUM			{{ return long(NUM, 10) }}
 		|	HEX_PREFIX HEX_NUM	{{ return long(HEX_NUM, 16) }}
 		|	ID			{{ return lookup(ID) }}
 		|	unop			{{ return unop }}
 		|	"\\(" expr "\\)"	{{ return expr }}
 
     rule unop:		"!" expr		{{ return not(expr) }}
 
     rule partend<<C>>:	(stmt<<C>>)* END 	{{ if (C): partpop()}}
 
     # This is needed because the legacy cpu command could not distinguish
     # between cpu vendors. It should just be PATH, but getting this change
     # into the source tree will be tricky... 
     # DO NOT USE ID AS IT MAY GO AWAY IN THE FUTURE
     rule partid:	ID 			{{ return ID }}
 		|	PATH			{{ return PATH }}
 
 #    rule parttype:	NORTHBRIDGE		{{ return 'northbridge' }} 
 #    		|	SUPERIO 		{{ return 'superio' }}
 #		|	PMC			{{ return 'pmc' }}
 #		|	SOUTHBRIDGE		{{ return 'southbridge' }}
 #		|	CPU			{{ return 'cpu' }}
 #		|	CHIP                    {{ return '' }}
 #
     rule parttype:	CHIP                    {{ return '' }}
 
     rule partdef<<C>>:				{{ name = 0 }} 
 			parttype partid		
 			[ STR			{{ name = dequote(STR) }}
 			]                       {{ if (C): part(parttype, partid, 'Config.lb', name) }}
 			partend<<C>> 		
 
     rule arch<<C>>:	ARCH ID			{{ if (C): setarch(ID) }}
 			partend<<C>>
     
     rule mainboardinit<<C>>:
 			MAINBOARDINIT DIRPATH	{{ if (C): addcrt0include(DIRPATH)}}
 
     rule initinclude<<C>>: 
 			INITINCLUDE 
 			STR 
 			DIRPATH			{{ if (C): addinitinclude(STR, DIRPATH)}}
 
     rule initobject<<C>>:
 			INITOBJECT DIRPATH	{{ if (C): addinitobject(DIRPATH)}}
 
     rule object<<C>>:	OBJECT DIRPATH		{{ if (C): addobject(DIRPATH)}}
 
     rule driver<<C>>:	DRIVER DIRPATH		{{ if (C): adddriver(DIRPATH)}}
 
     rule dir<<C>>:	DIR DIRPATH 		{{ if (C): dodir(DIRPATH, 'Config.lb') }}
 
     rule default<<C>>:	DEFAULT ID EQ value	{{ if (C): setdefault(ID, value, 0) }}
 
     rule ldscript<<C>>:	LDSCRIPT DIRPATH	{{ if (C): addldscript(DIRPATH) }}
 
     rule iif<<C>>:	IF ID			{{ c = lookup(ID) }}
 			(stmt<<C and c>>)* 
 			[ ELSE (stmt<<C and not c>>)* ]
 			END
 
     rule depsacts<<ID, C>>:
 			( DEPENDS STR		{{ if (C): adddep(ID, STR) }}
 			| ACTION STR		{{ if (C): addaction(ID, STR) }}
 			)*
 
     rule makerule<<C>>:	MAKERULE DIRPATH	{{ if (C): addrule(DIRPATH) }} 
 			depsacts<<DIRPATH, C>> 
 			END
 
     rule makedefine<<C>>:
 			MAKEDEFINE RAWTEXT	{{ if (C): adduserdefine(RAWTEXT) }}
 
     rule addaction<<C>>:
 			ADDACTION ID STR	{{ if (C): addaction(ID, STR) }}
 
     rule init<<C>>:	INIT DIRPATH		{{ if (C): addinit(DIRPATH) }}
 
     rule field:		STR			{{ return STR }}
 
     rule register<<C>>:	REGISTER field '=' STR	{{ if (C): addregister(field, STR) }}
 
     rule enable<<C>>:				{{ val = 1 }}
 	    		( ON 			{{ val = 1 }}
 			| OFF			{{ val = 0 }}
 			) 			{{ if(C): partstack.tos().set_enabled(val) }}
 
     rule resource<<C>>:				{{ type = "" }}
 	    		(  IO			{{ type = "IORESOURCE_FIXED | IORESOURCE_ASSIGNED | IORESOURCE_IO" }}
 			|   MEM			{{ type = "IORESOURCE_FIXED | IORESOURCE_ASSIGNED | IORESOURCE_MEM" }}
 			|   IRQ			{{ type = "IORESOURCE_FIXED | IORESOURCE_ASSIGNED | IORESOURCE_IRQ" }}
 			|   DRQ			{{ type = "IORESOURCE_FIXED | IORESOURCE_ASSIGNED | IORESOURCE_DRQ" }}
 			)
 			term '='		{{ index = term }}
 			term			{{ value = term }}
 						{{ if (C): partstack.tos().add_resource(type, index, value) }}
     
 			     
     rule resources<<C>>:			{{ if (C): partstack.tos().start_resources() }}
 	    		( resource<<C>> )*
 						{{ if (C): partstack.tos().end_resources() }}
 	    
     
     rule pci<<C>>:	PCI 			{{ if (C): devicepart('pci') }}
 
     			HEX_NUM			{{ slot = int(HEX_NUM,16) }}
 			'.' HEX_NUM		{{ function = int(HEX_NUM, 16) }}
 						{{ if (C): partstack.tos().addpcipath(slot, function) }}
     rule pci_domain<<C>>:	
 			PCI_DOMAIN 		{{ if (C): devicepart('pci_domain') }}
 			HEX_NUM			{{ pci_domain = int(HEX_NUM, 16) }}
 						{{ if (C): partstack.tos().addpci_domainpath(pci_domain) }}
 
     rule pnp<<C>>:	PNP  			{{ if (C): devicepart('pnp') }}
 			HEX_NUM			{{ port = int(HEX_NUM,16) }}
 			'.' HEX_NUM		{{ device = int(HEX_NUM, 16) }}
 						{{ if (C): partstack.tos().addpnppath(port, device) }}
 						
     rule i2c<<C>>:	I2C   			{{ if (C): devicepart('i2c') }}
 			HEX_NUM			{{ device = int(HEX_NUM, 16) }}
 						{{ if (C): partstack.tos().addi2cpath(device) }}
 
     rule apic<<C>>:	APIC   			{{ if (C): devicepart('apic') }}
 			HEX_NUM			{{ apic_id = int(HEX_NUM, 16) }}
 						{{ if (C): partstack.tos().addapicpath(apic_id) }}
 
     rule apic_cluster<<C>>: APIC_CLUSTER 	{{ if (C): devicepart('apic_cluster') }}
 			HEX_NUM			{{ cluster = int(HEX_NUM, 16) }}
 						{{ if (C): partstack.tos().addapic_clusterpath(cluster) }}
 
     rule cpu<<C>>:	CPU			{{ if (C): devicepart('cpu') }}
     			HEX_NUM			{{ id = int(HEX_NUM, 16) }}
 						{{ if (C): partstack.tos().addcpupath(id) }}
 
     rule cpu_bus<<C>>:	CPU_BUS			{{ if (C): devicepart('cpu_bus') }}
     			HEX_NUM			{{ id = int(HEX_NUM, 16) }}
 						{{ if (C): partstack.tos().addcpu_buspath(id) }}
 
     rule dev_path<<C>>:
 	    		pci<<C>>		{{ return pci }}
 		|	pci_domain<<C>>		{{ return pci_domain }}
 	    	|	pnp<<C>>		{{ return pnp }}
 		|	i2c<<C>>		{{ return i2c }}
 		|	apic<<C>>		{{ return apic }}
 		|	apic_cluster<<C>>	{{ return apic_cluster }}
 		|	cpu<<C>>		{{ return cpu }}
 		|	cpu_bus<<C>>		{{ return cpu_bus }}
 		
     rule prtval:	expr			{{ return str(expr) }}
 		|	STR			{{ return STR }}
 
     rule prtlist:	prtval			{{ el = "%(" + prtval }}
 			( "," prtval 		{{ el = el + "," + prtval }}
 			)*			{{ return el + ")" }}	
 
     rule prtstmt<<C>>:	PRINT STR 		{{ val = STR }}
 			[ "," prtlist 		{{ val = val + prtlist }}
 			]			{{ if (C): print eval(val) }}
 
     rule config<<C>>:	CONFIG PATH		{{ if (C): addconfig(PATH) }}
 
     rule device<<C>>:   DEVICE dev_path<<C>>
     			enable<<C>>			
 			resources<<C>>
 			partend<<C>> 
 
     rule stmt<<C>>:	arch<<C>>		{{ return arch}}
 		|	addaction<<C>>		{{ return addaction }}
     		|	config<<C>>		{{ return config}}
 		|	default<<C>>		{{ return default}}
 		|	dir<<C>>		{{ return dir}}
 		|	driver<<C>>		{{ return driver }}
 		|	iif<<C>>	 	{{ return iif }}
 		|	init<<C>>	 	{{ return init }}
 		|	initinclude<<C>>	{{ return initinclude }}
 		|	initobject<<C>>		{{ return initobject }}
 		|	ldscript<<C>>		{{ return ldscript}}
 		|	mainboardinit<<C>>	{{ return mainboardinit }}
 		|	makedefine<<C>> 	{{ return makedefine }}
 		|	makerule<<C>>		{{ return makerule }}
 		|	object<<C>>		{{ return object }}
 		|	option<<C>>		{{ return option }}
 		|	partdef<<C>>		{{ return partdef }}
 		| 	prtstmt<<C>>		{{ return prtstmt }}
 		|	register<<C>> 		{{ return register }}
 		|	device<<C>>		{{ return device }}
 
     # ENTRY for parsing Config.lb file
     rule cfgfile:	(uses<<1>>)* 
     			(stmt<<1>>)*
 			EOF			{{ return 1 }}
 
     rule cfgfile:	(uses<<1>>)* 
     			(stmt<<1>>)*
 			EOF			{{ return 1 }}
 
     rule usesid<<C>>:	ID			{{ if (C): usesoption(ID) }}
 
     rule uses<<C>>:	USES (usesid<<C>>)+
 
     rule mainboardvariables:	(uses<<1>>)*
 				(default<<1>>)*
 				(option<<1>>)*
 				END		{{ return 1}}
 
     rule value:		STR			{{ return dequote(STR) }} 
 		| 	expr			{{ return expr }}
 		|	DELEXPR			{{ return DELEXPR }}
 
     rule option<<C>>:	OPTION ID EQ value	{{ if (C): setoption(ID, value, 0) }}
 
     rule opif<<C>>:	IF ID			{{ c = lookup(ID) }}
 			(opstmt<<C and c>>)* 
 			[ ELSE (opstmt<<C and not c>>)* ] 
 			END
 
     rule opstmt<<C>>:	option<<C>>
 		|	opif<<C>>
 		|	prtstmt<<C>>
 
     rule payload<<C>>:	PAYLOAD DIRPATH		{{ if (C): payload(DIRPATH) }}
 
     rule mainboard:
 			MAINBOARD PATH		{{ mainboardsetup(PATH) }}
 
     rule romif<<C>>:	IF ID			{{ c = lookup(ID) }}
 			(romstmt<<C and c>>)* 
 			[ ELSE (romstmt<<C and not c>>)* ]
 			END
 
     rule romstmt<<C>>:	romif<<C>>
 		|	option<<C>>
 		|	payload<<C>>
 
     rule romimage:	ROMIMAGE STR		{{ startromimage(dequote(STR)) }}
 			(romstmt<<1>>)*
 			END			{{ endromimage() }}
 
     rule roms:		STR			{{ s = '[' + STR }}
 			( STR			{{ s = s + "," + STR }}
 			)*			{{ return eval(s + ']') }}
 
     rule buildrom:	BUILDROM DIRPATH expr roms	{{ addbuildrom(DIRPATH, expr, roms) }}
 
     rule romstmts:	romimage 
 		|	buildrom
 		|	opstmt<<1>>
 
     # ENTRY for parsing root part
     rule board:		{{ loadoptions("config", "Options.lb", "options") }}
 	    		TARGET DIRPATH		{{ target(DIRPATH) }}
 			mainboard
 			(romstmts)*		
 			EOF			{{ return 1 }}
 
     # ENTRY for parsing a delayed value
     rule delexpr:	"{" expr "}" EOF	{{ return expr }}
 
     rule wrstr<<ID>>:	STR			{{ setwrite(ID, dequote(STR)) }}
 
     rule defstmts<<ID>>:			{{ d = 0 }}
 			( DEFAULT
 			  ( value		{{ setdefault(ID, value, 1) }}
 			  | NONE		{{ setnodefault(ID) }}
 			  )			{{ d = d | 1 }}
 			| FORMAT STR		{{ setformat(ID, dequote(STR)) }}
 			| EXPORT 
 			  ( ALWAYS		{{ setexported(ID) }}
 			  | USED		{{ setexportable(ID) }}
 			  | NEVER		{{ setnoexport(ID) }}
 			  )			{{ d = d | 2 }}
 			| COMMENT STR 		{{ setcomment(ID, dequote(STR)); d = d | 4 }}
 			| WRITE (wrstr<<ID>>)+
 			)+			{{ return d }}
 		
     rule define:	DEFINE ID 		{{ newoption(ID) }}
 			defstmts<<ID>> END	{{ validdef(ID, defstmts) }}
 
     # ENTRY for parsing Options.lb file
     rule options:	(define)* EOF		{{ return 1 }}
 %%
 
 #=============================================================================
 #		FILE OUTPUT 
 #=============================================================================
 def writemakefileheader(file, fname):
 	file.write("# File: %s is autogenerated\n" % fname)
 
 def writemakefilefooter(file, fname):
 	file.write("\n\n%s: %s %s\n"
 		% (os.path.basename(fname), os.path.abspath(sys.argv[0]), top_config_file))
 	file.write("\t(cd %s ; export PYTHONPATH=%s/util/newconfig ; python %s %s %s)\n\n"
 		% (os.getcwd(), treetop, sys.argv[0], sys.argv[1], sys.argv[2]))
 
 def writemakefilesettings(path):
 	""" Write Makefile.settings to seperate the settings
 	from the actual makefile creation."""
 
 	global treetop, target_dir
 
 	filename = os.path.join(path, "Makefile.settings")
 	print "Creating", filename
 	file = safe_open(filename, 'w+')
 	writemakefileheader(file, filename)
 	file.write("TOP:=%s\n" % (treetop))
 	file.write("TARGET_DIR:=%s\n" % target_dir)
 	writemakefilefooter(file, filename)
 	file.close()
 
 def writeimagesettings(image):
 	"""Write Makefile.settings to seperate the settings
 	from the actual makefile creation."""
 
 	global treetop
 	global global_options_by_order
 
 	filename = os.path.join(image.gettargetdir(), "Makefile.settings")
 	print "Creating", filename
 	file = safe_open(filename, 'w+')
 	writemakefileheader(file, filename)
 	file.write("TOP:=%s\n" % (treetop))
 	file.write("TARGET_DIR:=%s\n" % (image.gettargetdir()))
 	file.write("\n")
 	exported = []
 	for o in global_exported_options:
 		exported.append(o)
 	for o in image.exported_options:
 		if (not o in exported):
 			exported.append(o)
 	for o in exported:
 		file.write("export %s:=" % o.name)
 		if (hasvalue(o.name, image)):
 			file.write("%s" % getformated(o.name, image))
 		file.write("\n")
 	file.write("\n")
 	file.write("export VARIABLES :=\n")
 	for o in exported:
 		file.write("export VARIABLES += %s\n" % o.name)
 	file.write("\n")
 	writemakefilefooter(file,filename)
 	file.close()
 
 # write the romimage makefile
 # let's try the Makefile
 # first, dump all the -D stuff
 
 def writeimagemakefile(image):
 	makefilepath = os.path.join(image.gettargetdir(), "Makefile")
 	print "Creating", makefilepath
 	file = safe_open(makefilepath, 'w+')
 	writemakefileheader(file, makefilepath)
 
 	# main rule
 	file.write("\nall: coreboot.rom\n\n")
 	file.write(".PHONY: all\n\n")
 	#file.write("include cpuflags\n")
 	# Putting "include cpuflags" in the Makefile has the problem that the
 	# cpuflags file would be generated _after_ we want to include it.
 	# Instead, let make do the work of computing CPUFLAGS:
 	file.write("# Get the value of TOP, VARIABLES, and several other variables.\n")
 	file.write("include Makefile.settings\n\n")
 	file.write("# Function to create an item like -Di586 or -DCONFIG_MAX_CPUS='1' or -Ui686\n")
 	file.write("D_item = $(if $(subst undefined,,$(origin $1)),-D$1$(if $($1),='$($1)',),-U$1)\n\n")
 	file.write("# Compute the value of CPUFLAGS here during make's first pass.\n")
 	file.write("CPUFLAGS := $(foreach _var_,$(VARIABLES),$(call D_item,$(_var_)))\n\n")
 
 	for i in image.getuserdefines():
 		file.write("%s\n" %i)
 	file.write("\n")
 
 	# print out all the object dependencies
 	file.write("\n# object dependencies (objectrules:)\n")
 	file.write("INIT-OBJECTS :=\n")
 	file.write("OBJECTS :=\n")
 	file.write("DRIVER :=\n")
 	file.write("\nSOURCES :=\n")
 	for irule, init in image.getinitobjectrules().items():
 		i_name = init[0]
 		i_source = init[1]
 		file.write("INIT-OBJECTS += %s\n" % (i_name))
 		file.write("SOURCES += %s\n" % (i_source))
 
 	for objrule, obj in image.getobjectrules().items():
 		obj_name = obj[0]
 		obj_source = obj[1]
 		file.write("OBJECTS += %s\n" % (obj_name))
 		file.write("SOURCES += %s\n" % (obj_source))
 
 	# for chip_target.c
 	file.write("OBJECTS += static.o\n")
 	file.write("SOURCES += static.c\n")
 
 	for driverrule, driver in image.getdriverrules().items():
 		obj_name = driver[0]
 		obj_source = driver[1]
 		file.write("DRIVER += %s\n" % (obj_name))
 		file.write("SOURCES += %s\n" % (obj_source))
 
 	# Print out all ldscript.ld dependencies.
 	file.write("\n# ldscript.ld dependencies:\n")
 	file.write("LDSUBSCRIPTS-1 := \n" )
 	for script in image.getldscripts():
 		file.write("LDSUBSCRIPTS-1 += %s\n" % topify(script))
 
 	# Print out the dependencies for crt0_includes.h
 	file.write("\n# Dependencies for crt0_includes.h\n")
 	file.write("CRT0_INCLUDES:=\n")
 	for inc in image.getinitincludes():
 		if (local_path.match(inc)):
 			file.write("CRT0_INCLUDES += %s\n" % inc)
 		else:
 			file.write("CRT0_INCLUDES += $(TOP)/src/%s\n" % inc)
 
 	# Print out the user defines.
 	file.write("\n# userdefines:\n")
 		
 	# Print out the base rules.
 	# Need to have a rule that counts on 'all'.
 	file.write("\n# mainrulelist:")
 
 	# Print out any user rules.
 	file.write("\n# From makerule or docipl commands:\n")
 
 	file.write("\n# initobjectrules:\n")
 	for irule, init in image.getinitobjectrules().items():
 		source = topify(init[1])
 		type = init[2]
 		if (type  == 'S'):
 			# for .S, .o depends on .s
 			file.write("%s: %s.s\n" % (init[0], init[3]))
         		file.write("\t$(CC) -c $(CPU_OPT) -o $@ $<\n")
 			# and .s depends on .S
 			file.write("%s.s: %s\n" % (init[3], source))
 			# Note: next 2 lines are ONE output line!
         		file.write("\t$(CPP) $(CPPFLAGS) $< ")
 			file.write(">$@.new && mv $@.new $@\n")
 		else:
 			file.write("%s: %s\n" % (init[0], source))
 			file.write("\t$(CC) -c $(CFLAGS) -o $@ $<\n")
 
 	file.write("\n# objectrules:\n")
 	for objrule, obj in image.getobjectrules().items():
 		source = topify(obj[1])
 		type = obj[2]
 		if (type  == 'S'):
 			# for .S, .o depends on .s
 			file.write("%s: %s.s\n" % (obj[0], obj[3]))
         		file.write("\t$(CC) -c $(CPU_OPT) -o $@ $<\n")
 			# and .s depends on .S
 			file.write("%s.s: %s\n" % (obj[3], source))
 			# Note: next 2 lines are ONE output line!
         		file.write("\t$(CPP) $(CPPFLAGS) $< ")
 			file.write(">$@.new && mv $@.new $@\n")
 		else:
 			file.write("%s: %s\n" % (obj[0], source))
 			file.write("\t$(CC) -c $(CFLAGS) -o $@ $<\n")
 		#file.write("%s\n" % objrule[2])
 
 	for driverrule, driver in image.getdriverrules().items():
 		source = topify(driver[1])
 		file.write("%s: %s\n" % (driver[0], source))
 		file.write("\t$(CC) -c $(CFLAGS) -o $@ $<\n")
 		#file.write("%s\n" % objrule[2])
 
 	# special rule for chip_target.c
 	file.write("static.o: static.c\n")
 	file.write("\t$(CC) -c $(CFLAGS) -o $@ $<\n")
 
 	# Print out the rules that will make cause the files
 	# generated by NLBConfig.py to be remade if any dependencies change.
 
 	file.write("\n# Remember the automatically generated files\n")
 	file.write("GENERATED:=\n")
 	for genfile in ['Makefile',
 			'nsuperio.c',
 			'static.c',
 			'corebootDoc.config' ]:
 		file.write("GENERATED += %s\n" % genfile)
 	file.write("GENERATED += %s\n" % image.getincludefilename())
 
 	keys = global_options_by_order
 	keys.sort()
 	file.write("\necho:\n")
 	for key in keys:
 		 file.write("\t@echo %s='$(%s)'\n"% (key,key))
 
 	for i, m in image.getmakerules().items():
 		file.write("%s: " %i)
 		for i in m.dependency:
 			file.write("%s " % i)
 		file.write("\n")
 		for i in m.actions:
 			file.write("\t%s\n" % i)
 	writemakefilefooter(file, makefilepath)
 	file.close()
 
 #
 def writemakefile(path):
 	makefilepath = os.path.join(path, "Makefile")
 	print "Creating", makefilepath
 	file = safe_open(makefilepath, 'w+')
 	writemakefileheader(file, makefilepath)
 
 	# main rule
 	file.write("\nall:")
 	for i in buildroms:
 		file.write(" %s" % i.name)
 	file.write("\n\n")	
 	file.write("include Makefile.settings\n\n")
 	for i, o in romimages.items():
 		file.write("%s/coreboot.rom:\n" % o.getname())
 		file.write("\tif (cd %s; \\\n" % o.getname())
 		file.write("\t\t$(MAKE) coreboot.rom)\\\n")
 		file.write("\tthen true; else exit 1; fi;\n\n")
 	file.write("clean: ")
 	for i in romimages.keys():
 		file.write(" %s-clean" % i)
+	file.write(" base-clean")
 	file.write("\n\n")
 	for i, o in romimages.items():
 		file.write("%s-clean:\n" % o.getname())
 		file.write("\t(cd %s; $(MAKE) clean)\n\n" % o.getname())
+	file.write("base-clean:\n")
+	file.write("\trm -f romcc*\n\n")
 
 	for i in buildroms:
 		file.write("%s:" % i.name)
 		for j in i.roms:
 			file.write(" %s/coreboot.rom " % j)
 		file.write("\n")
 		file.write("\t cat ")
 		for j in i.roms:
 			file.write(" %s/coreboot.rom " % j)
 		file.write("> %s\n\n" %i.name)
 
 
 	file.write(".PHONY: all clean")
 	for i in romimages.keys():
 		file.write(" %s-clean" % i)
 	for i, o in romimages.items():
 		file.write(" %s/coreboot.rom" % o.getname())
 	file.write("\n\n")
 
 	writemakefilefooter(file, makefilepath)
 	file.close()
 
 def writeinitincludes(image):
 	global include_pattern
 	filepath = os.path.join(image.gettargetdir(), image.getincludefilename())
 	print "Creating", filepath
 	outfile = safe_open(filepath, 'w+')
 	if (image.newformat()):
 		infile = safe_open(image.getinitfile(), 'r')
 
 		line = infile.readline()
 		while (line):
 			p = include_pattern.match(line)
 			if (p):
 				for i in image.getinitincludes():
 					inc = image.getinitinclude(i)
 					if (inc.getstring() == p.group(1)):
 						outfile.write("#include \"%s\"\n" % inc.getpath())
 			else:
 				outfile.write(line)
 			line = infile.readline()
 
 		infile.close()
 	else:
 		for i in image.getinitincludes():
 			outfile.write("#include <%s>\n" % i)
 	outfile.close()
 
 def writeldoptions(image):
 	"""Write ldoptions file."""
 	filename = os.path.join(image.gettargetdir(), "ldoptions")
 	print "Creating", filename
 	file = safe_open(filename, 'w+')
 	for o in global_exported_options:
 		if (hasvalue(o.name, image) and IsInt(getoption(o.name, image))):
 			file.write("%s = %s;\n" % (o.name, getformated(o.name, image)))
 	for o in image.exported_options:
 		if (not o in global_exported_options and hasvalue(o.name, image) and IsInt(getoption(o.name, image))):
 			file.write("%s = %s;\n" % (o.name, getformated(o.name, image)))
 	file.close()
 
 def dumptree(part, lvl):
 	debug.info(debug.dumptree, "DUMPTREE ME is")
 	part.dumpme(lvl)
 	# dump the siblings -- actually are there any? not sure
 	# siblings are:
 	debug.info(debug.dumptree, "DUMPTREE SIBLINGS are")
 	kid = part.next_sibling
 	while (kid):
 		kid.dumpme(lvl)
 		kid = kid.next_sibling
 	# dump the kids
 	debug.info(debug.dumptree, "DUMPTREE KIDS are")
 	#for kid in part.children:
 	if (part.children):
 		dumptree(part.children, lvl+1)
 	kid = part.next_sibling
 	while (kid):
 		if (kid.children):
 			dumptree(kid.children, lvl + 1)
 		kid = kid.next_sibling
 	debug.info(debug.dumptree, "DONE DUMPTREE")
 
 def writecode(image):
 	filename = os.path.join(img_dir, "static.c")
 	print "Creating", filename
 	file = safe_open(filename, 'w+')
 	file.write("#include <device/device.h>\n")
 	file.write("#include <device/pci.h>\n")
 	for path in image.getconfigincludes().values():
 		file.write("#include \"%s\"\n" % path)
 	gencode(image.getroot(), file, 0)
 	gencode(image.getroot(), file, 1)
 	file.close()
 
 def gencode(part, file, pass_num):
 	debug.info(debug.gencode, "GENCODE ME is")
 	part.gencode(file, pass_num)
 	# dump the siblings -- actually are there any? not sure
 	debug.info(debug.gencode, "GENCODE SIBLINGS are")
 	kid = part.next_sibling
 	while (kid):
 		kid.gencode(file, pass_num)
 		kid = kid.next_sibling
 	# now dump the children 
 	debug.info(debug.gencode, "GENCODE KIDS are")
 	if (part.children):
 		gencode(part.children, file, pass_num)
 	kid = part.next_sibling
 	while (kid):
 		if (kid.children):
 			gencode(kid.children, file, pass_num)
 		kid = kid.next_sibling
 	debug.info(debug.gencode, "DONE GENCODE")
 
 def verifyparse():
 	"""Add any run-time checks to verify that parsing the configuration
 	was successful"""
 
 	for image in romimages.values():
 		print("Verifying ROMIMAGE %s" % image.name)
 		if (image.newformat() and image.getinitfile() == ''):
 			fatal("An init file must be specified")
 		for op in image.exported_options:
 			if (getoptionvalue(op.name, op, image) == 0 and getoptionvalue(op.name, op, 0) == 0):
 				warning("Exported option %s has no value (check Options.lb)" % op.name);
 	print("Verifing global options")
 	for op in global_exported_options:
 		if (getoptionvalue(op.name, op, 0) == 0):
 			notice("Exported option %s has no value (check Options.lb)" % op.name);
 			
 #=============================================================================
 #		MAIN PROGRAM
 #=============================================================================
 if __name__=='__main__':
 	from sys import argv
 	if (len(argv) < 3):
 		fatal("Args: <file> <path to coreboot>")
 
 	top_config_file = os.path.abspath(sys.argv[1])
 
 	treetop = os.path.abspath(sys.argv[2])
 
 	# Now read in the customizing script...
 	loc.push(argv[1])
 	fp = safe_open(argv[1], 'r')
 	if (not parse('board', fp.read())):
 		fatal("Could not parse file")
 	loc.pop()
 
 	verifyparse()
 
 	# no longer need to check if an options has been used
 	alloptions = 1
 
 	for image_name, image in romimages.items():
 		if (debug.level(debug.dumptree)):
 			debug.info(debug.dumptree, "DEVICE TREE:")
 			dumptree(image.getroot(), 0)
 
 		img_dir = image.gettargetdir()
 		if not os.path.isdir(img_dir):
 			print "Creating directory %s" % img_dir
 			os.makedirs(img_dir)
 
 		if (debug.level(debug.dump)):
 			for i in image.getinitincludes():
 				debug.info(debug.dump, "crt0include file %s" % i)
 			for i in image.getdriverrules().keys():
 				debug.info(debug.dump, "driver file %s" % i)
 			for i in image.getldscripts():
 				debug.info(debug.dump, "ldscript file %s" % i)
 			for i, m in image.getmakerules().items():
 				debug.info(debug.dump, " makerule %s dep %s act %s" % (i, m.dependency, m.actions))
 
 		writecode(image)
 		writeimagesettings(image)
 		writeinitincludes(image)
 		writeimagemakefile(image)
 		writeldoptions(image)
 
 	writemakefilesettings(target_dir)
 	writemakefile(target_dir)
 
 	sys.exit(0)
